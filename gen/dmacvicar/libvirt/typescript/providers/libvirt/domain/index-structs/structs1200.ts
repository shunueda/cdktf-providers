import * as cdktf from 'cdktf';
export interface DomainDevicesFilesystemsAcpi {
  /**
  * Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#pstore>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#index Domain#index}
  */
  readonly index?: number;
}

export function domainDevicesFilesystemsAcpiToTerraform(struct?: DomainDevicesFilesystemsAcpi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    index: cdktf.numberToTerraform(struct!.index),
  }
}


export function domainDevicesFilesystemsAcpiToHclTerraform(struct?: DomainDevicesFilesystemsAcpi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    index: {
      value: cdktf.numberToHclTerraform(struct!.index),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesFilesystemsAcpiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesFilesystemsAcpi | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._index !== undefined) {
      hasAnyValues = true;
      internalValueResult.index = this._index;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesFilesystemsAcpi | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._index = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._index = value.index;
    }
  }

  // index - computed: false, optional: true, required: false
  private _index?: number; 
  public get index() {
    return this.getNumberAttribute('index');
  }
  public set index(value: number) {
    this._index = value;
  }
  public resetIndex() {
    this._index = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get indexInput() {
    return this._index;
  }
}
export interface DomainDevicesFilesystemsAddress {
}

export function domainDevicesFilesystemsAddressToTerraform(struct?: DomainDevicesFilesystemsAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function domainDevicesFilesystemsAddressToHclTerraform(struct?: DomainDevicesFilesystemsAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DomainDevicesFilesystemsAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesFilesystemsAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesFilesystemsAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DomainDevicesFilesystemsAlias {
  /**
  * Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
}

export function domainDevicesFilesystemsAliasToTerraform(struct?: DomainDevicesFilesystemsAlias | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function domainDevicesFilesystemsAliasToHclTerraform(struct?: DomainDevicesFilesystemsAlias | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesFilesystemsAliasOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesFilesystemsAlias | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesFilesystemsAlias | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DomainDevicesFilesystemsBinaryCache {
  /**
  * Sets the cache mode policy for the filesystem helper binary; value is user-provided and should match libvirt's supported cache modes (for example, "always", "none", or similar driver-specific values).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode: string;
}

export function domainDevicesFilesystemsBinaryCacheToTerraform(struct?: DomainDevicesFilesystemsBinaryCache | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
  }
}


export function domainDevicesFilesystemsBinaryCacheToHclTerraform(struct?: DomainDevicesFilesystemsBinaryCache | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesFilesystemsBinaryCacheOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesFilesystemsBinaryCache | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesFilesystemsBinaryCache | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
    }
  }

  // mode - computed: false, optional: false, required: true
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }
}
export interface DomainDevicesFilesystemsBinaryLock {
  /**
  * Enables or disables use of flock-style locking by the filesystem helper binary; value is typically "on"/"off" or "yes"/"no" according to libvirt's locking options. When omitted, the driver default is used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#flock Domain#flock}
  */
  readonly flock?: string;
  /**
  * Enables or disables use of POSIX locks by the filesystem helper binary; value is typically "on"/"off" or "yes"/"no" according to libvirt's locking options. When omitted, the driver default is used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#posix Domain#posix}
  */
  readonly posix?: string;
}

export function domainDevicesFilesystemsBinaryLockToTerraform(struct?: DomainDevicesFilesystemsBinaryLock | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    flock: cdktf.stringToTerraform(struct!.flock),
    posix: cdktf.stringToTerraform(struct!.posix),
  }
}


export function domainDevicesFilesystemsBinaryLockToHclTerraform(struct?: DomainDevicesFilesystemsBinaryLock | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    flock: {
      value: cdktf.stringToHclTerraform(struct!.flock),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    posix: {
      value: cdktf.stringToHclTerraform(struct!.posix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesFilesystemsBinaryLockOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesFilesystemsBinaryLock | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._flock !== undefined) {
      hasAnyValues = true;
      internalValueResult.flock = this._flock;
    }
    if (this._posix !== undefined) {
      hasAnyValues = true;
      internalValueResult.posix = this._posix;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesFilesystemsBinaryLock | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._flock = undefined;
      this._posix = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._flock = value.flock;
      this._posix = value.posix;
    }
  }

  // flock - computed: false, optional: true, required: false
  private _flock?: string; 
  public get flock() {
    return this.getStringAttribute('flock');
  }
  public set flock(value: string) {
    this._flock = value;
  }
  public resetFlock() {
    this._flock = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flockInput() {
    return this._flock;
  }

  // posix - computed: false, optional: true, required: false
  private _posix?: string; 
  public get posix() {
    return this.getStringAttribute('posix');
  }
  public set posix(value: string) {
    this._posix = value;
  }
  public resetPosix() {
    this._posix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get posixInput() {
    return this._posix;
  }
}
export interface DomainDevicesFilesystemsBinaryOpenFiles {
  /**
  * Sets the maximum number of open file descriptors allowed for the filesystem helper binary; value is a user-provided positive integer. For example, 1024 or 4096.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#max Domain#max}
  */
  readonly max: number;
}

export function domainDevicesFilesystemsBinaryOpenFilesToTerraform(struct?: DomainDevicesFilesystemsBinaryOpenFiles | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max: cdktf.numberToTerraform(struct!.max),
  }
}


export function domainDevicesFilesystemsBinaryOpenFilesToHclTerraform(struct?: DomainDevicesFilesystemsBinaryOpenFiles | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max: {
      value: cdktf.numberToHclTerraform(struct!.max),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesFilesystemsBinaryOpenFilesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesFilesystemsBinaryOpenFiles | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._max !== undefined) {
      hasAnyValues = true;
      internalValueResult.max = this._max;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesFilesystemsBinaryOpenFiles | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._max = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._max = value.max;
    }
  }

  // max - computed: false, optional: false, required: true
  private _max?: number; 
  public get max() {
    return this.getNumberAttribute('max');
  }
  public set max(value: number) {
    this._max = value;
  }
  // Temporarily expose input value. Use with caution.
  public get maxInput() {
    return this._max;
  }
}
export interface DomainDevicesFilesystemsBinarySandbox {
  /**
  * Sets the sandbox mode for the filesystem helper binary; value is user-provided and should match one of libvirt's supported sandbox modes for this backend. For example, a mode could indicate "chroot" or "none" depending on driver support.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode: string;
}

export function domainDevicesFilesystemsBinarySandboxToTerraform(struct?: DomainDevicesFilesystemsBinarySandbox | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
  }
}


export function domainDevicesFilesystemsBinarySandboxToHclTerraform(struct?: DomainDevicesFilesystemsBinarySandbox | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesFilesystemsBinarySandboxOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesFilesystemsBinarySandbox | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesFilesystemsBinarySandbox | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
    }
  }

  // mode - computed: false, optional: false, required: true
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }
}
export interface DomainDevicesFilesystemsBinaryThreadPool {
  /**
  * Sets the number of worker threads in the filesystem helper binary's thread pool; value is a user-provided non-negative integer. For example, 4 or 16.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#size Domain#size}
  */
  readonly size?: number;
}

export function domainDevicesFilesystemsBinaryThreadPoolToTerraform(struct?: DomainDevicesFilesystemsBinaryThreadPool | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    size: cdktf.numberToTerraform(struct!.size),
  }
}


export function domainDevicesFilesystemsBinaryThreadPoolToHclTerraform(struct?: DomainDevicesFilesystemsBinaryThreadPool | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    size: {
      value: cdktf.numberToHclTerraform(struct!.size),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesFilesystemsBinaryThreadPoolOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesFilesystemsBinaryThreadPool | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._size !== undefined) {
      hasAnyValues = true;
      internalValueResult.size = this._size;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesFilesystemsBinaryThreadPool | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._size = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._size = value.size;
    }
  }

  // size - computed: false, optional: true, required: false
  private _size?: number; 
  public get size() {
    return this.getNumberAttribute('size');
  }
  public set size(value: number) {
    this._size = value;
  }
  public resetSize() {
    this._size = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sizeInput() {
    return this._size;
  }
}
export interface DomainDevicesFilesystemsBinary {
  /**
  * Configures caching behavior for the filesystem helper binary, such as how it caches file metadata or data. The effective policy is controlled by the required mode attribute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#cache Domain#cache}
  */
  readonly cache?: DomainDevicesFilesystemsBinaryCache;
  /**
  * Configures file locking behavior used by the filesystem helper binary when accessing shared host files. Its flock and posix attributes enable or disable the respective locking mechanisms.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#lock Domain#lock}
  */
  readonly lock?: DomainDevicesFilesystemsBinaryLock;
  /**
  * Configures limits related to the number of open files the filesystem helper binary may keep, helping constrain resource usage. The max attribute defines the actual numeric limit.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#open_files Domain#open_files}
  */
  readonly openFiles?: DomainDevicesFilesystemsBinaryOpenFiles;
  /**
  * Sets the absolute path to the filesystem helper binary (such as a virtiofsd-style daemon) that will be executed to serve this filesystem. Value is user-provided and must point to an executable on the host (for example, "/usr/libexec/virtiofsd").
  * 
  * See: <https://libvirt.org/formatdomain.html#filesystems>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path?: string;
  /**
  * Configures sandboxing behavior for the filesystem helper binary, such as whether it runs in a restricted environment. The mode attribute selects the sandboxing policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sandbox Domain#sandbox}
  */
  readonly sandbox?: DomainDevicesFilesystemsBinarySandbox;
  /**
  * Configures the thread pool used by the filesystem helper binary to handle I/O requests. The size attribute controls the number of worker threads.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#thread_pool Domain#thread_pool}
  */
  readonly threadPool?: DomainDevicesFilesystemsBinaryThreadPool;
  /**
  * Enables or disables extended attribute (xattr) support for the filesystem helper binary when exporting the filesystem; value is typically "on"/"off" or "yes"/"no". When omitted, the backend default is used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#xattr Domain#xattr}
  */
  readonly xattr?: string;
}

export function domainDevicesFilesystemsBinaryToTerraform(struct?: DomainDevicesFilesystemsBinary | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cache: domainDevicesFilesystemsBinaryCacheToTerraform(struct!.cache),
    lock: domainDevicesFilesystemsBinaryLockToTerraform(struct!.lock),
    open_files: domainDevicesFilesystemsBinaryOpenFilesToTerraform(struct!.openFiles),
    path: cdktf.stringToTerraform(struct!.path),
    sandbox: domainDevicesFilesystemsBinarySandboxToTerraform(struct!.sandbox),
    thread_pool: domainDevicesFilesystemsBinaryThreadPoolToTerraform(struct!.threadPool),
    xattr: cdktf.stringToTerraform(struct!.xattr),
  }
}


export function domainDevicesFilesystemsBinaryToHclTerraform(struct?: DomainDevicesFilesystemsBinary | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cache: {
      value: domainDevicesFilesystemsBinaryCacheToHclTerraform(struct!.cache),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesFilesystemsBinaryCache",
    },
    lock: {
      value: domainDevicesFilesystemsBinaryLockToHclTerraform(struct!.lock),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesFilesystemsBinaryLock",
    },
    open_files: {
      value: domainDevicesFilesystemsBinaryOpenFilesToHclTerraform(struct!.openFiles),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesFilesystemsBinaryOpenFiles",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sandbox: {
      value: domainDevicesFilesystemsBinarySandboxToHclTerraform(struct!.sandbox),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesFilesystemsBinarySandbox",
    },
    thread_pool: {
      value: domainDevicesFilesystemsBinaryThreadPoolToHclTerraform(struct!.threadPool),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesFilesystemsBinaryThreadPool",
    },
    xattr: {
      value: cdktf.stringToHclTerraform(struct!.xattr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesFilesystemsBinaryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesFilesystemsBinary | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cache?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cache = this._cache?.internalValue;
    }
    if (this._lock?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.lock = this._lock?.internalValue;
    }
    if (this._openFiles?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.openFiles = this._openFiles?.internalValue;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._sandbox?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sandbox = this._sandbox?.internalValue;
    }
    if (this._threadPool?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.threadPool = this._threadPool?.internalValue;
    }
    if (this._xattr !== undefined) {
      hasAnyValues = true;
      internalValueResult.xattr = this._xattr;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesFilesystemsBinary | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cache.internalValue = undefined;
      this._lock.internalValue = undefined;
      this._openFiles.internalValue = undefined;
      this._path = undefined;
      this._sandbox.internalValue = undefined;
      this._threadPool.internalValue = undefined;
      this._xattr = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cache.internalValue = value.cache;
      this._lock.internalValue = value.lock;
      this._openFiles.internalValue = value.openFiles;
      this._path = value.path;
      this._sandbox.internalValue = value.sandbox;
      this._threadPool.internalValue = value.threadPool;
      this._xattr = value.xattr;
    }
  }

  // cache - computed: false, optional: true, required: false
  private _cache = new DomainDevicesFilesystemsBinaryCacheOutputReference(this, "cache");
  public get cache() {
    return this._cache;
  }
  public putCache(value: DomainDevicesFilesystemsBinaryCache) {
    this._cache.internalValue = value;
  }
  public resetCache() {
    this._cache.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cacheInput() {
    return this._cache.internalValue;
  }

  // lock - computed: false, optional: true, required: false
  private _lock = new DomainDevicesFilesystemsBinaryLockOutputReference(this, "lock");
  public get lock() {
    return this._lock;
  }
  public putLock(value: DomainDevicesFilesystemsBinaryLock) {
    this._lock.internalValue = value;
  }
  public resetLock() {
    this._lock.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lockInput() {
    return this._lock.internalValue;
  }

  // open_files - computed: false, optional: true, required: false
  private _openFiles = new DomainDevicesFilesystemsBinaryOpenFilesOutputReference(this, "open_files");
  public get openFiles() {
    return this._openFiles;
  }
  public putOpenFiles(value: DomainDevicesFilesystemsBinaryOpenFiles) {
    this._openFiles.internalValue = value;
  }
  public resetOpenFiles() {
    this._openFiles.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get openFilesInput() {
    return this._openFiles.internalValue;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sandbox - computed: false, optional: true, required: false
  private _sandbox = new DomainDevicesFilesystemsBinarySandboxOutputReference(this, "sandbox");
  public get sandbox() {
    return this._sandbox;
  }
  public putSandbox(value: DomainDevicesFilesystemsBinarySandbox) {
    this._sandbox.internalValue = value;
  }
  public resetSandbox() {
    this._sandbox.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sandboxInput() {
    return this._sandbox.internalValue;
  }

  // thread_pool - computed: false, optional: true, required: false
  private _threadPool = new DomainDevicesFilesystemsBinaryThreadPoolOutputReference(this, "thread_pool");
  public get threadPool() {
    return this._threadPool;
  }
  public putThreadPool(value: DomainDevicesFilesystemsBinaryThreadPool) {
    this._threadPool.internalValue = value;
  }
  public resetThreadPool() {
    this._threadPool.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get threadPoolInput() {
    return this._threadPool.internalValue;
  }

  // xattr - computed: false, optional: true, required: false
  private _xattr?: string; 
  public get xattr() {
    return this.getStringAttribute('xattr');
  }
  public set xattr(value: string) {
    this._xattr = value;
  }
  public resetXattr() {
    this._xattr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get xattrInput() {
    return this._xattr;
  }
}
export interface DomainDevicesFilesystemsBoot {
  /**
  * Sets an optional firmware load parameter string associated with booting from this redirected device, passed to firmware on platforms that support loadparm (e.g. s390x).
  * 
  * See: <https://libvirt.org/formatdomain.html#specifying-boot-order>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#load_parm Domain#load_parm}
  */
  readonly loadParm?: string;
  /**
  * Sets the boot priority for this redirected device, as a positive integer where lower values are tried earlier during guest boot (for example, 1 for first, 2 for second).
  * 
  * See: <https://libvirt.org/formatdomain.html#specifying-boot-order>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#order Domain#order}
  */
  readonly order: number;
}

export function domainDevicesFilesystemsBootToTerraform(struct?: DomainDevicesFilesystemsBoot | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    load_parm: cdktf.stringToTerraform(struct!.loadParm),
    order: cdktf.numberToTerraform(struct!.order),
  }
}


export function domainDevicesFilesystemsBootToHclTerraform(struct?: DomainDevicesFilesystemsBoot | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    load_parm: {
      value: cdktf.stringToHclTerraform(struct!.loadParm),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    order: {
      value: cdktf.numberToHclTerraform(struct!.order),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesFilesystemsBootOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesFilesystemsBoot | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._loadParm !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadParm = this._loadParm;
    }
    if (this._order !== undefined) {
      hasAnyValues = true;
      internalValueResult.order = this._order;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesFilesystemsBoot | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._loadParm = undefined;
      this._order = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._loadParm = value.loadParm;
      this._order = value.order;
    }
  }

  // load_parm - computed: false, optional: true, required: false
  private _loadParm?: string; 
  public get loadParm() {
    return this.getStringAttribute('load_parm');
  }
  public set loadParm(value: string) {
    this._loadParm = value;
  }
  public resetLoadParm() {
    this._loadParm = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadParmInput() {
    return this._loadParm;
  }

  // order - computed: false, optional: false, required: true
  private _order?: number; 
  public get order() {
    return this.getNumberAttribute('order');
  }
  public set order(value: number) {
    this._order = value;
  }
  // Temporarily expose input value. Use with caution.
  public get orderInput() {
    return this._order;
  }
}
export interface DomainDevicesFilesystemsDriver {
  /**
  * Enables or disables Address Translation Service for a virtio-based filesystem device; valid values are "on" or "off".
  * 
  * See: <https://libvirt.org/formatdomain.html#virtio-related-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#ats Domain#ats}
  */
  readonly ats?: string;
  /**
  * Sets an optional driver-specific format identifier for the filesystem backend; the value is user-provided and depends on the underlying driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#filesystems>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#format Domain#format}
  */
  readonly format?: string;
  /**
  * Enables or disables use of an emulated IOMMU for the virtio filesystem device; valid values are "on" or "off".
  * 
  * See: <https://libvirt.org/formatdomain.html#virtio-related-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#iommu Domain#iommu}
  */
  readonly iommu?: string;
  /**
  * Sets the backend driver name for the filesystem device (for example a specific virtiofs or 9p implementation); the value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#filesystems>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name?: string;
  /**
  * Enables or disables virtio packed ring layout for the filesystem device; valid values are "on" or "off".
  * 
  * See: <https://libvirt.org/formatdomain.html#virtio-related-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#packed Domain#packed}
  */
  readonly packed?: string;
  /**
  * Enables or disables use of a separate notification page per virtqueue for the virtio filesystem device; valid values are "on" or "off".
  * 
  * See: <https://libvirt.org/formatdomain.html#virtio-related-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#page_per_vq Domain#page_per_vq}
  */
  readonly pagePerVq?: string;
  /**
  * Sets a driver-specific queue-related parameter (such as number or size of queues) for the filesystem device; the value is user-provided and must be a non-negative integer when used.
  * 
  * See: <https://libvirt.org/formatdomain.html#filesystems>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#queue Domain#queue}
  */
  readonly queue?: number;
  /**
  * Selects the filesystem driver type, such as "virtiofs" or "path", determining how the host directory is exposed to the guest; the exact valid values are driver-dependent.
  * 
  * See: <https://libvirt.org/formatdomain.html#filesystems>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type?: string;
  /**
  * Sets the write policy for the filesystem backend (for example "immediate" or "delayed") controlling how writes are flushed to host storage; the value is user-provided and driver-specific.
  * 
  * See: <https://libvirt.org/formatdomain.html#filesystems>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#wr_policy Domain#wr_policy}
  */
  readonly wrPolicy?: string;
}

export function domainDevicesFilesystemsDriverToTerraform(struct?: DomainDevicesFilesystemsDriver | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ats: cdktf.stringToTerraform(struct!.ats),
    format: cdktf.stringToTerraform(struct!.format),
    iommu: cdktf.stringToTerraform(struct!.iommu),
    name: cdktf.stringToTerraform(struct!.name),
    packed: cdktf.stringToTerraform(struct!.packed),
    page_per_vq: cdktf.stringToTerraform(struct!.pagePerVq),
    queue: cdktf.numberToTerraform(struct!.queue),
    type: cdktf.stringToTerraform(struct!.type),
    wr_policy: cdktf.stringToTerraform(struct!.wrPolicy),
  }
}


export function domainDevicesFilesystemsDriverToHclTerraform(struct?: DomainDevicesFilesystemsDriver | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ats: {
      value: cdktf.stringToHclTerraform(struct!.ats),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    iommu: {
      value: cdktf.stringToHclTerraform(struct!.iommu),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    packed: {
      value: cdktf.stringToHclTerraform(struct!.packed),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    page_per_vq: {
      value: cdktf.stringToHclTerraform(struct!.pagePerVq),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    queue: {
      value: cdktf.numberToHclTerraform(struct!.queue),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    wr_policy: {
      value: cdktf.stringToHclTerraform(struct!.wrPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesFilesystemsDriverOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesFilesystemsDriver | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ats !== undefined) {
      hasAnyValues = true;
      internalValueResult.ats = this._ats;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._iommu !== undefined) {
      hasAnyValues = true;
      internalValueResult.iommu = this._iommu;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._packed !== undefined) {
      hasAnyValues = true;
      internalValueResult.packed = this._packed;
    }
    if (this._pagePerVq !== undefined) {
      hasAnyValues = true;
      internalValueResult.pagePerVq = this._pagePerVq;
    }
    if (this._queue !== undefined) {
      hasAnyValues = true;
      internalValueResult.queue = this._queue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._wrPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.wrPolicy = this._wrPolicy;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesFilesystemsDriver | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ats = undefined;
      this._format = undefined;
      this._iommu = undefined;
      this._name = undefined;
      this._packed = undefined;
      this._pagePerVq = undefined;
      this._queue = undefined;
      this._type = undefined;
      this._wrPolicy = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ats = value.ats;
      this._format = value.format;
      this._iommu = value.iommu;
      this._name = value.name;
      this._packed = value.packed;
      this._pagePerVq = value.pagePerVq;
      this._queue = value.queue;
      this._type = value.type;
      this._wrPolicy = value.wrPolicy;
    }
  }

  // ats - computed: false, optional: true, required: false
  private _ats?: string; 
  public get ats() {
    return this.getStringAttribute('ats');
  }
  public set ats(value: string) {
    this._ats = value;
  }
  public resetAts() {
    this._ats = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get atsInput() {
    return this._ats;
  }

  // format - computed: false, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // iommu - computed: false, optional: true, required: false
  private _iommu?: string; 
  public get iommu() {
    return this.getStringAttribute('iommu');
  }
  public set iommu(value: string) {
    this._iommu = value;
  }
  public resetIommu() {
    this._iommu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get iommuInput() {
    return this._iommu;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // packed - computed: false, optional: true, required: false
  private _packed?: string; 
  public get packed() {
    return this.getStringAttribute('packed');
  }
  public set packed(value: string) {
    this._packed = value;
  }
  public resetPacked() {
    this._packed = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get packedInput() {
    return this._packed;
  }

  // page_per_vq - computed: false, optional: true, required: false
  private _pagePerVq?: string; 
  public get pagePerVq() {
    return this.getStringAttribute('page_per_vq');
  }
  public set pagePerVq(value: string) {
    this._pagePerVq = value;
  }
  public resetPagePerVq() {
    this._pagePerVq = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pagePerVqInput() {
    return this._pagePerVq;
  }

  // queue - computed: false, optional: true, required: false
  private _queue?: number; 
  public get queue() {
    return this.getNumberAttribute('queue');
  }
  public set queue(value: number) {
    this._queue = value;
  }
  public resetQueue() {
    this._queue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queueInput() {
    return this._queue;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // wr_policy - computed: false, optional: true, required: false
  private _wrPolicy?: string; 
  public get wrPolicy() {
    return this.getStringAttribute('wr_policy');
  }
  public set wrPolicy(value: string) {
    this._wrPolicy = value;
  }
  public resetWrPolicy() {
    this._wrPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get wrPolicyInput() {
    return this._wrPolicy;
  }
}
export interface DomainDevicesFilesystemsIdMapGid {
  /**
  * Sets the size of the GID mapping range (number of consecutive IDs) for this mapping entry; must be a positive integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#filesystems>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#count Domain#count}
  */
  readonly count: number;
  /**
  * Sets the starting guest GID for this mapping range; must be a non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#filesystems>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#start Domain#start}
  */
  readonly start: number;
  /**
  * Sets the starting host GID to which the guest GID range is mapped; must be a non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#filesystems>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#target Domain#target}
  */
  readonly target: number;
}

export function domainDevicesFilesystemsIdMapGidToTerraform(struct?: DomainDevicesFilesystemsIdMapGid | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    count: cdktf.numberToTerraform(struct!.count),
    start: cdktf.numberToTerraform(struct!.start),
    target: cdktf.numberToTerraform(struct!.target),
  }
}


export function domainDevicesFilesystemsIdMapGidToHclTerraform(struct?: DomainDevicesFilesystemsIdMapGid | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    count: {
      value: cdktf.numberToHclTerraform(struct!.count),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    start: {
      value: cdktf.numberToHclTerraform(struct!.start),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    target: {
      value: cdktf.numberToHclTerraform(struct!.target),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesFilesystemsIdMapGidOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesFilesystemsIdMapGid | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._count !== undefined) {
      hasAnyValues = true;
      internalValueResult.count = this._count;
    }
    if (this._start !== undefined) {
      hasAnyValues = true;
      internalValueResult.start = this._start;
    }
    if (this._target !== undefined) {
      hasAnyValues = true;
      internalValueResult.target = this._target;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesFilesystemsIdMapGid | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._count = undefined;
      this._start = undefined;
      this._target = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._count = value.count;
      this._start = value.start;
      this._target = value.target;
    }
  }

  // count - computed: false, optional: false, required: true
  private _count?: number; 
  public get count() {
    return this.getNumberAttribute('count');
  }
  public set count(value: number) {
    this._count = value;
  }
  // Temporarily expose input value. Use with caution.
  public get countInput() {
    return this._count;
  }

  // start - computed: false, optional: false, required: true
  private _start?: number; 
  public get start() {
    return this.getNumberAttribute('start');
  }
  public set start(value: number) {
    this._start = value;
  }
  // Temporarily expose input value. Use with caution.
  public get startInput() {
    return this._start;
  }

  // target - computed: false, optional: false, required: true
  private _target?: number; 
  public get target() {
    return this.getNumberAttribute('target');
  }
  public set target(value: number) {
    this._target = value;
  }
  // Temporarily expose input value. Use with caution.
  public get targetInput() {
    return this._target;
  }
}

export class DomainDevicesFilesystemsIdMapGidList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesFilesystemsIdMapGid[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesFilesystemsIdMapGidOutputReference {
    return new DomainDevicesFilesystemsIdMapGidOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesFilesystemsIdMapUid {
  /**
  * Sets the size of the GID mapping range (number of consecutive IDs) for this mapping entry; must be a positive integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#filesystems>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#count Domain#count}
  */
  readonly count: number;
  /**
  * Sets the starting guest GID for this mapping range; must be a non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#filesystems>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#start Domain#start}
  */
  readonly start: number;
  /**
  * Sets the starting host GID to which the guest GID range is mapped; must be a non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#filesystems>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#target Domain#target}
  */
  readonly target: number;
}

export function domainDevicesFilesystemsIdMapUidToTerraform(struct?: DomainDevicesFilesystemsIdMapUid | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    count: cdktf.numberToTerraform(struct!.count),
    start: cdktf.numberToTerraform(struct!.start),
    target: cdktf.numberToTerraform(struct!.target),
  }
}


export function domainDevicesFilesystemsIdMapUidToHclTerraform(struct?: DomainDevicesFilesystemsIdMapUid | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    count: {
      value: cdktf.numberToHclTerraform(struct!.count),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    start: {
      value: cdktf.numberToHclTerraform(struct!.start),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    target: {
      value: cdktf.numberToHclTerraform(struct!.target),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesFilesystemsIdMapUidOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesFilesystemsIdMapUid | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._count !== undefined) {
      hasAnyValues = true;
      internalValueResult.count = this._count;
    }
    if (this._start !== undefined) {
      hasAnyValues = true;
      internalValueResult.start = this._start;
    }
    if (this._target !== undefined) {
      hasAnyValues = true;
      internalValueResult.target = this._target;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesFilesystemsIdMapUid | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._count = undefined;
      this._start = undefined;
      this._target = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._count = value.count;
      this._start = value.start;
      this._target = value.target;
    }
  }

  // count - computed: false, optional: false, required: true
  private _count?: number; 
  public get count() {
    return this.getNumberAttribute('count');
  }
  public set count(value: number) {
    this._count = value;
  }
  // Temporarily expose input value. Use with caution.
  public get countInput() {
    return this._count;
  }

  // start - computed: false, optional: false, required: true
  private _start?: number; 
  public get start() {
    return this.getNumberAttribute('start');
  }
  public set start(value: number) {
    this._start = value;
  }
  // Temporarily expose input value. Use with caution.
  public get startInput() {
    return this._start;
  }

  // target - computed: false, optional: false, required: true
  private _target?: number; 
  public get target() {
    return this.getNumberAttribute('target');
  }
  public set target(value: number) {
    this._target = value;
  }
  // Temporarily expose input value. Use with caution.
  public get targetInput() {
    return this._target;
  }
}

export class DomainDevicesFilesystemsIdMapUidList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesFilesystemsIdMapUid[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesFilesystemsIdMapUidOutputReference {
    return new DomainDevicesFilesystemsIdMapUidOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesFilesystemsIdMap {
  /**
  * Defines one or more group ID (GID) mapping ranges for the filesystem, remapping guest GIDs to host GIDs according to the attributes provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#filesystems>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#gid Domain#gid}
  */
  readonly gid?: DomainDevicesFilesystemsIdMapGid[] | cdktf.IResolvable;
  /**
  * Defines one or more user ID (UID) mapping ranges for the filesystem, remapping guest UIDs to host UIDs via count/start/target attributes similar to gid mapping.
  * 
  * See: <https://libvirt.org/formatdomain.html#filesystems>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#uid Domain#uid}
  */
  readonly uid?: DomainDevicesFilesystemsIdMapUid[] | cdktf.IResolvable;
}

export function domainDevicesFilesystemsIdMapToTerraform(struct?: DomainDevicesFilesystemsIdMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    gid: cdktf.listMapper(domainDevicesFilesystemsIdMapGidToTerraform, false)(struct!.gid),
    uid: cdktf.listMapper(domainDevicesFilesystemsIdMapUidToTerraform, false)(struct!.uid),
  }
}


export function domainDevicesFilesystemsIdMapToHclTerraform(struct?: DomainDevicesFilesystemsIdMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    gid: {
      value: cdktf.listMapperHcl(domainDevicesFilesystemsIdMapGidToHclTerraform, false)(struct!.gid),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesFilesystemsIdMapGidList",
    },
    uid: {
      value: cdktf.listMapperHcl(domainDevicesFilesystemsIdMapUidToHclTerraform, false)(struct!.uid),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesFilesystemsIdMapUidList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesFilesystemsIdMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesFilesystemsIdMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._gid?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.gid = this._gid?.internalValue;
    }
    if (this._uid?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.uid = this._uid?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesFilesystemsIdMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._gid.internalValue = undefined;
      this._uid.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._gid.internalValue = value.gid;
      this._uid.internalValue = value.uid;
    }
  }

  // gid - computed: false, optional: true, required: false
  private _gid = new DomainDevicesFilesystemsIdMapGidList(this, "gid", false);
  public get gid() {
    return this._gid;
  }
  public putGid(value: DomainDevicesFilesystemsIdMapGid[] | cdktf.IResolvable) {
    this._gid.internalValue = value;
  }
  public resetGid() {
    this._gid.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gidInput() {
    return this._gid.internalValue;
  }

  // uid - computed: false, optional: true, required: false
  private _uid = new DomainDevicesFilesystemsIdMapUidList(this, "uid", false);
  public get uid() {
    return this._uid;
  }
  public putUid(value: DomainDevicesFilesystemsIdMapUid[] | cdktf.IResolvable) {
    this._uid.internalValue = value;
  }
  public resetUid() {
    this._uid.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get uidInput() {
    return this._uid.internalValue;
  }
}
export interface DomainDevicesFilesystemsSourceBind {
  /**
  * Sets the absolute path of the host directory that is bind-mounted into the guest filesystem when using a bind source.
  * 
  * See: <https://libvirt.org/formatdomain.html#filesystems>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dir Domain#dir}
  */
  readonly dir: string;
}

export function domainDevicesFilesystemsSourceBindToTerraform(struct?: DomainDevicesFilesystemsSourceBind | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dir: cdktf.stringToTerraform(struct!.dir),
  }
}


export function domainDevicesFilesystemsSourceBindToHclTerraform(struct?: DomainDevicesFilesystemsSourceBind | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dir: {
      value: cdktf.stringToHclTerraform(struct!.dir),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesFilesystemsSourceBindOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesFilesystemsSourceBind | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dir !== undefined) {
      hasAnyValues = true;
      internalValueResult.dir = this._dir;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesFilesystemsSourceBind | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dir = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dir = value.dir;
    }
  }

  // dir - computed: false, optional: false, required: true
  private _dir?: string; 
  public get dir() {
    return this.getStringAttribute('dir');
  }
  public set dir(value: string) {
    this._dir = value;
  }
  // Temporarily expose input value. Use with caution.
  public get dirInput() {
    return this._dir;
  }
}
export interface DomainDevicesFilesystemsSourceBlock {
  /**
  * Sets the path of the host block device (for example `/dev/sdb1`) to use as the backing storage for the filesystem.
  * 
  * See: <https://libvirt.org/formatdomain.html#filesystems>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dev Domain#dev}
  */
  readonly dev: string;
}

export function domainDevicesFilesystemsSourceBlockToTerraform(struct?: DomainDevicesFilesystemsSourceBlock | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dev: cdktf.stringToTerraform(struct!.dev),
  }
}


export function domainDevicesFilesystemsSourceBlockToHclTerraform(struct?: DomainDevicesFilesystemsSourceBlock | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dev: {
      value: cdktf.stringToHclTerraform(struct!.dev),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesFilesystemsSourceBlockOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesFilesystemsSourceBlock | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dev !== undefined) {
      hasAnyValues = true;
      internalValueResult.dev = this._dev;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesFilesystemsSourceBlock | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dev = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dev = value.dev;
    }
  }

  // dev - computed: false, optional: false, required: true
  private _dev?: string; 
  public get dev() {
    return this.getStringAttribute('dev');
  }
  public set dev(value: string) {
    this._dev = value;
  }
  // Temporarily expose input value. Use with caution.
  public get devInput() {
    return this._dev;
  }
}
export interface DomainDevicesFilesystemsSourceFile {
  /**
  * Sets the path of the host file to be used as the filesystem source (for example `/var/lib/images/rootfs.img`).
  * 
  * See: <https://libvirt.org/formatdomain.html#filesystems>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file: string;
}

export function domainDevicesFilesystemsSourceFileToTerraform(struct?: DomainDevicesFilesystemsSourceFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    file: cdktf.stringToTerraform(struct!.file),
  }
}


export function domainDevicesFilesystemsSourceFileToHclTerraform(struct?: DomainDevicesFilesystemsSourceFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    file: {
      value: cdktf.stringToHclTerraform(struct!.file),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesFilesystemsSourceFileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesFilesystemsSourceFile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._file !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesFilesystemsSourceFile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._file = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._file = value.file;
    }
  }

  // file - computed: false, optional: false, required: true
  private _file?: string; 
  public get file() {
    return this.getStringAttribute('file');
  }
  public set file(value: string) {
    this._file = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file;
  }
}
export interface DomainDevicesFilesystemsSourceMount {
  /**
  * Sets the host directory that is already mounted and will be exposed directly to the guest as the filesystem source.
  * 
  * See: <https://libvirt.org/formatdomain.html#filesystems>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dir Domain#dir}
  */
  readonly dir?: string;
  /**
  * Sets the path of a host socket associated with the mount-based filesystem source (for example a virtio-fs daemon socket); value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#filesystems>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#socket Domain#socket}
  */
  readonly socket?: string;
}

export function domainDevicesFilesystemsSourceMountToTerraform(struct?: DomainDevicesFilesystemsSourceMount | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dir: cdktf.stringToTerraform(struct!.dir),
    socket: cdktf.stringToTerraform(struct!.socket),
  }
}


export function domainDevicesFilesystemsSourceMountToHclTerraform(struct?: DomainDevicesFilesystemsSourceMount | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dir: {
      value: cdktf.stringToHclTerraform(struct!.dir),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    socket: {
      value: cdktf.stringToHclTerraform(struct!.socket),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesFilesystemsSourceMountOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesFilesystemsSourceMount | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dir !== undefined) {
      hasAnyValues = true;
      internalValueResult.dir = this._dir;
    }
    if (this._socket !== undefined) {
      hasAnyValues = true;
      internalValueResult.socket = this._socket;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesFilesystemsSourceMount | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dir = undefined;
      this._socket = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dir = value.dir;
      this._socket = value.socket;
    }
  }

  // dir - computed: false, optional: true, required: false
  private _dir?: string; 
  public get dir() {
    return this.getStringAttribute('dir');
  }
  public set dir(value: string) {
    this._dir = value;
  }
  public resetDir() {
    this._dir = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dirInput() {
    return this._dir;
  }

  // socket - computed: false, optional: true, required: false
  private _socket?: string; 
  public get socket() {
    return this.getStringAttribute('socket');
  }
  public set socket(value: string) {
    this._socket = value;
  }
  public resetSocket() {
    this._socket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketInput() {
    return this._socket;
  }
}
export interface DomainDevicesFilesystemsSourceRam {
  /**
  * Sets the units for the RAM filesystem `usage` value, such as `KB`, `MB`, or `GB`; if omitted, libvirt uses its default unit handling.
  * 
  * See: <https://libvirt.org/formatdomain.html#filesystems>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#units Domain#units}
  */
  readonly units?: string;
  /**
  * Sets the size of the RAM-backed filesystem in the specified units (or libvirt default units); value is user-provided and must be a positive integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#filesystems>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#usage Domain#usage}
  */
  readonly usage: number;
}

export function domainDevicesFilesystemsSourceRamToTerraform(struct?: DomainDevicesFilesystemsSourceRam | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    units: cdktf.stringToTerraform(struct!.units),
    usage: cdktf.numberToTerraform(struct!.usage),
  }
}


export function domainDevicesFilesystemsSourceRamToHclTerraform(struct?: DomainDevicesFilesystemsSourceRam | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    units: {
      value: cdktf.stringToHclTerraform(struct!.units),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    usage: {
      value: cdktf.numberToHclTerraform(struct!.usage),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesFilesystemsSourceRamOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesFilesystemsSourceRam | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._units !== undefined) {
      hasAnyValues = true;
      internalValueResult.units = this._units;
    }
    if (this._usage !== undefined) {
      hasAnyValues = true;
      internalValueResult.usage = this._usage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesFilesystemsSourceRam | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._units = undefined;
      this._usage = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._units = value.units;
      this._usage = value.usage;
    }
  }

  // units - computed: false, optional: true, required: false
  private _units?: string; 
  public get units() {
    return this.getStringAttribute('units');
  }
  public set units(value: string) {
    this._units = value;
  }
  public resetUnits() {
    this._units = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unitsInput() {
    return this._units;
  }

  // usage - computed: false, optional: false, required: true
  private _usage?: number; 
  public get usage() {
    return this.getNumberAttribute('usage');
  }
  public set usage(value: number) {
    this._usage = value;
  }
  // Temporarily expose input value. Use with caution.
  public get usageInput() {
    return this._usage;
  }
}
export interface DomainDevicesFilesystemsSourceTemplate {
  /**
  * Sets the name of a filesystem source template to use, referring to a pre-defined template configuration; the value is user-provided and must match an existing template name.
  * 
  * See: <https://libvirt.org/formatdomain.html#filesystems>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
}

export function domainDevicesFilesystemsSourceTemplateToTerraform(struct?: DomainDevicesFilesystemsSourceTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function domainDevicesFilesystemsSourceTemplateToHclTerraform(struct?: DomainDevicesFilesystemsSourceTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesFilesystemsSourceTemplateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesFilesystemsSourceTemplate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesFilesystemsSourceTemplate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DomainDevicesFilesystemsSourceVolume {
  /**
  * Sets the name of the storage pool that contains the volume used as the filesystem source; the value is user-provided and must match an existing pool (for example, "default").
  * 
  * See: <https://libvirt.org/formatdomain.html#filesystems>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pool Domain#pool}
  */
  readonly pool: string;
  /**
  * Sets the name of the storage volume within the specified pool to expose as the filesystem source (for example, "myshare.img"); the value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#filesystems>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#volume Domain#volume}
  */
  readonly volume: string;
}

export function domainDevicesFilesystemsSourceVolumeToTerraform(struct?: DomainDevicesFilesystemsSourceVolume | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    pool: cdktf.stringToTerraform(struct!.pool),
    volume: cdktf.stringToTerraform(struct!.volume),
  }
}


export function domainDevicesFilesystemsSourceVolumeToHclTerraform(struct?: DomainDevicesFilesystemsSourceVolume | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    pool: {
      value: cdktf.stringToHclTerraform(struct!.pool),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    volume: {
      value: cdktf.stringToHclTerraform(struct!.volume),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesFilesystemsSourceVolumeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesFilesystemsSourceVolume | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._pool !== undefined) {
      hasAnyValues = true;
      internalValueResult.pool = this._pool;
    }
    if (this._volume !== undefined) {
      hasAnyValues = true;
      internalValueResult.volume = this._volume;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesFilesystemsSourceVolume | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._pool = undefined;
      this._volume = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._pool = value.pool;
      this._volume = value.volume;
    }
  }

  // pool - computed: false, optional: false, required: true
  private _pool?: string; 
  public get pool() {
    return this.getStringAttribute('pool');
  }
  public set pool(value: string) {
    this._pool = value;
  }
  // Temporarily expose input value. Use with caution.
  public get poolInput() {
    return this._pool;
  }

  // volume - computed: false, optional: false, required: true
  private _volume?: string; 
  public get volume() {
    return this.getStringAttribute('volume');
  }
  public set volume(value: string) {
    this._volume = value;
  }
  // Temporarily expose input value. Use with caution.
  public get volumeInput() {
    return this._volume;
  }
}
export interface DomainDevicesFilesystemsSource {
  /**
  * Selects a host directory to be exposed via a bind-mountstyle filesystem source, used when `type="mount"` and `accessmode`/`source` semantics require an existing directory.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bind Domain#bind}
  */
  readonly bind?: DomainDevicesFilesystemsSourceBind;
  /**
  * Selects a host block device node as the filesystem source, used for block-backed filesystems.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#block Domain#block}
  */
  readonly block?: DomainDevicesFilesystemsSourceBlock;
  /**
  * Selects a regular host file (for example an image or archive) as the filesystem source.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file?: DomainDevicesFilesystemsSourceFile;
  /**
  * Selects an existing host mount point or socket as the filesystem source, typically used for 9p/virtio-fs style exports.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mount Domain#mount}
  */
  readonly mount?: DomainDevicesFilesystemsSourceMount;
  /**
  * Selects a RAM-backed filesystem source that uses host memory only, configured by `usage` and optional `units`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#ram Domain#ram}
  */
  readonly ram?: DomainDevicesFilesystemsSourceRam;
  /**
  * Selects a template-based source for the filesystem, where the actual contents are derived from a template definition; the specific semantics and value are user-provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#template Domain#template}
  */
  readonly template?: DomainDevicesFilesystemsSourceTemplate;
  /**
  * Enables using a managed storage volume as the filesystem source instead of a host path, referencing a volume from a libvirt storage pool.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#volume Domain#volume}
  */
  readonly volume?: DomainDevicesFilesystemsSourceVolume;
}

export function domainDevicesFilesystemsSourceToTerraform(struct?: DomainDevicesFilesystemsSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind: domainDevicesFilesystemsSourceBindToTerraform(struct!.bind),
    block: domainDevicesFilesystemsSourceBlockToTerraform(struct!.block),
    file: domainDevicesFilesystemsSourceFileToTerraform(struct!.file),
    mount: domainDevicesFilesystemsSourceMountToTerraform(struct!.mount),
    ram: domainDevicesFilesystemsSourceRamToTerraform(struct!.ram),
    template: domainDevicesFilesystemsSourceTemplateToTerraform(struct!.template),
    volume: domainDevicesFilesystemsSourceVolumeToTerraform(struct!.volume),
  }
}


export function domainDevicesFilesystemsSourceToHclTerraform(struct?: DomainDevicesFilesystemsSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind: {
      value: domainDevicesFilesystemsSourceBindToHclTerraform(struct!.bind),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesFilesystemsSourceBind",
    },
    block: {
      value: domainDevicesFilesystemsSourceBlockToHclTerraform(struct!.block),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesFilesystemsSourceBlock",
    },
    file: {
      value: domainDevicesFilesystemsSourceFileToHclTerraform(struct!.file),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesFilesystemsSourceFile",
    },
    mount: {
      value: domainDevicesFilesystemsSourceMountToHclTerraform(struct!.mount),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesFilesystemsSourceMount",
    },
    ram: {
      value: domainDevicesFilesystemsSourceRamToHclTerraform(struct!.ram),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesFilesystemsSourceRam",
    },
    template: {
      value: domainDevicesFilesystemsSourceTemplateToHclTerraform(struct!.template),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesFilesystemsSourceTemplate",
    },
    volume: {
      value: domainDevicesFilesystemsSourceVolumeToHclTerraform(struct!.volume),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesFilesystemsSourceVolume",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesFilesystemsSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesFilesystemsSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bind?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bind = this._bind?.internalValue;
    }
    if (this._block?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.block = this._block?.internalValue;
    }
    if (this._file?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file?.internalValue;
    }
    if (this._mount?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.mount = this._mount?.internalValue;
    }
    if (this._ram?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ram = this._ram?.internalValue;
    }
    if (this._template?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.template = this._template?.internalValue;
    }
    if (this._volume?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.volume = this._volume?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesFilesystemsSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bind.internalValue = undefined;
      this._block.internalValue = undefined;
      this._file.internalValue = undefined;
      this._mount.internalValue = undefined;
      this._ram.internalValue = undefined;
      this._template.internalValue = undefined;
      this._volume.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bind.internalValue = value.bind;
      this._block.internalValue = value.block;
      this._file.internalValue = value.file;
      this._mount.internalValue = value.mount;
      this._ram.internalValue = value.ram;
      this._template.internalValue = value.template;
      this._volume.internalValue = value.volume;
    }
  }

  // bind - computed: false, optional: true, required: false
  private _bind = new DomainDevicesFilesystemsSourceBindOutputReference(this, "bind");
  public get bind() {
    return this._bind;
  }
  public putBind(value: DomainDevicesFilesystemsSourceBind) {
    this._bind.internalValue = value;
  }
  public resetBind() {
    this._bind.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInput() {
    return this._bind.internalValue;
  }

  // block - computed: false, optional: true, required: false
  private _block = new DomainDevicesFilesystemsSourceBlockOutputReference(this, "block");
  public get block() {
    return this._block;
  }
  public putBlock(value: DomainDevicesFilesystemsSourceBlock) {
    this._block.internalValue = value;
  }
  public resetBlock() {
    this._block.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get blockInput() {
    return this._block.internalValue;
  }

  // file - computed: false, optional: true, required: false
  private _file = new DomainDevicesFilesystemsSourceFileOutputReference(this, "file");
  public get file() {
    return this._file;
  }
  public putFile(value: DomainDevicesFilesystemsSourceFile) {
    this._file.internalValue = value;
  }
  public resetFile() {
    this._file.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file.internalValue;
  }

  // mount - computed: false, optional: true, required: false
  private _mount = new DomainDevicesFilesystemsSourceMountOutputReference(this, "mount");
  public get mount() {
    return this._mount;
  }
  public putMount(value: DomainDevicesFilesystemsSourceMount) {
    this._mount.internalValue = value;
  }
  public resetMount() {
    this._mount.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mountInput() {
    return this._mount.internalValue;
  }

  // ram - computed: false, optional: true, required: false
  private _ram = new DomainDevicesFilesystemsSourceRamOutputReference(this, "ram");
  public get ram() {
    return this._ram;
  }
  public putRam(value: DomainDevicesFilesystemsSourceRam) {
    this._ram.internalValue = value;
  }
  public resetRam() {
    this._ram.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ramInput() {
    return this._ram.internalValue;
  }

  // template - computed: false, optional: true, required: false
  private _template = new DomainDevicesFilesystemsSourceTemplateOutputReference(this, "template");
  public get template() {
    return this._template;
  }
  public putTemplate(value: DomainDevicesFilesystemsSourceTemplate) {
    this._template.internalValue = value;
  }
  public resetTemplate() {
    this._template.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get templateInput() {
    return this._template.internalValue;
  }

  // volume - computed: false, optional: true, required: false
  private _volume = new DomainDevicesFilesystemsSourceVolumeOutputReference(this, "volume");
  public get volume() {
    return this._volume;
  }
  public putVolume(value: DomainDevicesFilesystemsSourceVolume) {
    this._volume.internalValue = value;
  }
  public resetVolume() {
    this._volume.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get volumeInput() {
    return this._volume.internalValue;
  }
}
export interface DomainDevicesFilesystemsTarget {
  /**
  * Sets the guest-visible directory path for the filesystem mount point (for example, "/mnt/share"); the value is user-provided and must be an absolute path in the guest.
  * 
  * See: <https://libvirt.org/formatdomain.html#filesystems>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dir Domain#dir}
  */
  readonly dir: string;
}

export function domainDevicesFilesystemsTargetToTerraform(struct?: DomainDevicesFilesystemsTarget | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dir: cdktf.stringToTerraform(struct!.dir),
  }
}


export function domainDevicesFilesystemsTargetToHclTerraform(struct?: DomainDevicesFilesystemsTarget | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dir: {
      value: cdktf.stringToHclTerraform(struct!.dir),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesFilesystemsTargetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesFilesystemsTarget | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dir !== undefined) {
      hasAnyValues = true;
      internalValueResult.dir = this._dir;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesFilesystemsTarget | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dir = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dir = value.dir;
    }
  }

  // dir - computed: false, optional: false, required: true
  private _dir?: string; 
  public get dir() {
    return this.getStringAttribute('dir');
  }
  public set dir(value: string) {
    this._dir = value;
  }
  // Temporarily expose input value. Use with caution.
  public get dirInput() {
    return this._dir;
  }
}
export interface DomainDevicesFilesystems {
  /**
  * Sets how the guest accesses the host filesystem, typically "passthrough", "mapped", or "squash" for directory-based filesystems.
  * 
  * See: <https://libvirt.org/formatdomain.html#filesystems>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#access_mode Domain#access_mode}
  */
  readonly accessMode?: string;
  /**
  * Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#acpi Domain#acpi}
  */
  readonly acpi?: DomainDevicesFilesystemsAcpi;
  /**
  * Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: DomainDevicesFilesystemsAddress;
  /**
  * Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#alias Domain#alias}
  */
  readonly alias?: DomainDevicesFilesystemsAlias;
  /**
  * Configures a virtiofsd-like helper binary used to export the host filesystem to the guest, including its path and runtime limits. When omitted, libvirt or the hypervisor default behavior for the filesystem backend is used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#binary Domain#binary}
  */
  readonly binary?: DomainDevicesFilesystemsBinary;
  /**
  * Enables boot-order control for this redirected device, allowing it to participate in the device boot sequence.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#boot Domain#boot}
  */
  readonly boot?: DomainDevicesFilesystemsBoot;
  /**
  * Sets the default directory permission bits (in octal, e.g. 0755) that libvirt applies to newly created directories inside the guest-visible mount of this filesystem.
  * 
  * See: <https://libvirt.org/formatdomain.html#filesystems>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dmode Domain#dmode}
  */
  readonly dmode?: string;
  /**
  * Configures driver-specific options for the filesystem device, including implementation type and virtio transport tuning for applicable models.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#driver Domain#driver}
  */
  readonly driver?: DomainDevicesFilesystemsDriver;
  /**
  * Sets the default file permission bits (in octal, e.g. 0644) that libvirt applies to newly created regular files inside the guest-visible mount of this filesystem.
  * 
  * See: <https://libvirt.org/formatdomain.html#filesystems>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#fmode Domain#fmode}
  */
  readonly fmode?: string;
  /**
  * Configures user and group ID mapping for this filesystem device, allowing remapping of guest UIDs/GIDs to different host IDs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#id_map Domain#id_map}
  */
  readonly idMap?: DomainDevicesFilesystemsIdMap;
  /**
  * Sets the filesystem device model presented to the guest, typically `virtio` for paravirtualized filesystems; the exact value is user-provided but must be supported by the hypervisor (e.g. `virtiofs` for type `virtiofs`).
  * 
  * See: <https://libvirt.org/formatdomain.html#filesystems>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls how the guest is allowed to access multiple backing devices under a single shared filesystem, using libvirts `multidevs` policy such as `default`, `remap`, `forbid`, or `warn`.
  * 
  * See: <https://libvirt.org/formatdomain.html#filesystems>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#multi_devs Domain#multi_devs}
  */
  readonly multiDevs?: string;
  /**
  * Controls whether the filesystem is attached read-only to the guest; when true the `<readonly>` element is emitted, otherwise it is omitted and the filesystem is writable if supported.
  * 
  * See: <https://libvirt.org/formatdomain.html#filesystems>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#read_only Domain#read_only}
  */
  readonly readOnly?: boolean | cdktf.IResolvable;
  /**
  * Groups the specification of the host-side filesystem source, with exactly one of the child variants (`bind`, `block`, `file`, `mount`, `ram`, or `template`) used depending on the filesystem `type`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#source Domain#source}
  */
  readonly source?: DomainDevicesFilesystemsSource;
  /**
  * Sets a hard limit on the amount of host storage space that the filesystem device may consume; the numeric value is interpreted together with space_hard_limit_unit.
  * 
  * See: <https://libvirt.org/formatdomain.html#filesystems>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#space_hard_limit Domain#space_hard_limit}
  */
  readonly spaceHardLimit?: number;
  /**
  * Sets the unit for space_hard_limit (for example, "bytes", "KiB", "MiB", "GiB"); the value is a libvirt size unit string and must be consistent with the numeric limit.
  * 
  * See: <https://libvirt.org/formatdomain.html#filesystems>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#space_hard_limit_unit Domain#space_hard_limit_unit}
  */
  readonly spaceHardLimitUnit?: string;
  /**
  * Sets a soft (advisory) limit on the amount of host storage space that the filesystem device should use; the numeric value is interpreted together with space_soft_limit_unit.
  * 
  * See: <https://libvirt.org/formatdomain.html#filesystems>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#space_soft_limit Domain#space_soft_limit}
  */
  readonly spaceSoftLimit?: number;
  /**
  * Sets the unit for space_soft_limit (for example, "bytes", "KiB", "MiB", "GiB"); the value is a libvirt size unit string and must be consistent with the numeric limit.
  * 
  * See: <https://libvirt.org/formatdomain.html#filesystems>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#space_soft_limit_unit Domain#space_soft_limit_unit}
  */
  readonly spaceSoftLimitUnit?: string;
  /**
  * Configures how and where the filesystem is exposed inside the guest by providing the guest-side mount target.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#target Domain#target}
  */
  readonly target?: DomainDevicesFilesystemsTarget;
}

export function domainDevicesFilesystemsToTerraform(struct?: DomainDevicesFilesystems | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_mode: cdktf.stringToTerraform(struct!.accessMode),
    acpi: domainDevicesFilesystemsAcpiToTerraform(struct!.acpi),
    address: domainDevicesFilesystemsAddressToTerraform(struct!.address),
    alias: domainDevicesFilesystemsAliasToTerraform(struct!.alias),
    binary: domainDevicesFilesystemsBinaryToTerraform(struct!.binary),
    boot: domainDevicesFilesystemsBootToTerraform(struct!.boot),
    dmode: cdktf.stringToTerraform(struct!.dmode),
    driver: domainDevicesFilesystemsDriverToTerraform(struct!.driver),
    fmode: cdktf.stringToTerraform(struct!.fmode),
    id_map: domainDevicesFilesystemsIdMapToTerraform(struct!.idMap),
    model: cdktf.stringToTerraform(struct!.model),
    multi_devs: cdktf.stringToTerraform(struct!.multiDevs),
    read_only: cdktf.booleanToTerraform(struct!.readOnly),
    source: domainDevicesFilesystemsSourceToTerraform(struct!.source),
    space_hard_limit: cdktf.numberToTerraform(struct!.spaceHardLimit),
    space_hard_limit_unit: cdktf.stringToTerraform(struct!.spaceHardLimitUnit),
    space_soft_limit: cdktf.numberToTerraform(struct!.spaceSoftLimit),
    space_soft_limit_unit: cdktf.stringToTerraform(struct!.spaceSoftLimitUnit),
    target: domainDevicesFilesystemsTargetToTerraform(struct!.target),
  }
}


export function domainDevicesFilesystemsToHclTerraform(struct?: DomainDevicesFilesystems | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_mode: {
      value: cdktf.stringToHclTerraform(struct!.accessMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    acpi: {
      value: domainDevicesFilesystemsAcpiToHclTerraform(struct!.acpi),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesFilesystemsAcpi",
    },
    address: {
      value: domainDevicesFilesystemsAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesFilesystemsAddress",
    },
    alias: {
      value: domainDevicesFilesystemsAliasToHclTerraform(struct!.alias),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesFilesystemsAlias",
    },
    binary: {
      value: domainDevicesFilesystemsBinaryToHclTerraform(struct!.binary),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesFilesystemsBinary",
    },
    boot: {
      value: domainDevicesFilesystemsBootToHclTerraform(struct!.boot),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesFilesystemsBoot",
    },
    dmode: {
      value: cdktf.stringToHclTerraform(struct!.dmode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    driver: {
      value: domainDevicesFilesystemsDriverToHclTerraform(struct!.driver),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesFilesystemsDriver",
    },
    fmode: {
      value: cdktf.stringToHclTerraform(struct!.fmode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id_map: {
      value: domainDevicesFilesystemsIdMapToHclTerraform(struct!.idMap),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesFilesystemsIdMap",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    multi_devs: {
      value: cdktf.stringToHclTerraform(struct!.multiDevs),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    read_only: {
      value: cdktf.booleanToHclTerraform(struct!.readOnly),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    source: {
      value: domainDevicesFilesystemsSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesFilesystemsSource",
    },
    space_hard_limit: {
      value: cdktf.numberToHclTerraform(struct!.spaceHardLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    space_hard_limit_unit: {
      value: cdktf.stringToHclTerraform(struct!.spaceHardLimitUnit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    space_soft_limit: {
      value: cdktf.numberToHclTerraform(struct!.spaceSoftLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    space_soft_limit_unit: {
      value: cdktf.stringToHclTerraform(struct!.spaceSoftLimitUnit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    target: {
      value: domainDevicesFilesystemsTargetToHclTerraform(struct!.target),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesFilesystemsTarget",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesFilesystemsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesFilesystems | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessMode = this._accessMode;
    }
    if (this._acpi?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.acpi = this._acpi?.internalValue;
    }
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._alias?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.alias = this._alias?.internalValue;
    }
    if (this._binary?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.binary = this._binary?.internalValue;
    }
    if (this._boot?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.boot = this._boot?.internalValue;
    }
    if (this._dmode !== undefined) {
      hasAnyValues = true;
      internalValueResult.dmode = this._dmode;
    }
    if (this._driver?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.driver = this._driver?.internalValue;
    }
    if (this._fmode !== undefined) {
      hasAnyValues = true;
      internalValueResult.fmode = this._fmode;
    }
    if (this._idMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.idMap = this._idMap?.internalValue;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._multiDevs !== undefined) {
      hasAnyValues = true;
      internalValueResult.multiDevs = this._multiDevs;
    }
    if (this._readOnly !== undefined) {
      hasAnyValues = true;
      internalValueResult.readOnly = this._readOnly;
    }
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    if (this._spaceHardLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.spaceHardLimit = this._spaceHardLimit;
    }
    if (this._spaceHardLimitUnit !== undefined) {
      hasAnyValues = true;
      internalValueResult.spaceHardLimitUnit = this._spaceHardLimitUnit;
    }
    if (this._spaceSoftLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.spaceSoftLimit = this._spaceSoftLimit;
    }
    if (this._spaceSoftLimitUnit !== undefined) {
      hasAnyValues = true;
      internalValueResult.spaceSoftLimitUnit = this._spaceSoftLimitUnit;
    }
    if (this._target?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.target = this._target?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesFilesystems | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessMode = undefined;
      this._acpi.internalValue = undefined;
      this._address.internalValue = undefined;
      this._alias.internalValue = undefined;
      this._binary.internalValue = undefined;
      this._boot.internalValue = undefined;
      this._dmode = undefined;
      this._driver.internalValue = undefined;
      this._fmode = undefined;
      this._idMap.internalValue = undefined;
      this._model = undefined;
      this._multiDevs = undefined;
      this._readOnly = undefined;
      this._source.internalValue = undefined;
      this._spaceHardLimit = undefined;
      this._spaceHardLimitUnit = undefined;
      this._spaceSoftLimit = undefined;
      this._spaceSoftLimitUnit = undefined;
      this._target.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessMode = value.accessMode;
      this._acpi.internalValue = value.acpi;
      this._address.internalValue = value.address;
      this._alias.internalValue = value.alias;
      this._binary.internalValue = value.binary;
      this._boot.internalValue = value.boot;
      this._dmode = value.dmode;
      this._driver.internalValue = value.driver;
      this._fmode = value.fmode;
      this._idMap.internalValue = value.idMap;
      this._model = value.model;
      this._multiDevs = value.multiDevs;
      this._readOnly = value.readOnly;
      this._source.internalValue = value.source;
      this._spaceHardLimit = value.spaceHardLimit;
      this._spaceHardLimitUnit = value.spaceHardLimitUnit;
      this._spaceSoftLimit = value.spaceSoftLimit;
      this._spaceSoftLimitUnit = value.spaceSoftLimitUnit;
      this._target.internalValue = value.target;
    }
  }

  // access_mode - computed: false, optional: true, required: false
  private _accessMode?: string; 
  public get accessMode() {
    return this.getStringAttribute('access_mode');
  }
  public set accessMode(value: string) {
    this._accessMode = value;
  }
  public resetAccessMode() {
    this._accessMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessModeInput() {
    return this._accessMode;
  }

  // acpi - computed: false, optional: true, required: false
  private _acpi = new DomainDevicesFilesystemsAcpiOutputReference(this, "acpi");
  public get acpi() {
    return this._acpi;
  }
  public putAcpi(value: DomainDevicesFilesystemsAcpi) {
    this._acpi.internalValue = value;
  }
  public resetAcpi() {
    this._acpi.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get acpiInput() {
    return this._acpi.internalValue;
  }

  // address - computed: false, optional: true, required: false
  private _address = new DomainDevicesFilesystemsAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DomainDevicesFilesystemsAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // alias - computed: false, optional: true, required: false
  private _alias = new DomainDevicesFilesystemsAliasOutputReference(this, "alias");
  public get alias() {
    return this._alias;
  }
  public putAlias(value: DomainDevicesFilesystemsAlias) {
    this._alias.internalValue = value;
  }
  public resetAlias() {
    this._alias.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aliasInput() {
    return this._alias.internalValue;
  }

  // binary - computed: false, optional: true, required: false
  private _binary = new DomainDevicesFilesystemsBinaryOutputReference(this, "binary");
  public get binary() {
    return this._binary;
  }
  public putBinary(value: DomainDevicesFilesystemsBinary) {
    this._binary.internalValue = value;
  }
  public resetBinary() {
    this._binary.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get binaryInput() {
    return this._binary.internalValue;
  }

  // boot - computed: false, optional: true, required: false
  private _boot = new DomainDevicesFilesystemsBootOutputReference(this, "boot");
  public get boot() {
    return this._boot;
  }
  public putBoot(value: DomainDevicesFilesystemsBoot) {
    this._boot.internalValue = value;
  }
  public resetBoot() {
    this._boot.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bootInput() {
    return this._boot.internalValue;
  }

  // dmode - computed: false, optional: true, required: false
  private _dmode?: string; 
  public get dmode() {
    return this.getStringAttribute('dmode');
  }
  public set dmode(value: string) {
    this._dmode = value;
  }
  public resetDmode() {
    this._dmode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dmodeInput() {
    return this._dmode;
  }

  // driver - computed: false, optional: true, required: false
  private _driver = new DomainDevicesFilesystemsDriverOutputReference(this, "driver");
  public get driver() {
    return this._driver;
  }
  public putDriver(value: DomainDevicesFilesystemsDriver) {
    this._driver.internalValue = value;
  }
  public resetDriver() {
    this._driver.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get driverInput() {
    return this._driver.internalValue;
  }

  // fmode - computed: false, optional: true, required: false
  private _fmode?: string; 
  public get fmode() {
    return this.getStringAttribute('fmode');
  }
  public set fmode(value: string) {
    this._fmode = value;
  }
  public resetFmode() {
    this._fmode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fmodeInput() {
    return this._fmode;
  }

  // id_map - computed: false, optional: true, required: false
  private _idMap = new DomainDevicesFilesystemsIdMapOutputReference(this, "id_map");
  public get idMap() {
    return this._idMap;
  }
  public putIdMap(value: DomainDevicesFilesystemsIdMap) {
    this._idMap.internalValue = value;
  }
  public resetIdMap() {
    this._idMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idMapInput() {
    return this._idMap.internalValue;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // multi_devs - computed: false, optional: true, required: false
  private _multiDevs?: string; 
  public get multiDevs() {
    return this.getStringAttribute('multi_devs');
  }
  public set multiDevs(value: string) {
    this._multiDevs = value;
  }
  public resetMultiDevs() {
    this._multiDevs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get multiDevsInput() {
    return this._multiDevs;
  }

  // read_only - computed: false, optional: true, required: false
  private _readOnly?: boolean | cdktf.IResolvable; 
  public get readOnly() {
    return this.getBooleanAttribute('read_only');
  }
  public set readOnly(value: boolean | cdktf.IResolvable) {
    this._readOnly = value;
  }
  public resetReadOnly() {
    this._readOnly = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readOnlyInput() {
    return this._readOnly;
  }

  // source - computed: false, optional: true, required: false
  private _source = new DomainDevicesFilesystemsSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: DomainDevicesFilesystemsSource) {
    this._source.internalValue = value;
  }
  public resetSource() {
    this._source.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }

  // space_hard_limit - computed: false, optional: true, required: false
  private _spaceHardLimit?: number; 
  public get spaceHardLimit() {
    return this.getNumberAttribute('space_hard_limit');
  }
  public set spaceHardLimit(value: number) {
    this._spaceHardLimit = value;
  }
  public resetSpaceHardLimit() {
    this._spaceHardLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spaceHardLimitInput() {
    return this._spaceHardLimit;
  }

  // space_hard_limit_unit - computed: false, optional: true, required: false
  private _spaceHardLimitUnit?: string; 
  public get spaceHardLimitUnit() {
    return this.getStringAttribute('space_hard_limit_unit');
  }
  public set spaceHardLimitUnit(value: string) {
    this._spaceHardLimitUnit = value;
  }
  public resetSpaceHardLimitUnit() {
    this._spaceHardLimitUnit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spaceHardLimitUnitInput() {
    return this._spaceHardLimitUnit;
  }

  // space_soft_limit - computed: false, optional: true, required: false
  private _spaceSoftLimit?: number; 
  public get spaceSoftLimit() {
    return this.getNumberAttribute('space_soft_limit');
  }
  public set spaceSoftLimit(value: number) {
    this._spaceSoftLimit = value;
  }
  public resetSpaceSoftLimit() {
    this._spaceSoftLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spaceSoftLimitInput() {
    return this._spaceSoftLimit;
  }

  // space_soft_limit_unit - computed: false, optional: true, required: false
  private _spaceSoftLimitUnit?: string; 
  public get spaceSoftLimitUnit() {
    return this.getStringAttribute('space_soft_limit_unit');
  }
  public set spaceSoftLimitUnit(value: string) {
    this._spaceSoftLimitUnit = value;
  }
  public resetSpaceSoftLimitUnit() {
    this._spaceSoftLimitUnit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spaceSoftLimitUnitInput() {
    return this._spaceSoftLimitUnit;
  }

  // target - computed: false, optional: true, required: false
  private _target = new DomainDevicesFilesystemsTargetOutputReference(this, "target");
  public get target() {
    return this._target;
  }
  public putTarget(value: DomainDevicesFilesystemsTarget) {
    this._target.internalValue = value;
  }
  public resetTarget() {
    this._target.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetInput() {
    return this._target.internalValue;
  }
}

export class DomainDevicesFilesystemsList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesFilesystems[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesFilesystemsOutputReference {
    return new DomainDevicesFilesystemsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesGraphicsAudio {
}

export function domainDevicesGraphicsAudioToTerraform(struct?: DomainDevicesGraphicsAudio | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function domainDevicesGraphicsAudioToHclTerraform(struct?: DomainDevicesGraphicsAudio | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DomainDevicesGraphicsAudioOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesGraphicsAudio | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesGraphicsAudio | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }

  // id - computed: true, optional: false, required: false
  public get id() {
    return this.getNumberAttribute('id');
  }
}
export interface DomainDevicesGraphicsDbusGl {
  /**
  * Controls whether OpenGL acceleration is enabled for the DBus graphics backend; valid values are "yes" or "no".
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enable Domain#enable}
  */
  readonly enable?: string;
  /**
  * Sets the host render node device path used for GL rendering (for example, "/dev/dri/renderD128"); the value is user-provided and must refer to an existing render node.
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#render_node Domain#render_node}
  */
  readonly renderNode?: string;
}

export function domainDevicesGraphicsDbusGlToTerraform(struct?: DomainDevicesGraphicsDbusGl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.stringToTerraform(struct!.enable),
    render_node: cdktf.stringToTerraform(struct!.renderNode),
  }
}


export function domainDevicesGraphicsDbusGlToHclTerraform(struct?: DomainDevicesGraphicsDbusGl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.stringToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    render_node: {
      value: cdktf.stringToHclTerraform(struct!.renderNode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesGraphicsDbusGlOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesGraphicsDbusGl | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._renderNode !== undefined) {
      hasAnyValues = true;
      internalValueResult.renderNode = this._renderNode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesGraphicsDbusGl | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
      this._renderNode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
      this._renderNode = value.renderNode;
    }
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: string; 
  public get enable() {
    return this.getStringAttribute('enable');
  }
  public set enable(value: string) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // render_node - computed: false, optional: true, required: false
  private _renderNode?: string; 
  public get renderNode() {
    return this.getStringAttribute('render_node');
  }
  public set renderNode(value: string) {
    this._renderNode = value;
  }
  public resetRenderNode() {
    this._renderNode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get renderNodeInput() {
    return this._renderNode;
  }
}
export interface DomainDevicesGraphicsDbus {
  /**
  * Sets the DBus address (bus or endpoint string) that the graphics device uses for its DBus display connection; the value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: string;
  /**
  * Configures OpenGL acceleration options for the DBus graphics backend, including whether GL is enabled and which render node to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#gl Domain#gl}
  */
  readonly gl?: DomainDevicesGraphicsDbusGl;
  /**
  * Controls whether peer-to-peer DBus connections are used for the graphics device; valid values are "yes" or "no".
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#p2p Domain#p2p}
  */
  readonly p2P?: string;
}

export function domainDevicesGraphicsDbusToTerraform(struct?: DomainDevicesGraphicsDbus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
    gl: domainDevicesGraphicsDbusGlToTerraform(struct!.gl),
    p2p: cdktf.stringToTerraform(struct!.p2P),
  }
}


export function domainDevicesGraphicsDbusToHclTerraform(struct?: DomainDevicesGraphicsDbus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    gl: {
      value: domainDevicesGraphicsDbusGlToHclTerraform(struct!.gl),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesGraphicsDbusGl",
    },
    p2p: {
      value: cdktf.stringToHclTerraform(struct!.p2P),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesGraphicsDbusOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesGraphicsDbus | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    if (this._gl?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.gl = this._gl?.internalValue;
    }
    if (this._p2P !== undefined) {
      hasAnyValues = true;
      internalValueResult.p2P = this._p2P;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesGraphicsDbus | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
      this._gl.internalValue = undefined;
      this._p2P = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
      this._gl.internalValue = value.gl;
      this._p2P = value.p2P;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  public resetAddress() {
    this._address = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }

  // gl - computed: false, optional: true, required: false
  private _gl = new DomainDevicesGraphicsDbusGlOutputReference(this, "gl");
  public get gl() {
    return this._gl;
  }
  public putGl(value: DomainDevicesGraphicsDbusGl) {
    this._gl.internalValue = value;
  }
  public resetGl() {
    this._gl.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get glInput() {
    return this._gl.internalValue;
  }

  // p2p - computed: false, optional: true, required: false
  private _p2P?: string; 
  public get p2P() {
    return this.getStringAttribute('p2p');
  }
  public set p2P(value: string) {
    this._p2P = value;
  }
  public resetP2P() {
    this._p2P = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get p2PInput() {
    return this._p2P;
  }
}
export interface DomainDevicesGraphicsDesktop {
  /**
  * Sets the X11 display string for the SDL graphics desktop (for example, ":0.0") when using the SDL graphics backend; the value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#display Domain#display}
  */
  readonly display?: string;
  /**
  * Controls whether the SDL desktop window starts in fullscreen mode; accepts "yes" or "no".
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#full_screen Domain#full_screen}
  */
  readonly fullScreen?: string;
}

export function domainDevicesGraphicsDesktopToTerraform(struct?: DomainDevicesGraphicsDesktop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    display: cdktf.stringToTerraform(struct!.display),
    full_screen: cdktf.stringToTerraform(struct!.fullScreen),
  }
}


export function domainDevicesGraphicsDesktopToHclTerraform(struct?: DomainDevicesGraphicsDesktop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    display: {
      value: cdktf.stringToHclTerraform(struct!.display),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    full_screen: {
      value: cdktf.stringToHclTerraform(struct!.fullScreen),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesGraphicsDesktopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesGraphicsDesktop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._display !== undefined) {
      hasAnyValues = true;
      internalValueResult.display = this._display;
    }
    if (this._fullScreen !== undefined) {
      hasAnyValues = true;
      internalValueResult.fullScreen = this._fullScreen;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesGraphicsDesktop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._display = undefined;
      this._fullScreen = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._display = value.display;
      this._fullScreen = value.fullScreen;
    }
  }

  // display - computed: false, optional: true, required: false
  private _display?: string; 
  public get display() {
    return this.getStringAttribute('display');
  }
  public set display(value: string) {
    this._display = value;
  }
  public resetDisplay() {
    this._display = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get displayInput() {
    return this._display;
  }

  // full_screen - computed: false, optional: true, required: false
  private _fullScreen?: string; 
  public get fullScreen() {
    return this.getStringAttribute('full_screen');
  }
  public set fullScreen(value: string) {
    this._fullScreen = value;
  }
  public resetFullScreen() {
    this._fullScreen = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fullScreenInput() {
    return this._fullScreen;
  }
}
export interface DomainDevicesGraphicsEglHeadlessGl {
  /**
  * Sets the DRM render node path to use for EGL/GL rendering with egl-headless (for example, "/dev/dri/renderD128"); the value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#render_node Domain#render_node}
  */
  readonly renderNode?: string;
}

export function domainDevicesGraphicsEglHeadlessGlToTerraform(struct?: DomainDevicesGraphicsEglHeadlessGl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    render_node: cdktf.stringToTerraform(struct!.renderNode),
  }
}


export function domainDevicesGraphicsEglHeadlessGlToHclTerraform(struct?: DomainDevicesGraphicsEglHeadlessGl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    render_node: {
      value: cdktf.stringToHclTerraform(struct!.renderNode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesGraphicsEglHeadlessGlOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesGraphicsEglHeadlessGl | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._renderNode !== undefined) {
      hasAnyValues = true;
      internalValueResult.renderNode = this._renderNode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesGraphicsEglHeadlessGl | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._renderNode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._renderNode = value.renderNode;
    }
  }

  // render_node - computed: false, optional: true, required: false
  private _renderNode?: string; 
  public get renderNode() {
    return this.getStringAttribute('render_node');
  }
  public set renderNode(value: string) {
    this._renderNode = value;
  }
  public resetRenderNode() {
    this._renderNode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get renderNodeInput() {
    return this._renderNode;
  }
}
export interface DomainDevicesGraphicsEglHeadless {
  /**
  * Configures OpenGL-related options for the egl-headless graphics backend.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#gl Domain#gl}
  */
  readonly gl?: DomainDevicesGraphicsEglHeadlessGl;
}

export function domainDevicesGraphicsEglHeadlessToTerraform(struct?: DomainDevicesGraphicsEglHeadless | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    gl: domainDevicesGraphicsEglHeadlessGlToTerraform(struct!.gl),
  }
}


export function domainDevicesGraphicsEglHeadlessToHclTerraform(struct?: DomainDevicesGraphicsEglHeadless | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    gl: {
      value: domainDevicesGraphicsEglHeadlessGlToHclTerraform(struct!.gl),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesGraphicsEglHeadlessGl",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesGraphicsEglHeadlessOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesGraphicsEglHeadless | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._gl?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.gl = this._gl?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesGraphicsEglHeadless | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._gl.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._gl.internalValue = value.gl;
    }
  }

  // gl - computed: false, optional: true, required: false
  private _gl = new DomainDevicesGraphicsEglHeadlessGlOutputReference(this, "gl");
  public get gl() {
    return this._gl;
  }
  public putGl(value: DomainDevicesGraphicsEglHeadlessGl) {
    this._gl.internalValue = value;
  }
  public resetGl() {
    this._gl.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get glInput() {
    return this._gl.internalValue;
  }
}
export interface DomainDevicesGraphicsRdpListenersAddress {
  /**
  * Sets the host IP address or hostname on which this SPICE listener should bind (for example `127.0.0.1` or `0.0.0.0`; value is user-provided).
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: string;
}

export function domainDevicesGraphicsRdpListenersAddressToTerraform(struct?: DomainDevicesGraphicsRdpListenersAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
  }
}


export function domainDevicesGraphicsRdpListenersAddressToHclTerraform(struct?: DomainDevicesGraphicsRdpListenersAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesGraphicsRdpListenersAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesGraphicsRdpListenersAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesGraphicsRdpListenersAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  public resetAddress() {
    this._address = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }
}
export interface DomainDevicesGraphicsRdpListenersNetwork {
  /**
  * Optionally overrides the automatically chosen address for a network-based SPICE listener with a specific IP/hostname (user-provided value).
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: string;
  /**
  * Names the libvirt virtual network that defines where this SPICE listener will be exposed (value must match an existing libvirt network name).
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#network Domain#network}
  */
  readonly network?: string;
}

export function domainDevicesGraphicsRdpListenersNetworkToTerraform(struct?: DomainDevicesGraphicsRdpListenersNetwork | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
    network: cdktf.stringToTerraform(struct!.network),
  }
}


export function domainDevicesGraphicsRdpListenersNetworkToHclTerraform(struct?: DomainDevicesGraphicsRdpListenersNetwork | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    network: {
      value: cdktf.stringToHclTerraform(struct!.network),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesGraphicsRdpListenersNetworkOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesGraphicsRdpListenersNetwork | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    if (this._network !== undefined) {
      hasAnyValues = true;
      internalValueResult.network = this._network;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesGraphicsRdpListenersNetwork | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
      this._network = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
      this._network = value.network;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  public resetAddress() {
    this._address = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }

  // network - computed: false, optional: true, required: false
  private _network?: string; 
  public get network() {
    return this.getStringAttribute('network');
  }
  public set network(value: string) {
    this._network = value;
  }
  public resetNetwork() {
    this._network = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkInput() {
    return this._network;
  }
}
export interface DomainDevicesGraphicsRdpListenersSocket {
  /**
  * Sets the filesystem path to the UNIX domain socket used by this SPICE listener (for example `/var/run/libvirt/qemu/spice.sock`; value is user-provided).
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#socket Domain#socket}
  */
  readonly socket?: string;
}

export function domainDevicesGraphicsRdpListenersSocketToTerraform(struct?: DomainDevicesGraphicsRdpListenersSocket | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    socket: cdktf.stringToTerraform(struct!.socket),
  }
}


export function domainDevicesGraphicsRdpListenersSocketToHclTerraform(struct?: DomainDevicesGraphicsRdpListenersSocket | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    socket: {
      value: cdktf.stringToHclTerraform(struct!.socket),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesGraphicsRdpListenersSocketOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesGraphicsRdpListenersSocket | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._socket !== undefined) {
      hasAnyValues = true;
      internalValueResult.socket = this._socket;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesGraphicsRdpListenersSocket | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._socket = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._socket = value.socket;
    }
  }

  // socket - computed: false, optional: true, required: false
  private _socket?: string; 
  public get socket() {
    return this.getStringAttribute('socket');
  }
  public set socket(value: string) {
    this._socket = value;
  }
  public resetSocket() {
    this._socket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketInput() {
    return this._socket;
  }
}
export interface DomainDevicesGraphicsRdpListeners {
  /**
  * Declares a SPICE listener that binds directly to a host IP address using the nested `address` attribute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: DomainDevicesGraphicsRdpListenersAddress;
  /**
  * Declares a SPICE listener whose binding is determined by the specified libvirt virtual network and optional address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#network Domain#network}
  */
  readonly network?: DomainDevicesGraphicsRdpListenersNetwork;
  /**
  * Declares a SPICE listener that uses a UNIX domain socket instead of TCP/IP for client connections.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#socket Domain#socket}
  */
  readonly socket?: DomainDevicesGraphicsRdpListenersSocket;
}

export function domainDevicesGraphicsRdpListenersToTerraform(struct?: DomainDevicesGraphicsRdpListeners | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: domainDevicesGraphicsRdpListenersAddressToTerraform(struct!.address),
    network: domainDevicesGraphicsRdpListenersNetworkToTerraform(struct!.network),
    socket: domainDevicesGraphicsRdpListenersSocketToTerraform(struct!.socket),
  }
}


export function domainDevicesGraphicsRdpListenersToHclTerraform(struct?: DomainDevicesGraphicsRdpListeners | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: domainDevicesGraphicsRdpListenersAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesGraphicsRdpListenersAddress",
    },
    network: {
      value: domainDevicesGraphicsRdpListenersNetworkToHclTerraform(struct!.network),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesGraphicsRdpListenersNetwork",
    },
    socket: {
      value: domainDevicesGraphicsRdpListenersSocketToHclTerraform(struct!.socket),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesGraphicsRdpListenersSocket",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesGraphicsRdpListenersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesGraphicsRdpListeners | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._network?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.network = this._network?.internalValue;
    }
    if (this._socket?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.socket = this._socket?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesGraphicsRdpListeners | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._network.internalValue = undefined;
      this._socket.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._network.internalValue = value.network;
      this._socket.internalValue = value.socket;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address = new DomainDevicesGraphicsRdpListenersAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DomainDevicesGraphicsRdpListenersAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // network - computed: false, optional: true, required: false
  private _network = new DomainDevicesGraphicsRdpListenersNetworkOutputReference(this, "network");
  public get network() {
    return this._network;
  }
  public putNetwork(value: DomainDevicesGraphicsRdpListenersNetwork) {
    this._network.internalValue = value;
  }
  public resetNetwork() {
    this._network.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkInput() {
    return this._network.internalValue;
  }

  // socket - computed: false, optional: true, required: false
  private _socket = new DomainDevicesGraphicsRdpListenersSocketOutputReference(this, "socket");
  public get socket() {
    return this._socket;
  }
  public putSocket(value: DomainDevicesGraphicsRdpListenersSocket) {
    this._socket.internalValue = value;
  }
  public resetSocket() {
    this._socket.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketInput() {
    return this._socket.internalValue;
  }
}

export class DomainDevicesGraphicsRdpListenersList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesGraphicsRdpListeners[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesGraphicsRdpListenersOutputReference {
    return new DomainDevicesGraphicsRdpListenersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesGraphicsRdp {
  /**
  * Controls whether the RDP server port is chosen automatically ("yes") or must be specified explicitly ("no"); this is a string-to-boolean flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#auto_port Domain#auto_port}
  */
  readonly autoPort?: boolean | cdktf.IResolvable;
  /**
  * Sets a single listen address or special value (such as "0.0.0.0") for the RDP server; value is user-provided and used when listener sub-elements are not used.
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#listen Domain#listen}
  */
  readonly listen?: string;
  /**
  * Defines one or more listener endpoints for the RDP server (by address, network, or UNIX socket), overriding the simple listen attribute when present.
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#listeners Domain#listeners}
  */
  readonly listeners?: DomainDevicesGraphicsRdpListeners[] | cdktf.IResolvable;
  /**
  * Controls whether the RDP server allows multiple simultaneous clients ("yes") or restricts access to a single client ("no"); the value is user-provided as "yes"/"no".
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#multi_user Domain#multi_user}
  */
  readonly multiUser?: string;
  /**
  * Sets the password required to connect to the RDP server; the value is user-provided and may be empty to allow passwordless access, depending on hypervisor policy.
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#passwd Domain#passwd}
  */
  readonly passwd?: string;
  /**
  * Sets the TCP port number on which the RDP server listens (for example, 3389); must be a valid unused TCP port when auto_port is "no".
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#port Domain#port}
  */
  readonly port?: number;
  /**
  * Controls whether a new RDP client connection replaces the currently connected user ("yes") or is refused when a client is already connected ("no"); value is user-provided as "yes"/"no".
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#replace_user Domain#replace_user}
  */
  readonly replaceUser?: string;
  /**
  * Sets the username used by the RDP graphics backend for client authentication; the value is user-provided and backend-specific.
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#username Domain#username}
  */
  readonly username?: string;
}

export function domainDevicesGraphicsRdpToTerraform(struct?: DomainDevicesGraphicsRdp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auto_port: cdktf.booleanToTerraform(struct!.autoPort),
    listen: cdktf.stringToTerraform(struct!.listen),
    listeners: cdktf.listMapper(domainDevicesGraphicsRdpListenersToTerraform, false)(struct!.listeners),
    multi_user: cdktf.stringToTerraform(struct!.multiUser),
    passwd: cdktf.stringToTerraform(struct!.passwd),
    port: cdktf.numberToTerraform(struct!.port),
    replace_user: cdktf.stringToTerraform(struct!.replaceUser),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function domainDevicesGraphicsRdpToHclTerraform(struct?: DomainDevicesGraphicsRdp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auto_port: {
      value: cdktf.booleanToHclTerraform(struct!.autoPort),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    listen: {
      value: cdktf.stringToHclTerraform(struct!.listen),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    listeners: {
      value: cdktf.listMapperHcl(domainDevicesGraphicsRdpListenersToHclTerraform, false)(struct!.listeners),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesGraphicsRdpListenersList",
    },
    multi_user: {
      value: cdktf.stringToHclTerraform(struct!.multiUser),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passwd: {
      value: cdktf.stringToHclTerraform(struct!.passwd),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    replace_user: {
      value: cdktf.stringToHclTerraform(struct!.replaceUser),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesGraphicsRdpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesGraphicsRdp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._autoPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoPort = this._autoPort;
    }
    if (this._listen !== undefined) {
      hasAnyValues = true;
      internalValueResult.listen = this._listen;
    }
    if (this._listeners?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.listeners = this._listeners?.internalValue;
    }
    if (this._multiUser !== undefined) {
      hasAnyValues = true;
      internalValueResult.multiUser = this._multiUser;
    }
    if (this._passwd !== undefined) {
      hasAnyValues = true;
      internalValueResult.passwd = this._passwd;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._replaceUser !== undefined) {
      hasAnyValues = true;
      internalValueResult.replaceUser = this._replaceUser;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesGraphicsRdp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._autoPort = undefined;
      this._listen = undefined;
      this._listeners.internalValue = undefined;
      this._multiUser = undefined;
      this._passwd = undefined;
      this._port = undefined;
      this._replaceUser = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._autoPort = value.autoPort;
      this._listen = value.listen;
      this._listeners.internalValue = value.listeners;
      this._multiUser = value.multiUser;
      this._passwd = value.passwd;
      this._port = value.port;
      this._replaceUser = value.replaceUser;
      this._username = value.username;
    }
  }

  // auto_port - computed: false, optional: true, required: false
  private _autoPort?: boolean | cdktf.IResolvable; 
  public get autoPort() {
    return this.getBooleanAttribute('auto_port');
  }
  public set autoPort(value: boolean | cdktf.IResolvable) {
    this._autoPort = value;
  }
  public resetAutoPort() {
    this._autoPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoPortInput() {
    return this._autoPort;
  }

  // listen - computed: false, optional: true, required: false
  private _listen?: string; 
  public get listen() {
    return this.getStringAttribute('listen');
  }
  public set listen(value: string) {
    this._listen = value;
  }
  public resetListen() {
    this._listen = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get listenInput() {
    return this._listen;
  }

  // listeners - computed: false, optional: true, required: false
  private _listeners = new DomainDevicesGraphicsRdpListenersList(this, "listeners", false);
  public get listeners() {
    return this._listeners;
  }
  public putListeners(value: DomainDevicesGraphicsRdpListeners[] | cdktf.IResolvable) {
    this._listeners.internalValue = value;
  }
  public resetListeners() {
    this._listeners.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get listenersInput() {
    return this._listeners.internalValue;
  }

  // multi_user - computed: false, optional: true, required: false
  private _multiUser?: string; 
  public get multiUser() {
    return this.getStringAttribute('multi_user');
  }
  public set multiUser(value: string) {
    this._multiUser = value;
  }
  public resetMultiUser() {
    this._multiUser = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get multiUserInput() {
    return this._multiUser;
  }

  // passwd - computed: false, optional: true, required: false
  private _passwd?: string; 
  public get passwd() {
    return this.getStringAttribute('passwd');
  }
  public set passwd(value: string) {
    this._passwd = value;
  }
  public resetPasswd() {
    this._passwd = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwdInput() {
    return this._passwd;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // replace_user - computed: false, optional: true, required: false
  private _replaceUser?: string; 
  public get replaceUser() {
    return this.getStringAttribute('replace_user');
  }
  public set replaceUser(value: string) {
    this._replaceUser = value;
  }
  public resetReplaceUser() {
    this._replaceUser = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get replaceUserInput() {
    return this._replaceUser;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface DomainDevicesGraphicsSdlGl {
  /**
  * Controls whether OpenGL rendering is enabled for the SDL graphics backend; accepts "yes" or "no".
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enable Domain#enable}
  */
  readonly enable?: string;
}

export function domainDevicesGraphicsSdlGlToTerraform(struct?: DomainDevicesGraphicsSdlGl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.stringToTerraform(struct!.enable),
  }
}


export function domainDevicesGraphicsSdlGlToHclTerraform(struct?: DomainDevicesGraphicsSdlGl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.stringToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesGraphicsSdlGlOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesGraphicsSdlGl | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesGraphicsSdlGl | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
    }
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: string; 
  public get enable() {
    return this.getStringAttribute('enable');
  }
  public set enable(value: string) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }
}
export interface DomainDevicesGraphicsSdl {
  /**
  * Sets the SDL display identifier (for example, ":0.0") on which the SDL window is opened; the value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#display Domain#display}
  */
  readonly display?: string;
  /**
  * Controls whether the SDL window starts in fullscreen mode; accepts "yes" or "no".
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#full_screen Domain#full_screen}
  */
  readonly fullScreen?: string;
  /**
  * Enables configuration of OpenGL support for the SDL graphics backend; when present, it toggles SDL OpenGL rendering options.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#gl Domain#gl}
  */
  readonly gl?: DomainDevicesGraphicsSdlGl;
  /**
  * Sets the X11 authorization file or token used by SDL to connect to the X server; the value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#xauth Domain#xauth}
  */
  readonly xauth?: string;
}

export function domainDevicesGraphicsSdlToTerraform(struct?: DomainDevicesGraphicsSdl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    display: cdktf.stringToTerraform(struct!.display),
    full_screen: cdktf.stringToTerraform(struct!.fullScreen),
    gl: domainDevicesGraphicsSdlGlToTerraform(struct!.gl),
    xauth: cdktf.stringToTerraform(struct!.xauth),
  }
}


export function domainDevicesGraphicsSdlToHclTerraform(struct?: DomainDevicesGraphicsSdl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    display: {
      value: cdktf.stringToHclTerraform(struct!.display),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    full_screen: {
      value: cdktf.stringToHclTerraform(struct!.fullScreen),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    gl: {
      value: domainDevicesGraphicsSdlGlToHclTerraform(struct!.gl),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesGraphicsSdlGl",
    },
    xauth: {
      value: cdktf.stringToHclTerraform(struct!.xauth),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesGraphicsSdlOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesGraphicsSdl | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._display !== undefined) {
      hasAnyValues = true;
      internalValueResult.display = this._display;
    }
    if (this._fullScreen !== undefined) {
      hasAnyValues = true;
      internalValueResult.fullScreen = this._fullScreen;
    }
    if (this._gl?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.gl = this._gl?.internalValue;
    }
    if (this._xauth !== undefined) {
      hasAnyValues = true;
      internalValueResult.xauth = this._xauth;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesGraphicsSdl | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._display = undefined;
      this._fullScreen = undefined;
      this._gl.internalValue = undefined;
      this._xauth = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._display = value.display;
      this._fullScreen = value.fullScreen;
      this._gl.internalValue = value.gl;
      this._xauth = value.xauth;
    }
  }

  // display - computed: false, optional: true, required: false
  private _display?: string; 
  public get display() {
    return this.getStringAttribute('display');
  }
  public set display(value: string) {
    this._display = value;
  }
  public resetDisplay() {
    this._display = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get displayInput() {
    return this._display;
  }

  // full_screen - computed: false, optional: true, required: false
  private _fullScreen?: string; 
  public get fullScreen() {
    return this.getStringAttribute('full_screen');
  }
  public set fullScreen(value: string) {
    this._fullScreen = value;
  }
  public resetFullScreen() {
    this._fullScreen = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fullScreenInput() {
    return this._fullScreen;
  }

  // gl - computed: false, optional: true, required: false
  private _gl = new DomainDevicesGraphicsSdlGlOutputReference(this, "gl");
  public get gl() {
    return this._gl;
  }
  public putGl(value: DomainDevicesGraphicsSdlGl) {
    this._gl.internalValue = value;
  }
  public resetGl() {
    this._gl.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get glInput() {
    return this._gl.internalValue;
  }

  // xauth - computed: false, optional: true, required: false
  private _xauth?: string; 
  public get xauth() {
    return this.getStringAttribute('xauth');
  }
  public set xauth(value: string) {
    this._xauth = value;
  }
  public resetXauth() {
    this._xauth = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get xauthInput() {
    return this._xauth;
  }
}
export interface DomainDevicesGraphicsSpiceChannel {
  /**
  * Sets how the SPICE channel connects, typically "secure" or "insecure" depending on the desired transport; the value is required and user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode: string;
  /**
  * Names the SPICE channel to configure (for example, "main", "cursor", "display", "record", "playback"); this value is required and must match a supported SPICE channel name.
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
}

export function domainDevicesGraphicsSpiceChannelToTerraform(struct?: DomainDevicesGraphicsSpiceChannel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function domainDevicesGraphicsSpiceChannelToHclTerraform(struct?: DomainDevicesGraphicsSpiceChannel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesGraphicsSpiceChannelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesGraphicsSpiceChannel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesGraphicsSpiceChannel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
      this._name = value.name;
    }
  }

  // mode - computed: false, optional: false, required: true
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class DomainDevicesGraphicsSpiceChannelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesGraphicsSpiceChannel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesGraphicsSpiceChannelOutputReference {
    return new DomainDevicesGraphicsSpiceChannelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesGraphicsSpiceClipBoard {
  /**
  * Controls whether clipboard copy/paste is allowed over SPICE; accepts "yes" or "no".
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#copy_paste Domain#copy_paste}
  */
  readonly copyPaste: string;
}

export function domainDevicesGraphicsSpiceClipBoardToTerraform(struct?: DomainDevicesGraphicsSpiceClipBoard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    copy_paste: cdktf.stringToTerraform(struct!.copyPaste),
  }
}


export function domainDevicesGraphicsSpiceClipBoardToHclTerraform(struct?: DomainDevicesGraphicsSpiceClipBoard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    copy_paste: {
      value: cdktf.stringToHclTerraform(struct!.copyPaste),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesGraphicsSpiceClipBoardOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesGraphicsSpiceClipBoard | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._copyPaste !== undefined) {
      hasAnyValues = true;
      internalValueResult.copyPaste = this._copyPaste;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesGraphicsSpiceClipBoard | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._copyPaste = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._copyPaste = value.copyPaste;
    }
  }

  // copy_paste - computed: false, optional: false, required: true
  private _copyPaste?: string; 
  public get copyPaste() {
    return this.getStringAttribute('copy_paste');
  }
  public set copyPaste(value: string) {
    this._copyPaste = value;
  }
  // Temporarily expose input value. Use with caution.
  public get copyPasteInput() {
    return this._copyPaste;
  }
}
export interface DomainDevicesGraphicsSpiceFileTransfer {
  /**
  * Controls whether SPICE client file transfer into the guest is enabled; accepts "yes" or "no".
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enable Domain#enable}
  */
  readonly enable: string;
}

export function domainDevicesGraphicsSpiceFileTransferToTerraform(struct?: DomainDevicesGraphicsSpiceFileTransfer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.stringToTerraform(struct!.enable),
  }
}


export function domainDevicesGraphicsSpiceFileTransferToHclTerraform(struct?: DomainDevicesGraphicsSpiceFileTransfer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.stringToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesGraphicsSpiceFileTransferOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesGraphicsSpiceFileTransfer | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesGraphicsSpiceFileTransfer | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
    }
  }

  // enable - computed: false, optional: false, required: true
  private _enable?: string; 
  public get enable() {
    return this.getStringAttribute('enable');
  }
  public set enable(value: string) {
    this._enable = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }
}
export interface DomainDevicesGraphicsSpiceGl {
  /**
  * Controls whether OpenGL/3D rendering is enabled for SPICE (for example, via virgl); accepts "yes" or "no".
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enable Domain#enable}
  */
  readonly enable?: string;
  /**
  * Sets the host render node device path that SPICE should use for OpenGL rendering when GL is enabled (user-provided path such as `/dev/dri/renderD128`).
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#render_node Domain#render_node}
  */
  readonly renderNode?: string;
}

export function domainDevicesGraphicsSpiceGlToTerraform(struct?: DomainDevicesGraphicsSpiceGl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.stringToTerraform(struct!.enable),
    render_node: cdktf.stringToTerraform(struct!.renderNode),
  }
}


export function domainDevicesGraphicsSpiceGlToHclTerraform(struct?: DomainDevicesGraphicsSpiceGl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.stringToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    render_node: {
      value: cdktf.stringToHclTerraform(struct!.renderNode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesGraphicsSpiceGlOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesGraphicsSpiceGl | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._renderNode !== undefined) {
      hasAnyValues = true;
      internalValueResult.renderNode = this._renderNode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesGraphicsSpiceGl | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
      this._renderNode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
      this._renderNode = value.renderNode;
    }
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: string; 
  public get enable() {
    return this.getStringAttribute('enable');
  }
  public set enable(value: string) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // render_node - computed: false, optional: true, required: false
  private _renderNode?: string; 
  public get renderNode() {
    return this.getStringAttribute('render_node');
  }
  public set renderNode(value: string) {
    this._renderNode = value;
  }
  public resetRenderNode() {
    this._renderNode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get renderNodeInput() {
    return this._renderNode;
  }
}
export interface DomainDevicesGraphicsSpiceImage {
  /**
  * Sets the SPICE image compression policy; valid values include `auto_glz`, `auto_lz`, `quic`, `glz`, `lz`, `off`, and `always`.
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#compression Domain#compression}
  */
  readonly compression: string;
}

export function domainDevicesGraphicsSpiceImageToTerraform(struct?: DomainDevicesGraphicsSpiceImage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compression: cdktf.stringToTerraform(struct!.compression),
  }
}


export function domainDevicesGraphicsSpiceImageToHclTerraform(struct?: DomainDevicesGraphicsSpiceImage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compression: {
      value: cdktf.stringToHclTerraform(struct!.compression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesGraphicsSpiceImageOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesGraphicsSpiceImage | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compression !== undefined) {
      hasAnyValues = true;
      internalValueResult.compression = this._compression;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesGraphicsSpiceImage | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compression = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compression = value.compression;
    }
  }

  // compression - computed: false, optional: false, required: true
  private _compression?: string; 
  public get compression() {
    return this.getStringAttribute('compression');
  }
  public set compression(value: string) {
    this._compression = value;
  }
  // Temporarily expose input value. Use with caution.
  public get compressionInput() {
    return this._compression;
  }
}
export interface DomainDevicesGraphicsSpiceJpeg {
  /**
  * Sets the SPICE JPEG compression policy, typically one of `auto`, `never`, or `always`, controlling when JPEG is used for image encoding.
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#compression Domain#compression}
  */
  readonly compression: string;
}

export function domainDevicesGraphicsSpiceJpegToTerraform(struct?: DomainDevicesGraphicsSpiceJpeg | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compression: cdktf.stringToTerraform(struct!.compression),
  }
}


export function domainDevicesGraphicsSpiceJpegToHclTerraform(struct?: DomainDevicesGraphicsSpiceJpeg | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compression: {
      value: cdktf.stringToHclTerraform(struct!.compression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesGraphicsSpiceJpegOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesGraphicsSpiceJpeg | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compression !== undefined) {
      hasAnyValues = true;
      internalValueResult.compression = this._compression;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesGraphicsSpiceJpeg | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compression = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compression = value.compression;
    }
  }

  // compression - computed: false, optional: false, required: true
  private _compression?: string; 
  public get compression() {
    return this.getStringAttribute('compression');
  }
  public set compression(value: string) {
    this._compression = value;
  }
  // Temporarily expose input value. Use with caution.
  public get compressionInput() {
    return this._compression;
  }
}
export interface DomainDevicesGraphicsSpiceListenersAddress {
  /**
  * Sets the host IP address or hostname on which this SPICE listener should bind (for example `127.0.0.1` or `0.0.0.0`; value is user-provided).
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: string;
}

export function domainDevicesGraphicsSpiceListenersAddressToTerraform(struct?: DomainDevicesGraphicsSpiceListenersAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
  }
}


export function domainDevicesGraphicsSpiceListenersAddressToHclTerraform(struct?: DomainDevicesGraphicsSpiceListenersAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesGraphicsSpiceListenersAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesGraphicsSpiceListenersAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesGraphicsSpiceListenersAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  public resetAddress() {
    this._address = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }
}
export interface DomainDevicesGraphicsSpiceListenersNetwork {
  /**
  * Optionally overrides the automatically chosen address for a network-based SPICE listener with a specific IP/hostname (user-provided value).
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: string;
  /**
  * Names the libvirt virtual network that defines where this SPICE listener will be exposed (value must match an existing libvirt network name).
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#network Domain#network}
  */
  readonly network?: string;
}

export function domainDevicesGraphicsSpiceListenersNetworkToTerraform(struct?: DomainDevicesGraphicsSpiceListenersNetwork | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
    network: cdktf.stringToTerraform(struct!.network),
  }
}


export function domainDevicesGraphicsSpiceListenersNetworkToHclTerraform(struct?: DomainDevicesGraphicsSpiceListenersNetwork | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    network: {
      value: cdktf.stringToHclTerraform(struct!.network),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesGraphicsSpiceListenersNetworkOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesGraphicsSpiceListenersNetwork | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    if (this._network !== undefined) {
      hasAnyValues = true;
      internalValueResult.network = this._network;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesGraphicsSpiceListenersNetwork | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
      this._network = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
      this._network = value.network;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  public resetAddress() {
    this._address = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }

  // network - computed: false, optional: true, required: false
  private _network?: string; 
  public get network() {
    return this.getStringAttribute('network');
  }
  public set network(value: string) {
    this._network = value;
  }
  public resetNetwork() {
    this._network = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkInput() {
    return this._network;
  }
}
export interface DomainDevicesGraphicsSpiceListenersSocket {
  /**
  * Sets the filesystem path to the UNIX domain socket used by this SPICE listener (for example `/var/run/libvirt/qemu/spice.sock`; value is user-provided).
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#socket Domain#socket}
  */
  readonly socket?: string;
}

export function domainDevicesGraphicsSpiceListenersSocketToTerraform(struct?: DomainDevicesGraphicsSpiceListenersSocket | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    socket: cdktf.stringToTerraform(struct!.socket),
  }
}


export function domainDevicesGraphicsSpiceListenersSocketToHclTerraform(struct?: DomainDevicesGraphicsSpiceListenersSocket | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    socket: {
      value: cdktf.stringToHclTerraform(struct!.socket),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesGraphicsSpiceListenersSocketOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesGraphicsSpiceListenersSocket | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._socket !== undefined) {
      hasAnyValues = true;
      internalValueResult.socket = this._socket;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesGraphicsSpiceListenersSocket | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._socket = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._socket = value.socket;
    }
  }

  // socket - computed: false, optional: true, required: false
  private _socket?: string; 
  public get socket() {
    return this.getStringAttribute('socket');
  }
  public set socket(value: string) {
    this._socket = value;
  }
  public resetSocket() {
    this._socket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketInput() {
    return this._socket;
  }
}
export interface DomainDevicesGraphicsSpiceListeners {
  /**
  * Declares a SPICE listener that binds directly to a host IP address using the nested `address` attribute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: DomainDevicesGraphicsSpiceListenersAddress;
  /**
  * Declares a SPICE listener whose binding is determined by the specified libvirt virtual network and optional address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#network Domain#network}
  */
  readonly network?: DomainDevicesGraphicsSpiceListenersNetwork;
  /**
  * Declares a SPICE listener that uses a UNIX domain socket instead of TCP/IP for client connections.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#socket Domain#socket}
  */
  readonly socket?: DomainDevicesGraphicsSpiceListenersSocket;
}

export function domainDevicesGraphicsSpiceListenersToTerraform(struct?: DomainDevicesGraphicsSpiceListeners | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: domainDevicesGraphicsSpiceListenersAddressToTerraform(struct!.address),
    network: domainDevicesGraphicsSpiceListenersNetworkToTerraform(struct!.network),
    socket: domainDevicesGraphicsSpiceListenersSocketToTerraform(struct!.socket),
  }
}


export function domainDevicesGraphicsSpiceListenersToHclTerraform(struct?: DomainDevicesGraphicsSpiceListeners | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: domainDevicesGraphicsSpiceListenersAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesGraphicsSpiceListenersAddress",
    },
    network: {
      value: domainDevicesGraphicsSpiceListenersNetworkToHclTerraform(struct!.network),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesGraphicsSpiceListenersNetwork",
    },
    socket: {
      value: domainDevicesGraphicsSpiceListenersSocketToHclTerraform(struct!.socket),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesGraphicsSpiceListenersSocket",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesGraphicsSpiceListenersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesGraphicsSpiceListeners | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._network?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.network = this._network?.internalValue;
    }
    if (this._socket?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.socket = this._socket?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesGraphicsSpiceListeners | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._network.internalValue = undefined;
      this._socket.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._network.internalValue = value.network;
      this._socket.internalValue = value.socket;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address = new DomainDevicesGraphicsSpiceListenersAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DomainDevicesGraphicsSpiceListenersAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // network - computed: false, optional: true, required: false
  private _network = new DomainDevicesGraphicsSpiceListenersNetworkOutputReference(this, "network");
  public get network() {
    return this._network;
  }
  public putNetwork(value: DomainDevicesGraphicsSpiceListenersNetwork) {
    this._network.internalValue = value;
  }
  public resetNetwork() {
    this._network.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkInput() {
    return this._network.internalValue;
  }

  // socket - computed: false, optional: true, required: false
  private _socket = new DomainDevicesGraphicsSpiceListenersSocketOutputReference(this, "socket");
  public get socket() {
    return this._socket;
  }
  public putSocket(value: DomainDevicesGraphicsSpiceListenersSocket) {
    this._socket.internalValue = value;
  }
  public resetSocket() {
    this._socket.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketInput() {
    return this._socket.internalValue;
  }
}

export class DomainDevicesGraphicsSpiceListenersList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesGraphicsSpiceListeners[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesGraphicsSpiceListenersOutputReference {
    return new DomainDevicesGraphicsSpiceListenersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesGraphicsSpiceMouse {
  /**
  * Sets the SPICE mouse mode, typically `server` (relative pointer) or `client` (absolute pointer integration), controlling how mouse input is interpreted.
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode: string;
}

export function domainDevicesGraphicsSpiceMouseToTerraform(struct?: DomainDevicesGraphicsSpiceMouse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
  }
}


export function domainDevicesGraphicsSpiceMouseToHclTerraform(struct?: DomainDevicesGraphicsSpiceMouse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesGraphicsSpiceMouseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesGraphicsSpiceMouse | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesGraphicsSpiceMouse | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
    }
  }

  // mode - computed: false, optional: false, required: true
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }
}
export interface DomainDevicesGraphicsSpicePlayback {
  /**
  * Sets the audio compression mode for SPICE playback; valid values are those supported by libvirt/QEMU (for example "on", "off", or codec-specific modes), and a value is required when the playback element is present.
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#compression Domain#compression}
  */
  readonly compression: string;
}

export function domainDevicesGraphicsSpicePlaybackToTerraform(struct?: DomainDevicesGraphicsSpicePlayback | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compression: cdktf.stringToTerraform(struct!.compression),
  }
}


export function domainDevicesGraphicsSpicePlaybackToHclTerraform(struct?: DomainDevicesGraphicsSpicePlayback | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compression: {
      value: cdktf.stringToHclTerraform(struct!.compression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesGraphicsSpicePlaybackOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesGraphicsSpicePlayback | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compression !== undefined) {
      hasAnyValues = true;
      internalValueResult.compression = this._compression;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesGraphicsSpicePlayback | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compression = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compression = value.compression;
    }
  }

  // compression - computed: false, optional: false, required: true
  private _compression?: string; 
  public get compression() {
    return this.getStringAttribute('compression');
  }
  public set compression(value: string) {
    this._compression = value;
  }
  // Temporarily expose input value. Use with caution.
  public get compressionInput() {
    return this._compression;
  }
}
export interface DomainDevicesGraphicsSpiceStreaming {
  /**
  * Sets the SPICE display streaming mode (for example "filter", "all", or "off", depending on hypervisor support); a mode value is required when streaming is configured.
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode: string;
}

export function domainDevicesGraphicsSpiceStreamingToTerraform(struct?: DomainDevicesGraphicsSpiceStreaming | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
  }
}


export function domainDevicesGraphicsSpiceStreamingToHclTerraform(struct?: DomainDevicesGraphicsSpiceStreaming | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesGraphicsSpiceStreamingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesGraphicsSpiceStreaming | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesGraphicsSpiceStreaming | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
    }
  }

  // mode - computed: false, optional: false, required: true
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }
}
export interface DomainDevicesGraphicsSpiceZlib {
  /**
  * Sets the zlib compression policy for SPICE image data (for example "always", "never", or "auto", depending on hypervisor support); a value is required when the zlib element is present.
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#compression Domain#compression}
  */
  readonly compression: string;
}

export function domainDevicesGraphicsSpiceZlibToTerraform(struct?: DomainDevicesGraphicsSpiceZlib | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compression: cdktf.stringToTerraform(struct!.compression),
  }
}


export function domainDevicesGraphicsSpiceZlibToHclTerraform(struct?: DomainDevicesGraphicsSpiceZlib | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compression: {
      value: cdktf.stringToHclTerraform(struct!.compression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesGraphicsSpiceZlibOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesGraphicsSpiceZlib | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compression !== undefined) {
      hasAnyValues = true;
      internalValueResult.compression = this._compression;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesGraphicsSpiceZlib | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compression = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compression = value.compression;
    }
  }

  // compression - computed: false, optional: false, required: true
  private _compression?: string; 
  public get compression() {
    return this.getStringAttribute('compression');
  }
  public set compression(value: string) {
    this._compression = value;
  }
  // Temporarily expose input value. Use with caution.
  public get compressionInput() {
    return this._compression;
  }
}
export interface DomainDevicesGraphicsSpice {
  /**
  * Controls whether libvirt automatically selects the SPICE TCP port; this is a yes/no flag encoded as "yes" for true and "no" for false.
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#auto_port Domain#auto_port}
  */
  readonly autoPort?: boolean | cdktf.IResolvable;
  /**
  * Defines an individual SPICE channel (such as "main" or "cursor") and its connection mode.
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#channel Domain#channel}
  */
  readonly channel?: DomainDevicesGraphicsSpiceChannel[] | cdktf.IResolvable;
  /**
  * Enables configuration of clipboard sharing behavior between the SPICE client and the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#clip_board Domain#clip_board}
  */
  readonly clipBoard?: DomainDevicesGraphicsSpiceClipBoard;
  /**
  * Sets whether clients are allowed to connect at VM startup ("yes") or only later ("no"); accepts "yes" or "no".
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#connected Domain#connected}
  */
  readonly connected?: string;
  /**
  * Specifies the default connection mode for SPICE (for example, "any", "secure", or "insecure"); the value is user-provided but must be a mode supported by SPICE.
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#default_mode Domain#default_mode}
  */
  readonly defaultMode?: string;
  /**
  * Enables configuration of file transfer support between the SPICE client and the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file_transfer Domain#file_transfer}
  */
  readonly fileTransfer?: DomainDevicesGraphicsSpiceFileTransfer;
  /**
  * Enables configuration of OpenGL/3D rendering for the SPICE graphics backend.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#gl Domain#gl}
  */
  readonly gl?: DomainDevicesGraphicsSpiceGl;
  /**
  * Enables configuration of SPICE image encoding options; presence of this block allows tuning of how screen images are compressed before being sent to the client.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#image Domain#image}
  */
  readonly image?: DomainDevicesGraphicsSpiceImage;
  /**
  * Enables configuration of SPICE JPEG encoding behavior; presence of this block allows controlling whether and how JPEG compression is used for images.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#jpeg Domain#jpeg}
  */
  readonly jpeg?: DomainDevicesGraphicsSpiceJpeg;
  /**
  * Sets the keyboard layout name SPICE reports to the guest, such as `en-us` or `de`, to control key mapping behavior (value is user-provided).
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#keymap Domain#keymap}
  */
  readonly keymap?: string;
  /**
  * Sets a legacy listen address for the SPICE server; use of this attribute is generally superseded by the more detailed `listeners` configuration (value is user-provided IP/host or `0.0.0.0`).
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#listen Domain#listen}
  */
  readonly listen?: string;
  /**
  * Configures one or more SPICE listen endpoints (TCP address, libvirt network, or UNIX socket) through nested listener blocks.
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#listeners Domain#listeners}
  */
  readonly listeners?: DomainDevicesGraphicsSpiceListeners[] | cdktf.IResolvable;
  /**
  * Enables configuration of SPICE mouse handling behavior; presence of this block allows setting the mouse mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mouse Domain#mouse}
  */
  readonly mouse?: DomainDevicesGraphicsSpiceMouse;
  /**
  * Sets a simple password string required for SPICE client connections to this guest (value is user-provided and should follow your security policies).
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#passwd Domain#passwd}
  */
  readonly passwd?: string;
  /**
  * Sets an expiration timestamp for the SPICE password, using a libvirt-supported date/time format (for example `2010-04-19T12:00:00`).
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#passwd_valid_to Domain#passwd_valid_to}
  */
  readonly passwdValidTo?: string;
  /**
  * Enables configuration of SPICE audio playback behavior; presence of this block allows controlling whether audio output to the client is enabled or tuned.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#playback Domain#playback}
  */
  readonly playback?: DomainDevicesGraphicsSpicePlayback;
  /**
  * Sets the TCP port on which the SPICE server listens for unencrypted connections; value is a user-provided integer in the valid TCP port range.
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#port Domain#port}
  */
  readonly port?: number;
  /**
  * Enables SPICE streaming configuration, allowing control of how guest display frames are streamed to the client.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#streaming Domain#streaming}
  */
  readonly streaming?: DomainDevicesGraphicsSpiceStreaming;
  /**
  * Sets the TCP port on which the SPICE server listens for TLS-encrypted connections; value is a user-provided integer in the valid TCP port range.
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tls_port Domain#tls_port}
  */
  readonly tlsPort?: number;
  /**
  * Enables separate configuration of SPICE image compression using zlib for the display channel.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#zlib Domain#zlib}
  */
  readonly zlib?: DomainDevicesGraphicsSpiceZlib;
}

export function domainDevicesGraphicsSpiceToTerraform(struct?: DomainDevicesGraphicsSpice | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auto_port: cdktf.booleanToTerraform(struct!.autoPort),
    channel: cdktf.listMapper(domainDevicesGraphicsSpiceChannelToTerraform, false)(struct!.channel),
    clip_board: domainDevicesGraphicsSpiceClipBoardToTerraform(struct!.clipBoard),
    connected: cdktf.stringToTerraform(struct!.connected),
    default_mode: cdktf.stringToTerraform(struct!.defaultMode),
    file_transfer: domainDevicesGraphicsSpiceFileTransferToTerraform(struct!.fileTransfer),
    gl: domainDevicesGraphicsSpiceGlToTerraform(struct!.gl),
    image: domainDevicesGraphicsSpiceImageToTerraform(struct!.image),
    jpeg: domainDevicesGraphicsSpiceJpegToTerraform(struct!.jpeg),
    keymap: cdktf.stringToTerraform(struct!.keymap),
    listen: cdktf.stringToTerraform(struct!.listen),
    listeners: cdktf.listMapper(domainDevicesGraphicsSpiceListenersToTerraform, false)(struct!.listeners),
    mouse: domainDevicesGraphicsSpiceMouseToTerraform(struct!.mouse),
    passwd: cdktf.stringToTerraform(struct!.passwd),
    passwd_valid_to: cdktf.stringToTerraform(struct!.passwdValidTo),
    playback: domainDevicesGraphicsSpicePlaybackToTerraform(struct!.playback),
    port: cdktf.numberToTerraform(struct!.port),
    streaming: domainDevicesGraphicsSpiceStreamingToTerraform(struct!.streaming),
    tls_port: cdktf.numberToTerraform(struct!.tlsPort),
    zlib: domainDevicesGraphicsSpiceZlibToTerraform(struct!.zlib),
  }
}


export function domainDevicesGraphicsSpiceToHclTerraform(struct?: DomainDevicesGraphicsSpice | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auto_port: {
      value: cdktf.booleanToHclTerraform(struct!.autoPort),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    channel: {
      value: cdktf.listMapperHcl(domainDevicesGraphicsSpiceChannelToHclTerraform, false)(struct!.channel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesGraphicsSpiceChannelList",
    },
    clip_board: {
      value: domainDevicesGraphicsSpiceClipBoardToHclTerraform(struct!.clipBoard),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesGraphicsSpiceClipBoard",
    },
    connected: {
      value: cdktf.stringToHclTerraform(struct!.connected),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    default_mode: {
      value: cdktf.stringToHclTerraform(struct!.defaultMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    file_transfer: {
      value: domainDevicesGraphicsSpiceFileTransferToHclTerraform(struct!.fileTransfer),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesGraphicsSpiceFileTransfer",
    },
    gl: {
      value: domainDevicesGraphicsSpiceGlToHclTerraform(struct!.gl),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesGraphicsSpiceGl",
    },
    image: {
      value: domainDevicesGraphicsSpiceImageToHclTerraform(struct!.image),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesGraphicsSpiceImage",
    },
    jpeg: {
      value: domainDevicesGraphicsSpiceJpegToHclTerraform(struct!.jpeg),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesGraphicsSpiceJpeg",
    },
    keymap: {
      value: cdktf.stringToHclTerraform(struct!.keymap),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    listen: {
      value: cdktf.stringToHclTerraform(struct!.listen),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    listeners: {
      value: cdktf.listMapperHcl(domainDevicesGraphicsSpiceListenersToHclTerraform, false)(struct!.listeners),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesGraphicsSpiceListenersList",
    },
    mouse: {
      value: domainDevicesGraphicsSpiceMouseToHclTerraform(struct!.mouse),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesGraphicsSpiceMouse",
    },
    passwd: {
      value: cdktf.stringToHclTerraform(struct!.passwd),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passwd_valid_to: {
      value: cdktf.stringToHclTerraform(struct!.passwdValidTo),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    playback: {
      value: domainDevicesGraphicsSpicePlaybackToHclTerraform(struct!.playback),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesGraphicsSpicePlayback",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streaming: {
      value: domainDevicesGraphicsSpiceStreamingToHclTerraform(struct!.streaming),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesGraphicsSpiceStreaming",
    },
    tls_port: {
      value: cdktf.numberToHclTerraform(struct!.tlsPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    zlib: {
      value: domainDevicesGraphicsSpiceZlibToHclTerraform(struct!.zlib),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesGraphicsSpiceZlib",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesGraphicsSpiceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesGraphicsSpice | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._autoPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoPort = this._autoPort;
    }
    if (this._channel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.channel = this._channel?.internalValue;
    }
    if (this._clipBoard?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clipBoard = this._clipBoard?.internalValue;
    }
    if (this._connected !== undefined) {
      hasAnyValues = true;
      internalValueResult.connected = this._connected;
    }
    if (this._defaultMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultMode = this._defaultMode;
    }
    if (this._fileTransfer?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileTransfer = this._fileTransfer?.internalValue;
    }
    if (this._gl?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.gl = this._gl?.internalValue;
    }
    if (this._image?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image?.internalValue;
    }
    if (this._jpeg?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jpeg = this._jpeg?.internalValue;
    }
    if (this._keymap !== undefined) {
      hasAnyValues = true;
      internalValueResult.keymap = this._keymap;
    }
    if (this._listen !== undefined) {
      hasAnyValues = true;
      internalValueResult.listen = this._listen;
    }
    if (this._listeners?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.listeners = this._listeners?.internalValue;
    }
    if (this._mouse?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.mouse = this._mouse?.internalValue;
    }
    if (this._passwd !== undefined) {
      hasAnyValues = true;
      internalValueResult.passwd = this._passwd;
    }
    if (this._passwdValidTo !== undefined) {
      hasAnyValues = true;
      internalValueResult.passwdValidTo = this._passwdValidTo;
    }
    if (this._playback?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.playback = this._playback?.internalValue;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._streaming?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.streaming = this._streaming?.internalValue;
    }
    if (this._tlsPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsPort = this._tlsPort;
    }
    if (this._zlib?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.zlib = this._zlib?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesGraphicsSpice | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._autoPort = undefined;
      this._channel.internalValue = undefined;
      this._clipBoard.internalValue = undefined;
      this._connected = undefined;
      this._defaultMode = undefined;
      this._fileTransfer.internalValue = undefined;
      this._gl.internalValue = undefined;
      this._image.internalValue = undefined;
      this._jpeg.internalValue = undefined;
      this._keymap = undefined;
      this._listen = undefined;
      this._listeners.internalValue = undefined;
      this._mouse.internalValue = undefined;
      this._passwd = undefined;
      this._passwdValidTo = undefined;
      this._playback.internalValue = undefined;
      this._port = undefined;
      this._streaming.internalValue = undefined;
      this._tlsPort = undefined;
      this._zlib.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._autoPort = value.autoPort;
      this._channel.internalValue = value.channel;
      this._clipBoard.internalValue = value.clipBoard;
      this._connected = value.connected;
      this._defaultMode = value.defaultMode;
      this._fileTransfer.internalValue = value.fileTransfer;
      this._gl.internalValue = value.gl;
      this._image.internalValue = value.image;
      this._jpeg.internalValue = value.jpeg;
      this._keymap = value.keymap;
      this._listen = value.listen;
      this._listeners.internalValue = value.listeners;
      this._mouse.internalValue = value.mouse;
      this._passwd = value.passwd;
      this._passwdValidTo = value.passwdValidTo;
      this._playback.internalValue = value.playback;
      this._port = value.port;
      this._streaming.internalValue = value.streaming;
      this._tlsPort = value.tlsPort;
      this._zlib.internalValue = value.zlib;
    }
  }

  // auto_port - computed: false, optional: true, required: false
  private _autoPort?: boolean | cdktf.IResolvable; 
  public get autoPort() {
    return this.getBooleanAttribute('auto_port');
  }
  public set autoPort(value: boolean | cdktf.IResolvable) {
    this._autoPort = value;
  }
  public resetAutoPort() {
    this._autoPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoPortInput() {
    return this._autoPort;
  }

  // channel - computed: false, optional: true, required: false
  private _channel = new DomainDevicesGraphicsSpiceChannelList(this, "channel", false);
  public get channel() {
    return this._channel;
  }
  public putChannel(value: DomainDevicesGraphicsSpiceChannel[] | cdktf.IResolvable) {
    this._channel.internalValue = value;
  }
  public resetChannel() {
    this._channel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get channelInput() {
    return this._channel.internalValue;
  }

  // clip_board - computed: false, optional: true, required: false
  private _clipBoard = new DomainDevicesGraphicsSpiceClipBoardOutputReference(this, "clip_board");
  public get clipBoard() {
    return this._clipBoard;
  }
  public putClipBoard(value: DomainDevicesGraphicsSpiceClipBoard) {
    this._clipBoard.internalValue = value;
  }
  public resetClipBoard() {
    this._clipBoard.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clipBoardInput() {
    return this._clipBoard.internalValue;
  }

  // connected - computed: false, optional: true, required: false
  private _connected?: string; 
  public get connected() {
    return this.getStringAttribute('connected');
  }
  public set connected(value: string) {
    this._connected = value;
  }
  public resetConnected() {
    this._connected = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectedInput() {
    return this._connected;
  }

  // default_mode - computed: false, optional: true, required: false
  private _defaultMode?: string; 
  public get defaultMode() {
    return this.getStringAttribute('default_mode');
  }
  public set defaultMode(value: string) {
    this._defaultMode = value;
  }
  public resetDefaultMode() {
    this._defaultMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultModeInput() {
    return this._defaultMode;
  }

  // file_transfer - computed: false, optional: true, required: false
  private _fileTransfer = new DomainDevicesGraphicsSpiceFileTransferOutputReference(this, "file_transfer");
  public get fileTransfer() {
    return this._fileTransfer;
  }
  public putFileTransfer(value: DomainDevicesGraphicsSpiceFileTransfer) {
    this._fileTransfer.internalValue = value;
  }
  public resetFileTransfer() {
    this._fileTransfer.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileTransferInput() {
    return this._fileTransfer.internalValue;
  }

  // gl - computed: false, optional: true, required: false
  private _gl = new DomainDevicesGraphicsSpiceGlOutputReference(this, "gl");
  public get gl() {
    return this._gl;
  }
  public putGl(value: DomainDevicesGraphicsSpiceGl) {
    this._gl.internalValue = value;
  }
  public resetGl() {
    this._gl.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get glInput() {
    return this._gl.internalValue;
  }

  // image - computed: false, optional: true, required: false
  private _image = new DomainDevicesGraphicsSpiceImageOutputReference(this, "image");
  public get image() {
    return this._image;
  }
  public putImage(value: DomainDevicesGraphicsSpiceImage) {
    this._image.internalValue = value;
  }
  public resetImage() {
    this._image.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image.internalValue;
  }

  // jpeg - computed: false, optional: true, required: false
  private _jpeg = new DomainDevicesGraphicsSpiceJpegOutputReference(this, "jpeg");
  public get jpeg() {
    return this._jpeg;
  }
  public putJpeg(value: DomainDevicesGraphicsSpiceJpeg) {
    this._jpeg.internalValue = value;
  }
  public resetJpeg() {
    this._jpeg.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jpegInput() {
    return this._jpeg.internalValue;
  }

  // keymap - computed: false, optional: true, required: false
  private _keymap?: string; 
  public get keymap() {
    return this.getStringAttribute('keymap');
  }
  public set keymap(value: string) {
    this._keymap = value;
  }
  public resetKeymap() {
    this._keymap = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keymapInput() {
    return this._keymap;
  }

  // listen - computed: false, optional: true, required: false
  private _listen?: string; 
  public get listen() {
    return this.getStringAttribute('listen');
  }
  public set listen(value: string) {
    this._listen = value;
  }
  public resetListen() {
    this._listen = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get listenInput() {
    return this._listen;
  }

  // listeners - computed: false, optional: true, required: false
  private _listeners = new DomainDevicesGraphicsSpiceListenersList(this, "listeners", false);
  public get listeners() {
    return this._listeners;
  }
  public putListeners(value: DomainDevicesGraphicsSpiceListeners[] | cdktf.IResolvable) {
    this._listeners.internalValue = value;
  }
  public resetListeners() {
    this._listeners.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get listenersInput() {
    return this._listeners.internalValue;
  }

  // mouse - computed: false, optional: true, required: false
  private _mouse = new DomainDevicesGraphicsSpiceMouseOutputReference(this, "mouse");
  public get mouse() {
    return this._mouse;
  }
  public putMouse(value: DomainDevicesGraphicsSpiceMouse) {
    this._mouse.internalValue = value;
  }
  public resetMouse() {
    this._mouse.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mouseInput() {
    return this._mouse.internalValue;
  }

  // passwd - computed: false, optional: true, required: false
  private _passwd?: string; 
  public get passwd() {
    return this.getStringAttribute('passwd');
  }
  public set passwd(value: string) {
    this._passwd = value;
  }
  public resetPasswd() {
    this._passwd = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwdInput() {
    return this._passwd;
  }

  // passwd_valid_to - computed: false, optional: true, required: false
  private _passwdValidTo?: string; 
  public get passwdValidTo() {
    return this.getStringAttribute('passwd_valid_to');
  }
  public set passwdValidTo(value: string) {
    this._passwdValidTo = value;
  }
  public resetPasswdValidTo() {
    this._passwdValidTo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwdValidToInput() {
    return this._passwdValidTo;
  }

  // playback - computed: false, optional: true, required: false
  private _playback = new DomainDevicesGraphicsSpicePlaybackOutputReference(this, "playback");
  public get playback() {
    return this._playback;
  }
  public putPlayback(value: DomainDevicesGraphicsSpicePlayback) {
    this._playback.internalValue = value;
  }
  public resetPlayback() {
    this._playback.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get playbackInput() {
    return this._playback.internalValue;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // streaming - computed: false, optional: true, required: false
  private _streaming = new DomainDevicesGraphicsSpiceStreamingOutputReference(this, "streaming");
  public get streaming() {
    return this._streaming;
  }
  public putStreaming(value: DomainDevicesGraphicsSpiceStreaming) {
    this._streaming.internalValue = value;
  }
  public resetStreaming() {
    this._streaming.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamingInput() {
    return this._streaming.internalValue;
  }

  // tls_port - computed: false, optional: true, required: false
  private _tlsPort?: number; 
  public get tlsPort() {
    return this.getNumberAttribute('tls_port');
  }
  public set tlsPort(value: number) {
    this._tlsPort = value;
  }
  public resetTlsPort() {
    this._tlsPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsPortInput() {
    return this._tlsPort;
  }

  // zlib - computed: false, optional: true, required: false
  private _zlib = new DomainDevicesGraphicsSpiceZlibOutputReference(this, "zlib");
  public get zlib() {
    return this._zlib;
  }
  public putZlib(value: DomainDevicesGraphicsSpiceZlib) {
    this._zlib.internalValue = value;
  }
  public resetZlib() {
    this._zlib.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get zlibInput() {
    return this._zlib.internalValue;
  }
}
export interface DomainDevicesGraphicsVncListenersAddress {
  /**
  * Sets the host IP address or hostname on which this SPICE listener should bind (for example `127.0.0.1` or `0.0.0.0`; value is user-provided).
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: string;
}

export function domainDevicesGraphicsVncListenersAddressToTerraform(struct?: DomainDevicesGraphicsVncListenersAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
  }
}


export function domainDevicesGraphicsVncListenersAddressToHclTerraform(struct?: DomainDevicesGraphicsVncListenersAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesGraphicsVncListenersAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesGraphicsVncListenersAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesGraphicsVncListenersAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  public resetAddress() {
    this._address = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }
}
export interface DomainDevicesGraphicsVncListenersNetwork {
  /**
  * Optionally overrides the automatically chosen address for a network-based SPICE listener with a specific IP/hostname (user-provided value).
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: string;
  /**
  * Names the libvirt virtual network that defines where this SPICE listener will be exposed (value must match an existing libvirt network name).
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#network Domain#network}
  */
  readonly network?: string;
}

export function domainDevicesGraphicsVncListenersNetworkToTerraform(struct?: DomainDevicesGraphicsVncListenersNetwork | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
    network: cdktf.stringToTerraform(struct!.network),
  }
}


export function domainDevicesGraphicsVncListenersNetworkToHclTerraform(struct?: DomainDevicesGraphicsVncListenersNetwork | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    network: {
      value: cdktf.stringToHclTerraform(struct!.network),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesGraphicsVncListenersNetworkOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesGraphicsVncListenersNetwork | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    if (this._network !== undefined) {
      hasAnyValues = true;
      internalValueResult.network = this._network;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesGraphicsVncListenersNetwork | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
      this._network = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
      this._network = value.network;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  public resetAddress() {
    this._address = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }

  // network - computed: false, optional: true, required: false
  private _network?: string; 
  public get network() {
    return this.getStringAttribute('network');
  }
  public set network(value: string) {
    this._network = value;
  }
  public resetNetwork() {
    this._network = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkInput() {
    return this._network;
  }
}
export interface DomainDevicesGraphicsVncListenersSocket {
  /**
  * Sets the filesystem path to the UNIX domain socket used by this SPICE listener (for example `/var/run/libvirt/qemu/spice.sock`; value is user-provided).
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#socket Domain#socket}
  */
  readonly socket?: string;
}

export function domainDevicesGraphicsVncListenersSocketToTerraform(struct?: DomainDevicesGraphicsVncListenersSocket | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    socket: cdktf.stringToTerraform(struct!.socket),
  }
}


export function domainDevicesGraphicsVncListenersSocketToHclTerraform(struct?: DomainDevicesGraphicsVncListenersSocket | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    socket: {
      value: cdktf.stringToHclTerraform(struct!.socket),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesGraphicsVncListenersSocketOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesGraphicsVncListenersSocket | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._socket !== undefined) {
      hasAnyValues = true;
      internalValueResult.socket = this._socket;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesGraphicsVncListenersSocket | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._socket = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._socket = value.socket;
    }
  }

  // socket - computed: false, optional: true, required: false
  private _socket?: string; 
  public get socket() {
    return this.getStringAttribute('socket');
  }
  public set socket(value: string) {
    this._socket = value;
  }
  public resetSocket() {
    this._socket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketInput() {
    return this._socket;
  }
}
export interface DomainDevicesGraphicsVncListeners {
  /**
  * Declares a SPICE listener that binds directly to a host IP address using the nested `address` attribute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: DomainDevicesGraphicsVncListenersAddress;
  /**
  * Declares a SPICE listener whose binding is determined by the specified libvirt virtual network and optional address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#network Domain#network}
  */
  readonly network?: DomainDevicesGraphicsVncListenersNetwork;
  /**
  * Declares a SPICE listener that uses a UNIX domain socket instead of TCP/IP for client connections.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#socket Domain#socket}
  */
  readonly socket?: DomainDevicesGraphicsVncListenersSocket;
}

export function domainDevicesGraphicsVncListenersToTerraform(struct?: DomainDevicesGraphicsVncListeners | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: domainDevicesGraphicsVncListenersAddressToTerraform(struct!.address),
    network: domainDevicesGraphicsVncListenersNetworkToTerraform(struct!.network),
    socket: domainDevicesGraphicsVncListenersSocketToTerraform(struct!.socket),
  }
}


export function domainDevicesGraphicsVncListenersToHclTerraform(struct?: DomainDevicesGraphicsVncListeners | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: domainDevicesGraphicsVncListenersAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesGraphicsVncListenersAddress",
    },
    network: {
      value: domainDevicesGraphicsVncListenersNetworkToHclTerraform(struct!.network),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesGraphicsVncListenersNetwork",
    },
    socket: {
      value: domainDevicesGraphicsVncListenersSocketToHclTerraform(struct!.socket),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesGraphicsVncListenersSocket",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesGraphicsVncListenersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesGraphicsVncListeners | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._network?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.network = this._network?.internalValue;
    }
    if (this._socket?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.socket = this._socket?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesGraphicsVncListeners | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._network.internalValue = undefined;
      this._socket.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._network.internalValue = value.network;
      this._socket.internalValue = value.socket;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address = new DomainDevicesGraphicsVncListenersAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DomainDevicesGraphicsVncListenersAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // network - computed: false, optional: true, required: false
  private _network = new DomainDevicesGraphicsVncListenersNetworkOutputReference(this, "network");
  public get network() {
    return this._network;
  }
  public putNetwork(value: DomainDevicesGraphicsVncListenersNetwork) {
    this._network.internalValue = value;
  }
  public resetNetwork() {
    this._network.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkInput() {
    return this._network.internalValue;
  }

  // socket - computed: false, optional: true, required: false
  private _socket = new DomainDevicesGraphicsVncListenersSocketOutputReference(this, "socket");
  public get socket() {
    return this._socket;
  }
  public putSocket(value: DomainDevicesGraphicsVncListenersSocket) {
    this._socket.internalValue = value;
  }
  public resetSocket() {
    this._socket.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketInput() {
    return this._socket.internalValue;
  }
}

export class DomainDevicesGraphicsVncListenersList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesGraphicsVncListeners[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesGraphicsVncListenersOutputReference {
    return new DomainDevicesGraphicsVncListenersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesGraphicsVnc {
  /**
  * Controls whether the VNC server automatically chooses a TCP port; this is a string-valued boolean where "yes" enables automatic port selection and "no" disables it.
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#auto_port Domain#auto_port}
  */
  readonly autoPort?: boolean | cdktf.IResolvable;
  /**
  * Sets the initial connection policy for VNC (for example "keep", "fail", or "disconnect" as supported by libvirt) indicating how the guest should behave when a client is or is not connected.
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#connected Domain#connected}
  */
  readonly connected?: string;
  /**
  * Sets the keymap layout used for keyboard input over VNC; value is a user-provided keymap name such as "en-us" or "de".
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#keymap Domain#keymap}
  */
  readonly keymap?: string;
  /**
  * Configures how the VNC server listens for client connections, either as a simple address attribute or via child listener elements.
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#listen Domain#listen}
  */
  readonly listen?: string;
  /**
  * Provides one or more explicit VNC listen endpoints (address, network, or Unix socket) instead of a single listen address attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#listeners Domain#listeners}
  */
  readonly listeners?: DomainDevicesGraphicsVncListeners[] | cdktf.IResolvable;
  /**
  * Sets the VNC password required for clients to connect to this graphics device; the value is user-provided and should follow any security policies you enforce for secrets. Example: "S3cr3tP@ss".
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#passwd Domain#passwd}
  */
  readonly passwd?: string;
  /**
  * Sets an absolute expiry time for the VNC password, after which the password is no longer valid; the format is a user-provided timestamp string as expected by libvirt/qemu.
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#passwd_valid_to Domain#passwd_valid_to}
  */
  readonly passwdValidTo?: string;
  /**
  * Sets the TCP port on which the VNC server listens; use -1 or omit to let libvirt automatically choose an available port, or specify an integer port such as 5900.
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#port Domain#port}
  */
  readonly port?: number;
  /**
  * Enables or disables guest power control over the VNC session; accepts "yes" or "no".
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#power_control Domain#power_control}
  */
  readonly powerControl?: string;
  /**
  * Controls how VNC connections are shared between clients; valid values are "allow-exclusive", "force-shared", or "ignore".
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#share_policy Domain#share_policy}
  */
  readonly sharePolicy?: string;
  /**
  * Sets the path to a UNIX domain socket to use instead of a TCP port for the VNC server; the value is a user-provided filesystem path (for example, "/var/run/libvirt/qemu-vnc.sock").
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#socket Domain#socket}
  */
  readonly socket?: string;
  /**
  * Sets the TCP port for the VNC WebSocket proxy, allowing browser-based VNC clients to connect; use -1 or omit to auto-assign, or specify an integer port.
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#web_socket Domain#web_socket}
  */
  readonly webSocket?: number;
}

export function domainDevicesGraphicsVncToTerraform(struct?: DomainDevicesGraphicsVnc | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auto_port: cdktf.booleanToTerraform(struct!.autoPort),
    connected: cdktf.stringToTerraform(struct!.connected),
    keymap: cdktf.stringToTerraform(struct!.keymap),
    listen: cdktf.stringToTerraform(struct!.listen),
    listeners: cdktf.listMapper(domainDevicesGraphicsVncListenersToTerraform, false)(struct!.listeners),
    passwd: cdktf.stringToTerraform(struct!.passwd),
    passwd_valid_to: cdktf.stringToTerraform(struct!.passwdValidTo),
    port: cdktf.numberToTerraform(struct!.port),
    power_control: cdktf.stringToTerraform(struct!.powerControl),
    share_policy: cdktf.stringToTerraform(struct!.sharePolicy),
    socket: cdktf.stringToTerraform(struct!.socket),
    web_socket: cdktf.numberToTerraform(struct!.webSocket),
  }
}


export function domainDevicesGraphicsVncToHclTerraform(struct?: DomainDevicesGraphicsVnc | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auto_port: {
      value: cdktf.booleanToHclTerraform(struct!.autoPort),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    connected: {
      value: cdktf.stringToHclTerraform(struct!.connected),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keymap: {
      value: cdktf.stringToHclTerraform(struct!.keymap),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    listen: {
      value: cdktf.stringToHclTerraform(struct!.listen),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    listeners: {
      value: cdktf.listMapperHcl(domainDevicesGraphicsVncListenersToHclTerraform, false)(struct!.listeners),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesGraphicsVncListenersList",
    },
    passwd: {
      value: cdktf.stringToHclTerraform(struct!.passwd),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passwd_valid_to: {
      value: cdktf.stringToHclTerraform(struct!.passwdValidTo),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    power_control: {
      value: cdktf.stringToHclTerraform(struct!.powerControl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    share_policy: {
      value: cdktf.stringToHclTerraform(struct!.sharePolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    socket: {
      value: cdktf.stringToHclTerraform(struct!.socket),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    web_socket: {
      value: cdktf.numberToHclTerraform(struct!.webSocket),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesGraphicsVncOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesGraphicsVnc | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._autoPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoPort = this._autoPort;
    }
    if (this._connected !== undefined) {
      hasAnyValues = true;
      internalValueResult.connected = this._connected;
    }
    if (this._keymap !== undefined) {
      hasAnyValues = true;
      internalValueResult.keymap = this._keymap;
    }
    if (this._listen !== undefined) {
      hasAnyValues = true;
      internalValueResult.listen = this._listen;
    }
    if (this._listeners?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.listeners = this._listeners?.internalValue;
    }
    if (this._passwd !== undefined) {
      hasAnyValues = true;
      internalValueResult.passwd = this._passwd;
    }
    if (this._passwdValidTo !== undefined) {
      hasAnyValues = true;
      internalValueResult.passwdValidTo = this._passwdValidTo;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._powerControl !== undefined) {
      hasAnyValues = true;
      internalValueResult.powerControl = this._powerControl;
    }
    if (this._sharePolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.sharePolicy = this._sharePolicy;
    }
    if (this._socket !== undefined) {
      hasAnyValues = true;
      internalValueResult.socket = this._socket;
    }
    if (this._webSocket !== undefined) {
      hasAnyValues = true;
      internalValueResult.webSocket = this._webSocket;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesGraphicsVnc | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._autoPort = undefined;
      this._connected = undefined;
      this._keymap = undefined;
      this._listen = undefined;
      this._listeners.internalValue = undefined;
      this._passwd = undefined;
      this._passwdValidTo = undefined;
      this._port = undefined;
      this._powerControl = undefined;
      this._sharePolicy = undefined;
      this._socket = undefined;
      this._webSocket = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._autoPort = value.autoPort;
      this._connected = value.connected;
      this._keymap = value.keymap;
      this._listen = value.listen;
      this._listeners.internalValue = value.listeners;
      this._passwd = value.passwd;
      this._passwdValidTo = value.passwdValidTo;
      this._port = value.port;
      this._powerControl = value.powerControl;
      this._sharePolicy = value.sharePolicy;
      this._socket = value.socket;
      this._webSocket = value.webSocket;
    }
  }

  // auto_port - computed: false, optional: true, required: false
  private _autoPort?: boolean | cdktf.IResolvable; 
  public get autoPort() {
    return this.getBooleanAttribute('auto_port');
  }
  public set autoPort(value: boolean | cdktf.IResolvable) {
    this._autoPort = value;
  }
  public resetAutoPort() {
    this._autoPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoPortInput() {
    return this._autoPort;
  }

  // connected - computed: false, optional: true, required: false
  private _connected?: string; 
  public get connected() {
    return this.getStringAttribute('connected');
  }
  public set connected(value: string) {
    this._connected = value;
  }
  public resetConnected() {
    this._connected = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectedInput() {
    return this._connected;
  }

  // keymap - computed: false, optional: true, required: false
  private _keymap?: string; 
  public get keymap() {
    return this.getStringAttribute('keymap');
  }
  public set keymap(value: string) {
    this._keymap = value;
  }
  public resetKeymap() {
    this._keymap = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keymapInput() {
    return this._keymap;
  }

  // listen - computed: false, optional: true, required: false
  private _listen?: string; 
  public get listen() {
    return this.getStringAttribute('listen');
  }
  public set listen(value: string) {
    this._listen = value;
  }
  public resetListen() {
    this._listen = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get listenInput() {
    return this._listen;
  }

  // listeners - computed: false, optional: true, required: false
  private _listeners = new DomainDevicesGraphicsVncListenersList(this, "listeners", false);
  public get listeners() {
    return this._listeners;
  }
  public putListeners(value: DomainDevicesGraphicsVncListeners[] | cdktf.IResolvable) {
    this._listeners.internalValue = value;
  }
  public resetListeners() {
    this._listeners.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get listenersInput() {
    return this._listeners.internalValue;
  }

  // passwd - computed: false, optional: true, required: false
  private _passwd?: string; 
  public get passwd() {
    return this.getStringAttribute('passwd');
  }
  public set passwd(value: string) {
    this._passwd = value;
  }
  public resetPasswd() {
    this._passwd = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwdInput() {
    return this._passwd;
  }

  // passwd_valid_to - computed: false, optional: true, required: false
  private _passwdValidTo?: string; 
  public get passwdValidTo() {
    return this.getStringAttribute('passwd_valid_to');
  }
  public set passwdValidTo(value: string) {
    this._passwdValidTo = value;
  }
  public resetPasswdValidTo() {
    this._passwdValidTo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwdValidToInput() {
    return this._passwdValidTo;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // power_control - computed: false, optional: true, required: false
  private _powerControl?: string; 
  public get powerControl() {
    return this.getStringAttribute('power_control');
  }
  public set powerControl(value: string) {
    this._powerControl = value;
  }
  public resetPowerControl() {
    this._powerControl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get powerControlInput() {
    return this._powerControl;
  }

  // share_policy - computed: false, optional: true, required: false
  private _sharePolicy?: string; 
  public get sharePolicy() {
    return this.getStringAttribute('share_policy');
  }
  public set sharePolicy(value: string) {
    this._sharePolicy = value;
  }
  public resetSharePolicy() {
    this._sharePolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sharePolicyInput() {
    return this._sharePolicy;
  }

  // socket - computed: false, optional: true, required: false
  private _socket?: string; 
  public get socket() {
    return this.getStringAttribute('socket');
  }
  public set socket(value: string) {
    this._socket = value;
  }
  public resetSocket() {
    this._socket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketInput() {
    return this._socket;
  }

  // web_socket - computed: false, optional: true, required: false
  private _webSocket?: number; 
  public get webSocket() {
    return this.getNumberAttribute('web_socket');
  }
  public set webSocket(value: number) {
    this._webSocket = value;
  }
  public resetWebSocket() {
    this._webSocket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get webSocketInput() {
    return this._webSocket;
  }
}
export interface DomainDevicesGraphics {
  /**
  * Configures an audio backend association for this graphics device, linking it to a specific <audio> definition by id.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#audio Domain#audio}
  */
  readonly audio?: DomainDevicesGraphicsAudio;
  /**
  * Enables a DBus-based display backend for the graphics device, allowing the display to be exported over DBus instead of a traditional VNC/SPICE socket.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dbus Domain#dbus}
  */
  readonly dbus?: DomainDevicesGraphicsDbus;
  /**
  * Configures desktop integration for the graphics device, such as exposing the guest window as a desktop surface on the host; the specific value is user-provided according to the chosen graphics type.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#desktop Domain#desktop}
  */
  readonly desktop?: DomainDevicesGraphicsDesktop;
  /**
  * Enables the egl-headless graphics backend, which provides a headless OpenGL-capable display surface without a visible window.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#egl_headless Domain#egl_headless}
  */
  readonly eglHeadless?: DomainDevicesGraphicsEglHeadless;
  /**
  * Enables an RDP graphics server for the guest and configures its RDP-specific options.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#rdp Domain#rdp}
  */
  readonly rdp?: DomainDevicesGraphicsRdp;
  /**
  * Enables and configures an SDL graphics backend for the guest display; when present, an SDL graphics device is attached to the domain.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sdl Domain#sdl}
  */
  readonly sdl?: DomainDevicesGraphicsSdl;
  /**
  * Enables and configures a SPICE graphics backend for the guest display; when present, a SPICE graphics device is attached to the domain.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#spice Domain#spice}
  */
  readonly spice?: DomainDevicesGraphicsSpice;
  /**
  * Enables a VNC graphics device for the guest and groups all VNC-specific options such as port, listeners, keyboard mapping, and connection policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vnc Domain#vnc}
  */
  readonly vnc?: DomainDevicesGraphicsVnc;
}

export function domainDevicesGraphicsToTerraform(struct?: DomainDevicesGraphics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    audio: domainDevicesGraphicsAudioToTerraform(struct!.audio),
    dbus: domainDevicesGraphicsDbusToTerraform(struct!.dbus),
    desktop: domainDevicesGraphicsDesktopToTerraform(struct!.desktop),
    egl_headless: domainDevicesGraphicsEglHeadlessToTerraform(struct!.eglHeadless),
    rdp: domainDevicesGraphicsRdpToTerraform(struct!.rdp),
    sdl: domainDevicesGraphicsSdlToTerraform(struct!.sdl),
    spice: domainDevicesGraphicsSpiceToTerraform(struct!.spice),
    vnc: domainDevicesGraphicsVncToTerraform(struct!.vnc),
  }
}


export function domainDevicesGraphicsToHclTerraform(struct?: DomainDevicesGraphics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    audio: {
      value: domainDevicesGraphicsAudioToHclTerraform(struct!.audio),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesGraphicsAudio",
    },
    dbus: {
      value: domainDevicesGraphicsDbusToHclTerraform(struct!.dbus),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesGraphicsDbus",
    },
    desktop: {
      value: domainDevicesGraphicsDesktopToHclTerraform(struct!.desktop),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesGraphicsDesktop",
    },
    egl_headless: {
      value: domainDevicesGraphicsEglHeadlessToHclTerraform(struct!.eglHeadless),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesGraphicsEglHeadless",
    },
    rdp: {
      value: domainDevicesGraphicsRdpToHclTerraform(struct!.rdp),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesGraphicsRdp",
    },
    sdl: {
      value: domainDevicesGraphicsSdlToHclTerraform(struct!.sdl),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesGraphicsSdl",
    },
    spice: {
      value: domainDevicesGraphicsSpiceToHclTerraform(struct!.spice),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesGraphicsSpice",
    },
    vnc: {
      value: domainDevicesGraphicsVncToHclTerraform(struct!.vnc),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesGraphicsVnc",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesGraphicsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesGraphics | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._audio?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.audio = this._audio?.internalValue;
    }
    if (this._dbus?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dbus = this._dbus?.internalValue;
    }
    if (this._desktop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.desktop = this._desktop?.internalValue;
    }
    if (this._eglHeadless?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.eglHeadless = this._eglHeadless?.internalValue;
    }
    if (this._rdp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rdp = this._rdp?.internalValue;
    }
    if (this._sdl?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sdl = this._sdl?.internalValue;
    }
    if (this._spice?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spice = this._spice?.internalValue;
    }
    if (this._vnc?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.vnc = this._vnc?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesGraphics | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._audio.internalValue = undefined;
      this._dbus.internalValue = undefined;
      this._desktop.internalValue = undefined;
      this._eglHeadless.internalValue = undefined;
      this._rdp.internalValue = undefined;
      this._sdl.internalValue = undefined;
      this._spice.internalValue = undefined;
      this._vnc.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._audio.internalValue = value.audio;
      this._dbus.internalValue = value.dbus;
      this._desktop.internalValue = value.desktop;
      this._eglHeadless.internalValue = value.eglHeadless;
      this._rdp.internalValue = value.rdp;
      this._sdl.internalValue = value.sdl;
      this._spice.internalValue = value.spice;
      this._vnc.internalValue = value.vnc;
    }
  }

  // audio - computed: false, optional: true, required: false
  private _audio = new DomainDevicesGraphicsAudioOutputReference(this, "audio");
  public get audio() {
    return this._audio;
  }
  public putAudio(value: DomainDevicesGraphicsAudio) {
    this._audio.internalValue = value;
  }
  public resetAudio() {
    this._audio.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get audioInput() {
    return this._audio.internalValue;
  }

  // dbus - computed: false, optional: true, required: false
  private _dbus = new DomainDevicesGraphicsDbusOutputReference(this, "dbus");
  public get dbus() {
    return this._dbus;
  }
  public putDbus(value: DomainDevicesGraphicsDbus) {
    this._dbus.internalValue = value;
  }
  public resetDbus() {
    this._dbus.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dbusInput() {
    return this._dbus.internalValue;
  }

  // desktop - computed: false, optional: true, required: false
  private _desktop = new DomainDevicesGraphicsDesktopOutputReference(this, "desktop");
  public get desktop() {
    return this._desktop;
  }
  public putDesktop(value: DomainDevicesGraphicsDesktop) {
    this._desktop.internalValue = value;
  }
  public resetDesktop() {
    this._desktop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get desktopInput() {
    return this._desktop.internalValue;
  }

  // egl_headless - computed: false, optional: true, required: false
  private _eglHeadless = new DomainDevicesGraphicsEglHeadlessOutputReference(this, "egl_headless");
  public get eglHeadless() {
    return this._eglHeadless;
  }
  public putEglHeadless(value: DomainDevicesGraphicsEglHeadless) {
    this._eglHeadless.internalValue = value;
  }
  public resetEglHeadless() {
    this._eglHeadless.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get eglHeadlessInput() {
    return this._eglHeadless.internalValue;
  }

  // rdp - computed: false, optional: true, required: false
  private _rdp = new DomainDevicesGraphicsRdpOutputReference(this, "rdp");
  public get rdp() {
    return this._rdp;
  }
  public putRdp(value: DomainDevicesGraphicsRdp) {
    this._rdp.internalValue = value;
  }
  public resetRdp() {
    this._rdp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rdpInput() {
    return this._rdp.internalValue;
  }

  // sdl - computed: false, optional: true, required: false
  private _sdl = new DomainDevicesGraphicsSdlOutputReference(this, "sdl");
  public get sdl() {
    return this._sdl;
  }
  public putSdl(value: DomainDevicesGraphicsSdl) {
    this._sdl.internalValue = value;
  }
  public resetSdl() {
    this._sdl.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sdlInput() {
    return this._sdl.internalValue;
  }

  // spice - computed: false, optional: true, required: false
  private _spice = new DomainDevicesGraphicsSpiceOutputReference(this, "spice");
  public get spice() {
    return this._spice;
  }
  public putSpice(value: DomainDevicesGraphicsSpice) {
    this._spice.internalValue = value;
  }
  public resetSpice() {
    this._spice.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spiceInput() {
    return this._spice.internalValue;
  }

  // vnc - computed: false, optional: true, required: false
  private _vnc = new DomainDevicesGraphicsVncOutputReference(this, "vnc");
  public get vnc() {
    return this._vnc;
  }
  public putVnc(value: DomainDevicesGraphicsVnc) {
    this._vnc.internalValue = value;
  }
  public resetVnc() {
    this._vnc.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vncInput() {
    return this._vnc.internalValue;
  }
}

export class DomainDevicesGraphicsList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesGraphics[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesGraphicsOutputReference {
    return new DomainDevicesGraphicsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesHostdevsAcpi {
  /**
  * Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#pstore>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#index Domain#index}
  */
  readonly index?: number;
}

export function domainDevicesHostdevsAcpiToTerraform(struct?: DomainDevicesHostdevsAcpi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    index: cdktf.numberToTerraform(struct!.index),
  }
}


export function domainDevicesHostdevsAcpiToHclTerraform(struct?: DomainDevicesHostdevsAcpi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    index: {
      value: cdktf.numberToHclTerraform(struct!.index),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesHostdevsAcpiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesHostdevsAcpi | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._index !== undefined) {
      hasAnyValues = true;
      internalValueResult.index = this._index;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHostdevsAcpi | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._index = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._index = value.index;
    }
  }

  // index - computed: false, optional: true, required: false
  private _index?: number; 
  public get index() {
    return this.getNumberAttribute('index');
  }
  public set index(value: number) {
    this._index = value;
  }
  public resetIndex() {
    this._index = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get indexInput() {
    return this._index;
  }
}
export interface DomainDevicesHostdevsAddress {
}

export function domainDevicesHostdevsAddressToTerraform(struct?: DomainDevicesHostdevsAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function domainDevicesHostdevsAddressToHclTerraform(struct?: DomainDevicesHostdevsAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DomainDevicesHostdevsAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesHostdevsAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHostdevsAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DomainDevicesHostdevsAlias {
  /**
  * Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
}

export function domainDevicesHostdevsAliasToTerraform(struct?: DomainDevicesHostdevsAlias | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function domainDevicesHostdevsAliasToHclTerraform(struct?: DomainDevicesHostdevsAlias | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesHostdevsAliasOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesHostdevsAlias | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHostdevsAlias | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DomainDevicesHostdevsBoot {
  /**
  * Sets an optional firmware load parameter string associated with booting from this redirected device, passed to firmware on platforms that support loadparm (e.g. s390x).
  * 
  * See: <https://libvirt.org/formatdomain.html#specifying-boot-order>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#load_parm Domain#load_parm}
  */
  readonly loadParm?: string;
  /**
  * Sets the boot priority for this redirected device, as a positive integer where lower values are tried earlier during guest boot (for example, 1 for first, 2 for second).
  * 
  * See: <https://libvirt.org/formatdomain.html#specifying-boot-order>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#order Domain#order}
  */
  readonly order: number;
}

export function domainDevicesHostdevsBootToTerraform(struct?: DomainDevicesHostdevsBoot | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    load_parm: cdktf.stringToTerraform(struct!.loadParm),
    order: cdktf.numberToTerraform(struct!.order),
  }
}


export function domainDevicesHostdevsBootToHclTerraform(struct?: DomainDevicesHostdevsBoot | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    load_parm: {
      value: cdktf.stringToHclTerraform(struct!.loadParm),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    order: {
      value: cdktf.numberToHclTerraform(struct!.order),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesHostdevsBootOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesHostdevsBoot | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._loadParm !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadParm = this._loadParm;
    }
    if (this._order !== undefined) {
      hasAnyValues = true;
      internalValueResult.order = this._order;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHostdevsBoot | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._loadParm = undefined;
      this._order = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._loadParm = value.loadParm;
      this._order = value.order;
    }
  }

  // load_parm - computed: false, optional: true, required: false
  private _loadParm?: string; 
  public get loadParm() {
    return this.getStringAttribute('load_parm');
  }
  public set loadParm(value: string) {
    this._loadParm = value;
  }
  public resetLoadParm() {
    this._loadParm = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadParmInput() {
    return this._loadParm;
  }

  // order - computed: false, optional: false, required: true
  private _order?: number; 
  public get order() {
    return this.getNumberAttribute('order');
  }
  public set order(value: number) {
    this._order = value;
  }
  // Temporarily expose input value. Use with caution.
  public get orderInput() {
    return this._order;
  }
}
export interface DomainDevicesHostdevsCapsMiscSource {
  /**
  * Specifies a character-device style source (for example, a host chardev path) used by the miscellaneous capability; the value is a user-provided device path.
  * 
  * See: <https://libvirt.org/formatdomain.html#block-character-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#char Domain#char}
  */
  readonly char: string;
}

export function domainDevicesHostdevsCapsMiscSourceToTerraform(struct?: DomainDevicesHostdevsCapsMiscSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    char: cdktf.stringToTerraform(struct!.char),
  }
}


export function domainDevicesHostdevsCapsMiscSourceToHclTerraform(struct?: DomainDevicesHostdevsCapsMiscSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    char: {
      value: cdktf.stringToHclTerraform(struct!.char),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesHostdevsCapsMiscSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesHostdevsCapsMiscSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._char !== undefined) {
      hasAnyValues = true;
      internalValueResult.char = this._char;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHostdevsCapsMiscSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._char = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._char = value.char;
    }
  }

  // char - computed: false, optional: false, required: true
  private _char?: string; 
  public get char() {
    return this.getStringAttribute('char');
  }
  public set char(value: string) {
    this._char = value;
  }
  // Temporarily expose input value. Use with caution.
  public get charInput() {
    return this._char;
  }
}
export interface DomainDevicesHostdevsCapsMisc {
  /**
  * Defines the source configuration for the miscellaneous capability, such as underlying host resources or paths needed by that capability.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#source Domain#source}
  */
  readonly source?: DomainDevicesHostdevsCapsMiscSource;
}

export function domainDevicesHostdevsCapsMiscToTerraform(struct?: DomainDevicesHostdevsCapsMisc | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    source: domainDevicesHostdevsCapsMiscSourceToTerraform(struct!.source),
  }
}


export function domainDevicesHostdevsCapsMiscToHclTerraform(struct?: DomainDevicesHostdevsCapsMisc | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    source: {
      value: domainDevicesHostdevsCapsMiscSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesHostdevsCapsMiscSource",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesHostdevsCapsMiscOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesHostdevsCapsMisc | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHostdevsCapsMisc | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._source.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._source.internalValue = value.source;
    }
  }

  // source - computed: false, optional: true, required: false
  private _source = new DomainDevicesHostdevsCapsMiscSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: DomainDevicesHostdevsCapsMiscSource) {
    this._source.internalValue = value;
  }
  public resetSource() {
    this._source.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }
}
export interface DomainDevicesHostdevsCapsNetIp {
  /**
  * Sets the IP address assigned to the passthrough network device; value is user-provided (for example, "192.168.122.10" or "2001:db8::10").
  * 
  * See: <https://libvirt.org/formatdomain.html#ip-configuration>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: string;
  /**
  * Sets the IP address family for the passthrough network device, typically "ipv4" or "ipv6".
  * 
  * See: <https://libvirt.org/formatdomain.html#ip-configuration>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#family Domain#family}
  */
  readonly family?: string;
  /**
  * Sets the CIDR prefix length of the IP address for the passthrough network device, as a non-negative integer (for example, 24 for IPv4 or 64 for IPv6).
  * 
  * See: <https://libvirt.org/formatdomain.html#ip-configuration>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#prefix Domain#prefix}
  */
  readonly prefix?: number;
}

export function domainDevicesHostdevsCapsNetIpToTerraform(struct?: DomainDevicesHostdevsCapsNetIp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
    family: cdktf.stringToTerraform(struct!.family),
    prefix: cdktf.numberToTerraform(struct!.prefix),
  }
}


export function domainDevicesHostdevsCapsNetIpToHclTerraform(struct?: DomainDevicesHostdevsCapsNetIp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    family: {
      value: cdktf.stringToHclTerraform(struct!.family),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix: {
      value: cdktf.numberToHclTerraform(struct!.prefix),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesHostdevsCapsNetIpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesHostdevsCapsNetIp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    if (this._family !== undefined) {
      hasAnyValues = true;
      internalValueResult.family = this._family;
    }
    if (this._prefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefix = this._prefix;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHostdevsCapsNetIp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
      this._family = undefined;
      this._prefix = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
      this._family = value.family;
      this._prefix = value.prefix;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  public resetAddress() {
    this._address = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }

  // family - computed: false, optional: true, required: false
  private _family?: string; 
  public get family() {
    return this.getStringAttribute('family');
  }
  public set family(value: string) {
    this._family = value;
  }
  public resetFamily() {
    this._family = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get familyInput() {
    return this._family;
  }

  // prefix - computed: false, optional: true, required: false
  private _prefix?: number; 
  public get prefix() {
    return this.getNumberAttribute('prefix');
  }
  public set prefix(value: number) {
    this._prefix = value;
  }
  public resetPrefix() {
    this._prefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixInput() {
    return this._prefix;
  }
}

export class DomainDevicesHostdevsCapsNetIpList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesHostdevsCapsNetIp[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesHostdevsCapsNetIpOutputReference {
    return new DomainDevicesHostdevsCapsNetIpOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesHostdevsCapsNetRoute {
  /**
  * Sets the destination network address for the static route associated with the passthrough host device; value is user-provided (for example, "10.0.0.0").
  * 
  * See: <https://libvirt.org/formatdomain.html#ip-configuration>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: string;
  /**
  * Sets the address family for the static route, typically "ipv4" or "ipv6".
  * 
  * See: <https://libvirt.org/formatdomain.html#ip-configuration>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#family Domain#family}
  */
  readonly family?: string;
  /**
  * Sets the gateway IP address used to reach the route destination network via the passthrough device; value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#ip-configuration>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#gateway Domain#gateway}
  */
  readonly gateway?: string;
}

export function domainDevicesHostdevsCapsNetRouteToTerraform(struct?: DomainDevicesHostdevsCapsNetRoute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
    family: cdktf.stringToTerraform(struct!.family),
    gateway: cdktf.stringToTerraform(struct!.gateway),
  }
}


export function domainDevicesHostdevsCapsNetRouteToHclTerraform(struct?: DomainDevicesHostdevsCapsNetRoute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    family: {
      value: cdktf.stringToHclTerraform(struct!.family),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    gateway: {
      value: cdktf.stringToHclTerraform(struct!.gateway),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesHostdevsCapsNetRouteOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesHostdevsCapsNetRoute | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    if (this._family !== undefined) {
      hasAnyValues = true;
      internalValueResult.family = this._family;
    }
    if (this._gateway !== undefined) {
      hasAnyValues = true;
      internalValueResult.gateway = this._gateway;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHostdevsCapsNetRoute | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
      this._family = undefined;
      this._gateway = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
      this._family = value.family;
      this._gateway = value.gateway;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  public resetAddress() {
    this._address = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }

  // family - computed: false, optional: true, required: false
  private _family?: string; 
  public get family() {
    return this.getStringAttribute('family');
  }
  public set family(value: string) {
    this._family = value;
  }
  public resetFamily() {
    this._family = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get familyInput() {
    return this._family;
  }

  // gateway - computed: false, optional: true, required: false
  private _gateway?: string; 
  public get gateway() {
    return this.getStringAttribute('gateway');
  }
  public set gateway(value: string) {
    this._gateway = value;
  }
  public resetGateway() {
    this._gateway = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gatewayInput() {
    return this._gateway;
  }
}

export class DomainDevicesHostdevsCapsNetRouteList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesHostdevsCapsNetRoute[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesHostdevsCapsNetRouteOutputReference {
    return new DomainDevicesHostdevsCapsNetRouteOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesHostdevsCapsNetSource {
  /**
  * Specifies the name of the host network interface used as the source for the passthrough network device (for example, "eth0"); this field is required when configuring caps_net.source.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#interface Domain#interface}
  */
  readonly interface: string;
}

export function domainDevicesHostdevsCapsNetSourceToTerraform(struct?: DomainDevicesHostdevsCapsNetSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    interface: cdktf.stringToTerraform(struct!.interface),
  }
}


export function domainDevicesHostdevsCapsNetSourceToHclTerraform(struct?: DomainDevicesHostdevsCapsNetSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesHostdevsCapsNetSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesHostdevsCapsNetSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHostdevsCapsNetSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._interface = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._interface = value.interface;
    }
  }

  // interface - computed: false, optional: false, required: true
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }
}
export interface DomainDevicesHostdevsCapsNet {
  /**
  * Configures one or more IP addresses associated with the passthrough network host device, including address, family, and prefix.
  * 
  * See: <https://libvirt.org/formatdomain.html#ip-configuration>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#ip Domain#ip}
  */
  readonly ip?: DomainDevicesHostdevsCapsNetIp[] | cdktf.IResolvable;
  /**
  * Defines a static route reachable via the passthrough network host device, including destination address, family, and gateway.
  * 
  * See: <https://libvirt.org/formatdomain.html#ip-configuration>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#route Domain#route}
  */
  readonly route?: DomainDevicesHostdevsCapsNetRoute[] | cdktf.IResolvable;
  /**
  * Configures the source information for the passthrough network host device, such as the backing host interface.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#source Domain#source}
  */
  readonly source?: DomainDevicesHostdevsCapsNetSource;
}

export function domainDevicesHostdevsCapsNetToTerraform(struct?: DomainDevicesHostdevsCapsNet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ip: cdktf.listMapper(domainDevicesHostdevsCapsNetIpToTerraform, false)(struct!.ip),
    route: cdktf.listMapper(domainDevicesHostdevsCapsNetRouteToTerraform, false)(struct!.route),
    source: domainDevicesHostdevsCapsNetSourceToTerraform(struct!.source),
  }
}


export function domainDevicesHostdevsCapsNetToHclTerraform(struct?: DomainDevicesHostdevsCapsNet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ip: {
      value: cdktf.listMapperHcl(domainDevicesHostdevsCapsNetIpToHclTerraform, false)(struct!.ip),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesHostdevsCapsNetIpList",
    },
    route: {
      value: cdktf.listMapperHcl(domainDevicesHostdevsCapsNetRouteToHclTerraform, false)(struct!.route),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesHostdevsCapsNetRouteList",
    },
    source: {
      value: domainDevicesHostdevsCapsNetSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesHostdevsCapsNetSource",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesHostdevsCapsNetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesHostdevsCapsNet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ip?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ip = this._ip?.internalValue;
    }
    if (this._route?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.route = this._route?.internalValue;
    }
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHostdevsCapsNet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ip.internalValue = undefined;
      this._route.internalValue = undefined;
      this._source.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ip.internalValue = value.ip;
      this._route.internalValue = value.route;
      this._source.internalValue = value.source;
    }
  }

  // ip - computed: false, optional: true, required: false
  private _ip = new DomainDevicesHostdevsCapsNetIpList(this, "ip", false);
  public get ip() {
    return this._ip;
  }
  public putIp(value: DomainDevicesHostdevsCapsNetIp[] | cdktf.IResolvable) {
    this._ip.internalValue = value;
  }
  public resetIp() {
    this._ip.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipInput() {
    return this._ip.internalValue;
  }

  // route - computed: false, optional: true, required: false
  private _route = new DomainDevicesHostdevsCapsNetRouteList(this, "route", false);
  public get route() {
    return this._route;
  }
  public putRoute(value: DomainDevicesHostdevsCapsNetRoute[] | cdktf.IResolvable) {
    this._route.internalValue = value;
  }
  public resetRoute() {
    this._route.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeInput() {
    return this._route.internalValue;
  }

  // source - computed: false, optional: true, required: false
  private _source = new DomainDevicesHostdevsCapsNetSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: DomainDevicesHostdevsCapsNetSource) {
    this._source.internalValue = value;
  }
  public resetSource() {
    this._source.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }
}
export interface DomainDevicesHostdevsCapsStorageSource {
  /**
  * Specifies the path of the host block device used as the storage source for the passthrough device (for example, "/dev/sdb"); this field is required when configuring caps_storage.source.
  * 
  * See: <https://libvirt.org/formatdomain.html#block-character-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#block Domain#block}
  */
  readonly block: string;
}

export function domainDevicesHostdevsCapsStorageSourceToTerraform(struct?: DomainDevicesHostdevsCapsStorageSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    block: cdktf.stringToTerraform(struct!.block),
  }
}


export function domainDevicesHostdevsCapsStorageSourceToHclTerraform(struct?: DomainDevicesHostdevsCapsStorageSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    block: {
      value: cdktf.stringToHclTerraform(struct!.block),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesHostdevsCapsStorageSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesHostdevsCapsStorageSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._block !== undefined) {
      hasAnyValues = true;
      internalValueResult.block = this._block;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHostdevsCapsStorageSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._block = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._block = value.block;
    }
  }

  // block - computed: false, optional: false, required: true
  private _block?: string; 
  public get block() {
    return this.getStringAttribute('block');
  }
  public set block(value: string) {
    this._block = value;
  }
  // Temporarily expose input value. Use with caution.
  public get blockInput() {
    return this._block;
  }
}
export interface DomainDevicesHostdevsCapsStorage {
  /**
  * Defines the storage source information for the passthrough host device, typically pointing to a host block device.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#source Domain#source}
  */
  readonly source?: DomainDevicesHostdevsCapsStorageSource;
}

export function domainDevicesHostdevsCapsStorageToTerraform(struct?: DomainDevicesHostdevsCapsStorage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    source: domainDevicesHostdevsCapsStorageSourceToTerraform(struct!.source),
  }
}


export function domainDevicesHostdevsCapsStorageToHclTerraform(struct?: DomainDevicesHostdevsCapsStorage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    source: {
      value: domainDevicesHostdevsCapsStorageSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesHostdevsCapsStorageSource",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesHostdevsCapsStorageOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesHostdevsCapsStorage | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHostdevsCapsStorage | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._source.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._source.internalValue = value.source;
    }
  }

  // source - computed: false, optional: true, required: false
  private _source = new DomainDevicesHostdevsCapsStorageSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: DomainDevicesHostdevsCapsStorageSource) {
    this._source.internalValue = value;
  }
  public resetSource() {
    this._source.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }
}
export interface DomainDevicesHostdevsRom {
  /**
  * Controls whether the devices ROM is exposed in PCI BAR space, typically "on" or "off".
  * 
  * See: <https://libvirt.org/formatdomain.html#interface-rom-bios-configuration>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bar Domain#bar}
  */
  readonly bar?: string;
  /**
  * Enables or disables use of the ROM image for the host device, as a user-provided string flag (for example, "on"/"off" or "yes"/"no" depending on libvirt expectations).
  * 
  * See: <https://libvirt.org/formatdomain.html#interface-rom-bios-configuration>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enabled Domain#enabled}
  */
  readonly enabled?: string;
  /**
  * Specifies a path to a custom ROM file to use for the passthrough device (for example, "/usr/share/roms/nic.rom"); value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#interface-rom-bios-configuration>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file?: string;
}

export function domainDevicesHostdevsRomToTerraform(struct?: DomainDevicesHostdevsRom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bar: cdktf.stringToTerraform(struct!.bar),
    enabled: cdktf.stringToTerraform(struct!.enabled),
    file: cdktf.stringToTerraform(struct!.file),
  }
}


export function domainDevicesHostdevsRomToHclTerraform(struct?: DomainDevicesHostdevsRom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bar: {
      value: cdktf.stringToHclTerraform(struct!.bar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enabled: {
      value: cdktf.stringToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    file: {
      value: cdktf.stringToHclTerraform(struct!.file),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesHostdevsRomOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesHostdevsRom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bar !== undefined) {
      hasAnyValues = true;
      internalValueResult.bar = this._bar;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._file !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHostdevsRom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bar = undefined;
      this._enabled = undefined;
      this._file = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bar = value.bar;
      this._enabled = value.enabled;
      this._file = value.file;
    }
  }

  // bar - computed: false, optional: true, required: false
  private _bar?: string; 
  public get bar() {
    return this.getStringAttribute('bar');
  }
  public set bar(value: string) {
    this._bar = value;
  }
  public resetBar() {
    this._bar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get barInput() {
    return this._bar;
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: string; 
  public get enabled() {
    return this.getStringAttribute('enabled');
  }
  public set enabled(value: string) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // file - computed: false, optional: true, required: false
  private _file?: string; 
  public get file() {
    return this.getStringAttribute('file');
  }
  public set file(value: string) {
    this._file = value;
  }
  public resetFile() {
    this._file = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file;
  }
}
export interface DomainDevicesHostdevsSubsysMDevSourceAddress {
}

export function domainDevicesHostdevsSubsysMDevSourceAddressToTerraform(struct?: DomainDevicesHostdevsSubsysMDevSourceAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function domainDevicesHostdevsSubsysMDevSourceAddressToHclTerraform(struct?: DomainDevicesHostdevsSubsysMDevSourceAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DomainDevicesHostdevsSubsysMDevSourceAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesHostdevsSubsysMDevSourceAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHostdevsSubsysMDevSourceAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }

  // uuid - computed: true, optional: false, required: false
  public get uuid() {
    return this.getStringAttribute('uuid');
  }
}
export interface DomainDevicesHostdevsSubsysMDevSource {
  /**
  * Defines the host-side address for the mediated device source; for mdev this typically contains the UUID identifying the mediated device instance on the host.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: DomainDevicesHostdevsSubsysMDevSourceAddress;
}

export function domainDevicesHostdevsSubsysMDevSourceToTerraform(struct?: DomainDevicesHostdevsSubsysMDevSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: domainDevicesHostdevsSubsysMDevSourceAddressToTerraform(struct!.address),
  }
}


export function domainDevicesHostdevsSubsysMDevSourceToHclTerraform(struct?: DomainDevicesHostdevsSubsysMDevSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: domainDevicesHostdevsSubsysMDevSourceAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesHostdevsSubsysMDevSourceAddress",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesHostdevsSubsysMDevSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesHostdevsSubsysMDevSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHostdevsSubsysMDevSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address = new DomainDevicesHostdevsSubsysMDevSourceAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DomainDevicesHostdevsSubsysMDevSourceAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }
}
export interface DomainDevicesHostdevsSubsysMDev {
  /**
  * Sets how display output of a mediated (mdev) device is exposed to the guest; the value is user-provided and backend-specific (for example, selecting a particular vGPU display mode).
  * 
  * See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#display Domain#display}
  */
  readonly display?: string;
  /**
  * Sets the mediated device (mdev) model for this hostdev, identifying which virtual function or vGPU type is exposed to the guest; the value is user-provided and must match a model supported by the host driver (for example, an NVIDIA vGPU type name).
  * 
  * See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether a frame buffer (ramfb) is created for this mediated device; accepts "on"/"off" as yes/no flags when supported by the host driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#ram_fb Domain#ram_fb}
  */
  readonly ramFb?: string;
  /**
  * Groups the source configuration for the mediated device passed through to the guest, such as its unique address on the host.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#source Domain#source}
  */
  readonly source?: DomainDevicesHostdevsSubsysMDevSource;
}

export function domainDevicesHostdevsSubsysMDevToTerraform(struct?: DomainDevicesHostdevsSubsysMDev | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    display: cdktf.stringToTerraform(struct!.display),
    model: cdktf.stringToTerraform(struct!.model),
    ram_fb: cdktf.stringToTerraform(struct!.ramFb),
    source: domainDevicesHostdevsSubsysMDevSourceToTerraform(struct!.source),
  }
}


export function domainDevicesHostdevsSubsysMDevToHclTerraform(struct?: DomainDevicesHostdevsSubsysMDev | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    display: {
      value: cdktf.stringToHclTerraform(struct!.display),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ram_fb: {
      value: cdktf.stringToHclTerraform(struct!.ramFb),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    source: {
      value: domainDevicesHostdevsSubsysMDevSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesHostdevsSubsysMDevSource",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesHostdevsSubsysMDevOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesHostdevsSubsysMDev | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._display !== undefined) {
      hasAnyValues = true;
      internalValueResult.display = this._display;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._ramFb !== undefined) {
      hasAnyValues = true;
      internalValueResult.ramFb = this._ramFb;
    }
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHostdevsSubsysMDev | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._display = undefined;
      this._model = undefined;
      this._ramFb = undefined;
      this._source.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._display = value.display;
      this._model = value.model;
      this._ramFb = value.ramFb;
      this._source.internalValue = value.source;
    }
  }

  // display - computed: false, optional: true, required: false
  private _display?: string; 
  public get display() {
    return this.getStringAttribute('display');
  }
  public set display(value: string) {
    this._display = value;
  }
  public resetDisplay() {
    this._display = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get displayInput() {
    return this._display;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // ram_fb - computed: false, optional: true, required: false
  private _ramFb?: string; 
  public get ramFb() {
    return this.getStringAttribute('ram_fb');
  }
  public set ramFb(value: string) {
    this._ramFb = value;
  }
  public resetRamFb() {
    this._ramFb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ramFbInput() {
    return this._ramFb;
  }

  // source - computed: false, optional: true, required: false
  private _source = new DomainDevicesHostdevsSubsysMDevSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: DomainDevicesHostdevsSubsysMDevSource) {
    this._source.internalValue = value;
  }
  public resetSource() {
    this._source.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }
}
export interface DomainDevicesHostdevsSubsysPciDriver {
  /**
  * Sets the model of the guest-side driver used for this PCI hostdev; the value is user-provided and must be a model supported by the hypervisor for PCI passthrough.
  * 
  * See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Specifies the host-side kernel driver name to bind for this PCI device (for example, "vfio-pci"); the value is user-provided and must match a valid driver on the host.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name?: string;
}

export function domainDevicesHostdevsSubsysPciDriverToTerraform(struct?: DomainDevicesHostdevsSubsysPciDriver | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    model: cdktf.stringToTerraform(struct!.model),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function domainDevicesHostdevsSubsysPciDriverToHclTerraform(struct?: DomainDevicesHostdevsSubsysPciDriver | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesHostdevsSubsysPciDriverOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesHostdevsSubsysPciDriver | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHostdevsSubsysPciDriver | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._model = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._model = value.model;
      this._name = value.name;
    }
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DomainDevicesHostdevsSubsysPciSourceAddressZpci {
  /**
  * Sets the function ID (fid) for a zPCI device on s390x, identifying the specific zPCI function to passthrough; the value is user-provided and must match the host's zPCI configuration.
  * 
  * See: <https://libvirt.org/formatdomain.html#device-addresses>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#fid Domain#fid}
  */
  readonly fid?: number;
  /**
  * Sets the zPCI function UID for a passed-through PCI device on s390x, identifying the zPCI function within the guest; the value is user-provided and must match the host zPCI configuration.
  * 
  * See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#uid Domain#uid}
  */
  readonly uid?: number;
}

export function domainDevicesHostdevsSubsysPciSourceAddressZpciToTerraform(struct?: DomainDevicesHostdevsSubsysPciSourceAddressZpci | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fid: cdktf.numberToTerraform(struct!.fid),
    uid: cdktf.numberToTerraform(struct!.uid),
  }
}


export function domainDevicesHostdevsSubsysPciSourceAddressZpciToHclTerraform(struct?: DomainDevicesHostdevsSubsysPciSourceAddressZpci | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fid: {
      value: cdktf.numberToHclTerraform(struct!.fid),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    uid: {
      value: cdktf.numberToHclTerraform(struct!.uid),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesHostdevsSubsysPciSourceAddressZpciOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesHostdevsSubsysPciSourceAddressZpci | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fid !== undefined) {
      hasAnyValues = true;
      internalValueResult.fid = this._fid;
    }
    if (this._uid !== undefined) {
      hasAnyValues = true;
      internalValueResult.uid = this._uid;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHostdevsSubsysPciSourceAddressZpci | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fid = undefined;
      this._uid = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fid = value.fid;
      this._uid = value.uid;
    }
  }

  // fid - computed: false, optional: true, required: false
  private _fid?: number; 
  public get fid() {
    return this.getNumberAttribute('fid');
  }
  public set fid(value: number) {
    this._fid = value;
  }
  public resetFid() {
    this._fid = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fidInput() {
    return this._fid;
  }

  // uid - computed: false, optional: true, required: false
  private _uid?: number; 
  public get uid() {
    return this.getNumberAttribute('uid');
  }
  public set uid(value: number) {
    this._uid = value;
  }
  public resetUid() {
    this._uid = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get uidInput() {
    return this._uid;
  }
}
export interface DomainDevicesHostdevsSubsysPciSourceAddress {
  /**
  * Sets the PCI bus number of the host device to passthrough; the value is usually a hexadecimal or decimal bus index matching the host's PCI topology (for example, "0x03").
  * 
  * See: <https://libvirt.org/formatdomain.html#device-addresses>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bus Domain#bus}
  */
  readonly bus?: number;
  /**
  * Sets the PCI domain number of the host device (segment), typically "0" on most systems; the value must match the device's domain as reported by tools like lspci.
  * 
  * See: <https://libvirt.org/formatdomain.html#device-addresses>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#domain Domain#domain}
  */
  readonly domain?: number;
  /**
  * Sets the PCI function number of the host device (07), usually provided as a small integer or hex string (for example, "0" or "0x0") corresponding to the device's function.
  * 
  * See: <https://libvirt.org/formatdomain.html#device-addresses>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#function Domain#function}
  */
  readonly function?: number;
  /**
  * Indicates whether the PCI device is part of a multifunction PCI slot; accepts "on"/"off" as yes/no flags.
  * 
  * See: <https://libvirt.org/formatdomain.html#device-addresses>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#multi_function Domain#multi_function}
  */
  readonly multiFunction?: string;
  /**
  * Sets the PCI slot number of the host device, usually as a hex or decimal value (for example, "0x00" or "0") matching the slot shown by lspci.
  * 
  * See: <https://libvirt.org/formatdomain.html#device-addresses>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#slot Domain#slot}
  */
  readonly slot?: number;
  /**
  * Groups additional addressing attributes for s390x zPCI devices, used when passing through PCI devices on IBM Z systems.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#zpci Domain#zpci}
  */
  readonly zpci?: DomainDevicesHostdevsSubsysPciSourceAddressZpci;
}

export function domainDevicesHostdevsSubsysPciSourceAddressToTerraform(struct?: DomainDevicesHostdevsSubsysPciSourceAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bus: cdktf.numberToTerraform(struct!.bus),
    domain: cdktf.numberToTerraform(struct!.domain),
    function: cdktf.numberToTerraform(struct!.function),
    multi_function: cdktf.stringToTerraform(struct!.multiFunction),
    slot: cdktf.numberToTerraform(struct!.slot),
    zpci: domainDevicesHostdevsSubsysPciSourceAddressZpciToTerraform(struct!.zpci),
  }
}


export function domainDevicesHostdevsSubsysPciSourceAddressToHclTerraform(struct?: DomainDevicesHostdevsSubsysPciSourceAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bus: {
      value: cdktf.numberToHclTerraform(struct!.bus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    domain: {
      value: cdktf.numberToHclTerraform(struct!.domain),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    function: {
      value: cdktf.numberToHclTerraform(struct!.function),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    multi_function: {
      value: cdktf.stringToHclTerraform(struct!.multiFunction),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    slot: {
      value: cdktf.numberToHclTerraform(struct!.slot),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    zpci: {
      value: domainDevicesHostdevsSubsysPciSourceAddressZpciToHclTerraform(struct!.zpci),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesHostdevsSubsysPciSourceAddressZpci",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesHostdevsSubsysPciSourceAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesHostdevsSubsysPciSourceAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bus !== undefined) {
      hasAnyValues = true;
      internalValueResult.bus = this._bus;
    }
    if (this._domain !== undefined) {
      hasAnyValues = true;
      internalValueResult.domain = this._domain;
    }
    if (this._function !== undefined) {
      hasAnyValues = true;
      internalValueResult.function = this._function;
    }
    if (this._multiFunction !== undefined) {
      hasAnyValues = true;
      internalValueResult.multiFunction = this._multiFunction;
    }
    if (this._slot !== undefined) {
      hasAnyValues = true;
      internalValueResult.slot = this._slot;
    }
    if (this._zpci?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.zpci = this._zpci?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHostdevsSubsysPciSourceAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bus = undefined;
      this._domain = undefined;
      this._function = undefined;
      this._multiFunction = undefined;
      this._slot = undefined;
      this._zpci.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bus = value.bus;
      this._domain = value.domain;
      this._function = value.function;
      this._multiFunction = value.multiFunction;
      this._slot = value.slot;
      this._zpci.internalValue = value.zpci;
    }
  }

  // bus - computed: false, optional: true, required: false
  private _bus?: number; 
  public get bus() {
    return this.getNumberAttribute('bus');
  }
  public set bus(value: number) {
    this._bus = value;
  }
  public resetBus() {
    this._bus = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get busInput() {
    return this._bus;
  }

  // domain - computed: false, optional: true, required: false
  private _domain?: number; 
  public get domain() {
    return this.getNumberAttribute('domain');
  }
  public set domain(value: number) {
    this._domain = value;
  }
  public resetDomain() {
    this._domain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get domainInput() {
    return this._domain;
  }

  // function - computed: false, optional: true, required: false
  private _function?: number; 
  public get function() {
    return this.getNumberAttribute('function');
  }
  public set function(value: number) {
    this._function = value;
  }
  public resetFunction() {
    this._function = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get functionInput() {
    return this._function;
  }

  // multi_function - computed: false, optional: true, required: false
  private _multiFunction?: string; 
  public get multiFunction() {
    return this.getStringAttribute('multi_function');
  }
  public set multiFunction(value: string) {
    this._multiFunction = value;
  }
  public resetMultiFunction() {
    this._multiFunction = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get multiFunctionInput() {
    return this._multiFunction;
  }

  // slot - computed: false, optional: true, required: false
  private _slot?: number; 
  public get slot() {
    return this.getNumberAttribute('slot');
  }
  public set slot(value: number) {
    this._slot = value;
  }
  public resetSlot() {
    this._slot = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get slotInput() {
    return this._slot;
  }

  // zpci - computed: false, optional: true, required: false
  private _zpci = new DomainDevicesHostdevsSubsysPciSourceAddressZpciOutputReference(this, "zpci");
  public get zpci() {
    return this._zpci;
  }
  public putZpci(value: DomainDevicesHostdevsSubsysPciSourceAddressZpci) {
    this._zpci.internalValue = value;
  }
  public resetZpci() {
    this._zpci.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get zpciInput() {
    return this._zpci.internalValue;
  }
}
export interface DomainDevicesHostdevsSubsysPciSource {
  /**
  * Defines the host PCI address of the device to passthrough, typically via domain, bus, slot, and function (and optional zPCI info on s390x).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: DomainDevicesHostdevsSubsysPciSourceAddress;
  /**
  * Controls whether write filtering is enabled for a PCI passthrough device, typically to restrict or filter MMIO/PCI configuration writes; accepts user-provided value as defined by libvirt (for example "on" or "off").
  * 
  * See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#write_filtering Domain#write_filtering}
  */
  readonly writeFiltering?: string;
}

export function domainDevicesHostdevsSubsysPciSourceToTerraform(struct?: DomainDevicesHostdevsSubsysPciSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: domainDevicesHostdevsSubsysPciSourceAddressToTerraform(struct!.address),
    write_filtering: cdktf.stringToTerraform(struct!.writeFiltering),
  }
}


export function domainDevicesHostdevsSubsysPciSourceToHclTerraform(struct?: DomainDevicesHostdevsSubsysPciSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: domainDevicesHostdevsSubsysPciSourceAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesHostdevsSubsysPciSourceAddress",
    },
    write_filtering: {
      value: cdktf.stringToHclTerraform(struct!.writeFiltering),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesHostdevsSubsysPciSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesHostdevsSubsysPciSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._writeFiltering !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeFiltering = this._writeFiltering;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHostdevsSubsysPciSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._writeFiltering = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._writeFiltering = value.writeFiltering;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address = new DomainDevicesHostdevsSubsysPciSourceAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DomainDevicesHostdevsSubsysPciSourceAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // write_filtering - computed: false, optional: true, required: false
  private _writeFiltering?: string; 
  public get writeFiltering() {
    return this.getStringAttribute('write_filtering');
  }
  public set writeFiltering(value: string) {
    this._writeFiltering = value;
  }
  public resetWriteFiltering() {
    this._writeFiltering = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeFilteringInput() {
    return this._writeFiltering;
  }
}
export interface DomainDevicesHostdevsSubsysPciTeaming {
  /**
  * Controls whether the teaming configuration for this hostdev should survive guest reboots; when true, the team is kept persistent, when false it is transient for the current guest lifecycle.
  * 
  * See: <https://libvirt.org/formatdomain.html#teaming-a-virtio-hostdev-nic-pair>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#persistent Domain#persistent}
  */
  readonly persistent?: string;
  /**
  * Sets the teaming mode for this hostdev (for example "persistent" or "transient") and is required when teaming is configured; valid values are those supported by libvirt for teaming type.
  * 
  * See: <https://libvirt.org/formatdomain.html#teaming-a-virtio-hostdev-nic-pair>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type: string;
}

export function domainDevicesHostdevsSubsysPciTeamingToTerraform(struct?: DomainDevicesHostdevsSubsysPciTeaming | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    persistent: cdktf.stringToTerraform(struct!.persistent),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function domainDevicesHostdevsSubsysPciTeamingToHclTerraform(struct?: DomainDevicesHostdevsSubsysPciTeaming | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    persistent: {
      value: cdktf.stringToHclTerraform(struct!.persistent),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesHostdevsSubsysPciTeamingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesHostdevsSubsysPciTeaming | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._persistent !== undefined) {
      hasAnyValues = true;
      internalValueResult.persistent = this._persistent;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHostdevsSubsysPciTeaming | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._persistent = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._persistent = value.persistent;
      this._type = value.type;
    }
  }

  // persistent - computed: false, optional: true, required: false
  private _persistent?: string; 
  public get persistent() {
    return this.getStringAttribute('persistent');
  }
  public set persistent(value: string) {
    this._persistent = value;
  }
  public resetPersistent() {
    this._persistent = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get persistentInput() {
    return this._persistent;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DomainDevicesHostdevsSubsysPci {
  /**
  * Controls whether this PCI hostdev is treated as a display device (for example, a GPU providing primary display); valid values are "on" or "off" as yes/no flags when supported.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#display Domain#display}
  */
  readonly display?: string;
  /**
  * Groups driver-related configuration for PCI passthrough, such as which kernel driver or model to use for the device in the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#driver Domain#driver}
  */
  readonly driver?: DomainDevicesHostdevsSubsysPciDriver;
  /**
  * Controls whether a ramfb (in-memory frame buffer) is created for this PCI hostdev, typically used with GPUs; accepts "on"/"off" as yes/no flags when supported.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#ram_fb Domain#ram_fb}
  */
  readonly ramFb?: string;
  /**
  * Groups the source configuration for the PCI device being passed through, including its PCI address on the host.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#source Domain#source}
  */
  readonly source?: DomainDevicesHostdevsSubsysPciSource;
  /**
  * Configures this PCI hostdev as part of an interface teaming/bonding setup in the guest, pairing it with another interface for failover.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#teaming Domain#teaming}
  */
  readonly teaming?: DomainDevicesHostdevsSubsysPciTeaming;
}

export function domainDevicesHostdevsSubsysPciToTerraform(struct?: DomainDevicesHostdevsSubsysPci | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    display: cdktf.stringToTerraform(struct!.display),
    driver: domainDevicesHostdevsSubsysPciDriverToTerraform(struct!.driver),
    ram_fb: cdktf.stringToTerraform(struct!.ramFb),
    source: domainDevicesHostdevsSubsysPciSourceToTerraform(struct!.source),
    teaming: domainDevicesHostdevsSubsysPciTeamingToTerraform(struct!.teaming),
  }
}


export function domainDevicesHostdevsSubsysPciToHclTerraform(struct?: DomainDevicesHostdevsSubsysPci | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    display: {
      value: cdktf.stringToHclTerraform(struct!.display),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    driver: {
      value: domainDevicesHostdevsSubsysPciDriverToHclTerraform(struct!.driver),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesHostdevsSubsysPciDriver",
    },
    ram_fb: {
      value: cdktf.stringToHclTerraform(struct!.ramFb),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    source: {
      value: domainDevicesHostdevsSubsysPciSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesHostdevsSubsysPciSource",
    },
    teaming: {
      value: domainDevicesHostdevsSubsysPciTeamingToHclTerraform(struct!.teaming),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesHostdevsSubsysPciTeaming",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesHostdevsSubsysPciOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesHostdevsSubsysPci | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._display !== undefined) {
      hasAnyValues = true;
      internalValueResult.display = this._display;
    }
    if (this._driver?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.driver = this._driver?.internalValue;
    }
    if (this._ramFb !== undefined) {
      hasAnyValues = true;
      internalValueResult.ramFb = this._ramFb;
    }
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    if (this._teaming?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.teaming = this._teaming?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHostdevsSubsysPci | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._display = undefined;
      this._driver.internalValue = undefined;
      this._ramFb = undefined;
      this._source.internalValue = undefined;
      this._teaming.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._display = value.display;
      this._driver.internalValue = value.driver;
      this._ramFb = value.ramFb;
      this._source.internalValue = value.source;
      this._teaming.internalValue = value.teaming;
    }
  }

  // display - computed: false, optional: true, required: false
  private _display?: string; 
  public get display() {
    return this.getStringAttribute('display');
  }
  public set display(value: string) {
    this._display = value;
  }
  public resetDisplay() {
    this._display = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get displayInput() {
    return this._display;
  }

  // driver - computed: false, optional: true, required: false
  private _driver = new DomainDevicesHostdevsSubsysPciDriverOutputReference(this, "driver");
  public get driver() {
    return this._driver;
  }
  public putDriver(value: DomainDevicesHostdevsSubsysPciDriver) {
    this._driver.internalValue = value;
  }
  public resetDriver() {
    this._driver.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get driverInput() {
    return this._driver.internalValue;
  }

  // ram_fb - computed: false, optional: true, required: false
  private _ramFb?: string; 
  public get ramFb() {
    return this.getStringAttribute('ram_fb');
  }
  public set ramFb(value: string) {
    this._ramFb = value;
  }
  public resetRamFb() {
    this._ramFb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ramFbInput() {
    return this._ramFb;
  }

  // source - computed: false, optional: true, required: false
  private _source = new DomainDevicesHostdevsSubsysPciSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: DomainDevicesHostdevsSubsysPciSource) {
    this._source.internalValue = value;
  }
  public resetSource() {
    this._source.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }

  // teaming - computed: false, optional: true, required: false
  private _teaming = new DomainDevicesHostdevsSubsysPciTeamingOutputReference(this, "teaming");
  public get teaming() {
    return this._teaming;
  }
  public putTeaming(value: DomainDevicesHostdevsSubsysPciTeaming) {
    this._teaming.internalValue = value;
  }
  public resetTeaming() {
    this._teaming.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get teamingInput() {
    return this._teaming.internalValue;
  }
}
export interface DomainDevicesHostdevsSubsysScsiSourceHostAdapter {
  /**
  * Sets the name of the host SCSI adapter (for example a HBA or SCSI host name) from which the device is sourced; this attribute is required when using the adapter-based SCSI source.
  * 
  * See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
}

export function domainDevicesHostdevsSubsysScsiSourceHostAdapterToTerraform(struct?: DomainDevicesHostdevsSubsysScsiSourceHostAdapter | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function domainDevicesHostdevsSubsysScsiSourceHostAdapterToHclTerraform(struct?: DomainDevicesHostdevsSubsysScsiSourceHostAdapter | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesHostdevsSubsysScsiSourceHostAdapterOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesHostdevsSubsysScsiSourceHostAdapter | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHostdevsSubsysScsiSourceHostAdapter | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DomainDevicesHostdevsSubsysScsiSourceHostAddress {
  /**
  * Sets the SCSI bus number of the host device to passthrough; the value is a user-provided non-negative integer matching the host SCSI topology (e.g. "0").
  * 
  * See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bus Domain#bus}
  */
  readonly bus?: number;
  /**
  * Sets the SCSI controller number of the host device to passthrough; the value is a user-provided non-negative integer matching the host SCSI topology.
  * 
  * See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#controller Domain#controller}
  */
  readonly controller?: number;
  /**
  * Sets the SCSI target ID on the host bus for the device to be passed through; the value is a user-provided non-negative integer (e.g. "0" or "1").
  * 
  * See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#target Domain#target}
  */
  readonly target?: number;
  /**
  * Sets the SCSI LUN/unit number of the host device to passthrough; the value is a user-provided non-negative integer matching the host LUN (e.g. "0").
  * 
  * See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#unit Domain#unit}
  */
  readonly unit?: number;
}

export function domainDevicesHostdevsSubsysScsiSourceHostAddressToTerraform(struct?: DomainDevicesHostdevsSubsysScsiSourceHostAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bus: cdktf.numberToTerraform(struct!.bus),
    controller: cdktf.numberToTerraform(struct!.controller),
    target: cdktf.numberToTerraform(struct!.target),
    unit: cdktf.numberToTerraform(struct!.unit),
  }
}


export function domainDevicesHostdevsSubsysScsiSourceHostAddressToHclTerraform(struct?: DomainDevicesHostdevsSubsysScsiSourceHostAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bus: {
      value: cdktf.numberToHclTerraform(struct!.bus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    controller: {
      value: cdktf.numberToHclTerraform(struct!.controller),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    target: {
      value: cdktf.numberToHclTerraform(struct!.target),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    unit: {
      value: cdktf.numberToHclTerraform(struct!.unit),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesHostdevsSubsysScsiSourceHostAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesHostdevsSubsysScsiSourceHostAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bus !== undefined) {
      hasAnyValues = true;
      internalValueResult.bus = this._bus;
    }
    if (this._controller !== undefined) {
      hasAnyValues = true;
      internalValueResult.controller = this._controller;
    }
    if (this._target !== undefined) {
      hasAnyValues = true;
      internalValueResult.target = this._target;
    }
    if (this._unit !== undefined) {
      hasAnyValues = true;
      internalValueResult.unit = this._unit;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHostdevsSubsysScsiSourceHostAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bus = undefined;
      this._controller = undefined;
      this._target = undefined;
      this._unit = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bus = value.bus;
      this._controller = value.controller;
      this._target = value.target;
      this._unit = value.unit;
    }
  }

  // bus - computed: false, optional: true, required: false
  private _bus?: number; 
  public get bus() {
    return this.getNumberAttribute('bus');
  }
  public set bus(value: number) {
    this._bus = value;
  }
  public resetBus() {
    this._bus = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get busInput() {
    return this._bus;
  }

  // controller - computed: false, optional: true, required: false
  private _controller?: number; 
  public get controller() {
    return this.getNumberAttribute('controller');
  }
  public set controller(value: number) {
    this._controller = value;
  }
  public resetController() {
    this._controller = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get controllerInput() {
    return this._controller;
  }

  // target - computed: false, optional: true, required: false
  private _target?: number; 
  public get target() {
    return this.getNumberAttribute('target');
  }
  public set target(value: number) {
    this._target = value;
  }
  public resetTarget() {
    this._target = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetInput() {
    return this._target;
  }

  // unit - computed: false, optional: true, required: false
  private _unit?: number; 
  public get unit() {
    return this.getNumberAttribute('unit');
  }
  public set unit(value: number) {
    this._unit = value;
  }
  public resetUnit() {
    this._unit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unitInput() {
    return this._unit;
  }
}
export interface DomainDevicesHostdevsSubsysScsiSourceHost {
  /**
  * Selects the host SCSI adapter that provides the target/LUN to be passed through to the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#adapter Domain#adapter}
  */
  readonly adapter?: DomainDevicesHostdevsSubsysScsiSourceHostAdapter;
  /**
  * Defines the SCSI address (bus, controller, target, unit) of the host-side device that is being passed through.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: DomainDevicesHostdevsSubsysScsiSourceHostAddress;
}

export function domainDevicesHostdevsSubsysScsiSourceHostToTerraform(struct?: DomainDevicesHostdevsSubsysScsiSourceHost | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    adapter: domainDevicesHostdevsSubsysScsiSourceHostAdapterToTerraform(struct!.adapter),
    address: domainDevicesHostdevsSubsysScsiSourceHostAddressToTerraform(struct!.address),
  }
}


export function domainDevicesHostdevsSubsysScsiSourceHostToHclTerraform(struct?: DomainDevicesHostdevsSubsysScsiSourceHost | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    adapter: {
      value: domainDevicesHostdevsSubsysScsiSourceHostAdapterToHclTerraform(struct!.adapter),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesHostdevsSubsysScsiSourceHostAdapter",
    },
    address: {
      value: domainDevicesHostdevsSubsysScsiSourceHostAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesHostdevsSubsysScsiSourceHostAddress",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesHostdevsSubsysScsiSourceHostOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesHostdevsSubsysScsiSourceHost | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._adapter?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.adapter = this._adapter?.internalValue;
    }
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHostdevsSubsysScsiSourceHost | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._adapter.internalValue = undefined;
      this._address.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._adapter.internalValue = value.adapter;
      this._address.internalValue = value.address;
    }
  }

  // adapter - computed: false, optional: true, required: false
  private _adapter = new DomainDevicesHostdevsSubsysScsiSourceHostAdapterOutputReference(this, "adapter");
  public get adapter() {
    return this._adapter;
  }
  public putAdapter(value: DomainDevicesHostdevsSubsysScsiSourceHostAdapter) {
    this._adapter.internalValue = value;
  }
  public resetAdapter() {
    this._adapter.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get adapterInput() {
    return this._adapter.internalValue;
  }

  // address - computed: false, optional: true, required: false
  private _address = new DomainDevicesHostdevsSubsysScsiSourceHostAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DomainDevicesHostdevsSubsysScsiSourceHostAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }
}
export interface DomainDevicesHostdevsSubsysScsiSourceIscsiAuthSecret {
  /**
  * Sets how the referenced secret is identified; typical values are user-provided strings such as "uuid" or "usage" depending on how the secret is looked up.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type?: string;
  /**
  * Sets the libvirt secret usage name when referencing the iSCSI auth secret by usage; the value is a user-provided identifier such as an iSCSI target name.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#usage Domain#usage}
  */
  readonly usage?: string;
}

export function domainDevicesHostdevsSubsysScsiSourceIscsiAuthSecretToTerraform(struct?: DomainDevicesHostdevsSubsysScsiSourceIscsiAuthSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    type: cdktf.stringToTerraform(struct!.type),
    usage: cdktf.stringToTerraform(struct!.usage),
  }
}


export function domainDevicesHostdevsSubsysScsiSourceIscsiAuthSecretToHclTerraform(struct?: DomainDevicesHostdevsSubsysScsiSourceIscsiAuthSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    usage: {
      value: cdktf.stringToHclTerraform(struct!.usage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesHostdevsSubsysScsiSourceIscsiAuthSecretOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesHostdevsSubsysScsiSourceIscsiAuthSecret | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._usage !== undefined) {
      hasAnyValues = true;
      internalValueResult.usage = this._usage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHostdevsSubsysScsiSourceIscsiAuthSecret | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._type = undefined;
      this._usage = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._type = value.type;
      this._usage = value.usage;
    }
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // usage - computed: false, optional: true, required: false
  private _usage?: string; 
  public get usage() {
    return this.getStringAttribute('usage');
  }
  public set usage(value: string) {
    this._usage = value;
  }
  public resetUsage() {
    this._usage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usageInput() {
    return this._usage;
  }

  // uuid - computed: true, optional: false, required: false
  public get uuid() {
    return this.getStringAttribute('uuid');
  }
}
export interface DomainDevicesHostdevsSubsysScsiSourceIscsiAuth {
  /**
  * Configures the libvirt secret object used to hold the iSCSI authentication password for this hostdev; this references an existing libvirt secret, not the clear-text secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#secret Domain#secret}
  */
  readonly secret?: DomainDevicesHostdevsSubsysScsiSourceIscsiAuthSecret;
  /**
  * Sets the CHAP username used when authenticating to the iSCSI target for this SCSI hostdev; the value is user-provided (for example, "chapuser1").
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#username Domain#username}
  */
  readonly username?: string;
}

export function domainDevicesHostdevsSubsysScsiSourceIscsiAuthToTerraform(struct?: DomainDevicesHostdevsSubsysScsiSourceIscsiAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret: domainDevicesHostdevsSubsysScsiSourceIscsiAuthSecretToTerraform(struct!.secret),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function domainDevicesHostdevsSubsysScsiSourceIscsiAuthToHclTerraform(struct?: DomainDevicesHostdevsSubsysScsiSourceIscsiAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret: {
      value: domainDevicesHostdevsSubsysScsiSourceIscsiAuthSecretToHclTerraform(struct!.secret),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesHostdevsSubsysScsiSourceIscsiAuthSecret",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesHostdevsSubsysScsiSourceIscsiAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesHostdevsSubsysScsiSourceIscsiAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secret?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret?.internalValue;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHostdevsSubsysScsiSourceIscsiAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secret.internalValue = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secret.internalValue = value.secret;
      this._username = value.username;
    }
  }

  // secret - computed: false, optional: true, required: false
  private _secret = new DomainDevicesHostdevsSubsysScsiSourceIscsiAuthSecretOutputReference(this, "secret");
  public get secret() {
    return this._secret;
  }
  public putSecret(value: DomainDevicesHostdevsSubsysScsiSourceIscsiAuthSecret) {
    this._secret.internalValue = value;
  }
  public resetSecret() {
    this._secret.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret.internalValue;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface DomainDevicesHostdevsSubsysScsiSourceIscsiHost {
  /**
  * Sets the hostname or IP address of the iSCSI target portal (for example, "10.0.0.10" or "iscsi.example.com").
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name?: string;
  /**
  * Sets the TCP port of the iSCSI target portal; if omitted, libvirt/driver defaults (commonly 3260) are used.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#port Domain#port}
  */
  readonly port?: string;
  /**
  * Sets a UNIX domain socket path to connect to an iSCSI target via a local socket instead of TCP; value is a user-provided filesystem path.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#socket Domain#socket}
  */
  readonly socket?: string;
  /**
  * Sets the transport type used to reach the iSCSI target portal; valid values are user-provided strings as supported by the environment (for example, "tcp" or "iser").
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#transport Domain#transport}
  */
  readonly transport?: string;
}

export function domainDevicesHostdevsSubsysScsiSourceIscsiHostToTerraform(struct?: DomainDevicesHostdevsSubsysScsiSourceIscsiHost | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    port: cdktf.stringToTerraform(struct!.port),
    socket: cdktf.stringToTerraform(struct!.socket),
    transport: cdktf.stringToTerraform(struct!.transport),
  }
}


export function domainDevicesHostdevsSubsysScsiSourceIscsiHostToHclTerraform(struct?: DomainDevicesHostdevsSubsysScsiSourceIscsiHost | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.stringToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    socket: {
      value: cdktf.stringToHclTerraform(struct!.socket),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    transport: {
      value: cdktf.stringToHclTerraform(struct!.transport),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesHostdevsSubsysScsiSourceIscsiHostOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesHostdevsSubsysScsiSourceIscsiHost | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._socket !== undefined) {
      hasAnyValues = true;
      internalValueResult.socket = this._socket;
    }
    if (this._transport !== undefined) {
      hasAnyValues = true;
      internalValueResult.transport = this._transport;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHostdevsSubsysScsiSourceIscsiHost | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._port = undefined;
      this._socket = undefined;
      this._transport = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._port = value.port;
      this._socket = value.socket;
      this._transport = value.transport;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port - computed: false, optional: true, required: false
  private _port?: string; 
  public get port() {
    return this.getStringAttribute('port');
  }
  public set port(value: string) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // socket - computed: false, optional: true, required: false
  private _socket?: string; 
  public get socket() {
    return this.getStringAttribute('socket');
  }
  public set socket(value: string) {
    this._socket = value;
  }
  public resetSocket() {
    this._socket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketInput() {
    return this._socket;
  }

  // transport - computed: false, optional: true, required: false
  private _transport?: string; 
  public get transport() {
    return this.getStringAttribute('transport');
  }
  public set transport(value: string) {
    this._transport = value;
  }
  public resetTransport() {
    this._transport = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get transportInput() {
    return this._transport;
  }
}

export class DomainDevicesHostdevsSubsysScsiSourceIscsiHostList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesHostdevsSubsysScsiSourceIscsiHost[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesHostdevsSubsysScsiSourceIscsiHostOutputReference {
    return new DomainDevicesHostdevsSubsysScsiSourceIscsiHostOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesHostdevsSubsysScsiSourceIscsiInitiatorIqn {
  /**
  * Sets the iSCSI initiator name (IQN string) used when logging into the target, such as "iqn.1994-05.com.redhat:client1".
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
}

export function domainDevicesHostdevsSubsysScsiSourceIscsiInitiatorIqnToTerraform(struct?: DomainDevicesHostdevsSubsysScsiSourceIscsiInitiatorIqn | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function domainDevicesHostdevsSubsysScsiSourceIscsiInitiatorIqnToHclTerraform(struct?: DomainDevicesHostdevsSubsysScsiSourceIscsiInitiatorIqn | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesHostdevsSubsysScsiSourceIscsiInitiatorIqnOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesHostdevsSubsysScsiSourceIscsiInitiatorIqn | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHostdevsSubsysScsiSourceIscsiInitiatorIqn | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DomainDevicesHostdevsSubsysScsiSourceIscsiInitiator {
  /**
  * Declares the initiator IQN block for the iSCSI connection; this must be present when specifying an explicit initiator.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#iqn Domain#iqn}
  */
  readonly iqn?: DomainDevicesHostdevsSubsysScsiSourceIscsiInitiatorIqn;
}

export function domainDevicesHostdevsSubsysScsiSourceIscsiInitiatorToTerraform(struct?: DomainDevicesHostdevsSubsysScsiSourceIscsiInitiator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    iqn: domainDevicesHostdevsSubsysScsiSourceIscsiInitiatorIqnToTerraform(struct!.iqn),
  }
}


export function domainDevicesHostdevsSubsysScsiSourceIscsiInitiatorToHclTerraform(struct?: DomainDevicesHostdevsSubsysScsiSourceIscsiInitiator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    iqn: {
      value: domainDevicesHostdevsSubsysScsiSourceIscsiInitiatorIqnToHclTerraform(struct!.iqn),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesHostdevsSubsysScsiSourceIscsiInitiatorIqn",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesHostdevsSubsysScsiSourceIscsiInitiatorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesHostdevsSubsysScsiSourceIscsiInitiator | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._iqn?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.iqn = this._iqn?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHostdevsSubsysScsiSourceIscsiInitiator | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._iqn.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._iqn.internalValue = value.iqn;
    }
  }

  // iqn - computed: false, optional: true, required: false
  private _iqn = new DomainDevicesHostdevsSubsysScsiSourceIscsiInitiatorIqnOutputReference(this, "iqn");
  public get iqn() {
    return this._iqn;
  }
  public putIqn(value: DomainDevicesHostdevsSubsysScsiSourceIscsiInitiatorIqn) {
    this._iqn.internalValue = value;
  }
  public resetIqn() {
    this._iqn.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get iqnInput() {
    return this._iqn.internalValue;
  }
}
export interface DomainDevicesHostdevsSubsysScsiSourceIscsi {
  /**
  * Configures CHAP authentication parameters for the iSCSI source backing an assigned SCSI host device; include this block only when the target requires authentication.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#auth Domain#auth}
  */
  readonly auth?: DomainDevicesHostdevsSubsysScsiSourceIscsiAuth;
  /**
  * Configures the iSCSI target portal settings (address and transport details) for the SCSI hostdevs backing device.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#host Domain#host}
  */
  readonly host?: DomainDevicesHostdevsSubsysScsiSourceIscsiHost[] | cdktf.IResolvable;
  /**
  * Configures iSCSI initiator information for the SCSI hostdev, including the initiator IQN used to identify the host.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#initiator Domain#initiator}
  */
  readonly initiator?: DomainDevicesHostdevsSubsysScsiSourceIscsiInitiator;
  /**
  * Sets the iSCSI target name (IQN or other target identifier) that provides the LUNs for this SCSI hostdev; for example, "iqn.2010-10.org.example:storage.lun1".
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
}

export function domainDevicesHostdevsSubsysScsiSourceIscsiToTerraform(struct?: DomainDevicesHostdevsSubsysScsiSourceIscsi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: domainDevicesHostdevsSubsysScsiSourceIscsiAuthToTerraform(struct!.auth),
    host: cdktf.listMapper(domainDevicesHostdevsSubsysScsiSourceIscsiHostToTerraform, false)(struct!.host),
    initiator: domainDevicesHostdevsSubsysScsiSourceIscsiInitiatorToTerraform(struct!.initiator),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function domainDevicesHostdevsSubsysScsiSourceIscsiToHclTerraform(struct?: DomainDevicesHostdevsSubsysScsiSourceIscsi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: domainDevicesHostdevsSubsysScsiSourceIscsiAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesHostdevsSubsysScsiSourceIscsiAuth",
    },
    host: {
      value: cdktf.listMapperHcl(domainDevicesHostdevsSubsysScsiSourceIscsiHostToHclTerraform, false)(struct!.host),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesHostdevsSubsysScsiSourceIscsiHostList",
    },
    initiator: {
      value: domainDevicesHostdevsSubsysScsiSourceIscsiInitiatorToHclTerraform(struct!.initiator),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesHostdevsSubsysScsiSourceIscsiInitiator",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesHostdevsSubsysScsiSourceIscsiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesHostdevsSubsysScsiSourceIscsi | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._host?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host?.internalValue;
    }
    if (this._initiator?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.initiator = this._initiator?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHostdevsSubsysScsiSourceIscsi | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._host.internalValue = undefined;
      this._initiator.internalValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._host.internalValue = value.host;
      this._initiator.internalValue = value.initiator;
      this._name = value.name;
    }
  }

  // auth - computed: false, optional: true, required: false
  private _auth = new DomainDevicesHostdevsSubsysScsiSourceIscsiAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DomainDevicesHostdevsSubsysScsiSourceIscsiAuth) {
    this._auth.internalValue = value;
  }
  public resetAuth() {
    this._auth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // host - computed: false, optional: true, required: false
  private _host = new DomainDevicesHostdevsSubsysScsiSourceIscsiHostList(this, "host", false);
  public get host() {
    return this._host;
  }
  public putHost(value: DomainDevicesHostdevsSubsysScsiSourceIscsiHost[] | cdktf.IResolvable) {
    this._host.internalValue = value;
  }
  public resetHost() {
    this._host.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host.internalValue;
  }

  // initiator - computed: false, optional: true, required: false
  private _initiator = new DomainDevicesHostdevsSubsysScsiSourceIscsiInitiatorOutputReference(this, "initiator");
  public get initiator() {
    return this._initiator;
  }
  public putInitiator(value: DomainDevicesHostdevsSubsysScsiSourceIscsiInitiator) {
    this._initiator.internalValue = value;
  }
  public resetInitiator() {
    this._initiator.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initiatorInput() {
    return this._initiator.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DomainDevicesHostdevsSubsysScsiSource {
  /**
  * Describes a host-side SCSI target used as the source for the SCSI hostdev, including adapter and SCSI address information.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#host Domain#host}
  */
  readonly host?: DomainDevicesHostdevsSubsysScsiSourceHost;
  /**
  * Defines an iSCSI-backed SCSI source for the hostdev, specifying that the passed-through SCSI device is provided by an iSCSI target; additional connection details are given in child elements or attributes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#iscsi Domain#iscsi}
  */
  readonly iscsi?: DomainDevicesHostdevsSubsysScsiSourceIscsi;
}

export function domainDevicesHostdevsSubsysScsiSourceToTerraform(struct?: DomainDevicesHostdevsSubsysScsiSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: domainDevicesHostdevsSubsysScsiSourceHostToTerraform(struct!.host),
    iscsi: domainDevicesHostdevsSubsysScsiSourceIscsiToTerraform(struct!.iscsi),
  }
}


export function domainDevicesHostdevsSubsysScsiSourceToHclTerraform(struct?: DomainDevicesHostdevsSubsysScsiSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: domainDevicesHostdevsSubsysScsiSourceHostToHclTerraform(struct!.host),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesHostdevsSubsysScsiSourceHost",
    },
    iscsi: {
      value: domainDevicesHostdevsSubsysScsiSourceIscsiToHclTerraform(struct!.iscsi),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesHostdevsSubsysScsiSourceIscsi",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesHostdevsSubsysScsiSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesHostdevsSubsysScsiSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host?.internalValue;
    }
    if (this._iscsi?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.iscsi = this._iscsi?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHostdevsSubsysScsiSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host.internalValue = undefined;
      this._iscsi.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host.internalValue = value.host;
      this._iscsi.internalValue = value.iscsi;
    }
  }

  // host - computed: false, optional: true, required: false
  private _host = new DomainDevicesHostdevsSubsysScsiSourceHostOutputReference(this, "host");
  public get host() {
    return this._host;
  }
  public putHost(value: DomainDevicesHostdevsSubsysScsiSourceHost) {
    this._host.internalValue = value;
  }
  public resetHost() {
    this._host.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host.internalValue;
  }

  // iscsi - computed: false, optional: true, required: false
  private _iscsi = new DomainDevicesHostdevsSubsysScsiSourceIscsiOutputReference(this, "iscsi");
  public get iscsi() {
    return this._iscsi;
  }
  public putIscsi(value: DomainDevicesHostdevsSubsysScsiSourceIscsi) {
    this._iscsi.internalValue = value;
  }
  public resetIscsi() {
    this._iscsi.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get iscsiInput() {
    return this._iscsi.internalValue;
  }
}
export interface DomainDevicesHostdevsSubsysScsi {
  /**
  * Controls whether raw I/O is allowed for the SCSI hostdev, typically using a yes/no style value as supported by libvirt (for example "yes" or "no").
  * 
  * See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#raw_io Domain#raw_io}
  */
  readonly rawIo?: string;
  /**
  * Marks the SCSI hostdev as read-only when true by emitting the readonly element; when false or unset, the device is writable and the element is omitted.
  * 
  * See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#read_only Domain#read_only}
  */
  readonly readOnly?: boolean | cdktf.IResolvable;
  /**
  * Sets the SG_IO policy for the SCSI hostdev (e.g. allowing or restricting SG_IO commands), using user-provided values supported by libvirt such as "filtered" or "unfiltered".
  * 
  * See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sgio Domain#sgio}
  */
  readonly sgio?: string;
  /**
  * Marks the SCSI hostdev as shareable between multiple guests when true by emitting the shareable element; when false or unset, the device is treated as exclusively owned and the element is omitted.
  * 
  * See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#shareable Domain#shareable}
  */
  readonly shareable?: boolean | cdktf.IResolvable;
  /**
  * Defines the source characteristics of the SCSI host device to passthrough, such as host adapter, SCSI address, or iSCSI parameters.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#source Domain#source}
  */
  readonly source?: DomainDevicesHostdevsSubsysScsiSource;
}

export function domainDevicesHostdevsSubsysScsiToTerraform(struct?: DomainDevicesHostdevsSubsysScsi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    raw_io: cdktf.stringToTerraform(struct!.rawIo),
    read_only: cdktf.booleanToTerraform(struct!.readOnly),
    sgio: cdktf.stringToTerraform(struct!.sgio),
    shareable: cdktf.booleanToTerraform(struct!.shareable),
    source: domainDevicesHostdevsSubsysScsiSourceToTerraform(struct!.source),
  }
}


export function domainDevicesHostdevsSubsysScsiToHclTerraform(struct?: DomainDevicesHostdevsSubsysScsi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    raw_io: {
      value: cdktf.stringToHclTerraform(struct!.rawIo),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    read_only: {
      value: cdktf.booleanToHclTerraform(struct!.readOnly),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    sgio: {
      value: cdktf.stringToHclTerraform(struct!.sgio),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    shareable: {
      value: cdktf.booleanToHclTerraform(struct!.shareable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    source: {
      value: domainDevicesHostdevsSubsysScsiSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesHostdevsSubsysScsiSource",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesHostdevsSubsysScsiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesHostdevsSubsysScsi | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._rawIo !== undefined) {
      hasAnyValues = true;
      internalValueResult.rawIo = this._rawIo;
    }
    if (this._readOnly !== undefined) {
      hasAnyValues = true;
      internalValueResult.readOnly = this._readOnly;
    }
    if (this._sgio !== undefined) {
      hasAnyValues = true;
      internalValueResult.sgio = this._sgio;
    }
    if (this._shareable !== undefined) {
      hasAnyValues = true;
      internalValueResult.shareable = this._shareable;
    }
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHostdevsSubsysScsi | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._rawIo = undefined;
      this._readOnly = undefined;
      this._sgio = undefined;
      this._shareable = undefined;
      this._source.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._rawIo = value.rawIo;
      this._readOnly = value.readOnly;
      this._sgio = value.sgio;
      this._shareable = value.shareable;
      this._source.internalValue = value.source;
    }
  }

  // raw_io - computed: false, optional: true, required: false
  private _rawIo?: string; 
  public get rawIo() {
    return this.getStringAttribute('raw_io');
  }
  public set rawIo(value: string) {
    this._rawIo = value;
  }
  public resetRawIo() {
    this._rawIo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rawIoInput() {
    return this._rawIo;
  }

  // read_only - computed: false, optional: true, required: false
  private _readOnly?: boolean | cdktf.IResolvable; 
  public get readOnly() {
    return this.getBooleanAttribute('read_only');
  }
  public set readOnly(value: boolean | cdktf.IResolvable) {
    this._readOnly = value;
  }
  public resetReadOnly() {
    this._readOnly = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readOnlyInput() {
    return this._readOnly;
  }

  // sgio - computed: false, optional: true, required: false
  private _sgio?: string; 
  public get sgio() {
    return this.getStringAttribute('sgio');
  }
  public set sgio(value: string) {
    this._sgio = value;
  }
  public resetSgio() {
    this._sgio = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sgioInput() {
    return this._sgio;
  }

  // shareable - computed: false, optional: true, required: false
  private _shareable?: boolean | cdktf.IResolvable; 
  public get shareable() {
    return this.getBooleanAttribute('shareable');
  }
  public set shareable(value: boolean | cdktf.IResolvable) {
    this._shareable = value;
  }
  public resetShareable() {
    this._shareable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shareableInput() {
    return this._shareable;
  }

  // source - computed: false, optional: true, required: false
  private _source = new DomainDevicesHostdevsSubsysScsiSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: DomainDevicesHostdevsSubsysScsiSource) {
    this._source.internalValue = value;
  }
  public resetSource() {
    this._source.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }
}
export interface DomainDevicesHostdevsSubsysScsiHostSource {
  /**
  * Sets the transport protocol used by the SCSI host adapter source (for example, "fc" for Fibre Channel); the value is user-provided and must be supported by the host.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#protocol Domain#protocol}
  */
  readonly protocol?: string;
  /**
  * Sets the World Wide Port Name (WWPN) of the SCSI/Fibre Channel host adapter source as a user-provided string, typically a 16hexdigit identifier like "5005076801401b3f".
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#wwpn Domain#wwpn}
  */
  readonly wwpn?: string;
}

export function domainDevicesHostdevsSubsysScsiHostSourceToTerraform(struct?: DomainDevicesHostdevsSubsysScsiHostSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    protocol: cdktf.stringToTerraform(struct!.protocol),
    wwpn: cdktf.stringToTerraform(struct!.wwpn),
  }
}


export function domainDevicesHostdevsSubsysScsiHostSourceToHclTerraform(struct?: DomainDevicesHostdevsSubsysScsiHostSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    wwpn: {
      value: cdktf.stringToHclTerraform(struct!.wwpn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesHostdevsSubsysScsiHostSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesHostdevsSubsysScsiHostSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._wwpn !== undefined) {
      hasAnyValues = true;
      internalValueResult.wwpn = this._wwpn;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHostdevsSubsysScsiHostSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._protocol = undefined;
      this._wwpn = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._protocol = value.protocol;
      this._wwpn = value.wwpn;
    }
  }

  // protocol - computed: false, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // wwpn - computed: false, optional: true, required: false
  private _wwpn?: string; 
  public get wwpn() {
    return this.getStringAttribute('wwpn');
  }
  public set wwpn(value: string) {
    this._wwpn = value;
  }
  public resetWwpn() {
    this._wwpn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get wwpnInput() {
    return this._wwpn;
  }
}
export interface DomainDevicesHostdevsSubsysScsiHost {
  /**
  * Sets the model of SCSI host adapter to present to the guest for this hostdev; the value is user-provided and must match a model supported by the hypervisor backend.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Defines the source characteristics of the SCSI host adapter passthrough, such as protocol and WWPN.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#source Domain#source}
  */
  readonly source?: DomainDevicesHostdevsSubsysScsiHostSource;
}

export function domainDevicesHostdevsSubsysScsiHostToTerraform(struct?: DomainDevicesHostdevsSubsysScsiHost | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    model: cdktf.stringToTerraform(struct!.model),
    source: domainDevicesHostdevsSubsysScsiHostSourceToTerraform(struct!.source),
  }
}


export function domainDevicesHostdevsSubsysScsiHostToHclTerraform(struct?: DomainDevicesHostdevsSubsysScsiHost | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    source: {
      value: domainDevicesHostdevsSubsysScsiHostSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesHostdevsSubsysScsiHostSource",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesHostdevsSubsysScsiHostOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesHostdevsSubsysScsiHost | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHostdevsSubsysScsiHost | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._model = undefined;
      this._source.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._model = value.model;
      this._source.internalValue = value.source;
    }
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // source - computed: false, optional: true, required: false
  private _source = new DomainDevicesHostdevsSubsysScsiHostSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: DomainDevicesHostdevsSubsysScsiHostSource) {
    this._source.internalValue = value;
  }
  public resetSource() {
    this._source.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }
}
export interface DomainDevicesHostdevsSubsysUsbSourceAddress {
  /**
  * Sets the numeric USB bus on the host where the device is attached; value is user-provided as reported by tools like `lsusb` (for example, `1`).
  * 
  * See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bus Domain#bus}
  */
  readonly bus?: number;
  /**
  * Sets the numeric USB device number on the selected bus; value is user-provided based on host enumeration (for example, `2`).
  * 
  * See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#device Domain#device}
  */
  readonly device?: number;
  /**
  * Sets the USB port path on the host (often a dotseparated string like `1` or `1.2`) to identify the device by its hub/port topology.
  * 
  * See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#port Domain#port}
  */
  readonly port?: string;
}

export function domainDevicesHostdevsSubsysUsbSourceAddressToTerraform(struct?: DomainDevicesHostdevsSubsysUsbSourceAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bus: cdktf.numberToTerraform(struct!.bus),
    device: cdktf.numberToTerraform(struct!.device),
    port: cdktf.stringToTerraform(struct!.port),
  }
}


export function domainDevicesHostdevsSubsysUsbSourceAddressToHclTerraform(struct?: DomainDevicesHostdevsSubsysUsbSourceAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bus: {
      value: cdktf.numberToHclTerraform(struct!.bus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    device: {
      value: cdktf.numberToHclTerraform(struct!.device),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port: {
      value: cdktf.stringToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesHostdevsSubsysUsbSourceAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesHostdevsSubsysUsbSourceAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bus !== undefined) {
      hasAnyValues = true;
      internalValueResult.bus = this._bus;
    }
    if (this._device !== undefined) {
      hasAnyValues = true;
      internalValueResult.device = this._device;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHostdevsSubsysUsbSourceAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bus = undefined;
      this._device = undefined;
      this._port = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bus = value.bus;
      this._device = value.device;
      this._port = value.port;
    }
  }

  // bus - computed: false, optional: true, required: false
  private _bus?: number; 
  public get bus() {
    return this.getNumberAttribute('bus');
  }
  public set bus(value: number) {
    this._bus = value;
  }
  public resetBus() {
    this._bus = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get busInput() {
    return this._bus;
  }

  // device - computed: false, optional: true, required: false
  private _device?: number; 
  public get device() {
    return this.getNumberAttribute('device');
  }
  public set device(value: number) {
    this._device = value;
  }
  public resetDevice() {
    this._device = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deviceInput() {
    return this._device;
  }

  // port - computed: false, optional: true, required: false
  private _port?: string; 
  public get port() {
    return this.getStringAttribute('port');
  }
  public set port(value: string) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }
}
export interface DomainDevicesHostdevsSubsysUsbSourceProduct {
}

export function domainDevicesHostdevsSubsysUsbSourceProductToTerraform(struct?: DomainDevicesHostdevsSubsysUsbSourceProduct | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function domainDevicesHostdevsSubsysUsbSourceProductToHclTerraform(struct?: DomainDevicesHostdevsSubsysUsbSourceProduct | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DomainDevicesHostdevsSubsysUsbSourceProductOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesHostdevsSubsysUsbSourceProduct | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHostdevsSubsysUsbSourceProduct | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }

  // id - computed: true, optional: false, required: false
  public get id() {
    return this.getStringAttribute('id');
  }
}
export interface DomainDevicesHostdevsSubsysUsbSourceVendor {
}

export function domainDevicesHostdevsSubsysUsbSourceVendorToTerraform(struct?: DomainDevicesHostdevsSubsysUsbSourceVendor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function domainDevicesHostdevsSubsysUsbSourceVendorToHclTerraform(struct?: DomainDevicesHostdevsSubsysUsbSourceVendor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DomainDevicesHostdevsSubsysUsbSourceVendorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesHostdevsSubsysUsbSourceVendor | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHostdevsSubsysUsbSourceVendor | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }

  // id - computed: true, optional: false, required: false
  public get id() {
    return this.getStringAttribute('id');
  }
}
export interface DomainDevicesHostdevsSubsysUsbSource {
  /**
  * Specifies the physical USB topology of the host device (bus, device, and/or port) used to select which USB device is passed through.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: DomainDevicesHostdevsSubsysUsbSourceAddress;
  /**
  * Controls whether a reset is issued to the USB device when it is assigned or re-assigned to the guest; value is user-provided (typically `on`/`off` or `yes`/`no` depending on libvirt version).
  * 
  * See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#guest_reset Domain#guest_reset}
  */
  readonly guestReset?: string;
  /**
  * Selects a USB device for passthrough by its vendor ID, typically used together with `source.product`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#product Domain#product}
  */
  readonly product?: DomainDevicesHostdevsSubsysUsbSourceProduct;
  /**
  * Sets how strictly libvirt enforces the presence of the USB device at startup; accepts values like `mandatory`, `requisite`, or `optional` depending on libvirt support.
  * 
  * See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#start_up_policy Domain#start_up_policy}
  */
  readonly startUpPolicy?: string;
  /**
  * Selects a USB device for passthrough by its vendor ID, typically used together with `source.product`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vendor Domain#vendor}
  */
  readonly vendor?: DomainDevicesHostdevsSubsysUsbSourceVendor;
}

export function domainDevicesHostdevsSubsysUsbSourceToTerraform(struct?: DomainDevicesHostdevsSubsysUsbSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: domainDevicesHostdevsSubsysUsbSourceAddressToTerraform(struct!.address),
    guest_reset: cdktf.stringToTerraform(struct!.guestReset),
    product: domainDevicesHostdevsSubsysUsbSourceProductToTerraform(struct!.product),
    start_up_policy: cdktf.stringToTerraform(struct!.startUpPolicy),
    vendor: domainDevicesHostdevsSubsysUsbSourceVendorToTerraform(struct!.vendor),
  }
}


export function domainDevicesHostdevsSubsysUsbSourceToHclTerraform(struct?: DomainDevicesHostdevsSubsysUsbSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: domainDevicesHostdevsSubsysUsbSourceAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesHostdevsSubsysUsbSourceAddress",
    },
    guest_reset: {
      value: cdktf.stringToHclTerraform(struct!.guestReset),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    product: {
      value: domainDevicesHostdevsSubsysUsbSourceProductToHclTerraform(struct!.product),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesHostdevsSubsysUsbSourceProduct",
    },
    start_up_policy: {
      value: cdktf.stringToHclTerraform(struct!.startUpPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    vendor: {
      value: domainDevicesHostdevsSubsysUsbSourceVendorToHclTerraform(struct!.vendor),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesHostdevsSubsysUsbSourceVendor",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesHostdevsSubsysUsbSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesHostdevsSubsysUsbSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._guestReset !== undefined) {
      hasAnyValues = true;
      internalValueResult.guestReset = this._guestReset;
    }
    if (this._product?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.product = this._product?.internalValue;
    }
    if (this._startUpPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.startUpPolicy = this._startUpPolicy;
    }
    if (this._vendor?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.vendor = this._vendor?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHostdevsSubsysUsbSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._guestReset = undefined;
      this._product.internalValue = undefined;
      this._startUpPolicy = undefined;
      this._vendor.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._guestReset = value.guestReset;
      this._product.internalValue = value.product;
      this._startUpPolicy = value.startUpPolicy;
      this._vendor.internalValue = value.vendor;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address = new DomainDevicesHostdevsSubsysUsbSourceAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DomainDevicesHostdevsSubsysUsbSourceAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // guest_reset - computed: false, optional: true, required: false
  private _guestReset?: string; 
  public get guestReset() {
    return this.getStringAttribute('guest_reset');
  }
  public set guestReset(value: string) {
    this._guestReset = value;
  }
  public resetGuestReset() {
    this._guestReset = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get guestResetInput() {
    return this._guestReset;
  }

  // product - computed: false, optional: true, required: false
  private _product = new DomainDevicesHostdevsSubsysUsbSourceProductOutputReference(this, "product");
  public get product() {
    return this._product;
  }
  public putProduct(value: DomainDevicesHostdevsSubsysUsbSourceProduct) {
    this._product.internalValue = value;
  }
  public resetProduct() {
    this._product.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get productInput() {
    return this._product.internalValue;
  }

  // start_up_policy - computed: false, optional: true, required: false
  private _startUpPolicy?: string; 
  public get startUpPolicy() {
    return this.getStringAttribute('start_up_policy');
  }
  public set startUpPolicy(value: string) {
    this._startUpPolicy = value;
  }
  public resetStartUpPolicy() {
    this._startUpPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get startUpPolicyInput() {
    return this._startUpPolicy;
  }

  // vendor - computed: false, optional: true, required: false
  private _vendor = new DomainDevicesHostdevsSubsysUsbSourceVendorOutputReference(this, "vendor");
  public get vendor() {
    return this._vendor;
  }
  public putVendor(value: DomainDevicesHostdevsSubsysUsbSourceVendor) {
    this._vendor.internalValue = value;
  }
  public resetVendor() {
    this._vendor.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vendorInput() {
    return this._vendor.internalValue;
  }
}
export interface DomainDevicesHostdevsSubsysUsb {
  /**
  * Sets how the USB host device is identified for passthrough, either by topology (bus/port) or by vendor/product IDs and related options.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#source Domain#source}
  */
  readonly source?: DomainDevicesHostdevsSubsysUsbSource;
}

export function domainDevicesHostdevsSubsysUsbToTerraform(struct?: DomainDevicesHostdevsSubsysUsb | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    source: domainDevicesHostdevsSubsysUsbSourceToTerraform(struct!.source),
  }
}


export function domainDevicesHostdevsSubsysUsbToHclTerraform(struct?: DomainDevicesHostdevsSubsysUsb | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    source: {
      value: domainDevicesHostdevsSubsysUsbSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesHostdevsSubsysUsbSource",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesHostdevsSubsysUsbOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesHostdevsSubsysUsb | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHostdevsSubsysUsb | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._source.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._source.internalValue = value.source;
    }
  }

  // source - computed: false, optional: true, required: false
  private _source = new DomainDevicesHostdevsSubsysUsbSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: DomainDevicesHostdevsSubsysUsbSource) {
    this._source.internalValue = value;
  }
  public resetSource() {
    this._source.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }
}
export interface DomainDevicesHostdevs {
  /**
  * Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#acpi Domain#acpi}
  */
  readonly acpi?: DomainDevicesHostdevsAcpi;
  /**
  * Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: DomainDevicesHostdevsAddress;
  /**
  * Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#alias Domain#alias}
  */
  readonly alias?: DomainDevicesHostdevsAlias;
  /**
  * Enables boot-order control for this redirected device, allowing it to participate in the device boot sequence.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#boot Domain#boot}
  */
  readonly boot?: DomainDevicesHostdevsBoot;
  /**
  * Enables miscellaneous capability-specific configuration for the host device, used for device types that expose extra capabilities not covered by other elements.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#caps_misc Domain#caps_misc}
  */
  readonly capsMisc?: DomainDevicesHostdevsCapsMisc;
  /**
  * Enables network-related capability configuration for the host device, typically for host NICs or VF-based network passthrough with extra capabilities.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#caps_net Domain#caps_net}
  */
  readonly capsNet?: DomainDevicesHostdevsCapsNet;
  /**
  * Configures storage-related capabilities for a passthrough host device, such as its backing block source.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#caps_storage Domain#caps_storage}
  */
  readonly capsStorage?: DomainDevicesHostdevsCapsStorage;
  /**
  * Controls whether libvirt manages detaching and reattaching the host device driver, as a string boolean where "yes" enables management and "no" disables it.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#managed Domain#managed}
  */
  readonly managed?: boolean | cdktf.IResolvable;
  /**
  * Configures an optional PCI ROM image for the passthrough host device, including whether it is enabled, where it is mapped, and an alternate ROM file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#rom Domain#rom}
  */
  readonly rom?: DomainDevicesHostdevsRom;
  /**
  * Configures mediated device (mdev)specific settings for a passthrough host device, such as display handling for a vGPU.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#subsys_m_dev Domain#subsys_m_dev}
  */
  readonly subsysMDev?: DomainDevicesHostdevsSubsysMDev;
  /**
  * Selects PCI as the host device subsystem type and groups all PCI-specific passthrough settings for this hostdev.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#subsys_pci Domain#subsys_pci}
  */
  readonly subsysPci?: DomainDevicesHostdevsSubsysPci;
  /**
  * Configures a host SCSI device (or LUN) to be passed through to the guest using a SCSI hostdev subsystem.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#subsys_scsi Domain#subsys_scsi}
  */
  readonly subsysScsi?: DomainDevicesHostdevsSubsysScsi;
  /**
  * Configures a SCSI host adapterstyle host device passthrough (SubsysSCSIHost) to the guest, rather than an individual LUN.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#subsys_scsi_host Domain#subsys_scsi_host}
  */
  readonly subsysScsiHost?: DomainDevicesHostdevsSubsysScsiHost;
  /**
  * Configures a host USB device passthrough entry for the guest, corresponding to a `<hostdev>` with USB subsystem-specific settings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#subsys_usb Domain#subsys_usb}
  */
  readonly subsysUsb?: DomainDevicesHostdevsSubsysUsb;
}

export function domainDevicesHostdevsToTerraform(struct?: DomainDevicesHostdevs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    acpi: domainDevicesHostdevsAcpiToTerraform(struct!.acpi),
    address: domainDevicesHostdevsAddressToTerraform(struct!.address),
    alias: domainDevicesHostdevsAliasToTerraform(struct!.alias),
    boot: domainDevicesHostdevsBootToTerraform(struct!.boot),
    caps_misc: domainDevicesHostdevsCapsMiscToTerraform(struct!.capsMisc),
    caps_net: domainDevicesHostdevsCapsNetToTerraform(struct!.capsNet),
    caps_storage: domainDevicesHostdevsCapsStorageToTerraform(struct!.capsStorage),
    managed: cdktf.booleanToTerraform(struct!.managed),
    rom: domainDevicesHostdevsRomToTerraform(struct!.rom),
    subsys_m_dev: domainDevicesHostdevsSubsysMDevToTerraform(struct!.subsysMDev),
    subsys_pci: domainDevicesHostdevsSubsysPciToTerraform(struct!.subsysPci),
    subsys_scsi: domainDevicesHostdevsSubsysScsiToTerraform(struct!.subsysScsi),
    subsys_scsi_host: domainDevicesHostdevsSubsysScsiHostToTerraform(struct!.subsysScsiHost),
    subsys_usb: domainDevicesHostdevsSubsysUsbToTerraform(struct!.subsysUsb),
  }
}


export function domainDevicesHostdevsToHclTerraform(struct?: DomainDevicesHostdevs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    acpi: {
      value: domainDevicesHostdevsAcpiToHclTerraform(struct!.acpi),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesHostdevsAcpi",
    },
    address: {
      value: domainDevicesHostdevsAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesHostdevsAddress",
    },
    alias: {
      value: domainDevicesHostdevsAliasToHclTerraform(struct!.alias),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesHostdevsAlias",
    },
    boot: {
      value: domainDevicesHostdevsBootToHclTerraform(struct!.boot),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesHostdevsBoot",
    },
    caps_misc: {
      value: domainDevicesHostdevsCapsMiscToHclTerraform(struct!.capsMisc),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesHostdevsCapsMisc",
    },
    caps_net: {
      value: domainDevicesHostdevsCapsNetToHclTerraform(struct!.capsNet),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesHostdevsCapsNet",
    },
    caps_storage: {
      value: domainDevicesHostdevsCapsStorageToHclTerraform(struct!.capsStorage),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesHostdevsCapsStorage",
    },
    managed: {
      value: cdktf.booleanToHclTerraform(struct!.managed),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    rom: {
      value: domainDevicesHostdevsRomToHclTerraform(struct!.rom),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesHostdevsRom",
    },
    subsys_m_dev: {
      value: domainDevicesHostdevsSubsysMDevToHclTerraform(struct!.subsysMDev),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesHostdevsSubsysMDev",
    },
    subsys_pci: {
      value: domainDevicesHostdevsSubsysPciToHclTerraform(struct!.subsysPci),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesHostdevsSubsysPci",
    },
    subsys_scsi: {
      value: domainDevicesHostdevsSubsysScsiToHclTerraform(struct!.subsysScsi),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesHostdevsSubsysScsi",
    },
    subsys_scsi_host: {
      value: domainDevicesHostdevsSubsysScsiHostToHclTerraform(struct!.subsysScsiHost),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesHostdevsSubsysScsiHost",
    },
    subsys_usb: {
      value: domainDevicesHostdevsSubsysUsbToHclTerraform(struct!.subsysUsb),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesHostdevsSubsysUsb",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesHostdevsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesHostdevs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._acpi?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.acpi = this._acpi?.internalValue;
    }
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._alias?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.alias = this._alias?.internalValue;
    }
    if (this._boot?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.boot = this._boot?.internalValue;
    }
    if (this._capsMisc?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.capsMisc = this._capsMisc?.internalValue;
    }
    if (this._capsNet?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.capsNet = this._capsNet?.internalValue;
    }
    if (this._capsStorage?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.capsStorage = this._capsStorage?.internalValue;
    }
    if (this._managed !== undefined) {
      hasAnyValues = true;
      internalValueResult.managed = this._managed;
    }
    if (this._rom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rom = this._rom?.internalValue;
    }
    if (this._subsysMDev?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.subsysMDev = this._subsysMDev?.internalValue;
    }
    if (this._subsysPci?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.subsysPci = this._subsysPci?.internalValue;
    }
    if (this._subsysScsi?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.subsysScsi = this._subsysScsi?.internalValue;
    }
    if (this._subsysScsiHost?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.subsysScsiHost = this._subsysScsiHost?.internalValue;
    }
    if (this._subsysUsb?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.subsysUsb = this._subsysUsb?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHostdevs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._acpi.internalValue = undefined;
      this._address.internalValue = undefined;
      this._alias.internalValue = undefined;
      this._boot.internalValue = undefined;
      this._capsMisc.internalValue = undefined;
      this._capsNet.internalValue = undefined;
      this._capsStorage.internalValue = undefined;
      this._managed = undefined;
      this._rom.internalValue = undefined;
      this._subsysMDev.internalValue = undefined;
      this._subsysPci.internalValue = undefined;
      this._subsysScsi.internalValue = undefined;
      this._subsysScsiHost.internalValue = undefined;
      this._subsysUsb.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._acpi.internalValue = value.acpi;
      this._address.internalValue = value.address;
      this._alias.internalValue = value.alias;
      this._boot.internalValue = value.boot;
      this._capsMisc.internalValue = value.capsMisc;
      this._capsNet.internalValue = value.capsNet;
      this._capsStorage.internalValue = value.capsStorage;
      this._managed = value.managed;
      this._rom.internalValue = value.rom;
      this._subsysMDev.internalValue = value.subsysMDev;
      this._subsysPci.internalValue = value.subsysPci;
      this._subsysScsi.internalValue = value.subsysScsi;
      this._subsysScsiHost.internalValue = value.subsysScsiHost;
      this._subsysUsb.internalValue = value.subsysUsb;
    }
  }

  // acpi - computed: false, optional: true, required: false
  private _acpi = new DomainDevicesHostdevsAcpiOutputReference(this, "acpi");
  public get acpi() {
    return this._acpi;
  }
  public putAcpi(value: DomainDevicesHostdevsAcpi) {
    this._acpi.internalValue = value;
  }
  public resetAcpi() {
    this._acpi.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get acpiInput() {
    return this._acpi.internalValue;
  }

  // address - computed: false, optional: true, required: false
  private _address = new DomainDevicesHostdevsAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DomainDevicesHostdevsAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // alias - computed: false, optional: true, required: false
  private _alias = new DomainDevicesHostdevsAliasOutputReference(this, "alias");
  public get alias() {
    return this._alias;
  }
  public putAlias(value: DomainDevicesHostdevsAlias) {
    this._alias.internalValue = value;
  }
  public resetAlias() {
    this._alias.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aliasInput() {
    return this._alias.internalValue;
  }

  // boot - computed: false, optional: true, required: false
  private _boot = new DomainDevicesHostdevsBootOutputReference(this, "boot");
  public get boot() {
    return this._boot;
  }
  public putBoot(value: DomainDevicesHostdevsBoot) {
    this._boot.internalValue = value;
  }
  public resetBoot() {
    this._boot.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bootInput() {
    return this._boot.internalValue;
  }

  // caps_misc - computed: false, optional: true, required: false
  private _capsMisc = new DomainDevicesHostdevsCapsMiscOutputReference(this, "caps_misc");
  public get capsMisc() {
    return this._capsMisc;
  }
  public putCapsMisc(value: DomainDevicesHostdevsCapsMisc) {
    this._capsMisc.internalValue = value;
  }
  public resetCapsMisc() {
    this._capsMisc.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get capsMiscInput() {
    return this._capsMisc.internalValue;
  }

  // caps_net - computed: false, optional: true, required: false
  private _capsNet = new DomainDevicesHostdevsCapsNetOutputReference(this, "caps_net");
  public get capsNet() {
    return this._capsNet;
  }
  public putCapsNet(value: DomainDevicesHostdevsCapsNet) {
    this._capsNet.internalValue = value;
  }
  public resetCapsNet() {
    this._capsNet.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get capsNetInput() {
    return this._capsNet.internalValue;
  }

  // caps_storage - computed: false, optional: true, required: false
  private _capsStorage = new DomainDevicesHostdevsCapsStorageOutputReference(this, "caps_storage");
  public get capsStorage() {
    return this._capsStorage;
  }
  public putCapsStorage(value: DomainDevicesHostdevsCapsStorage) {
    this._capsStorage.internalValue = value;
  }
  public resetCapsStorage() {
    this._capsStorage.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get capsStorageInput() {
    return this._capsStorage.internalValue;
  }

  // managed - computed: false, optional: true, required: false
  private _managed?: boolean | cdktf.IResolvable; 
  public get managed() {
    return this.getBooleanAttribute('managed');
  }
  public set managed(value: boolean | cdktf.IResolvable) {
    this._managed = value;
  }
  public resetManaged() {
    this._managed = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get managedInput() {
    return this._managed;
  }

  // rom - computed: false, optional: true, required: false
  private _rom = new DomainDevicesHostdevsRomOutputReference(this, "rom");
  public get rom() {
    return this._rom;
  }
  public putRom(value: DomainDevicesHostdevsRom) {
    this._rom.internalValue = value;
  }
  public resetRom() {
    this._rom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get romInput() {
    return this._rom.internalValue;
  }

  // subsys_m_dev - computed: false, optional: true, required: false
  private _subsysMDev = new DomainDevicesHostdevsSubsysMDevOutputReference(this, "subsys_m_dev");
  public get subsysMDev() {
    return this._subsysMDev;
  }
  public putSubsysMDev(value: DomainDevicesHostdevsSubsysMDev) {
    this._subsysMDev.internalValue = value;
  }
  public resetSubsysMDev() {
    this._subsysMDev.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subsysMDevInput() {
    return this._subsysMDev.internalValue;
  }

  // subsys_pci - computed: false, optional: true, required: false
  private _subsysPci = new DomainDevicesHostdevsSubsysPciOutputReference(this, "subsys_pci");
  public get subsysPci() {
    return this._subsysPci;
  }
  public putSubsysPci(value: DomainDevicesHostdevsSubsysPci) {
    this._subsysPci.internalValue = value;
  }
  public resetSubsysPci() {
    this._subsysPci.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subsysPciInput() {
    return this._subsysPci.internalValue;
  }

  // subsys_scsi - computed: false, optional: true, required: false
  private _subsysScsi = new DomainDevicesHostdevsSubsysScsiOutputReference(this, "subsys_scsi");
  public get subsysScsi() {
    return this._subsysScsi;
  }
  public putSubsysScsi(value: DomainDevicesHostdevsSubsysScsi) {
    this._subsysScsi.internalValue = value;
  }
  public resetSubsysScsi() {
    this._subsysScsi.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subsysScsiInput() {
    return this._subsysScsi.internalValue;
  }

  // subsys_scsi_host - computed: false, optional: true, required: false
  private _subsysScsiHost = new DomainDevicesHostdevsSubsysScsiHostOutputReference(this, "subsys_scsi_host");
  public get subsysScsiHost() {
    return this._subsysScsiHost;
  }
  public putSubsysScsiHost(value: DomainDevicesHostdevsSubsysScsiHost) {
    this._subsysScsiHost.internalValue = value;
  }
  public resetSubsysScsiHost() {
    this._subsysScsiHost.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subsysScsiHostInput() {
    return this._subsysScsiHost.internalValue;
  }

  // subsys_usb - computed: false, optional: true, required: false
  private _subsysUsb = new DomainDevicesHostdevsSubsysUsbOutputReference(this, "subsys_usb");
  public get subsysUsb() {
    return this._subsysUsb;
  }
  public putSubsysUsb(value: DomainDevicesHostdevsSubsysUsb) {
    this._subsysUsb.internalValue = value;
  }
  public resetSubsysUsb() {
    this._subsysUsb.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subsysUsbInput() {
    return this._subsysUsb.internalValue;
  }
}

export class DomainDevicesHostdevsList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesHostdevs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesHostdevsOutputReference {
    return new DomainDevicesHostdevsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesHubsAcpi {
  /**
  * Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#pstore>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#index Domain#index}
  */
  readonly index?: number;
}

export function domainDevicesHubsAcpiToTerraform(struct?: DomainDevicesHubsAcpi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    index: cdktf.numberToTerraform(struct!.index),
  }
}


export function domainDevicesHubsAcpiToHclTerraform(struct?: DomainDevicesHubsAcpi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    index: {
      value: cdktf.numberToHclTerraform(struct!.index),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesHubsAcpiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesHubsAcpi | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._index !== undefined) {
      hasAnyValues = true;
      internalValueResult.index = this._index;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHubsAcpi | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._index = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._index = value.index;
    }
  }

  // index - computed: false, optional: true, required: false
  private _index?: number; 
  public get index() {
    return this.getNumberAttribute('index');
  }
  public set index(value: number) {
    this._index = value;
  }
  public resetIndex() {
    this._index = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get indexInput() {
    return this._index;
  }
}
export interface DomainDevicesHubsAddress {
}

export function domainDevicesHubsAddressToTerraform(struct?: DomainDevicesHubsAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function domainDevicesHubsAddressToHclTerraform(struct?: DomainDevicesHubsAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DomainDevicesHubsAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesHubsAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHubsAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DomainDevicesHubsAlias {
  /**
  * Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
}

export function domainDevicesHubsAliasToTerraform(struct?: DomainDevicesHubsAlias | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function domainDevicesHubsAliasToHclTerraform(struct?: DomainDevicesHubsAlias | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesHubsAliasOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesHubsAlias | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHubsAlias | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DomainDevicesHubs {
  /**
  * Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#acpi Domain#acpi}
  */
  readonly acpi?: DomainDevicesHubsAcpi;
  /**
  * Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: DomainDevicesHubsAddress;
  /**
  * Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#alias Domain#alias}
  */
  readonly alias?: DomainDevicesHubsAlias;
  /**
  * Specifies the hub type, typically the bus on which the hub is implemented (for example, `usb`); value is user-provided but must be supported by the hypervisor.
  * 
  * See: <https://libvirt.org/formatdomain.html#hub-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type: string;
}

export function domainDevicesHubsToTerraform(struct?: DomainDevicesHubs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    acpi: domainDevicesHubsAcpiToTerraform(struct!.acpi),
    address: domainDevicesHubsAddressToTerraform(struct!.address),
    alias: domainDevicesHubsAliasToTerraform(struct!.alias),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function domainDevicesHubsToHclTerraform(struct?: DomainDevicesHubs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    acpi: {
      value: domainDevicesHubsAcpiToHclTerraform(struct!.acpi),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesHubsAcpi",
    },
    address: {
      value: domainDevicesHubsAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesHubsAddress",
    },
    alias: {
      value: domainDevicesHubsAliasToHclTerraform(struct!.alias),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesHubsAlias",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesHubsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesHubs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._acpi?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.acpi = this._acpi?.internalValue;
    }
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._alias?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.alias = this._alias?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesHubs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._acpi.internalValue = undefined;
      this._address.internalValue = undefined;
      this._alias.internalValue = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._acpi.internalValue = value.acpi;
      this._address.internalValue = value.address;
      this._alias.internalValue = value.alias;
      this._type = value.type;
    }
  }

  // acpi - computed: false, optional: true, required: false
  private _acpi = new DomainDevicesHubsAcpiOutputReference(this, "acpi");
  public get acpi() {
    return this._acpi;
  }
  public putAcpi(value: DomainDevicesHubsAcpi) {
    this._acpi.internalValue = value;
  }
  public resetAcpi() {
    this._acpi.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get acpiInput() {
    return this._acpi.internalValue;
  }

  // address - computed: false, optional: true, required: false
  private _address = new DomainDevicesHubsAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DomainDevicesHubsAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // alias - computed: false, optional: true, required: false
  private _alias = new DomainDevicesHubsAliasOutputReference(this, "alias");
  public get alias() {
    return this._alias;
  }
  public putAlias(value: DomainDevicesHubsAlias) {
    this._alias.internalValue = value;
  }
  public resetAlias() {
    this._alias.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aliasInput() {
    return this._alias.internalValue;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}

export class DomainDevicesHubsList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesHubs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesHubsOutputReference {
    return new DomainDevicesHubsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesInputsAcpi {
  /**
  * Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#pstore>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#index Domain#index}
  */
  readonly index?: number;
}

export function domainDevicesInputsAcpiToTerraform(struct?: DomainDevicesInputsAcpi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    index: cdktf.numberToTerraform(struct!.index),
  }
}


export function domainDevicesInputsAcpiToHclTerraform(struct?: DomainDevicesInputsAcpi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    index: {
      value: cdktf.numberToHclTerraform(struct!.index),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInputsAcpiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInputsAcpi | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._index !== undefined) {
      hasAnyValues = true;
      internalValueResult.index = this._index;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInputsAcpi | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._index = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._index = value.index;
    }
  }

  // index - computed: false, optional: true, required: false
  private _index?: number; 
  public get index() {
    return this.getNumberAttribute('index');
  }
  public set index(value: number) {
    this._index = value;
  }
  public resetIndex() {
    this._index = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get indexInput() {
    return this._index;
  }
}
export interface DomainDevicesInputsAddress {
}

export function domainDevicesInputsAddressToTerraform(struct?: DomainDevicesInputsAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function domainDevicesInputsAddressToHclTerraform(struct?: DomainDevicesInputsAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DomainDevicesInputsAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInputsAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInputsAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DomainDevicesInputsAlias {
  /**
  * Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
}

export function domainDevicesInputsAliasToTerraform(struct?: DomainDevicesInputsAlias | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function domainDevicesInputsAliasToHclTerraform(struct?: DomainDevicesInputsAlias | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInputsAliasOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInputsAlias | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInputsAlias | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DomainDevicesInputsDriver {
  /**
  * Enables or disables Address Translation Services (ATS) for a virtio input device, using "on" or "off" when the device is behind an emulated IOMMU.
  * 
  * See: <https://libvirt.org/formatdomain.html#virtio-related-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#ats Domain#ats}
  */
  readonly ats?: string;
  /**
  * Enables or disables use of an emulated IOMMU for this virtio input device, typically with "on" or "off" when integrating with a guest IOMMU.
  * 
  * See: <https://libvirt.org/formatdomain.html#virtio-related-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#iommu Domain#iommu}
  */
  readonly iommu?: string;
  /**
  * Toggles use of packed virtqueue format for this virtio input device, usually set to "on" or "off" to match guest driver capabilities.
  * 
  * See: <https://libvirt.org/formatdomain.html#virtio-related-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#packed Domain#packed}
  */
  readonly packed?: string;
  /**
  * Controls whether each virtqueue of this virtio input device uses a separate page-table mapping, typically "on" or "off" for finegrained IOMMU mapping.
  * 
  * See: <https://libvirt.org/formatdomain.html#virtio-related-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#page_per_vq Domain#page_per_vq}
  */
  readonly pagePerVq?: string;
}

export function domainDevicesInputsDriverToTerraform(struct?: DomainDevicesInputsDriver | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ats: cdktf.stringToTerraform(struct!.ats),
    iommu: cdktf.stringToTerraform(struct!.iommu),
    packed: cdktf.stringToTerraform(struct!.packed),
    page_per_vq: cdktf.stringToTerraform(struct!.pagePerVq),
  }
}


export function domainDevicesInputsDriverToHclTerraform(struct?: DomainDevicesInputsDriver | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ats: {
      value: cdktf.stringToHclTerraform(struct!.ats),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    iommu: {
      value: cdktf.stringToHclTerraform(struct!.iommu),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    packed: {
      value: cdktf.stringToHclTerraform(struct!.packed),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    page_per_vq: {
      value: cdktf.stringToHclTerraform(struct!.pagePerVq),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInputsDriverOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInputsDriver | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ats !== undefined) {
      hasAnyValues = true;
      internalValueResult.ats = this._ats;
    }
    if (this._iommu !== undefined) {
      hasAnyValues = true;
      internalValueResult.iommu = this._iommu;
    }
    if (this._packed !== undefined) {
      hasAnyValues = true;
      internalValueResult.packed = this._packed;
    }
    if (this._pagePerVq !== undefined) {
      hasAnyValues = true;
      internalValueResult.pagePerVq = this._pagePerVq;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInputsDriver | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ats = undefined;
      this._iommu = undefined;
      this._packed = undefined;
      this._pagePerVq = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ats = value.ats;
      this._iommu = value.iommu;
      this._packed = value.packed;
      this._pagePerVq = value.pagePerVq;
    }
  }

  // ats - computed: false, optional: true, required: false
  private _ats?: string; 
  public get ats() {
    return this.getStringAttribute('ats');
  }
  public set ats(value: string) {
    this._ats = value;
  }
  public resetAts() {
    this._ats = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get atsInput() {
    return this._ats;
  }

  // iommu - computed: false, optional: true, required: false
  private _iommu?: string; 
  public get iommu() {
    return this.getStringAttribute('iommu');
  }
  public set iommu(value: string) {
    this._iommu = value;
  }
  public resetIommu() {
    this._iommu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get iommuInput() {
    return this._iommu;
  }

  // packed - computed: false, optional: true, required: false
  private _packed?: string; 
  public get packed() {
    return this.getStringAttribute('packed');
  }
  public set packed(value: string) {
    this._packed = value;
  }
  public resetPacked() {
    this._packed = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get packedInput() {
    return this._packed;
  }

  // page_per_vq - computed: false, optional: true, required: false
  private _pagePerVq?: string; 
  public get pagePerVq() {
    return this.getStringAttribute('page_per_vq');
  }
  public set pagePerVq(value: string) {
    this._pagePerVq = value;
  }
  public resetPagePerVq() {
    this._pagePerVq = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pagePerVqInput() {
    return this._pagePerVq;
  }
}
export interface DomainDevicesInputsSourceEvDev {
  /**
  * Specifies the mandatory path to the host evdev device node (for example, "/dev/input/event3") that backs this input device.
  * 
  * See: <https://libvirt.org/formatdomain.html#input-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dev Domain#dev}
  */
  readonly dev: string;
  /**
  * Controls whether libvirt/QEMU grabs exclusive access to the host evdev device ("yes" or "no"), preventing it from being used by the host while attached to the guest.
  * 
  * See: <https://libvirt.org/formatdomain.html#input-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#grab Domain#grab}
  */
  readonly grab?: string;
  /**
  * Enables or disables hotkey-based toggling of the grab state for the evdev device, typically using "yes" or "no" if supported.
  * 
  * See: <https://libvirt.org/formatdomain.html#input-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#grab_toggle Domain#grab_toggle}
  */
  readonly grabToggle?: string;
  /**
  * Controls whether key repeat is handled for this evdev-based input device ("yes" or "no"), affecting how held keys generate repeated events in the guest.
  * 
  * See: <https://libvirt.org/formatdomain.html#input-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#repeat Domain#repeat}
  */
  readonly repeat?: string;
}

export function domainDevicesInputsSourceEvDevToTerraform(struct?: DomainDevicesInputsSourceEvDev | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dev: cdktf.stringToTerraform(struct!.dev),
    grab: cdktf.stringToTerraform(struct!.grab),
    grab_toggle: cdktf.stringToTerraform(struct!.grabToggle),
    repeat: cdktf.stringToTerraform(struct!.repeat),
  }
}


export function domainDevicesInputsSourceEvDevToHclTerraform(struct?: DomainDevicesInputsSourceEvDev | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dev: {
      value: cdktf.stringToHclTerraform(struct!.dev),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    grab: {
      value: cdktf.stringToHclTerraform(struct!.grab),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    grab_toggle: {
      value: cdktf.stringToHclTerraform(struct!.grabToggle),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    repeat: {
      value: cdktf.stringToHclTerraform(struct!.repeat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInputsSourceEvDevOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInputsSourceEvDev | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dev !== undefined) {
      hasAnyValues = true;
      internalValueResult.dev = this._dev;
    }
    if (this._grab !== undefined) {
      hasAnyValues = true;
      internalValueResult.grab = this._grab;
    }
    if (this._grabToggle !== undefined) {
      hasAnyValues = true;
      internalValueResult.grabToggle = this._grabToggle;
    }
    if (this._repeat !== undefined) {
      hasAnyValues = true;
      internalValueResult.repeat = this._repeat;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInputsSourceEvDev | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dev = undefined;
      this._grab = undefined;
      this._grabToggle = undefined;
      this._repeat = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dev = value.dev;
      this._grab = value.grab;
      this._grabToggle = value.grabToggle;
      this._repeat = value.repeat;
    }
  }

  // dev - computed: false, optional: false, required: true
  private _dev?: string; 
  public get dev() {
    return this.getStringAttribute('dev');
  }
  public set dev(value: string) {
    this._dev = value;
  }
  // Temporarily expose input value. Use with caution.
  public get devInput() {
    return this._dev;
  }

  // grab - computed: false, optional: true, required: false
  private _grab?: string; 
  public get grab() {
    return this.getStringAttribute('grab');
  }
  public set grab(value: string) {
    this._grab = value;
  }
  public resetGrab() {
    this._grab = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get grabInput() {
    return this._grab;
  }

  // grab_toggle - computed: false, optional: true, required: false
  private _grabToggle?: string; 
  public get grabToggle() {
    return this.getStringAttribute('grab_toggle');
  }
  public set grabToggle(value: string) {
    this._grabToggle = value;
  }
  public resetGrabToggle() {
    this._grabToggle = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get grabToggleInput() {
    return this._grabToggle;
  }

  // repeat - computed: false, optional: true, required: false
  private _repeat?: string; 
  public get repeat() {
    return this.getStringAttribute('repeat');
  }
  public set repeat(value: string) {
    this._repeat = value;
  }
  public resetRepeat() {
    this._repeat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get repeatInput() {
    return this._repeat;
  }
}
export interface DomainDevicesInputsSourcePassthrough {
  /**
  * Specifies the mandatory path to the host evdev device node used for passthrough (for example, "/dev/input/event5"); the value is a user-provided absolute device path.
  * 
  * See: <https://libvirt.org/formatdomain.html#input-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#ev_dev Domain#ev_dev}
  */
  readonly evDev: string;
}

export function domainDevicesInputsSourcePassthroughToTerraform(struct?: DomainDevicesInputsSourcePassthrough | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ev_dev: cdktf.stringToTerraform(struct!.evDev),
  }
}


export function domainDevicesInputsSourcePassthroughToHclTerraform(struct?: DomainDevicesInputsSourcePassthrough | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ev_dev: {
      value: cdktf.stringToHclTerraform(struct!.evDev),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInputsSourcePassthroughOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInputsSourcePassthrough | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._evDev !== undefined) {
      hasAnyValues = true;
      internalValueResult.evDev = this._evDev;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInputsSourcePassthrough | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._evDev = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._evDev = value.evDev;
    }
  }

  // ev_dev - computed: false, optional: false, required: true
  private _evDev?: string; 
  public get evDev() {
    return this.getStringAttribute('ev_dev');
  }
  public set evDev(value: string) {
    this._evDev = value;
  }
  // Temporarily expose input value. Use with caution.
  public get evDevInput() {
    return this._evDev;
  }
}
export interface DomainDevicesInputsSource {
  /**
  * Attaches the input device to a host evdev device node, allowing direct passthrough of events from that device to the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#ev_dev Domain#ev_dev}
  */
  readonly evDev?: DomainDevicesInputsSourceEvDev;
  /**
  * Configures the input device as a passthrough device using a host evdev path, allowing low-level event forwarding directly to the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#passthrough Domain#passthrough}
  */
  readonly passthrough?: DomainDevicesInputsSourcePassthrough;
}

export function domainDevicesInputsSourceToTerraform(struct?: DomainDevicesInputsSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ev_dev: domainDevicesInputsSourceEvDevToTerraform(struct!.evDev),
    passthrough: domainDevicesInputsSourcePassthroughToTerraform(struct!.passthrough),
  }
}


export function domainDevicesInputsSourceToHclTerraform(struct?: DomainDevicesInputsSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ev_dev: {
      value: domainDevicesInputsSourceEvDevToHclTerraform(struct!.evDev),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesInputsSourceEvDev",
    },
    passthrough: {
      value: domainDevicesInputsSourcePassthroughToHclTerraform(struct!.passthrough),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesInputsSourcePassthrough",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInputsSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInputsSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._evDev?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.evDev = this._evDev?.internalValue;
    }
    if (this._passthrough?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.passthrough = this._passthrough?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInputsSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._evDev.internalValue = undefined;
      this._passthrough.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._evDev.internalValue = value.evDev;
      this._passthrough.internalValue = value.passthrough;
    }
  }

  // ev_dev - computed: false, optional: true, required: false
  private _evDev = new DomainDevicesInputsSourceEvDevOutputReference(this, "ev_dev");
  public get evDev() {
    return this._evDev;
  }
  public putEvDev(value: DomainDevicesInputsSourceEvDev) {
    this._evDev.internalValue = value;
  }
  public resetEvDev() {
    this._evDev.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get evDevInput() {
    return this._evDev.internalValue;
  }

  // passthrough - computed: false, optional: true, required: false
  private _passthrough = new DomainDevicesInputsSourcePassthroughOutputReference(this, "passthrough");
  public get passthrough() {
    return this._passthrough;
  }
  public putPassthrough(value: DomainDevicesInputsSourcePassthrough) {
    this._passthrough.internalValue = value;
  }
  public resetPassthrough() {
    this._passthrough.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passthroughInput() {
    return this._passthrough.internalValue;
  }
}
export interface DomainDevicesInputs {
  /**
  * Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#acpi Domain#acpi}
  */
  readonly acpi?: DomainDevicesInputsAcpi;
  /**
  * Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: DomainDevicesInputsAddress;
  /**
  * Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#alias Domain#alias}
  */
  readonly alias?: DomainDevicesInputsAlias;
  /**
  * Selects the bus on which the input device is exposed to the guest, such as "ps2", "usb", "virtio", or "xen" depending on the guest type and model.
  * 
  * See: <https://libvirt.org/formatdomain.html#input-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bus Domain#bus}
  */
  readonly bus?: string;
  /**
  * Configures optional driver-specific settings for this input device, including virtio transport options when using a virtio-based model.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#driver Domain#driver}
  */
  readonly driver?: DomainDevicesInputsDriver;
  /**
  * Selects the emulated input device model (for example, "ps2", "usb-tablet", "virtio-mouse", or "virtio-keyboard"), determining how the guest OS sees this input device.
  * 
  * See: <https://libvirt.org/formatdomain.html#input-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Configures the host-side source backing this input device, such as an evdev device or passthrough from a host input device.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#source Domain#source}
  */
  readonly source?: DomainDevicesInputsSource;
  /**
  * Sets the type of input device attached to the guest (for example, tablet, mouse, keyboard); value is user-provided and must be supported by the chosen hypervisor. Example: "tablet" for a USB graphics-tablet-style pointing device.
  * 
  * See: <https://libvirt.org/formatdomain.html#input-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type: string;
}

export function domainDevicesInputsToTerraform(struct?: DomainDevicesInputs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    acpi: domainDevicesInputsAcpiToTerraform(struct!.acpi),
    address: domainDevicesInputsAddressToTerraform(struct!.address),
    alias: domainDevicesInputsAliasToTerraform(struct!.alias),
    bus: cdktf.stringToTerraform(struct!.bus),
    driver: domainDevicesInputsDriverToTerraform(struct!.driver),
    model: cdktf.stringToTerraform(struct!.model),
    source: domainDevicesInputsSourceToTerraform(struct!.source),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function domainDevicesInputsToHclTerraform(struct?: DomainDevicesInputs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    acpi: {
      value: domainDevicesInputsAcpiToHclTerraform(struct!.acpi),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesInputsAcpi",
    },
    address: {
      value: domainDevicesInputsAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesInputsAddress",
    },
    alias: {
      value: domainDevicesInputsAliasToHclTerraform(struct!.alias),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesInputsAlias",
    },
    bus: {
      value: cdktf.stringToHclTerraform(struct!.bus),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    driver: {
      value: domainDevicesInputsDriverToHclTerraform(struct!.driver),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesInputsDriver",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    source: {
      value: domainDevicesInputsSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesInputsSource",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInputsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesInputs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._acpi?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.acpi = this._acpi?.internalValue;
    }
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._alias?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.alias = this._alias?.internalValue;
    }
    if (this._bus !== undefined) {
      hasAnyValues = true;
      internalValueResult.bus = this._bus;
    }
    if (this._driver?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.driver = this._driver?.internalValue;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInputs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._acpi.internalValue = undefined;
      this._address.internalValue = undefined;
      this._alias.internalValue = undefined;
      this._bus = undefined;
      this._driver.internalValue = undefined;
      this._model = undefined;
      this._source.internalValue = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._acpi.internalValue = value.acpi;
      this._address.internalValue = value.address;
      this._alias.internalValue = value.alias;
      this._bus = value.bus;
      this._driver.internalValue = value.driver;
      this._model = value.model;
      this._source.internalValue = value.source;
      this._type = value.type;
    }
  }

  // acpi - computed: false, optional: true, required: false
  private _acpi = new DomainDevicesInputsAcpiOutputReference(this, "acpi");
  public get acpi() {
    return this._acpi;
  }
  public putAcpi(value: DomainDevicesInputsAcpi) {
    this._acpi.internalValue = value;
  }
  public resetAcpi() {
    this._acpi.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get acpiInput() {
    return this._acpi.internalValue;
  }

  // address - computed: false, optional: true, required: false
  private _address = new DomainDevicesInputsAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DomainDevicesInputsAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // alias - computed: false, optional: true, required: false
  private _alias = new DomainDevicesInputsAliasOutputReference(this, "alias");
  public get alias() {
    return this._alias;
  }
  public putAlias(value: DomainDevicesInputsAlias) {
    this._alias.internalValue = value;
  }
  public resetAlias() {
    this._alias.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aliasInput() {
    return this._alias.internalValue;
  }

  // bus - computed: false, optional: true, required: false
  private _bus?: string; 
  public get bus() {
    return this.getStringAttribute('bus');
  }
  public set bus(value: string) {
    this._bus = value;
  }
  public resetBus() {
    this._bus = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get busInput() {
    return this._bus;
  }

  // driver - computed: false, optional: true, required: false
  private _driver = new DomainDevicesInputsDriverOutputReference(this, "driver");
  public get driver() {
    return this._driver;
  }
  public putDriver(value: DomainDevicesInputsDriver) {
    this._driver.internalValue = value;
  }
  public resetDriver() {
    this._driver.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get driverInput() {
    return this._driver.internalValue;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // source - computed: false, optional: true, required: false
  private _source = new DomainDevicesInputsSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: DomainDevicesInputsSource) {
    this._source.internalValue = value;
  }
  public resetSource() {
    this._source.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}

export class DomainDevicesInputsList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesInputs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesInputsOutputReference {
    return new DomainDevicesInputsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesInterfacesAcpi {
  /**
  * Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#pstore>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#index Domain#index}
  */
  readonly index?: number;
}

export function domainDevicesInterfacesAcpiToTerraform(struct?: DomainDevicesInterfacesAcpi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    index: cdktf.numberToTerraform(struct!.index),
  }
}


export function domainDevicesInterfacesAcpiToHclTerraform(struct?: DomainDevicesInterfacesAcpi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    index: {
      value: cdktf.numberToHclTerraform(struct!.index),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesAcpiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesAcpi | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._index !== undefined) {
      hasAnyValues = true;
      internalValueResult.index = this._index;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesAcpi | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._index = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._index = value.index;
    }
  }

  // index - computed: false, optional: true, required: false
  private _index?: number; 
  public get index() {
    return this.getNumberAttribute('index');
  }
  public set index(value: number) {
    this._index = value;
  }
  public resetIndex() {
    this._index = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get indexInput() {
    return this._index;
  }
}
export interface DomainDevicesInterfacesAddress {
}

export function domainDevicesInterfacesAddressToTerraform(struct?: DomainDevicesInterfacesAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function domainDevicesInterfacesAddressToHclTerraform(struct?: DomainDevicesInterfacesAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DomainDevicesInterfacesAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DomainDevicesInterfacesAlias {
  /**
  * Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
}

export function domainDevicesInterfacesAliasToTerraform(struct?: DomainDevicesInterfacesAlias | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function domainDevicesInterfacesAliasToHclTerraform(struct?: DomainDevicesInterfacesAlias | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesAliasOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesAlias | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesAlias | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DomainDevicesInterfacesBackend {
  /**
  * Sets a path to a host log file where backend-related messages for this interface are written; value is a user-provided filesystem path.
  * 
  * See: <https://libvirt.org/formatdomain.html#userspace-connection-using-passt>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#log_file Domain#log_file}
  */
  readonly logFile?: string;
  /**
  * Specifies the tap device to be used by the backend instead of one automatically created (for example, "tap0"); value is a user-provided interface name.
  * 
  * See: <https://libvirt.org/formatdomain.html#setting-network-backend-specific-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tap Domain#tap}
  */
  readonly tap?: string;
  /**
  * Selects the backend implementation type (for example, "passt" for a passt userspace backend); value must match a backend type supported by the hypervisor.
  * 
  * See: <https://libvirt.org/formatdomain.html#userspace-connection-using-passt>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type?: string;
  /**
  * Overrides the default vhost device path for this interfaces backend (for example, "/dev/vhost-net"); value is a user-provided path.
  * 
  * See: <https://libvirt.org/formatdomain.html#setting-network-backend-specific-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vhost Domain#vhost}
  */
  readonly vhost?: string;
}

export function domainDevicesInterfacesBackendToTerraform(struct?: DomainDevicesInterfacesBackend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    log_file: cdktf.stringToTerraform(struct!.logFile),
    tap: cdktf.stringToTerraform(struct!.tap),
    type: cdktf.stringToTerraform(struct!.type),
    vhost: cdktf.stringToTerraform(struct!.vhost),
  }
}


export function domainDevicesInterfacesBackendToHclTerraform(struct?: DomainDevicesInterfacesBackend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    log_file: {
      value: cdktf.stringToHclTerraform(struct!.logFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tap: {
      value: cdktf.stringToHclTerraform(struct!.tap),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    vhost: {
      value: cdktf.stringToHclTerraform(struct!.vhost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesBackendOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesBackend | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._logFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.logFile = this._logFile;
    }
    if (this._tap !== undefined) {
      hasAnyValues = true;
      internalValueResult.tap = this._tap;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._vhost !== undefined) {
      hasAnyValues = true;
      internalValueResult.vhost = this._vhost;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesBackend | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._logFile = undefined;
      this._tap = undefined;
      this._type = undefined;
      this._vhost = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._logFile = value.logFile;
      this._tap = value.tap;
      this._type = value.type;
      this._vhost = value.vhost;
    }
  }

  // log_file - computed: false, optional: true, required: false
  private _logFile?: string; 
  public get logFile() {
    return this.getStringAttribute('log_file');
  }
  public set logFile(value: string) {
    this._logFile = value;
  }
  public resetLogFile() {
    this._logFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logFileInput() {
    return this._logFile;
  }

  // tap - computed: false, optional: true, required: false
  private _tap?: string; 
  public get tap() {
    return this.getStringAttribute('tap');
  }
  public set tap(value: string) {
    this._tap = value;
  }
  public resetTap() {
    this._tap = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tapInput() {
    return this._tap;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // vhost - computed: false, optional: true, required: false
  private _vhost?: string; 
  public get vhost() {
    return this.getStringAttribute('vhost');
  }
  public set vhost(value: string) {
    this._vhost = value;
  }
  public resetVhost() {
    this._vhost = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vhostInput() {
    return this._vhost;
  }
}
export interface DomainDevicesInterfacesBackendDomain {
  /**
  * Sets the name of the backend (driver) domain that will host the network backend for this interface; value must match an existing domain name.
  * 
  * See: <https://libvirt.org/formatdomain.html#setting-up-a-network-backend-in-a-driver-domain>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
}

export function domainDevicesInterfacesBackendDomainToTerraform(struct?: DomainDevicesInterfacesBackendDomain | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function domainDevicesInterfacesBackendDomainToHclTerraform(struct?: DomainDevicesInterfacesBackendDomain | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesBackendDomainOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesBackendDomain | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesBackendDomain | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DomainDevicesInterfacesBandwidthInbound {
  /**
  * Sets the longterm average outbound bandwidth for this interface in kilobytes per second; the hypervisor shapes egress traffic around this sustained rate.
  * 
  * See: <https://libvirt.org/formatdomain.html#quality-of-service>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#average Domain#average}
  */
  readonly average?: number;
  /**
  * Sets the maximum size of a temporary outbound bandwidth burst, in kilobytes, that can exceed the average rate before throttling applies.
  * 
  * See: <https://libvirt.org/formatdomain.html#quality-of-service>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#burst Domain#burst}
  */
  readonly burst?: number;
  /**
  * Sets a minimum guaranteed outbound bandwidth for this interface in kilobytes per second, below which the traffic should not be throttled if capacity is available.
  * 
  * See: <https://libvirt.org/formatdomain.html#quality-of-service>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#floor Domain#floor}
  */
  readonly floor?: number;
  /**
  * Sets an absolute peak outbound bandwidth limit for this interface in kilobytes per second that cannot be exceeded even during bursts.
  * 
  * See: <https://libvirt.org/formatdomain.html#quality-of-service>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#peak Domain#peak}
  */
  readonly peak?: number;
}

export function domainDevicesInterfacesBandwidthInboundToTerraform(struct?: DomainDevicesInterfacesBandwidthInbound | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    average: cdktf.numberToTerraform(struct!.average),
    burst: cdktf.numberToTerraform(struct!.burst),
    floor: cdktf.numberToTerraform(struct!.floor),
    peak: cdktf.numberToTerraform(struct!.peak),
  }
}


export function domainDevicesInterfacesBandwidthInboundToHclTerraform(struct?: DomainDevicesInterfacesBandwidthInbound | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    average: {
      value: cdktf.numberToHclTerraform(struct!.average),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    burst: {
      value: cdktf.numberToHclTerraform(struct!.burst),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    floor: {
      value: cdktf.numberToHclTerraform(struct!.floor),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    peak: {
      value: cdktf.numberToHclTerraform(struct!.peak),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesBandwidthInboundOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesBandwidthInbound | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._average !== undefined) {
      hasAnyValues = true;
      internalValueResult.average = this._average;
    }
    if (this._burst !== undefined) {
      hasAnyValues = true;
      internalValueResult.burst = this._burst;
    }
    if (this._floor !== undefined) {
      hasAnyValues = true;
      internalValueResult.floor = this._floor;
    }
    if (this._peak !== undefined) {
      hasAnyValues = true;
      internalValueResult.peak = this._peak;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesBandwidthInbound | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._average = undefined;
      this._burst = undefined;
      this._floor = undefined;
      this._peak = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._average = value.average;
      this._burst = value.burst;
      this._floor = value.floor;
      this._peak = value.peak;
    }
  }

  // average - computed: false, optional: true, required: false
  private _average?: number; 
  public get average() {
    return this.getNumberAttribute('average');
  }
  public set average(value: number) {
    this._average = value;
  }
  public resetAverage() {
    this._average = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get averageInput() {
    return this._average;
  }

  // burst - computed: false, optional: true, required: false
  private _burst?: number; 
  public get burst() {
    return this.getNumberAttribute('burst');
  }
  public set burst(value: number) {
    this._burst = value;
  }
  public resetBurst() {
    this._burst = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get burstInput() {
    return this._burst;
  }

  // floor - computed: false, optional: true, required: false
  private _floor?: number; 
  public get floor() {
    return this.getNumberAttribute('floor');
  }
  public set floor(value: number) {
    this._floor = value;
  }
  public resetFloor() {
    this._floor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get floorInput() {
    return this._floor;
  }

  // peak - computed: false, optional: true, required: false
  private _peak?: number; 
  public get peak() {
    return this.getNumberAttribute('peak');
  }
  public set peak(value: number) {
    this._peak = value;
  }
  public resetPeak() {
    this._peak = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get peakInput() {
    return this._peak;
  }
}
export interface DomainDevicesInterfacesBandwidthOutbound {
  /**
  * Sets the longterm average outbound bandwidth for this interface in kilobytes per second; the hypervisor shapes egress traffic around this sustained rate.
  * 
  * See: <https://libvirt.org/formatdomain.html#quality-of-service>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#average Domain#average}
  */
  readonly average?: number;
  /**
  * Sets the maximum size of a temporary outbound bandwidth burst, in kilobytes, that can exceed the average rate before throttling applies.
  * 
  * See: <https://libvirt.org/formatdomain.html#quality-of-service>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#burst Domain#burst}
  */
  readonly burst?: number;
  /**
  * Sets a minimum guaranteed outbound bandwidth for this interface in kilobytes per second, below which the traffic should not be throttled if capacity is available.
  * 
  * See: <https://libvirt.org/formatdomain.html#quality-of-service>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#floor Domain#floor}
  */
  readonly floor?: number;
  /**
  * Sets an absolute peak outbound bandwidth limit for this interface in kilobytes per second that cannot be exceeded even during bursts.
  * 
  * See: <https://libvirt.org/formatdomain.html#quality-of-service>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#peak Domain#peak}
  */
  readonly peak?: number;
}

export function domainDevicesInterfacesBandwidthOutboundToTerraform(struct?: DomainDevicesInterfacesBandwidthOutbound | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    average: cdktf.numberToTerraform(struct!.average),
    burst: cdktf.numberToTerraform(struct!.burst),
    floor: cdktf.numberToTerraform(struct!.floor),
    peak: cdktf.numberToTerraform(struct!.peak),
  }
}


export function domainDevicesInterfacesBandwidthOutboundToHclTerraform(struct?: DomainDevicesInterfacesBandwidthOutbound | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    average: {
      value: cdktf.numberToHclTerraform(struct!.average),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    burst: {
      value: cdktf.numberToHclTerraform(struct!.burst),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    floor: {
      value: cdktf.numberToHclTerraform(struct!.floor),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    peak: {
      value: cdktf.numberToHclTerraform(struct!.peak),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesBandwidthOutboundOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesBandwidthOutbound | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._average !== undefined) {
      hasAnyValues = true;
      internalValueResult.average = this._average;
    }
    if (this._burst !== undefined) {
      hasAnyValues = true;
      internalValueResult.burst = this._burst;
    }
    if (this._floor !== undefined) {
      hasAnyValues = true;
      internalValueResult.floor = this._floor;
    }
    if (this._peak !== undefined) {
      hasAnyValues = true;
      internalValueResult.peak = this._peak;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesBandwidthOutbound | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._average = undefined;
      this._burst = undefined;
      this._floor = undefined;
      this._peak = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._average = value.average;
      this._burst = value.burst;
      this._floor = value.floor;
      this._peak = value.peak;
    }
  }

  // average - computed: false, optional: true, required: false
  private _average?: number; 
  public get average() {
    return this.getNumberAttribute('average');
  }
  public set average(value: number) {
    this._average = value;
  }
  public resetAverage() {
    this._average = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get averageInput() {
    return this._average;
  }

  // burst - computed: false, optional: true, required: false
  private _burst?: number; 
  public get burst() {
    return this.getNumberAttribute('burst');
  }
  public set burst(value: number) {
    this._burst = value;
  }
  public resetBurst() {
    this._burst = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get burstInput() {
    return this._burst;
  }

  // floor - computed: false, optional: true, required: false
  private _floor?: number; 
  public get floor() {
    return this.getNumberAttribute('floor');
  }
  public set floor(value: number) {
    this._floor = value;
  }
  public resetFloor() {
    this._floor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get floorInput() {
    return this._floor;
  }

  // peak - computed: false, optional: true, required: false
  private _peak?: number; 
  public get peak() {
    return this.getNumberAttribute('peak');
  }
  public set peak(value: number) {
    this._peak = value;
  }
  public resetPeak() {
    this._peak = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get peakInput() {
    return this._peak;
  }
}
export interface DomainDevicesInterfacesBandwidth {
  /**
  * Configures outbound traffic shaping limits for this interface, allowing you to restrict or prioritize egress bandwidth using the child attributes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#inbound Domain#inbound}
  */
  readonly inbound?: DomainDevicesInterfacesBandwidthInbound;
  /**
  * Configures outbound traffic shaping limits for this interface, allowing you to restrict or prioritize egress bandwidth using the child attributes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#outbound Domain#outbound}
  */
  readonly outbound?: DomainDevicesInterfacesBandwidthOutbound;
}

export function domainDevicesInterfacesBandwidthToTerraform(struct?: DomainDevicesInterfacesBandwidth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    inbound: domainDevicesInterfacesBandwidthInboundToTerraform(struct!.inbound),
    outbound: domainDevicesInterfacesBandwidthOutboundToTerraform(struct!.outbound),
  }
}


export function domainDevicesInterfacesBandwidthToHclTerraform(struct?: DomainDevicesInterfacesBandwidth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    inbound: {
      value: domainDevicesInterfacesBandwidthInboundToHclTerraform(struct!.inbound),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesInterfacesBandwidthInbound",
    },
    outbound: {
      value: domainDevicesInterfacesBandwidthOutboundToHclTerraform(struct!.outbound),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesInterfacesBandwidthOutbound",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesBandwidthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesBandwidth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._inbound?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.inbound = this._inbound?.internalValue;
    }
    if (this._outbound?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.outbound = this._outbound?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesBandwidth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._inbound.internalValue = undefined;
      this._outbound.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._inbound.internalValue = value.inbound;
      this._outbound.internalValue = value.outbound;
    }
  }

  // inbound - computed: false, optional: true, required: false
  private _inbound = new DomainDevicesInterfacesBandwidthInboundOutputReference(this, "inbound");
  public get inbound() {
    return this._inbound;
  }
  public putInbound(value: DomainDevicesInterfacesBandwidthInbound) {
    this._inbound.internalValue = value;
  }
  public resetInbound() {
    this._inbound.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inboundInput() {
    return this._inbound.internalValue;
  }

  // outbound - computed: false, optional: true, required: false
  private _outbound = new DomainDevicesInterfacesBandwidthOutboundOutputReference(this, "outbound");
  public get outbound() {
    return this._outbound;
  }
  public putOutbound(value: DomainDevicesInterfacesBandwidthOutbound) {
    this._outbound.internalValue = value;
  }
  public resetOutbound() {
    this._outbound.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get outboundInput() {
    return this._outbound.internalValue;
  }
}
export interface DomainDevicesInterfacesBoot {
  /**
  * Sets an optional firmware load parameter string associated with booting from this redirected device, passed to firmware on platforms that support loadparm (e.g. s390x).
  * 
  * See: <https://libvirt.org/formatdomain.html#specifying-boot-order>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#load_parm Domain#load_parm}
  */
  readonly loadParm?: string;
  /**
  * Sets the boot priority for this redirected device, as a positive integer where lower values are tried earlier during guest boot (for example, 1 for first, 2 for second).
  * 
  * See: <https://libvirt.org/formatdomain.html#specifying-boot-order>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#order Domain#order}
  */
  readonly order: number;
}

export function domainDevicesInterfacesBootToTerraform(struct?: DomainDevicesInterfacesBoot | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    load_parm: cdktf.stringToTerraform(struct!.loadParm),
    order: cdktf.numberToTerraform(struct!.order),
  }
}


export function domainDevicesInterfacesBootToHclTerraform(struct?: DomainDevicesInterfacesBoot | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    load_parm: {
      value: cdktf.stringToHclTerraform(struct!.loadParm),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    order: {
      value: cdktf.numberToHclTerraform(struct!.order),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesBootOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesBoot | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._loadParm !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadParm = this._loadParm;
    }
    if (this._order !== undefined) {
      hasAnyValues = true;
      internalValueResult.order = this._order;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesBoot | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._loadParm = undefined;
      this._order = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._loadParm = value.loadParm;
      this._order = value.order;
    }
  }

  // load_parm - computed: false, optional: true, required: false
  private _loadParm?: string; 
  public get loadParm() {
    return this.getStringAttribute('load_parm');
  }
  public set loadParm(value: string) {
    this._loadParm = value;
  }
  public resetLoadParm() {
    this._loadParm = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadParmInput() {
    return this._loadParm;
  }

  // order - computed: false, optional: false, required: true
  private _order?: number; 
  public get order() {
    return this.getNumberAttribute('order');
  }
  public set order(value: number) {
    this._order = value;
  }
  // Temporarily expose input value. Use with caution.
  public get orderInput() {
    return this._order;
  }
}
export interface DomainDevicesInterfacesCoalesceRxFrames {
  /**
  * Sets the maximum number of received frames that may be coalesced before triggering processing; value is a nonnegative integer in frames.
  * 
  * See: <https://libvirt.org/formatdomain.html#coalesce-settings>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#max Domain#max}
  */
  readonly max?: number;
}

export function domainDevicesInterfacesCoalesceRxFramesToTerraform(struct?: DomainDevicesInterfacesCoalesceRxFrames | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max: cdktf.numberToTerraform(struct!.max),
  }
}


export function domainDevicesInterfacesCoalesceRxFramesToHclTerraform(struct?: DomainDevicesInterfacesCoalesceRxFrames | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max: {
      value: cdktf.numberToHclTerraform(struct!.max),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesCoalesceRxFramesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesCoalesceRxFrames | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._max !== undefined) {
      hasAnyValues = true;
      internalValueResult.max = this._max;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesCoalesceRxFrames | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._max = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._max = value.max;
    }
  }

  // max - computed: false, optional: true, required: false
  private _max?: number; 
  public get max() {
    return this.getNumberAttribute('max');
  }
  public set max(value: number) {
    this._max = value;
  }
  public resetMax() {
    this._max = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxInput() {
    return this._max;
  }
}
export interface DomainDevicesInterfacesCoalesceRx {
  /**
  * Configures coalescing based on the number of received frames before an interrupt or notification is generated.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#frames Domain#frames}
  */
  readonly frames?: DomainDevicesInterfacesCoalesceRxFrames;
}

export function domainDevicesInterfacesCoalesceRxToTerraform(struct?: DomainDevicesInterfacesCoalesceRx | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    frames: domainDevicesInterfacesCoalesceRxFramesToTerraform(struct!.frames),
  }
}


export function domainDevicesInterfacesCoalesceRxToHclTerraform(struct?: DomainDevicesInterfacesCoalesceRx | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    frames: {
      value: domainDevicesInterfacesCoalesceRxFramesToHclTerraform(struct!.frames),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesInterfacesCoalesceRxFrames",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesCoalesceRxOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesCoalesceRx | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._frames?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.frames = this._frames?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesCoalesceRx | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._frames.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._frames.internalValue = value.frames;
    }
  }

  // frames - computed: false, optional: true, required: false
  private _frames = new DomainDevicesInterfacesCoalesceRxFramesOutputReference(this, "frames");
  public get frames() {
    return this._frames;
  }
  public putFrames(value: DomainDevicesInterfacesCoalesceRxFrames) {
    this._frames.internalValue = value;
  }
  public resetFrames() {
    this._frames.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get framesInput() {
    return this._frames.internalValue;
  }
}
export interface DomainDevicesInterfacesCoalesce {
  /**
  * Configures receiveside coalescing parameters for this interface.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#rx Domain#rx}
  */
  readonly rx?: DomainDevicesInterfacesCoalesceRx;
}

export function domainDevicesInterfacesCoalesceToTerraform(struct?: DomainDevicesInterfacesCoalesce | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    rx: domainDevicesInterfacesCoalesceRxToTerraform(struct!.rx),
  }
}


export function domainDevicesInterfacesCoalesceToHclTerraform(struct?: DomainDevicesInterfacesCoalesce | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    rx: {
      value: domainDevicesInterfacesCoalesceRxToHclTerraform(struct!.rx),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesInterfacesCoalesceRx",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesCoalesceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesCoalesce | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._rx?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rx = this._rx?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesCoalesce | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._rx.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._rx.internalValue = value.rx;
    }
  }

  // rx - computed: false, optional: true, required: false
  private _rx = new DomainDevicesInterfacesCoalesceRxOutputReference(this, "rx");
  public get rx() {
    return this._rx;
  }
  public putRx(value: DomainDevicesInterfacesCoalesceRx) {
    this._rx.internalValue = value;
  }
  public resetRx() {
    this._rx.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rxInput() {
    return this._rx.internalValue;
  }
}
export interface DomainDevicesInterfacesDownScript {
  /**
  * Sets the absolute or relative filesystem path to the script that is run when the interface is torn down (for example, "/etc/qemu-ifdown").
  * 
  * See: <https://libvirt.org/formatdomain.html#generic-ethernet-connection>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
}

export function domainDevicesInterfacesDownScriptToTerraform(struct?: DomainDevicesInterfacesDownScript | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function domainDevicesInterfacesDownScriptToHclTerraform(struct?: DomainDevicesInterfacesDownScript | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesDownScriptOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesDownScript | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesDownScript | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface DomainDevicesInterfacesDriverGuest {
  /**
  * Enables or disables checksum offload as advertised to the guest, controlling whether the guest is expected to handle checksums in software; value is typically "on" or "off".
  * 
  * See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#csum Domain#csum}
  */
  readonly csum?: string;
  /**
  * Enables or disables ECN (Explicit Congestion Notification) offload features as advertised to the guest; value is typically "on" or "off".
  * 
  * See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#ecn Domain#ecn}
  */
  readonly ecn?: string;
  /**
  * Configures whether TCP segmentation offload (TSO) for IPv4 is enabled on the guest side of a virtio network interface driver; value is user-provided, typically a boolean-like on/off or yes/no.
  * 
  * See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tso4 Domain#tso4}
  */
  readonly tso4?: string;
  /**
  * Configures whether TCP segmentation offload (TSO) for IPv6 is enabled on the guest side of a virtio network interface driver; value is user-provided, typically a boolean-like on/off or yes/no.
  * 
  * See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tso6 Domain#tso6}
  */
  readonly tso6?: string;
  /**
  * Configures whether UDP fragmentation offload (UFO) is enabled on the guest side of a virtio network interface driver; value is user-provided, typically a boolean-like on/off or yes/no.
  * 
  * See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#ufo Domain#ufo}
  */
  readonly ufo?: string;
}

export function domainDevicesInterfacesDriverGuestToTerraform(struct?: DomainDevicesInterfacesDriverGuest | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    csum: cdktf.stringToTerraform(struct!.csum),
    ecn: cdktf.stringToTerraform(struct!.ecn),
    tso4: cdktf.stringToTerraform(struct!.tso4),
    tso6: cdktf.stringToTerraform(struct!.tso6),
    ufo: cdktf.stringToTerraform(struct!.ufo),
  }
}


export function domainDevicesInterfacesDriverGuestToHclTerraform(struct?: DomainDevicesInterfacesDriverGuest | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    csum: {
      value: cdktf.stringToHclTerraform(struct!.csum),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ecn: {
      value: cdktf.stringToHclTerraform(struct!.ecn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tso4: {
      value: cdktf.stringToHclTerraform(struct!.tso4),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tso6: {
      value: cdktf.stringToHclTerraform(struct!.tso6),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ufo: {
      value: cdktf.stringToHclTerraform(struct!.ufo),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesDriverGuestOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesDriverGuest | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._csum !== undefined) {
      hasAnyValues = true;
      internalValueResult.csum = this._csum;
    }
    if (this._ecn !== undefined) {
      hasAnyValues = true;
      internalValueResult.ecn = this._ecn;
    }
    if (this._tso4 !== undefined) {
      hasAnyValues = true;
      internalValueResult.tso4 = this._tso4;
    }
    if (this._tso6 !== undefined) {
      hasAnyValues = true;
      internalValueResult.tso6 = this._tso6;
    }
    if (this._ufo !== undefined) {
      hasAnyValues = true;
      internalValueResult.ufo = this._ufo;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesDriverGuest | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._csum = undefined;
      this._ecn = undefined;
      this._tso4 = undefined;
      this._tso6 = undefined;
      this._ufo = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._csum = value.csum;
      this._ecn = value.ecn;
      this._tso4 = value.tso4;
      this._tso6 = value.tso6;
      this._ufo = value.ufo;
    }
  }

  // csum - computed: false, optional: true, required: false
  private _csum?: string; 
  public get csum() {
    return this.getStringAttribute('csum');
  }
  public set csum(value: string) {
    this._csum = value;
  }
  public resetCsum() {
    this._csum = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get csumInput() {
    return this._csum;
  }

  // ecn - computed: false, optional: true, required: false
  private _ecn?: string; 
  public get ecn() {
    return this.getStringAttribute('ecn');
  }
  public set ecn(value: string) {
    this._ecn = value;
  }
  public resetEcn() {
    this._ecn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ecnInput() {
    return this._ecn;
  }

  // tso4 - computed: false, optional: true, required: false
  private _tso4?: string; 
  public get tso4() {
    return this.getStringAttribute('tso4');
  }
  public set tso4(value: string) {
    this._tso4 = value;
  }
  public resetTso4() {
    this._tso4 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tso4Input() {
    return this._tso4;
  }

  // tso6 - computed: false, optional: true, required: false
  private _tso6?: string; 
  public get tso6() {
    return this.getStringAttribute('tso6');
  }
  public set tso6(value: string) {
    this._tso6 = value;
  }
  public resetTso6() {
    this._tso6 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tso6Input() {
    return this._tso6;
  }

  // ufo - computed: false, optional: true, required: false
  private _ufo?: string; 
  public get ufo() {
    return this.getStringAttribute('ufo');
  }
  public set ufo(value: string) {
    this._ufo = value;
  }
  public resetUfo() {
    this._ufo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ufoInput() {
    return this._ufo;
  }
}
export interface DomainDevicesInterfacesDriverHost {
  /**
  * Configures whether checksum offload is enabled on the host side of a virtio network interface driver; value is user-provided, typically on/off or yes/no.
  * 
  * See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#csum Domain#csum}
  */
  readonly csum?: string;
  /**
  * Configures whether Explicit Congestion Notification (ECN) offload is enabled on the host side of a virtio network interface driver; value is user-provided, typically on/off or yes/no.
  * 
  * See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#ecn Domain#ecn}
  */
  readonly ecn?: string;
  /**
  * Configures whether generic segmentation offload (GSO) is enabled on the host side of a virtio network interface driver; value is user-provided, typically on/off or yes/no.
  * 
  * See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#gso Domain#gso}
  */
  readonly gso?: string;
  /**
  * Configures whether mergeable receive buffers (mrg_rxbuf) are enabled on the host side of a virtio network interface driver; value is user-provided, typically on/off or yes/no.
  * 
  * See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mrg_rx_buf Domain#mrg_rx_buf}
  */
  readonly mrgRxBuf?: string;
  /**
  * Configures whether TCP segmentation offload (TSO) for IPv4 is enabled on the host side of a virtio network interface driver; value is user-provided, typically on/off or yes/no.
  * 
  * See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tso4 Domain#tso4}
  */
  readonly tso4?: string;
  /**
  * Configures whether TCP segmentation offload (TSO) for IPv6 is enabled on the host side of a virtio network interface driver; value is user-provided, typically on/off or yes/no.
  * 
  * See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tso6 Domain#tso6}
  */
  readonly tso6?: string;
  /**
  * Configures whether UDP fragmentation offload (UFO) is enabled on the host side of a virtio network interface driver; value is user-provided, typically on/off or yes/no.
  * 
  * See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#ufo Domain#ufo}
  */
  readonly ufo?: string;
}

export function domainDevicesInterfacesDriverHostToTerraform(struct?: DomainDevicesInterfacesDriverHost | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    csum: cdktf.stringToTerraform(struct!.csum),
    ecn: cdktf.stringToTerraform(struct!.ecn),
    gso: cdktf.stringToTerraform(struct!.gso),
    mrg_rx_buf: cdktf.stringToTerraform(struct!.mrgRxBuf),
    tso4: cdktf.stringToTerraform(struct!.tso4),
    tso6: cdktf.stringToTerraform(struct!.tso6),
    ufo: cdktf.stringToTerraform(struct!.ufo),
  }
}


export function domainDevicesInterfacesDriverHostToHclTerraform(struct?: DomainDevicesInterfacesDriverHost | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    csum: {
      value: cdktf.stringToHclTerraform(struct!.csum),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ecn: {
      value: cdktf.stringToHclTerraform(struct!.ecn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    gso: {
      value: cdktf.stringToHclTerraform(struct!.gso),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mrg_rx_buf: {
      value: cdktf.stringToHclTerraform(struct!.mrgRxBuf),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tso4: {
      value: cdktf.stringToHclTerraform(struct!.tso4),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tso6: {
      value: cdktf.stringToHclTerraform(struct!.tso6),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ufo: {
      value: cdktf.stringToHclTerraform(struct!.ufo),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesDriverHostOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesDriverHost | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._csum !== undefined) {
      hasAnyValues = true;
      internalValueResult.csum = this._csum;
    }
    if (this._ecn !== undefined) {
      hasAnyValues = true;
      internalValueResult.ecn = this._ecn;
    }
    if (this._gso !== undefined) {
      hasAnyValues = true;
      internalValueResult.gso = this._gso;
    }
    if (this._mrgRxBuf !== undefined) {
      hasAnyValues = true;
      internalValueResult.mrgRxBuf = this._mrgRxBuf;
    }
    if (this._tso4 !== undefined) {
      hasAnyValues = true;
      internalValueResult.tso4 = this._tso4;
    }
    if (this._tso6 !== undefined) {
      hasAnyValues = true;
      internalValueResult.tso6 = this._tso6;
    }
    if (this._ufo !== undefined) {
      hasAnyValues = true;
      internalValueResult.ufo = this._ufo;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesDriverHost | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._csum = undefined;
      this._ecn = undefined;
      this._gso = undefined;
      this._mrgRxBuf = undefined;
      this._tso4 = undefined;
      this._tso6 = undefined;
      this._ufo = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._csum = value.csum;
      this._ecn = value.ecn;
      this._gso = value.gso;
      this._mrgRxBuf = value.mrgRxBuf;
      this._tso4 = value.tso4;
      this._tso6 = value.tso6;
      this._ufo = value.ufo;
    }
  }

  // csum - computed: false, optional: true, required: false
  private _csum?: string; 
  public get csum() {
    return this.getStringAttribute('csum');
  }
  public set csum(value: string) {
    this._csum = value;
  }
  public resetCsum() {
    this._csum = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get csumInput() {
    return this._csum;
  }

  // ecn - computed: false, optional: true, required: false
  private _ecn?: string; 
  public get ecn() {
    return this.getStringAttribute('ecn');
  }
  public set ecn(value: string) {
    this._ecn = value;
  }
  public resetEcn() {
    this._ecn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ecnInput() {
    return this._ecn;
  }

  // gso - computed: false, optional: true, required: false
  private _gso?: string; 
  public get gso() {
    return this.getStringAttribute('gso');
  }
  public set gso(value: string) {
    this._gso = value;
  }
  public resetGso() {
    this._gso = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gsoInput() {
    return this._gso;
  }

  // mrg_rx_buf - computed: false, optional: true, required: false
  private _mrgRxBuf?: string; 
  public get mrgRxBuf() {
    return this.getStringAttribute('mrg_rx_buf');
  }
  public set mrgRxBuf(value: string) {
    this._mrgRxBuf = value;
  }
  public resetMrgRxBuf() {
    this._mrgRxBuf = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mrgRxBufInput() {
    return this._mrgRxBuf;
  }

  // tso4 - computed: false, optional: true, required: false
  private _tso4?: string; 
  public get tso4() {
    return this.getStringAttribute('tso4');
  }
  public set tso4(value: string) {
    this._tso4 = value;
  }
  public resetTso4() {
    this._tso4 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tso4Input() {
    return this._tso4;
  }

  // tso6 - computed: false, optional: true, required: false
  private _tso6?: string; 
  public get tso6() {
    return this.getStringAttribute('tso6');
  }
  public set tso6(value: string) {
    this._tso6 = value;
  }
  public resetTso6() {
    this._tso6 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tso6Input() {
    return this._tso6;
  }

  // ufo - computed: false, optional: true, required: false
  private _ufo?: string; 
  public get ufo() {
    return this.getStringAttribute('ufo');
  }
  public set ufo(value: string) {
    this._ufo = value;
  }
  public resetUfo() {
    this._ufo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ufoInput() {
    return this._ufo;
  }
}
export interface DomainDevicesInterfacesDriver {
  /**
  * Enables or disables Address Translation Service (ATS) for a virtio interface when used with an emulated IOMMU; value is typically "on" or "off".
  * 
  * See: <https://libvirt.org/formatdomain.html#virtio-related-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#ats Domain#ats}
  */
  readonly ats?: string;
  /**
  * Enables or disables virtio event index optimization for this interface; value is typically "on" or "off".
  * 
  * See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#event_idx Domain#event_idx}
  */
  readonly eventIdx?: string;
  /**
  * Configures guestvisible offload capabilities advertised by this interfaces driver.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#guest Domain#guest}
  */
  readonly guest?: DomainDevicesInterfacesDriverGuest;
  /**
  * Groups driver-specific offload and tuning options that apply to the host side of a virtio network interface; individual attributes within this block are user-provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#host Domain#host}
  */
  readonly host?: DomainDevicesInterfacesDriverHost;
  /**
  * Configures whether ioeventfd is used for the virtio network interface, enabling eventfd-based notification for I/O; value is user-provided, usually a boolean-like on/off.
  * 
  * See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#io_event_fd Domain#io_event_fd}
  */
  readonly ioEventFd?: string;
  /**
  * Configures whether the virtio network device uses an emulated IOMMU for DMA translation; value is user-provided, typically on/off or yes/no.
  * 
  * See: <https://libvirt.org/formatdomain.html#virtio-related-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#iommu Domain#iommu}
  */
  readonly iommu?: string;
  /**
  * Sets the driver name/type for the network interface backend (for example, a specific vhost or virtio implementation); value is user-provided string.
  * 
  * See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name?: string;
  /**
  * Configures whether the virtio network interface uses packed virtqueue format instead of split queues; value is user-provided, typically on/off or yes/no.
  * 
  * See: <https://libvirt.org/formatdomain.html#virtio-related-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#packed Domain#packed}
  */
  readonly packed?: string;
  /**
  * Configures whether each virtqueue of the virtio network interface uses a dedicated page (page_per_vq); value is user-provided, typically on/off or yes/no.
  * 
  * See: <https://libvirt.org/formatdomain.html#virtio-related-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#page_per_vq Domain#page_per_vq}
  */
  readonly pagePerVq?: string;
  /**
  * Sets the number of virtio queues for the network interface to support multiqueue networking; value is user-provided positive integer (for example, 4 or 8).
  * 
  * See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#queues Domain#queues}
  */
  readonly queues?: number;
  /**
  * Configures whether Receive Side Scaling (RSS) is enabled for the virtio network interface, distributing traffic across multiple queues; value is user-provided, typically on/off or yes/no.
  * 
  * See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#rss Domain#rss}
  */
  readonly rss?: string;
  /**
  * Configures whether the virtio network interface reports RSS hash information to the guest; value is user-provided, typically on/off or yes/no.
  * 
  * See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#rss_hash_report Domain#rss_hash_report}
  */
  readonly rssHashReport?: string;
  /**
  * Sets the size (number of descriptors) of the receive queue for the virtio network interface; value is user-provided non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#rx_queue_size Domain#rx_queue_size}
  */
  readonly rxQueueSize?: number;
  /**
  * Sets the transmit mode for a virtio network interface driver; valid values are user-provided but typically include modes like 'iothread' or 'timer' depending on QEMU support.
  * 
  * See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tx_mode Domain#tx_mode}
  */
  readonly txMode?: string;
  /**
  * Sets the size (number of descriptors) of the transmit queue for a virtio network interface driver; value is a user-provided positive integer tuned for performance.
  * 
  * See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tx_queue_size Domain#tx_queue_size}
  */
  readonly txQueueSize?: number;
}

export function domainDevicesInterfacesDriverToTerraform(struct?: DomainDevicesInterfacesDriver | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ats: cdktf.stringToTerraform(struct!.ats),
    event_idx: cdktf.stringToTerraform(struct!.eventIdx),
    guest: domainDevicesInterfacesDriverGuestToTerraform(struct!.guest),
    host: domainDevicesInterfacesDriverHostToTerraform(struct!.host),
    io_event_fd: cdktf.stringToTerraform(struct!.ioEventFd),
    iommu: cdktf.stringToTerraform(struct!.iommu),
    name: cdktf.stringToTerraform(struct!.name),
    packed: cdktf.stringToTerraform(struct!.packed),
    page_per_vq: cdktf.stringToTerraform(struct!.pagePerVq),
    queues: cdktf.numberToTerraform(struct!.queues),
    rss: cdktf.stringToTerraform(struct!.rss),
    rss_hash_report: cdktf.stringToTerraform(struct!.rssHashReport),
    rx_queue_size: cdktf.numberToTerraform(struct!.rxQueueSize),
    tx_mode: cdktf.stringToTerraform(struct!.txMode),
    tx_queue_size: cdktf.numberToTerraform(struct!.txQueueSize),
  }
}


export function domainDevicesInterfacesDriverToHclTerraform(struct?: DomainDevicesInterfacesDriver | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ats: {
      value: cdktf.stringToHclTerraform(struct!.ats),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    event_idx: {
      value: cdktf.stringToHclTerraform(struct!.eventIdx),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    guest: {
      value: domainDevicesInterfacesDriverGuestToHclTerraform(struct!.guest),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesInterfacesDriverGuest",
    },
    host: {
      value: domainDevicesInterfacesDriverHostToHclTerraform(struct!.host),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesInterfacesDriverHost",
    },
    io_event_fd: {
      value: cdktf.stringToHclTerraform(struct!.ioEventFd),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    iommu: {
      value: cdktf.stringToHclTerraform(struct!.iommu),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    packed: {
      value: cdktf.stringToHclTerraform(struct!.packed),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    page_per_vq: {
      value: cdktf.stringToHclTerraform(struct!.pagePerVq),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    queues: {
      value: cdktf.numberToHclTerraform(struct!.queues),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    rss: {
      value: cdktf.stringToHclTerraform(struct!.rss),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    rss_hash_report: {
      value: cdktf.stringToHclTerraform(struct!.rssHashReport),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    rx_queue_size: {
      value: cdktf.numberToHclTerraform(struct!.rxQueueSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    tx_mode: {
      value: cdktf.stringToHclTerraform(struct!.txMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tx_queue_size: {
      value: cdktf.numberToHclTerraform(struct!.txQueueSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesDriverOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesDriver | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ats !== undefined) {
      hasAnyValues = true;
      internalValueResult.ats = this._ats;
    }
    if (this._eventIdx !== undefined) {
      hasAnyValues = true;
      internalValueResult.eventIdx = this._eventIdx;
    }
    if (this._guest?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.guest = this._guest?.internalValue;
    }
    if (this._host?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host?.internalValue;
    }
    if (this._ioEventFd !== undefined) {
      hasAnyValues = true;
      internalValueResult.ioEventFd = this._ioEventFd;
    }
    if (this._iommu !== undefined) {
      hasAnyValues = true;
      internalValueResult.iommu = this._iommu;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._packed !== undefined) {
      hasAnyValues = true;
      internalValueResult.packed = this._packed;
    }
    if (this._pagePerVq !== undefined) {
      hasAnyValues = true;
      internalValueResult.pagePerVq = this._pagePerVq;
    }
    if (this._queues !== undefined) {
      hasAnyValues = true;
      internalValueResult.queues = this._queues;
    }
    if (this._rss !== undefined) {
      hasAnyValues = true;
      internalValueResult.rss = this._rss;
    }
    if (this._rssHashReport !== undefined) {
      hasAnyValues = true;
      internalValueResult.rssHashReport = this._rssHashReport;
    }
    if (this._rxQueueSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.rxQueueSize = this._rxQueueSize;
    }
    if (this._txMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.txMode = this._txMode;
    }
    if (this._txQueueSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.txQueueSize = this._txQueueSize;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesDriver | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ats = undefined;
      this._eventIdx = undefined;
      this._guest.internalValue = undefined;
      this._host.internalValue = undefined;
      this._ioEventFd = undefined;
      this._iommu = undefined;
      this._name = undefined;
      this._packed = undefined;
      this._pagePerVq = undefined;
      this._queues = undefined;
      this._rss = undefined;
      this._rssHashReport = undefined;
      this._rxQueueSize = undefined;
      this._txMode = undefined;
      this._txQueueSize = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ats = value.ats;
      this._eventIdx = value.eventIdx;
      this._guest.internalValue = value.guest;
      this._host.internalValue = value.host;
      this._ioEventFd = value.ioEventFd;
      this._iommu = value.iommu;
      this._name = value.name;
      this._packed = value.packed;
      this._pagePerVq = value.pagePerVq;
      this._queues = value.queues;
      this._rss = value.rss;
      this._rssHashReport = value.rssHashReport;
      this._rxQueueSize = value.rxQueueSize;
      this._txMode = value.txMode;
      this._txQueueSize = value.txQueueSize;
    }
  }

  // ats - computed: false, optional: true, required: false
  private _ats?: string; 
  public get ats() {
    return this.getStringAttribute('ats');
  }
  public set ats(value: string) {
    this._ats = value;
  }
  public resetAts() {
    this._ats = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get atsInput() {
    return this._ats;
  }

  // event_idx - computed: false, optional: true, required: false
  private _eventIdx?: string; 
  public get eventIdx() {
    return this.getStringAttribute('event_idx');
  }
  public set eventIdx(value: string) {
    this._eventIdx = value;
  }
  public resetEventIdx() {
    this._eventIdx = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get eventIdxInput() {
    return this._eventIdx;
  }

  // guest - computed: false, optional: true, required: false
  private _guest = new DomainDevicesInterfacesDriverGuestOutputReference(this, "guest");
  public get guest() {
    return this._guest;
  }
  public putGuest(value: DomainDevicesInterfacesDriverGuest) {
    this._guest.internalValue = value;
  }
  public resetGuest() {
    this._guest.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get guestInput() {
    return this._guest.internalValue;
  }

  // host - computed: false, optional: true, required: false
  private _host = new DomainDevicesInterfacesDriverHostOutputReference(this, "host");
  public get host() {
    return this._host;
  }
  public putHost(value: DomainDevicesInterfacesDriverHost) {
    this._host.internalValue = value;
  }
  public resetHost() {
    this._host.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host.internalValue;
  }

  // io_event_fd - computed: false, optional: true, required: false
  private _ioEventFd?: string; 
  public get ioEventFd() {
    return this.getStringAttribute('io_event_fd');
  }
  public set ioEventFd(value: string) {
    this._ioEventFd = value;
  }
  public resetIoEventFd() {
    this._ioEventFd = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ioEventFdInput() {
    return this._ioEventFd;
  }

  // iommu - computed: false, optional: true, required: false
  private _iommu?: string; 
  public get iommu() {
    return this.getStringAttribute('iommu');
  }
  public set iommu(value: string) {
    this._iommu = value;
  }
  public resetIommu() {
    this._iommu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get iommuInput() {
    return this._iommu;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // packed - computed: false, optional: true, required: false
  private _packed?: string; 
  public get packed() {
    return this.getStringAttribute('packed');
  }
  public set packed(value: string) {
    this._packed = value;
  }
  public resetPacked() {
    this._packed = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get packedInput() {
    return this._packed;
  }

  // page_per_vq - computed: false, optional: true, required: false
  private _pagePerVq?: string; 
  public get pagePerVq() {
    return this.getStringAttribute('page_per_vq');
  }
  public set pagePerVq(value: string) {
    this._pagePerVq = value;
  }
  public resetPagePerVq() {
    this._pagePerVq = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pagePerVqInput() {
    return this._pagePerVq;
  }

  // queues - computed: false, optional: true, required: false
  private _queues?: number; 
  public get queues() {
    return this.getNumberAttribute('queues');
  }
  public set queues(value: number) {
    this._queues = value;
  }
  public resetQueues() {
    this._queues = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queuesInput() {
    return this._queues;
  }

  // rss - computed: false, optional: true, required: false
  private _rss?: string; 
  public get rss() {
    return this.getStringAttribute('rss');
  }
  public set rss(value: string) {
    this._rss = value;
  }
  public resetRss() {
    this._rss = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rssInput() {
    return this._rss;
  }

  // rss_hash_report - computed: false, optional: true, required: false
  private _rssHashReport?: string; 
  public get rssHashReport() {
    return this.getStringAttribute('rss_hash_report');
  }
  public set rssHashReport(value: string) {
    this._rssHashReport = value;
  }
  public resetRssHashReport() {
    this._rssHashReport = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rssHashReportInput() {
    return this._rssHashReport;
  }

  // rx_queue_size - computed: false, optional: true, required: false
  private _rxQueueSize?: number; 
  public get rxQueueSize() {
    return this.getNumberAttribute('rx_queue_size');
  }
  public set rxQueueSize(value: number) {
    this._rxQueueSize = value;
  }
  public resetRxQueueSize() {
    this._rxQueueSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rxQueueSizeInput() {
    return this._rxQueueSize;
  }

  // tx_mode - computed: false, optional: true, required: false
  private _txMode?: string; 
  public get txMode() {
    return this.getStringAttribute('tx_mode');
  }
  public set txMode(value: string) {
    this._txMode = value;
  }
  public resetTxMode() {
    this._txMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get txModeInput() {
    return this._txMode;
  }

  // tx_queue_size - computed: false, optional: true, required: false
  private _txQueueSize?: number; 
  public get txQueueSize() {
    return this.getNumberAttribute('tx_queue_size');
  }
  public set txQueueSize(value: number) {
    this._txQueueSize = value;
  }
  public resetTxQueueSize() {
    this._txQueueSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get txQueueSizeInput() {
    return this._txQueueSize;
  }
}
export interface DomainDevicesInterfacesFilterRefParameters {
  /**
  * Sets the parameter name passed into the nwfilter definition; value is user-provided and must match a parameter expected by the filter (for example, "IP", "MAC").
  * 
  * See: <https://libvirt.org/formatdomain.html#traffic-filtering-with-nwfilter>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
  /**
  * Sets the value for the named nwfilter parameter; value is user-provided and typically encodes an address, port, or other match value (for example, "192.168.122.1").
  * 
  * See: <https://libvirt.org/formatdomain.html#traffic-filtering-with-nwfilter>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#value Domain#value}
  */
  readonly value: string;
}

export function domainDevicesInterfacesFilterRefParametersToTerraform(struct?: DomainDevicesInterfacesFilterRefParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function domainDevicesInterfacesFilterRefParametersToHclTerraform(struct?: DomainDevicesInterfacesFilterRefParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesFilterRefParametersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesInterfacesFilterRefParameters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesFilterRefParameters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DomainDevicesInterfacesFilterRefParametersList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesInterfacesFilterRefParameters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesInterfacesFilterRefParametersOutputReference {
    return new DomainDevicesInterfacesFilterRefParametersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesInterfacesFilterRef {
  /**
  * Specifies the name of the nwfilter profile to apply to this interface; value is a user-provided filter name that must refer to an existing nwfilter definition (for example, "clean-traffic").
  * 
  * See: <https://libvirt.org/formatdomain.html#traffic-filtering-with-nwfilter>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#filter Domain#filter}
  */
  readonly filter: string;
  /**
  * Provides one or more parameter overrides for the selected nwfilter, each supplying a named value used by the filters rules.
  * 
  * See: <https://libvirt.org/formatdomain.html#traffic-filtering-with-nwfilter>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#parameters Domain#parameters}
  */
  readonly parameters?: DomainDevicesInterfacesFilterRefParameters[] | cdktf.IResolvable;
}

export function domainDevicesInterfacesFilterRefToTerraform(struct?: DomainDevicesInterfacesFilterRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    filter: cdktf.stringToTerraform(struct!.filter),
    parameters: cdktf.listMapper(domainDevicesInterfacesFilterRefParametersToTerraform, false)(struct!.parameters),
  }
}


export function domainDevicesInterfacesFilterRefToHclTerraform(struct?: DomainDevicesInterfacesFilterRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    filter: {
      value: cdktf.stringToHclTerraform(struct!.filter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parameters: {
      value: cdktf.listMapperHcl(domainDevicesInterfacesFilterRefParametersToHclTerraform, false)(struct!.parameters),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesInterfacesFilterRefParametersList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesFilterRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesFilterRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._filter !== undefined) {
      hasAnyValues = true;
      internalValueResult.filter = this._filter;
    }
    if (this._parameters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.parameters = this._parameters?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesFilterRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._filter = undefined;
      this._parameters.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._filter = value.filter;
      this._parameters.internalValue = value.parameters;
    }
  }

  // filter - computed: false, optional: false, required: true
  private _filter?: string; 
  public get filter() {
    return this.getStringAttribute('filter');
  }
  public set filter(value: string) {
    this._filter = value;
  }
  // Temporarily expose input value. Use with caution.
  public get filterInput() {
    return this._filter;
  }

  // parameters - computed: false, optional: true, required: false
  private _parameters = new DomainDevicesInterfacesFilterRefParametersList(this, "parameters", false);
  public get parameters() {
    return this._parameters;
  }
  public putParameters(value: DomainDevicesInterfacesFilterRefParameters[] | cdktf.IResolvable) {
    this._parameters.internalValue = value;
  }
  public resetParameters() {
    this._parameters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parametersInput() {
    return this._parameters.internalValue;
  }
}
export interface DomainDevicesInterfacesGuest {
  /**
  * Sets the actual interface name inside the guest when it differs from the nominal guest.dev name; value is user-provided (for example, "ens3").
  * 
  * See: <https://libvirt.org/formatdomain.html#network-interfaces>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#actual Domain#actual}
  */
  readonly actual?: string;
  /**
  * Sets the guest-visible network interface name (e.g. Linux device name) for this NIC; value is user-provided (for example, "eth0").
  * 
  * See: <https://libvirt.org/formatdomain.html#network-interfaces>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dev Domain#dev}
  */
  readonly dev?: string;
}

export function domainDevicesInterfacesGuestToTerraform(struct?: DomainDevicesInterfacesGuest | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    actual: cdktf.stringToTerraform(struct!.actual),
    dev: cdktf.stringToTerraform(struct!.dev),
  }
}


export function domainDevicesInterfacesGuestToHclTerraform(struct?: DomainDevicesInterfacesGuest | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    actual: {
      value: cdktf.stringToHclTerraform(struct!.actual),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dev: {
      value: cdktf.stringToHclTerraform(struct!.dev),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesGuestOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesGuest | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._actual !== undefined) {
      hasAnyValues = true;
      internalValueResult.actual = this._actual;
    }
    if (this._dev !== undefined) {
      hasAnyValues = true;
      internalValueResult.dev = this._dev;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesGuest | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._actual = undefined;
      this._dev = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._actual = value.actual;
      this._dev = value.dev;
    }
  }

  // actual - computed: false, optional: true, required: false
  private _actual?: string; 
  public get actual() {
    return this.getStringAttribute('actual');
  }
  public set actual(value: string) {
    this._actual = value;
  }
  public resetActual() {
    this._actual = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actualInput() {
    return this._actual;
  }

  // dev - computed: false, optional: true, required: false
  private _dev?: string; 
  public get dev() {
    return this.getStringAttribute('dev');
  }
  public set dev(value: string) {
    this._dev = value;
  }
  public resetDev() {
    this._dev = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devInput() {
    return this._dev;
  }
}
export interface DomainDevicesInterfacesIp {
  /**
  * Sets the IP address assigned to the interface in the guest; must be a valid IPv4 or IPv6 address string (for example, "192.168.122.10" or "2001:db8::10").
  * 
  * See: <https://libvirt.org/formatdomain.html#ip-configuration>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address: string;
  /**
  * Selects the address family for the interface IP, typically "ipv4" or "ipv6"; if omitted, libvirt infers it from the address format.
  * 
  * See: <https://libvirt.org/formatdomain.html#ip-configuration>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#family Domain#family}
  */
  readonly family?: string;
  /**
  * Sets the peer address for point-to-point style links, as a valid IPv4 or IPv6 address string; value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#ip-configuration>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#peer Domain#peer}
  */
  readonly peer?: string;
  /**
  * Sets the prefix length (CIDR) for the interface IP address as a non-negative integer (for example, 24 for "192.168.122.0/24").
  * 
  * See: <https://libvirt.org/formatdomain.html#ip-configuration>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#prefix Domain#prefix}
  */
  readonly prefix?: number;
}

export function domainDevicesInterfacesIpToTerraform(struct?: DomainDevicesInterfacesIp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
    family: cdktf.stringToTerraform(struct!.family),
    peer: cdktf.stringToTerraform(struct!.peer),
    prefix: cdktf.numberToTerraform(struct!.prefix),
  }
}


export function domainDevicesInterfacesIpToHclTerraform(struct?: DomainDevicesInterfacesIp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    family: {
      value: cdktf.stringToHclTerraform(struct!.family),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    peer: {
      value: cdktf.stringToHclTerraform(struct!.peer),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix: {
      value: cdktf.numberToHclTerraform(struct!.prefix),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesIpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesInterfacesIp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    if (this._family !== undefined) {
      hasAnyValues = true;
      internalValueResult.family = this._family;
    }
    if (this._peer !== undefined) {
      hasAnyValues = true;
      internalValueResult.peer = this._peer;
    }
    if (this._prefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefix = this._prefix;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesIp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
      this._family = undefined;
      this._peer = undefined;
      this._prefix = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
      this._family = value.family;
      this._peer = value.peer;
      this._prefix = value.prefix;
    }
  }

  // address - computed: false, optional: false, required: true
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }

  // family - computed: false, optional: true, required: false
  private _family?: string; 
  public get family() {
    return this.getStringAttribute('family');
  }
  public set family(value: string) {
    this._family = value;
  }
  public resetFamily() {
    this._family = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get familyInput() {
    return this._family;
  }

  // peer - computed: false, optional: true, required: false
  private _peer?: string; 
  public get peer() {
    return this.getStringAttribute('peer');
  }
  public set peer(value: string) {
    this._peer = value;
  }
  public resetPeer() {
    this._peer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get peerInput() {
    return this._peer;
  }

  // prefix - computed: false, optional: true, required: false
  private _prefix?: number; 
  public get prefix() {
    return this.getNumberAttribute('prefix');
  }
  public set prefix(value: number) {
    this._prefix = value;
  }
  public resetPrefix() {
    this._prefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixInput() {
    return this._prefix;
  }
}

export class DomainDevicesInterfacesIpList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesInterfacesIp[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesInterfacesIpOutputReference {
    return new DomainDevicesInterfacesIpOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesInterfacesLink {
  /**
  * Sets the virtual link state for the NIC, with valid values "up" or "down" (when "down", the interface behaves as if unplugged in the guest).
  * 
  * See: <https://libvirt.org/formatdomain.html#modifying-virtual-link-state>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state: string;
}

export function domainDevicesInterfacesLinkToTerraform(struct?: DomainDevicesInterfacesLink | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainDevicesInterfacesLinkToHclTerraform(struct?: DomainDevicesInterfacesLink | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesLinkOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesLink | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesLink | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: false, required: true
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainDevicesInterfacesMac {
  /**
  * Sets the MAC address of the NIC as a 6-byte hexadecimal address string (for example, "52:54:00:ab:cd:ef"); must be unique per interface on the same network.
  * 
  * See: <https://libvirt.org/formatdomain.html#network-interfaces>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address: string;
  /**
  * Controls how libvirt handles MAC address conflicts for this NIC; valid values are implementation-defined strings such as "none" or "duplicate" where supported, and are user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#network-interfaces>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#check Domain#check}
  */
  readonly check?: string;
  /**
  * Sets the MAC address type for the interface; value is user-provided (for example, vendor-specific type strings) and is optional.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type?: string;
}

export function domainDevicesInterfacesMacToTerraform(struct?: DomainDevicesInterfacesMac | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
    check: cdktf.stringToTerraform(struct!.check),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function domainDevicesInterfacesMacToHclTerraform(struct?: DomainDevicesInterfacesMac | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    check: {
      value: cdktf.stringToHclTerraform(struct!.check),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesMacOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesMac | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    if (this._check !== undefined) {
      hasAnyValues = true;
      internalValueResult.check = this._check;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesMac | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
      this._check = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
      this._check = value.check;
      this._type = value.type;
    }
  }

  // address - computed: false, optional: false, required: true
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }

  // check - computed: false, optional: true, required: false
  private _check?: string; 
  public get check() {
    return this.getStringAttribute('check');
  }
  public set check(value: string) {
    this._check = value;
  }
  public resetCheck() {
    this._check = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get checkInput() {
    return this._check;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DomainDevicesInterfacesModel {
  /**
  * Sets the NIC model name to present to the guest; valid values are user-provided model identifiers such as "virtio", "e1000", "rtl8139", etc.
  * 
  * See: <https://libvirt.org/formatdomain.html#setting-the-nic-model>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type: string;
}

export function domainDevicesInterfacesModelToTerraform(struct?: DomainDevicesInterfacesModel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function domainDevicesInterfacesModelToHclTerraform(struct?: DomainDevicesInterfacesModel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesModelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesModel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesModel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._type = value.type;
    }
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DomainDevicesInterfacesMtu {
  /**
  * Sets the MTU size for the virtual network link as a non-negative integer (for example, 1500 or 9000).
  * 
  * See: <https://libvirt.org/formatdomain.html#mtu-configuration>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#size Domain#size}
  */
  readonly size: number;
}

export function domainDevicesInterfacesMtuToTerraform(struct?: DomainDevicesInterfacesMtu | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    size: cdktf.numberToTerraform(struct!.size),
  }
}


export function domainDevicesInterfacesMtuToHclTerraform(struct?: DomainDevicesInterfacesMtu | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    size: {
      value: cdktf.numberToHclTerraform(struct!.size),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesMtuOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesMtu | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._size !== undefined) {
      hasAnyValues = true;
      internalValueResult.size = this._size;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesMtu | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._size = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._size = value.size;
    }
  }

  // size - computed: false, optional: false, required: true
  private _size?: number; 
  public get size() {
    return this.getNumberAttribute('size');
  }
  public set size(value: number) {
    this._size = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sizeInput() {
    return this._size;
  }
}
export interface DomainDevicesInterfacesPortForwardRanges {
  /**
  * Sets the last port in the forwarded range (inclusive); if omitted, the range effectively applies only to the start port.
  * 
  * See: <https://libvirt.org/formatdomain.html#userspace-connection-using-passt>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#end Domain#end}
  */
  readonly end?: number;
  /**
  * Indicates that this range is an exclusion from previously defined inclusive ranges; value is user-provided (for example, "yes" or "true") and treated as a presence/flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#userspace-connection-using-passt>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#exclude Domain#exclude}
  */
  readonly exclude?: string;
  /**
  * Sets the first host port in the forwarded range; must be an integer in the valid TCP/UDP port range (165535).
  * 
  * See: <https://libvirt.org/formatdomain.html#userspace-connection-using-passt>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#start Domain#start}
  */
  readonly start: number;
  /**
  * Sets the guest port to which traffic is forwarded; if omitted, the guest port defaults to the same number as the host start port.
  * 
  * See: <https://libvirt.org/formatdomain.html#userspace-connection-using-passt>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#to Domain#to}
  */
  readonly to?: number;
}

export function domainDevicesInterfacesPortForwardRangesToTerraform(struct?: DomainDevicesInterfacesPortForwardRanges | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    end: cdktf.numberToTerraform(struct!.end),
    exclude: cdktf.stringToTerraform(struct!.exclude),
    start: cdktf.numberToTerraform(struct!.start),
    to: cdktf.numberToTerraform(struct!.to),
  }
}


export function domainDevicesInterfacesPortForwardRangesToHclTerraform(struct?: DomainDevicesInterfacesPortForwardRanges | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    end: {
      value: cdktf.numberToHclTerraform(struct!.end),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    exclude: {
      value: cdktf.stringToHclTerraform(struct!.exclude),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    start: {
      value: cdktf.numberToHclTerraform(struct!.start),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    to: {
      value: cdktf.numberToHclTerraform(struct!.to),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesPortForwardRangesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesInterfacesPortForwardRanges | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._end !== undefined) {
      hasAnyValues = true;
      internalValueResult.end = this._end;
    }
    if (this._exclude !== undefined) {
      hasAnyValues = true;
      internalValueResult.exclude = this._exclude;
    }
    if (this._start !== undefined) {
      hasAnyValues = true;
      internalValueResult.start = this._start;
    }
    if (this._to !== undefined) {
      hasAnyValues = true;
      internalValueResult.to = this._to;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesPortForwardRanges | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._end = undefined;
      this._exclude = undefined;
      this._start = undefined;
      this._to = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._end = value.end;
      this._exclude = value.exclude;
      this._start = value.start;
      this._to = value.to;
    }
  }

  // end - computed: false, optional: true, required: false
  private _end?: number; 
  public get end() {
    return this.getNumberAttribute('end');
  }
  public set end(value: number) {
    this._end = value;
  }
  public resetEnd() {
    this._end = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endInput() {
    return this._end;
  }

  // exclude - computed: false, optional: true, required: false
  private _exclude?: string; 
  public get exclude() {
    return this.getStringAttribute('exclude');
  }
  public set exclude(value: string) {
    this._exclude = value;
  }
  public resetExclude() {
    this._exclude = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get excludeInput() {
    return this._exclude;
  }

  // start - computed: false, optional: false, required: true
  private _start?: number; 
  public get start() {
    return this.getNumberAttribute('start');
  }
  public set start(value: number) {
    this._start = value;
  }
  // Temporarily expose input value. Use with caution.
  public get startInput() {
    return this._start;
  }

  // to - computed: false, optional: true, required: false
  private _to?: number; 
  public get to() {
    return this.getNumberAttribute('to');
  }
  public set to(value: number) {
    this._to = value;
  }
  public resetTo() {
    this._to = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get toInput() {
    return this._to;
  }
}

export class DomainDevicesInterfacesPortForwardRangesList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesInterfacesPortForwardRanges[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesInterfacesPortForwardRangesOutputReference {
    return new DomainDevicesInterfacesPortForwardRangesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesInterfacesPortForward {
  /**
  * Sets the host IP address to listen on for forwarded ports; value is user-provided IPv4 or IPv6 address.
  * 
  * See: <https://libvirt.org/formatdomain.html#userspace-connection-using-passt>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: string;
  /**
  * Selects the host network device whose addresses are used as the source for forwarded connections; value is a user-provided interface name (for example, "eth0").
  * 
  * See: <https://libvirt.org/formatdomain.html#userspace-connection-using-passt>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dev Domain#dev}
  */
  readonly dev?: string;
  /**
  * Sets the IP protocol used for the forwarding rule, typically "tcp" or "udp"; value is required and user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#userspace-connection-using-passt>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#proto Domain#proto}
  */
  readonly proto: string;
  /**
  * Defines one or more port ranges to forward from host to guest for the selected protocol.
  * 
  * See: <https://libvirt.org/formatdomain.html#userspace-connection-using-passt>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#ranges Domain#ranges}
  */
  readonly ranges?: DomainDevicesInterfacesPortForwardRanges[] | cdktf.IResolvable;
}

export function domainDevicesInterfacesPortForwardToTerraform(struct?: DomainDevicesInterfacesPortForward | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
    dev: cdktf.stringToTerraform(struct!.dev),
    proto: cdktf.stringToTerraform(struct!.proto),
    ranges: cdktf.listMapper(domainDevicesInterfacesPortForwardRangesToTerraform, false)(struct!.ranges),
  }
}


export function domainDevicesInterfacesPortForwardToHclTerraform(struct?: DomainDevicesInterfacesPortForward | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dev: {
      value: cdktf.stringToHclTerraform(struct!.dev),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    proto: {
      value: cdktf.stringToHclTerraform(struct!.proto),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ranges: {
      value: cdktf.listMapperHcl(domainDevicesInterfacesPortForwardRangesToHclTerraform, false)(struct!.ranges),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesInterfacesPortForwardRangesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesPortForwardOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesInterfacesPortForward | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    if (this._dev !== undefined) {
      hasAnyValues = true;
      internalValueResult.dev = this._dev;
    }
    if (this._proto !== undefined) {
      hasAnyValues = true;
      internalValueResult.proto = this._proto;
    }
    if (this._ranges?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ranges = this._ranges?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesPortForward | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
      this._dev = undefined;
      this._proto = undefined;
      this._ranges.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
      this._dev = value.dev;
      this._proto = value.proto;
      this._ranges.internalValue = value.ranges;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  public resetAddress() {
    this._address = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }

  // dev - computed: false, optional: true, required: false
  private _dev?: string; 
  public get dev() {
    return this.getStringAttribute('dev');
  }
  public set dev(value: string) {
    this._dev = value;
  }
  public resetDev() {
    this._dev = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devInput() {
    return this._dev;
  }

  // proto - computed: false, optional: false, required: true
  private _proto?: string; 
  public get proto() {
    return this.getStringAttribute('proto');
  }
  public set proto(value: string) {
    this._proto = value;
  }
  // Temporarily expose input value. Use with caution.
  public get protoInput() {
    return this._proto;
  }

  // ranges - computed: false, optional: true, required: false
  private _ranges = new DomainDevicesInterfacesPortForwardRangesList(this, "ranges", false);
  public get ranges() {
    return this._ranges;
  }
  public putRanges(value: DomainDevicesInterfacesPortForwardRanges[] | cdktf.IResolvable) {
    this._ranges.internalValue = value;
  }
  public resetRanges() {
    this._ranges.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rangesInput() {
    return this._ranges.internalValue;
  }
}

export class DomainDevicesInterfacesPortForwardList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesInterfacesPortForward[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesInterfacesPortForwardOutputReference {
    return new DomainDevicesInterfacesPortForwardOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesInterfacesPortOptions {
  /**
  * Controls whether this interfaces traffic is isolated from other guests on the same virtual network; boolean-like string where "yes" isolates and "no" (or omission) does not.
  * 
  * See: <https://libvirt.org/formatdomain.html#isolating-guests-network-traffic-from-each-other>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#isolated Domain#isolated}
  */
  readonly isolated?: string;
}

export function domainDevicesInterfacesPortOptionsToTerraform(struct?: DomainDevicesInterfacesPortOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    isolated: cdktf.stringToTerraform(struct!.isolated),
  }
}


export function domainDevicesInterfacesPortOptionsToHclTerraform(struct?: DomainDevicesInterfacesPortOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    isolated: {
      value: cdktf.stringToHclTerraform(struct!.isolated),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesPortOptionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesPortOptions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._isolated !== undefined) {
      hasAnyValues = true;
      internalValueResult.isolated = this._isolated;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesPortOptions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._isolated = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._isolated = value.isolated;
    }
  }

  // isolated - computed: false, optional: true, required: false
  private _isolated?: string; 
  public get isolated() {
    return this.getStringAttribute('isolated');
  }
  public set isolated(value: string) {
    this._isolated = value;
  }
  public resetIsolated() {
    this._isolated = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get isolatedInput() {
    return this._isolated;
  }
}
export interface DomainDevicesInterfacesRom {
  /**
  * Controls whether the devices ROM is exposed in PCI BAR space, typically "on" or "off".
  * 
  * See: <https://libvirt.org/formatdomain.html#interface-rom-bios-configuration>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bar Domain#bar}
  */
  readonly bar?: string;
  /**
  * Enables or disables use of the ROM image for the host device, as a user-provided string flag (for example, "on"/"off" or "yes"/"no" depending on libvirt expectations).
  * 
  * See: <https://libvirt.org/formatdomain.html#interface-rom-bios-configuration>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enabled Domain#enabled}
  */
  readonly enabled?: string;
  /**
  * Specifies a path to a custom ROM file to use for the passthrough device (for example, "/usr/share/roms/nic.rom"); value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#interface-rom-bios-configuration>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file?: string;
}

export function domainDevicesInterfacesRomToTerraform(struct?: DomainDevicesInterfacesRom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bar: cdktf.stringToTerraform(struct!.bar),
    enabled: cdktf.stringToTerraform(struct!.enabled),
    file: cdktf.stringToTerraform(struct!.file),
  }
}


export function domainDevicesInterfacesRomToHclTerraform(struct?: DomainDevicesInterfacesRom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bar: {
      value: cdktf.stringToHclTerraform(struct!.bar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enabled: {
      value: cdktf.stringToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    file: {
      value: cdktf.stringToHclTerraform(struct!.file),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesRomOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesRom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bar !== undefined) {
      hasAnyValues = true;
      internalValueResult.bar = this._bar;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._file !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesRom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bar = undefined;
      this._enabled = undefined;
      this._file = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bar = value.bar;
      this._enabled = value.enabled;
      this._file = value.file;
    }
  }

  // bar - computed: false, optional: true, required: false
  private _bar?: string; 
  public get bar() {
    return this.getStringAttribute('bar');
  }
  public set bar(value: string) {
    this._bar = value;
  }
  public resetBar() {
    this._bar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get barInput() {
    return this._bar;
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: string; 
  public get enabled() {
    return this.getStringAttribute('enabled');
  }
  public set enabled(value: string) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // file - computed: false, optional: true, required: false
  private _file?: string; 
  public get file() {
    return this.getStringAttribute('file');
  }
  public set file(value: string) {
    this._file = value;
  }
  public resetFile() {
    this._file = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file;
  }
}
export interface DomainDevicesInterfacesRoute {
  /**
  * Sets the destination network address for the static route, as an IPv4 or IPv6 address depending on the family (for example, "192.168.10.0" or "2001:db8::").
  * 
  * See: <https://libvirt.org/formatdomain.html#ip-configuration>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address: string;
  /**
  * Specifies the address family for the route, typically "ipv4" or "ipv6"; if omitted, libvirt infers it from the address format.
  * 
  * See: <https://libvirt.org/formatdomain.html#ip-configuration>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#family Domain#family}
  */
  readonly family?: string;
  /**
  * Sets the gateway IP address used for the static route (must be in the same family as the route address, for example "192.168.10.1").
  * 
  * See: <https://libvirt.org/formatdomain.html#ip-configuration>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#gateway Domain#gateway}
  */
  readonly gateway: string;
  /**
  * Sets an optional numeric route metric (preference) for the static route, as a non-negative integer where lower values are preferred.
  * 
  * See: <https://libvirt.org/formatdomain.html#ip-configuration>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#metric Domain#metric}
  */
  readonly metric?: number;
  /**
  * Specifies the netmask for an IPv4 static route as a dotted-quad mask (for example, "255.255.255.0"); use prefix instead for IPv6 or CIDR-style configuration.
  * 
  * See: <https://libvirt.org/formatdomain.html#ip-configuration>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#netmask Domain#netmask}
  */
  readonly netmask?: string;
  /**
  * Specifies the prefix length for the route (for example, 24 for "192.168.10.0/24" or 64 for "2001:db8::/64"), used instead of netmask for CIDR-style configuration.
  * 
  * See: <https://libvirt.org/formatdomain.html#ip-configuration>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#prefix Domain#prefix}
  */
  readonly prefix?: number;
}

export function domainDevicesInterfacesRouteToTerraform(struct?: DomainDevicesInterfacesRoute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
    family: cdktf.stringToTerraform(struct!.family),
    gateway: cdktf.stringToTerraform(struct!.gateway),
    metric: cdktf.numberToTerraform(struct!.metric),
    netmask: cdktf.stringToTerraform(struct!.netmask),
    prefix: cdktf.numberToTerraform(struct!.prefix),
  }
}


export function domainDevicesInterfacesRouteToHclTerraform(struct?: DomainDevicesInterfacesRoute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    family: {
      value: cdktf.stringToHclTerraform(struct!.family),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    gateway: {
      value: cdktf.stringToHclTerraform(struct!.gateway),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metric: {
      value: cdktf.numberToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    netmask: {
      value: cdktf.stringToHclTerraform(struct!.netmask),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix: {
      value: cdktf.numberToHclTerraform(struct!.prefix),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesRouteOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesInterfacesRoute | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    if (this._family !== undefined) {
      hasAnyValues = true;
      internalValueResult.family = this._family;
    }
    if (this._gateway !== undefined) {
      hasAnyValues = true;
      internalValueResult.gateway = this._gateway;
    }
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    if (this._netmask !== undefined) {
      hasAnyValues = true;
      internalValueResult.netmask = this._netmask;
    }
    if (this._prefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefix = this._prefix;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesRoute | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
      this._family = undefined;
      this._gateway = undefined;
      this._metric = undefined;
      this._netmask = undefined;
      this._prefix = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
      this._family = value.family;
      this._gateway = value.gateway;
      this._metric = value.metric;
      this._netmask = value.netmask;
      this._prefix = value.prefix;
    }
  }

  // address - computed: false, optional: false, required: true
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }

  // family - computed: false, optional: true, required: false
  private _family?: string; 
  public get family() {
    return this.getStringAttribute('family');
  }
  public set family(value: string) {
    this._family = value;
  }
  public resetFamily() {
    this._family = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get familyInput() {
    return this._family;
  }

  // gateway - computed: false, optional: false, required: true
  private _gateway?: string; 
  public get gateway() {
    return this.getStringAttribute('gateway');
  }
  public set gateway(value: string) {
    this._gateway = value;
  }
  // Temporarily expose input value. Use with caution.
  public get gatewayInput() {
    return this._gateway;
  }

  // metric - computed: false, optional: true, required: false
  private _metric?: number; 
  public get metric() {
    return this.getNumberAttribute('metric');
  }
  public set metric(value: number) {
    this._metric = value;
  }
  public resetMetric() {
    this._metric = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }

  // netmask - computed: false, optional: true, required: false
  private _netmask?: string; 
  public get netmask() {
    return this.getStringAttribute('netmask');
  }
  public set netmask(value: string) {
    this._netmask = value;
  }
  public resetNetmask() {
    this._netmask = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get netmaskInput() {
    return this._netmask;
  }

  // prefix - computed: false, optional: true, required: false
  private _prefix?: number; 
  public get prefix() {
    return this.getNumberAttribute('prefix');
  }
  public set prefix(value: number) {
    this._prefix = value;
  }
  public resetPrefix() {
    this._prefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixInput() {
    return this._prefix;
  }
}

export class DomainDevicesInterfacesRouteList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesInterfacesRoute[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesInterfacesRouteOutputReference {
    return new DomainDevicesInterfacesRouteOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesInterfacesScript {
  /**
  * Sets the absolute or relative filesystem path to the script that is run when the interface is torn down (for example, "/etc/qemu-ifdown").
  * 
  * See: <https://libvirt.org/formatdomain.html#generic-ethernet-connection>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
}

export function domainDevicesInterfacesScriptToTerraform(struct?: DomainDevicesInterfacesScript | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function domainDevicesInterfacesScriptToHclTerraform(struct?: DomainDevicesInterfacesScript | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesScriptOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesScript | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesScript | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface DomainDevicesInterfacesSourceBridge {
  /**
  * Sets the name of the existing host bridge device to which the interface connects (for example, "br0").
  * 
  * See: <https://libvirt.org/formatdomain.html#bridge-to-lan>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bridge Domain#bridge}
  */
  readonly bridge: string;
}

export function domainDevicesInterfacesSourceBridgeToTerraform(struct?: DomainDevicesInterfacesSourceBridge | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bridge: cdktf.stringToTerraform(struct!.bridge),
  }
}


export function domainDevicesInterfacesSourceBridgeToHclTerraform(struct?: DomainDevicesInterfacesSourceBridge | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bridge: {
      value: cdktf.stringToHclTerraform(struct!.bridge),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesSourceBridgeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesSourceBridge | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bridge !== undefined) {
      hasAnyValues = true;
      internalValueResult.bridge = this._bridge;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesSourceBridge | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bridge = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bridge = value.bridge;
    }
  }

  // bridge - computed: false, optional: false, required: true
  private _bridge?: string; 
  public get bridge() {
    return this.getStringAttribute('bridge');
  }
  public set bridge(value: string) {
    this._bridge = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bridgeInput() {
    return this._bridge;
  }
}
export interface DomainDevicesInterfacesSourceClientLocal {
  /**
  * Sets the local IP address on which the UDP tunnel-backed interface listens; value is user-provided (e.g. "0.0.0.0" or a specific host address).
  * 
  * See: <https://libvirt.org/formatdomain.html#udp-unicast-tunnel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: string;
  /**
  * Sets the local UDP port on which the tunnel-backed interface listens; value is a user-provided non-negative integer (e.g. 5000).
  * 
  * See: <https://libvirt.org/formatdomain.html#udp-unicast-tunnel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#port Domain#port}
  */
  readonly port?: number;
}

export function domainDevicesInterfacesSourceClientLocalToTerraform(struct?: DomainDevicesInterfacesSourceClientLocal | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
    port: cdktf.numberToTerraform(struct!.port),
  }
}


export function domainDevicesInterfacesSourceClientLocalToHclTerraform(struct?: DomainDevicesInterfacesSourceClientLocal | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesSourceClientLocalOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesSourceClientLocal | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesSourceClientLocal | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
      this._port = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
      this._port = value.port;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  public resetAddress() {
    this._address = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }
}
export interface DomainDevicesInterfacesSourceClient {
  /**
  * Sets the remote peers IP or hostname for the tunnel client connection (user-provided, e.g. "10.0.0.1" or "example.com").
  * 
  * See: <https://libvirt.org/formatdomain.html#tcp-tunnel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: string;
  /**
  * Configures the local (listening) endpoint for a UDP tunnel-backed network interface, enabling the guest-side address/port to be fixed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#local Domain#local}
  */
  readonly local?: DomainDevicesInterfacesSourceClientLocal;
  /**
  * Sets the remote port number for the tunnels client connection, as a decimal TCP or UDP port (for example, 1194).
  * 
  * See: <https://libvirt.org/formatdomain.html#tcp-tunnel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#port Domain#port}
  */
  readonly port?: number;
}

export function domainDevicesInterfacesSourceClientToTerraform(struct?: DomainDevicesInterfacesSourceClient | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
    local: domainDevicesInterfacesSourceClientLocalToTerraform(struct!.local),
    port: cdktf.numberToTerraform(struct!.port),
  }
}


export function domainDevicesInterfacesSourceClientToHclTerraform(struct?: DomainDevicesInterfacesSourceClient | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    local: {
      value: domainDevicesInterfacesSourceClientLocalToHclTerraform(struct!.local),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesInterfacesSourceClientLocal",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesSourceClientOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesSourceClient | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    if (this._local?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.local = this._local?.internalValue;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesSourceClient | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
      this._local.internalValue = undefined;
      this._port = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
      this._local.internalValue = value.local;
      this._port = value.port;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  public resetAddress() {
    this._address = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }

  // local - computed: false, optional: true, required: false
  private _local = new DomainDevicesInterfacesSourceClientLocalOutputReference(this, "local");
  public get local() {
    return this._local;
  }
  public putLocal(value: DomainDevicesInterfacesSourceClientLocal) {
    this._local.internalValue = value;
  }
  public resetLocal() {
    this._local.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localInput() {
    return this._local.internalValue;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }
}
export interface DomainDevicesInterfacesSourceDirect {
  /**
  * Sets the name of the host network interface (e.g. `eth0`, `eno1`) that is directly attached to the guest via a macvtap direct interface.
  * 
  * See: <https://libvirt.org/formatdomain.html#direct-attachment-to-physical-interface>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dev Domain#dev}
  */
  readonly dev?: string;
  /**
  * Sets the direct attachment mode for a macvtap direct interface; valid values are user-provided strings such as `vepa`, `bridge`, `private`, or `passthrough` as supported by libvirt/qemu.
  * 
  * See: <https://libvirt.org/formatdomain.html#direct-attachment-to-physical-interface>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode?: string;
}

export function domainDevicesInterfacesSourceDirectToTerraform(struct?: DomainDevicesInterfacesSourceDirect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dev: cdktf.stringToTerraform(struct!.dev),
    mode: cdktf.stringToTerraform(struct!.mode),
  }
}


export function domainDevicesInterfacesSourceDirectToHclTerraform(struct?: DomainDevicesInterfacesSourceDirect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dev: {
      value: cdktf.stringToHclTerraform(struct!.dev),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesSourceDirectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesSourceDirect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dev !== undefined) {
      hasAnyValues = true;
      internalValueResult.dev = this._dev;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesSourceDirect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dev = undefined;
      this._mode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dev = value.dev;
      this._mode = value.mode;
    }
  }

  // dev - computed: false, optional: true, required: false
  private _dev?: string; 
  public get dev() {
    return this.getStringAttribute('dev');
  }
  public set dev(value: string) {
    this._dev = value;
  }
  public resetDev() {
    this._dev = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devInput() {
    return this._dev;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }
}
export interface DomainDevicesInterfacesSourceEthernetIp {
  /**
  * Sets the IP address assigned to the interface in the guest; must be a valid IPv4 or IPv6 address string (for example, "192.168.122.10" or "2001:db8::10").
  * 
  * See: <https://libvirt.org/formatdomain.html#ip-configuration>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address: string;
  /**
  * Selects the address family for the interface IP, typically "ipv4" or "ipv6"; if omitted, libvirt infers it from the address format.
  * 
  * See: <https://libvirt.org/formatdomain.html#ip-configuration>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#family Domain#family}
  */
  readonly family?: string;
  /**
  * Sets the peer address for point-to-point style links, as a valid IPv4 or IPv6 address string; value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#ip-configuration>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#peer Domain#peer}
  */
  readonly peer?: string;
  /**
  * Sets the prefix length (CIDR) for the interface IP address as a non-negative integer (for example, 24 for "192.168.122.0/24").
  * 
  * See: <https://libvirt.org/formatdomain.html#ip-configuration>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#prefix Domain#prefix}
  */
  readonly prefix?: number;
}

export function domainDevicesInterfacesSourceEthernetIpToTerraform(struct?: DomainDevicesInterfacesSourceEthernetIp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
    family: cdktf.stringToTerraform(struct!.family),
    peer: cdktf.stringToTerraform(struct!.peer),
    prefix: cdktf.numberToTerraform(struct!.prefix),
  }
}


export function domainDevicesInterfacesSourceEthernetIpToHclTerraform(struct?: DomainDevicesInterfacesSourceEthernetIp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    family: {
      value: cdktf.stringToHclTerraform(struct!.family),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    peer: {
      value: cdktf.stringToHclTerraform(struct!.peer),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix: {
      value: cdktf.numberToHclTerraform(struct!.prefix),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesSourceEthernetIpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesInterfacesSourceEthernetIp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    if (this._family !== undefined) {
      hasAnyValues = true;
      internalValueResult.family = this._family;
    }
    if (this._peer !== undefined) {
      hasAnyValues = true;
      internalValueResult.peer = this._peer;
    }
    if (this._prefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefix = this._prefix;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesSourceEthernetIp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
      this._family = undefined;
      this._peer = undefined;
      this._prefix = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
      this._family = value.family;
      this._peer = value.peer;
      this._prefix = value.prefix;
    }
  }

  // address - computed: false, optional: false, required: true
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }

  // family - computed: false, optional: true, required: false
  private _family?: string; 
  public get family() {
    return this.getStringAttribute('family');
  }
  public set family(value: string) {
    this._family = value;
  }
  public resetFamily() {
    this._family = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get familyInput() {
    return this._family;
  }

  // peer - computed: false, optional: true, required: false
  private _peer?: string; 
  public get peer() {
    return this.getStringAttribute('peer');
  }
  public set peer(value: string) {
    this._peer = value;
  }
  public resetPeer() {
    this._peer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get peerInput() {
    return this._peer;
  }

  // prefix - computed: false, optional: true, required: false
  private _prefix?: number; 
  public get prefix() {
    return this.getNumberAttribute('prefix');
  }
  public set prefix(value: number) {
    this._prefix = value;
  }
  public resetPrefix() {
    this._prefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixInput() {
    return this._prefix;
  }
}

export class DomainDevicesInterfacesSourceEthernetIpList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesInterfacesSourceEthernetIp[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesInterfacesSourceEthernetIpOutputReference {
    return new DomainDevicesInterfacesSourceEthernetIpOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesInterfacesSourceEthernetRoute {
  /**
  * Sets the destination network address for the static route, as an IPv4 or IPv6 address depending on the family (for example, "192.168.10.0" or "2001:db8::").
  * 
  * See: <https://libvirt.org/formatdomain.html#ip-configuration>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address: string;
  /**
  * Specifies the address family for the route, typically "ipv4" or "ipv6"; if omitted, libvirt infers it from the address format.
  * 
  * See: <https://libvirt.org/formatdomain.html#ip-configuration>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#family Domain#family}
  */
  readonly family?: string;
  /**
  * Sets the gateway IP address used for the static route (must be in the same family as the route address, for example "192.168.10.1").
  * 
  * See: <https://libvirt.org/formatdomain.html#ip-configuration>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#gateway Domain#gateway}
  */
  readonly gateway: string;
  /**
  * Sets an optional numeric route metric (preference) for the static route, as a non-negative integer where lower values are preferred.
  * 
  * See: <https://libvirt.org/formatdomain.html#ip-configuration>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#metric Domain#metric}
  */
  readonly metric?: number;
  /**
  * Specifies the netmask for an IPv4 static route as a dotted-quad mask (for example, "255.255.255.0"); use prefix instead for IPv6 or CIDR-style configuration.
  * 
  * See: <https://libvirt.org/formatdomain.html#ip-configuration>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#netmask Domain#netmask}
  */
  readonly netmask?: string;
  /**
  * Specifies the prefix length for the route (for example, 24 for "192.168.10.0/24" or 64 for "2001:db8::/64"), used instead of netmask for CIDR-style configuration.
  * 
  * See: <https://libvirt.org/formatdomain.html#ip-configuration>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#prefix Domain#prefix}
  */
  readonly prefix?: number;
}

export function domainDevicesInterfacesSourceEthernetRouteToTerraform(struct?: DomainDevicesInterfacesSourceEthernetRoute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
    family: cdktf.stringToTerraform(struct!.family),
    gateway: cdktf.stringToTerraform(struct!.gateway),
    metric: cdktf.numberToTerraform(struct!.metric),
    netmask: cdktf.stringToTerraform(struct!.netmask),
    prefix: cdktf.numberToTerraform(struct!.prefix),
  }
}


export function domainDevicesInterfacesSourceEthernetRouteToHclTerraform(struct?: DomainDevicesInterfacesSourceEthernetRoute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    family: {
      value: cdktf.stringToHclTerraform(struct!.family),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    gateway: {
      value: cdktf.stringToHclTerraform(struct!.gateway),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metric: {
      value: cdktf.numberToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    netmask: {
      value: cdktf.stringToHclTerraform(struct!.netmask),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix: {
      value: cdktf.numberToHclTerraform(struct!.prefix),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesSourceEthernetRouteOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesInterfacesSourceEthernetRoute | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    if (this._family !== undefined) {
      hasAnyValues = true;
      internalValueResult.family = this._family;
    }
    if (this._gateway !== undefined) {
      hasAnyValues = true;
      internalValueResult.gateway = this._gateway;
    }
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    if (this._netmask !== undefined) {
      hasAnyValues = true;
      internalValueResult.netmask = this._netmask;
    }
    if (this._prefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefix = this._prefix;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesSourceEthernetRoute | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
      this._family = undefined;
      this._gateway = undefined;
      this._metric = undefined;
      this._netmask = undefined;
      this._prefix = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
      this._family = value.family;
      this._gateway = value.gateway;
      this._metric = value.metric;
      this._netmask = value.netmask;
      this._prefix = value.prefix;
    }
  }

  // address - computed: false, optional: false, required: true
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }

  // family - computed: false, optional: true, required: false
  private _family?: string; 
  public get family() {
    return this.getStringAttribute('family');
  }
  public set family(value: string) {
    this._family = value;
  }
  public resetFamily() {
    this._family = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get familyInput() {
    return this._family;
  }

  // gateway - computed: false, optional: false, required: true
  private _gateway?: string; 
  public get gateway() {
    return this.getStringAttribute('gateway');
  }
  public set gateway(value: string) {
    this._gateway = value;
  }
  // Temporarily expose input value. Use with caution.
  public get gatewayInput() {
    return this._gateway;
  }

  // metric - computed: false, optional: true, required: false
  private _metric?: number; 
  public get metric() {
    return this.getNumberAttribute('metric');
  }
  public set metric(value: number) {
    this._metric = value;
  }
  public resetMetric() {
    this._metric = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }

  // netmask - computed: false, optional: true, required: false
  private _netmask?: string; 
  public get netmask() {
    return this.getStringAttribute('netmask');
  }
  public set netmask(value: string) {
    this._netmask = value;
  }
  public resetNetmask() {
    this._netmask = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get netmaskInput() {
    return this._netmask;
  }

  // prefix - computed: false, optional: true, required: false
  private _prefix?: number; 
  public get prefix() {
    return this.getNumberAttribute('prefix');
  }
  public set prefix(value: number) {
    this._prefix = value;
  }
  public resetPrefix() {
    this._prefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixInput() {
    return this._prefix;
  }
}

export class DomainDevicesInterfacesSourceEthernetRouteList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesInterfacesSourceEthernetRoute[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesInterfacesSourceEthernetRouteOutputReference {
    return new DomainDevicesInterfacesSourceEthernetRouteOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesInterfacesSourceEthernet {
  /**
  * Configures an IP address to assign inside the guest for this ethernet interface, including address, family, prefix, and optional peer.
  * 
  * See: <https://libvirt.org/formatdomain.html#ip-configuration>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#ip Domain#ip}
  */
  readonly ip?: DomainDevicesInterfacesSourceEthernetIp[] | cdktf.IResolvable;
  /**
  * Defines a static route associated with this ethernet interface inside the guest, including destination, gateway, and optional metric or netmask/prefix.
  * 
  * See: <https://libvirt.org/formatdomain.html#ip-configuration>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#route Domain#route}
  */
  readonly route?: DomainDevicesInterfacesSourceEthernetRoute[] | cdktf.IResolvable;
}

export function domainDevicesInterfacesSourceEthernetToTerraform(struct?: DomainDevicesInterfacesSourceEthernet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ip: cdktf.listMapper(domainDevicesInterfacesSourceEthernetIpToTerraform, false)(struct!.ip),
    route: cdktf.listMapper(domainDevicesInterfacesSourceEthernetRouteToTerraform, false)(struct!.route),
  }
}


export function domainDevicesInterfacesSourceEthernetToHclTerraform(struct?: DomainDevicesInterfacesSourceEthernet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ip: {
      value: cdktf.listMapperHcl(domainDevicesInterfacesSourceEthernetIpToHclTerraform, false)(struct!.ip),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesInterfacesSourceEthernetIpList",
    },
    route: {
      value: cdktf.listMapperHcl(domainDevicesInterfacesSourceEthernetRouteToHclTerraform, false)(struct!.route),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesInterfacesSourceEthernetRouteList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesSourceEthernetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesSourceEthernet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ip?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ip = this._ip?.internalValue;
    }
    if (this._route?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.route = this._route?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesSourceEthernet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ip.internalValue = undefined;
      this._route.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ip.internalValue = value.ip;
      this._route.internalValue = value.route;
    }
  }

  // ip - computed: false, optional: true, required: false
  private _ip = new DomainDevicesInterfacesSourceEthernetIpList(this, "ip", false);
  public get ip() {
    return this._ip;
  }
  public putIp(value: DomainDevicesInterfacesSourceEthernetIp[] | cdktf.IResolvable) {
    this._ip.internalValue = value;
  }
  public resetIp() {
    this._ip.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipInput() {
    return this._ip.internalValue;
  }

  // route - computed: false, optional: true, required: false
  private _route = new DomainDevicesInterfacesSourceEthernetRouteList(this, "route", false);
  public get route() {
    return this._route;
  }
  public putRoute(value: DomainDevicesInterfacesSourceEthernetRoute[] | cdktf.IResolvable) {
    this._route.internalValue = value;
  }
  public resetRoute() {
    this._route.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeInput() {
    return this._route.internalValue;
  }
}
export interface DomainDevicesInterfacesSourceHostdevPciAddressZpci {
  /**
  * Sets the function ID (fid) for a zPCI device on s390x, identifying the specific zPCI function to passthrough; the value is user-provided and must match the host's zPCI configuration.
  * 
  * See: <https://libvirt.org/formatdomain.html#device-addresses>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#fid Domain#fid}
  */
  readonly fid?: number;
  /**
  * Sets the zPCI function UID for a passed-through PCI device on s390x, identifying the zPCI function within the guest; the value is user-provided and must match the host zPCI configuration.
  * 
  * See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#uid Domain#uid}
  */
  readonly uid?: number;
}

export function domainDevicesInterfacesSourceHostdevPciAddressZpciToTerraform(struct?: DomainDevicesInterfacesSourceHostdevPciAddressZpci | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fid: cdktf.numberToTerraform(struct!.fid),
    uid: cdktf.numberToTerraform(struct!.uid),
  }
}


export function domainDevicesInterfacesSourceHostdevPciAddressZpciToHclTerraform(struct?: DomainDevicesInterfacesSourceHostdevPciAddressZpci | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fid: {
      value: cdktf.numberToHclTerraform(struct!.fid),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    uid: {
      value: cdktf.numberToHclTerraform(struct!.uid),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesSourceHostdevPciAddressZpciOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesSourceHostdevPciAddressZpci | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fid !== undefined) {
      hasAnyValues = true;
      internalValueResult.fid = this._fid;
    }
    if (this._uid !== undefined) {
      hasAnyValues = true;
      internalValueResult.uid = this._uid;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesSourceHostdevPciAddressZpci | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fid = undefined;
      this._uid = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fid = value.fid;
      this._uid = value.uid;
    }
  }

  // fid - computed: false, optional: true, required: false
  private _fid?: number; 
  public get fid() {
    return this.getNumberAttribute('fid');
  }
  public set fid(value: number) {
    this._fid = value;
  }
  public resetFid() {
    this._fid = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fidInput() {
    return this._fid;
  }

  // uid - computed: false, optional: true, required: false
  private _uid?: number; 
  public get uid() {
    return this.getNumberAttribute('uid');
  }
  public set uid(value: number) {
    this._uid = value;
  }
  public resetUid() {
    this._uid = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get uidInput() {
    return this._uid;
  }
}
export interface DomainDevicesInterfacesSourceHostdevPciAddress {
  /**
  * Sets the PCI bus number of the host device to passthrough; the value is usually a hexadecimal or decimal bus index matching the host's PCI topology (for example, "0x03").
  * 
  * See: <https://libvirt.org/formatdomain.html#device-addresses>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bus Domain#bus}
  */
  readonly bus?: number;
  /**
  * Sets the PCI domain number of the host device (segment), typically "0" on most systems; the value must match the device's domain as reported by tools like lspci.
  * 
  * See: <https://libvirt.org/formatdomain.html#device-addresses>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#domain Domain#domain}
  */
  readonly domain?: number;
  /**
  * Sets the PCI function number of the host device (07), usually provided as a small integer or hex string (for example, "0" or "0x0") corresponding to the device's function.
  * 
  * See: <https://libvirt.org/formatdomain.html#device-addresses>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#function Domain#function}
  */
  readonly function?: number;
  /**
  * Indicates whether the PCI device is part of a multifunction PCI slot; accepts "on"/"off" as yes/no flags.
  * 
  * See: <https://libvirt.org/formatdomain.html#device-addresses>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#multi_function Domain#multi_function}
  */
  readonly multiFunction?: string;
  /**
  * Sets the PCI slot number of the host device, usually as a hex or decimal value (for example, "0x00" or "0") matching the slot shown by lspci.
  * 
  * See: <https://libvirt.org/formatdomain.html#device-addresses>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#slot Domain#slot}
  */
  readonly slot?: number;
  /**
  * Groups additional addressing attributes for s390x zPCI devices, used when passing through PCI devices on IBM Z systems.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#zpci Domain#zpci}
  */
  readonly zpci?: DomainDevicesInterfacesSourceHostdevPciAddressZpci;
}

export function domainDevicesInterfacesSourceHostdevPciAddressToTerraform(struct?: DomainDevicesInterfacesSourceHostdevPciAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bus: cdktf.numberToTerraform(struct!.bus),
    domain: cdktf.numberToTerraform(struct!.domain),
    function: cdktf.numberToTerraform(struct!.function),
    multi_function: cdktf.stringToTerraform(struct!.multiFunction),
    slot: cdktf.numberToTerraform(struct!.slot),
    zpci: domainDevicesInterfacesSourceHostdevPciAddressZpciToTerraform(struct!.zpci),
  }
}


export function domainDevicesInterfacesSourceHostdevPciAddressToHclTerraform(struct?: DomainDevicesInterfacesSourceHostdevPciAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bus: {
      value: cdktf.numberToHclTerraform(struct!.bus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    domain: {
      value: cdktf.numberToHclTerraform(struct!.domain),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    function: {
      value: cdktf.numberToHclTerraform(struct!.function),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    multi_function: {
      value: cdktf.stringToHclTerraform(struct!.multiFunction),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    slot: {
      value: cdktf.numberToHclTerraform(struct!.slot),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    zpci: {
      value: domainDevicesInterfacesSourceHostdevPciAddressZpciToHclTerraform(struct!.zpci),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesInterfacesSourceHostdevPciAddressZpci",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesSourceHostdevPciAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesSourceHostdevPciAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bus !== undefined) {
      hasAnyValues = true;
      internalValueResult.bus = this._bus;
    }
    if (this._domain !== undefined) {
      hasAnyValues = true;
      internalValueResult.domain = this._domain;
    }
    if (this._function !== undefined) {
      hasAnyValues = true;
      internalValueResult.function = this._function;
    }
    if (this._multiFunction !== undefined) {
      hasAnyValues = true;
      internalValueResult.multiFunction = this._multiFunction;
    }
    if (this._slot !== undefined) {
      hasAnyValues = true;
      internalValueResult.slot = this._slot;
    }
    if (this._zpci?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.zpci = this._zpci?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesSourceHostdevPciAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bus = undefined;
      this._domain = undefined;
      this._function = undefined;
      this._multiFunction = undefined;
      this._slot = undefined;
      this._zpci.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bus = value.bus;
      this._domain = value.domain;
      this._function = value.function;
      this._multiFunction = value.multiFunction;
      this._slot = value.slot;
      this._zpci.internalValue = value.zpci;
    }
  }

  // bus - computed: false, optional: true, required: false
  private _bus?: number; 
  public get bus() {
    return this.getNumberAttribute('bus');
  }
  public set bus(value: number) {
    this._bus = value;
  }
  public resetBus() {
    this._bus = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get busInput() {
    return this._bus;
  }

  // domain - computed: false, optional: true, required: false
  private _domain?: number; 
  public get domain() {
    return this.getNumberAttribute('domain');
  }
  public set domain(value: number) {
    this._domain = value;
  }
  public resetDomain() {
    this._domain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get domainInput() {
    return this._domain;
  }

  // function - computed: false, optional: true, required: false
  private _function?: number; 
  public get function() {
    return this.getNumberAttribute('function');
  }
  public set function(value: number) {
    this._function = value;
  }
  public resetFunction() {
    this._function = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get functionInput() {
    return this._function;
  }

  // multi_function - computed: false, optional: true, required: false
  private _multiFunction?: string; 
  public get multiFunction() {
    return this.getStringAttribute('multi_function');
  }
  public set multiFunction(value: string) {
    this._multiFunction = value;
  }
  public resetMultiFunction() {
    this._multiFunction = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get multiFunctionInput() {
    return this._multiFunction;
  }

  // slot - computed: false, optional: true, required: false
  private _slot?: number; 
  public get slot() {
    return this.getNumberAttribute('slot');
  }
  public set slot(value: number) {
    this._slot = value;
  }
  public resetSlot() {
    this._slot = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get slotInput() {
    return this._slot;
  }

  // zpci - computed: false, optional: true, required: false
  private _zpci = new DomainDevicesInterfacesSourceHostdevPciAddressZpciOutputReference(this, "zpci");
  public get zpci() {
    return this._zpci;
  }
  public putZpci(value: DomainDevicesInterfacesSourceHostdevPciAddressZpci) {
    this._zpci.internalValue = value;
  }
  public resetZpci() {
    this._zpci.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get zpciInput() {
    return this._zpci.internalValue;
  }
}
export interface DomainDevicesInterfacesSourceHostdevPci {
  /**
  * Defines the host PCI address of the device to passthrough, typically via domain, bus, slot, and function (and optional zPCI info on s390x).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: DomainDevicesInterfacesSourceHostdevPciAddress;
  /**
  * Controls whether write filtering is enabled for a PCI passthrough device, typically to restrict or filter MMIO/PCI configuration writes; accepts user-provided value as defined by libvirt (for example "on" or "off").
  * 
  * See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#write_filtering Domain#write_filtering}
  */
  readonly writeFiltering?: string;
}

export function domainDevicesInterfacesSourceHostdevPciToTerraform(struct?: DomainDevicesInterfacesSourceHostdevPci | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: domainDevicesInterfacesSourceHostdevPciAddressToTerraform(struct!.address),
    write_filtering: cdktf.stringToTerraform(struct!.writeFiltering),
  }
}


export function domainDevicesInterfacesSourceHostdevPciToHclTerraform(struct?: DomainDevicesInterfacesSourceHostdevPci | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: domainDevicesInterfacesSourceHostdevPciAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesInterfacesSourceHostdevPciAddress",
    },
    write_filtering: {
      value: cdktf.stringToHclTerraform(struct!.writeFiltering),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesSourceHostdevPciOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesSourceHostdevPci | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._writeFiltering !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeFiltering = this._writeFiltering;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesSourceHostdevPci | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._writeFiltering = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._writeFiltering = value.writeFiltering;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address = new DomainDevicesInterfacesSourceHostdevPciAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DomainDevicesInterfacesSourceHostdevPciAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // write_filtering - computed: false, optional: true, required: false
  private _writeFiltering?: string; 
  public get writeFiltering() {
    return this.getStringAttribute('write_filtering');
  }
  public set writeFiltering(value: string) {
    this._writeFiltering = value;
  }
  public resetWriteFiltering() {
    this._writeFiltering = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeFilteringInput() {
    return this._writeFiltering;
  }
}
export interface DomainDevicesInterfacesSourceHostdevUsbAddress {
  /**
  * Sets the numeric USB bus on the host where the device is attached; value is user-provided as reported by tools like `lsusb` (for example, `1`).
  * 
  * See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bus Domain#bus}
  */
  readonly bus?: number;
  /**
  * Sets the numeric USB device number on the selected bus; value is user-provided based on host enumeration (for example, `2`).
  * 
  * See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#device Domain#device}
  */
  readonly device?: number;
  /**
  * Sets the USB port path on the host (often a dotseparated string like `1` or `1.2`) to identify the device by its hub/port topology.
  * 
  * See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#port Domain#port}
  */
  readonly port?: string;
}

export function domainDevicesInterfacesSourceHostdevUsbAddressToTerraform(struct?: DomainDevicesInterfacesSourceHostdevUsbAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bus: cdktf.numberToTerraform(struct!.bus),
    device: cdktf.numberToTerraform(struct!.device),
    port: cdktf.stringToTerraform(struct!.port),
  }
}


export function domainDevicesInterfacesSourceHostdevUsbAddressToHclTerraform(struct?: DomainDevicesInterfacesSourceHostdevUsbAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bus: {
      value: cdktf.numberToHclTerraform(struct!.bus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    device: {
      value: cdktf.numberToHclTerraform(struct!.device),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port: {
      value: cdktf.stringToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesSourceHostdevUsbAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesSourceHostdevUsbAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bus !== undefined) {
      hasAnyValues = true;
      internalValueResult.bus = this._bus;
    }
    if (this._device !== undefined) {
      hasAnyValues = true;
      internalValueResult.device = this._device;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesSourceHostdevUsbAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bus = undefined;
      this._device = undefined;
      this._port = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bus = value.bus;
      this._device = value.device;
      this._port = value.port;
    }
  }

  // bus - computed: false, optional: true, required: false
  private _bus?: number; 
  public get bus() {
    return this.getNumberAttribute('bus');
  }
  public set bus(value: number) {
    this._bus = value;
  }
  public resetBus() {
    this._bus = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get busInput() {
    return this._bus;
  }

  // device - computed: false, optional: true, required: false
  private _device?: number; 
  public get device() {
    return this.getNumberAttribute('device');
  }
  public set device(value: number) {
    this._device = value;
  }
  public resetDevice() {
    this._device = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deviceInput() {
    return this._device;
  }

  // port - computed: false, optional: true, required: false
  private _port?: string; 
  public get port() {
    return this.getStringAttribute('port');
  }
  public set port(value: string) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }
}
export interface DomainDevicesInterfacesSourceHostdevUsbProduct {
}

export function domainDevicesInterfacesSourceHostdevUsbProductToTerraform(struct?: DomainDevicesInterfacesSourceHostdevUsbProduct | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function domainDevicesInterfacesSourceHostdevUsbProductToHclTerraform(struct?: DomainDevicesInterfacesSourceHostdevUsbProduct | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DomainDevicesInterfacesSourceHostdevUsbProductOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesSourceHostdevUsbProduct | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesSourceHostdevUsbProduct | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }

  // id - computed: true, optional: false, required: false
  public get id() {
    return this.getStringAttribute('id');
  }
}
export interface DomainDevicesInterfacesSourceHostdevUsbVendor {
}

export function domainDevicesInterfacesSourceHostdevUsbVendorToTerraform(struct?: DomainDevicesInterfacesSourceHostdevUsbVendor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function domainDevicesInterfacesSourceHostdevUsbVendorToHclTerraform(struct?: DomainDevicesInterfacesSourceHostdevUsbVendor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DomainDevicesInterfacesSourceHostdevUsbVendorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesSourceHostdevUsbVendor | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesSourceHostdevUsbVendor | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }

  // id - computed: true, optional: false, required: false
  public get id() {
    return this.getStringAttribute('id');
  }
}
export interface DomainDevicesInterfacesSourceHostdevUsb {
  /**
  * Specifies the physical USB topology of the host device (bus, device, and/or port) used to select which USB device is passed through.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: DomainDevicesInterfacesSourceHostdevUsbAddress;
  /**
  * Controls whether a reset is issued to the USB device when it is assigned or re-assigned to the guest; value is user-provided (typically `on`/`off` or `yes`/`no` depending on libvirt version).
  * 
  * See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#guest_reset Domain#guest_reset}
  */
  readonly guestReset?: string;
  /**
  * Selects a USB device for passthrough by its vendor ID, typically used together with `source.product`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#product Domain#product}
  */
  readonly product?: DomainDevicesInterfacesSourceHostdevUsbProduct;
  /**
  * Sets how strictly libvirt enforces the presence of the USB device at startup; accepts values like `mandatory`, `requisite`, or `optional` depending on libvirt support.
  * 
  * See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#start_up_policy Domain#start_up_policy}
  */
  readonly startUpPolicy?: string;
  /**
  * Selects a USB device for passthrough by its vendor ID, typically used together with `source.product`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vendor Domain#vendor}
  */
  readonly vendor?: DomainDevicesInterfacesSourceHostdevUsbVendor;
}

export function domainDevicesInterfacesSourceHostdevUsbToTerraform(struct?: DomainDevicesInterfacesSourceHostdevUsb | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: domainDevicesInterfacesSourceHostdevUsbAddressToTerraform(struct!.address),
    guest_reset: cdktf.stringToTerraform(struct!.guestReset),
    product: domainDevicesInterfacesSourceHostdevUsbProductToTerraform(struct!.product),
    start_up_policy: cdktf.stringToTerraform(struct!.startUpPolicy),
    vendor: domainDevicesInterfacesSourceHostdevUsbVendorToTerraform(struct!.vendor),
  }
}


export function domainDevicesInterfacesSourceHostdevUsbToHclTerraform(struct?: DomainDevicesInterfacesSourceHostdevUsb | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: domainDevicesInterfacesSourceHostdevUsbAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesInterfacesSourceHostdevUsbAddress",
    },
    guest_reset: {
      value: cdktf.stringToHclTerraform(struct!.guestReset),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    product: {
      value: domainDevicesInterfacesSourceHostdevUsbProductToHclTerraform(struct!.product),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesInterfacesSourceHostdevUsbProduct",
    },
    start_up_policy: {
      value: cdktf.stringToHclTerraform(struct!.startUpPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    vendor: {
      value: domainDevicesInterfacesSourceHostdevUsbVendorToHclTerraform(struct!.vendor),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesInterfacesSourceHostdevUsbVendor",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesSourceHostdevUsbOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesSourceHostdevUsb | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._guestReset !== undefined) {
      hasAnyValues = true;
      internalValueResult.guestReset = this._guestReset;
    }
    if (this._product?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.product = this._product?.internalValue;
    }
    if (this._startUpPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.startUpPolicy = this._startUpPolicy;
    }
    if (this._vendor?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.vendor = this._vendor?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesSourceHostdevUsb | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._guestReset = undefined;
      this._product.internalValue = undefined;
      this._startUpPolicy = undefined;
      this._vendor.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._guestReset = value.guestReset;
      this._product.internalValue = value.product;
      this._startUpPolicy = value.startUpPolicy;
      this._vendor.internalValue = value.vendor;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address = new DomainDevicesInterfacesSourceHostdevUsbAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DomainDevicesInterfacesSourceHostdevUsbAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // guest_reset - computed: false, optional: true, required: false
  private _guestReset?: string; 
  public get guestReset() {
    return this.getStringAttribute('guest_reset');
  }
  public set guestReset(value: string) {
    this._guestReset = value;
  }
  public resetGuestReset() {
    this._guestReset = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get guestResetInput() {
    return this._guestReset;
  }

  // product - computed: false, optional: true, required: false
  private _product = new DomainDevicesInterfacesSourceHostdevUsbProductOutputReference(this, "product");
  public get product() {
    return this._product;
  }
  public putProduct(value: DomainDevicesInterfacesSourceHostdevUsbProduct) {
    this._product.internalValue = value;
  }
  public resetProduct() {
    this._product.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get productInput() {
    return this._product.internalValue;
  }

  // start_up_policy - computed: false, optional: true, required: false
  private _startUpPolicy?: string; 
  public get startUpPolicy() {
    return this.getStringAttribute('start_up_policy');
  }
  public set startUpPolicy(value: string) {
    this._startUpPolicy = value;
  }
  public resetStartUpPolicy() {
    this._startUpPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get startUpPolicyInput() {
    return this._startUpPolicy;
  }

  // vendor - computed: false, optional: true, required: false
  private _vendor = new DomainDevicesInterfacesSourceHostdevUsbVendorOutputReference(this, "vendor");
  public get vendor() {
    return this._vendor;
  }
  public putVendor(value: DomainDevicesInterfacesSourceHostdevUsbVendor) {
    this._vendor.internalValue = value;
  }
  public resetVendor() {
    this._vendor.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vendorInput() {
    return this._vendor.internalValue;
  }
}
export interface DomainDevicesInterfacesSourceHostdev {
  /**
  * Groups the source configuration for the PCI device being passed through, including its PCI address on the host.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pci Domain#pci}
  */
  readonly pci?: DomainDevicesInterfacesSourceHostdevPci;
  /**
  * Sets how the USB host device is identified for passthrough, either by topology (bus/port) or by vendor/product IDs and related options.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#usb Domain#usb}
  */
  readonly usb?: DomainDevicesInterfacesSourceHostdevUsb;
}

export function domainDevicesInterfacesSourceHostdevToTerraform(struct?: DomainDevicesInterfacesSourceHostdev | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    pci: domainDevicesInterfacesSourceHostdevPciToTerraform(struct!.pci),
    usb: domainDevicesInterfacesSourceHostdevUsbToTerraform(struct!.usb),
  }
}


export function domainDevicesInterfacesSourceHostdevToHclTerraform(struct?: DomainDevicesInterfacesSourceHostdev | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    pci: {
      value: domainDevicesInterfacesSourceHostdevPciToHclTerraform(struct!.pci),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesInterfacesSourceHostdevPci",
    },
    usb: {
      value: domainDevicesInterfacesSourceHostdevUsbToHclTerraform(struct!.usb),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesInterfacesSourceHostdevUsb",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesSourceHostdevOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesSourceHostdev | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._pci?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pci = this._pci?.internalValue;
    }
    if (this._usb?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.usb = this._usb?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesSourceHostdev | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._pci.internalValue = undefined;
      this._usb.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._pci.internalValue = value.pci;
      this._usb.internalValue = value.usb;
    }
  }

  // pci - computed: false, optional: true, required: false
  private _pci = new DomainDevicesInterfacesSourceHostdevPciOutputReference(this, "pci");
  public get pci() {
    return this._pci;
  }
  public putPci(value: DomainDevicesInterfacesSourceHostdevPci) {
    this._pci.internalValue = value;
  }
  public resetPci() {
    this._pci.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pciInput() {
    return this._pci.internalValue;
  }

  // usb - computed: false, optional: true, required: false
  private _usb = new DomainDevicesInterfacesSourceHostdevUsbOutputReference(this, "usb");
  public get usb() {
    return this._usb;
  }
  public putUsb(value: DomainDevicesInterfacesSourceHostdevUsb) {
    this._usb.internalValue = value;
  }
  public resetUsb() {
    this._usb.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usbInput() {
    return this._usb.internalValue;
  }
}
export interface DomainDevicesInterfacesSourceInternal {
  /**
  * Sets the name of the internal network that the interface connects to; value is user-provided and must match the identifier used by the underlying hypervisor for that internal network.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name?: string;
}

export function domainDevicesInterfacesSourceInternalToTerraform(struct?: DomainDevicesInterfacesSourceInternal | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function domainDevicesInterfacesSourceInternalToHclTerraform(struct?: DomainDevicesInterfacesSourceInternal | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesSourceInternalOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesSourceInternal | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesSourceInternal | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DomainDevicesInterfacesSourceMcastLocal {
  /**
  * Sets the local IP address on which the UDP tunnel-backed interface listens; value is user-provided (e.g. "0.0.0.0" or a specific host address).
  * 
  * See: <https://libvirt.org/formatdomain.html#udp-unicast-tunnel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: string;
  /**
  * Sets the local UDP port on which the tunnel-backed interface listens; value is a user-provided non-negative integer (e.g. 5000).
  * 
  * See: <https://libvirt.org/formatdomain.html#udp-unicast-tunnel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#port Domain#port}
  */
  readonly port?: number;
}

export function domainDevicesInterfacesSourceMcastLocalToTerraform(struct?: DomainDevicesInterfacesSourceMcastLocal | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
    port: cdktf.numberToTerraform(struct!.port),
  }
}


export function domainDevicesInterfacesSourceMcastLocalToHclTerraform(struct?: DomainDevicesInterfacesSourceMcastLocal | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesSourceMcastLocalOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesSourceMcastLocal | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesSourceMcastLocal | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
      this._port = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
      this._port = value.port;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  public resetAddress() {
    this._address = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }
}
export interface DomainDevicesInterfacesSourceMcast {
  /**
  * Sets the remote multicast group IP address that this interface joins for the multicast tunnel (user-provided unicast/multicast address, e.g. 239.x.x.x).
  * 
  * See: <https://libvirt.org/formatdomain.html#multicast-tunnel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: string;
  /**
  * Configures the local (listening) endpoint for a UDP tunnel-backed network interface, enabling the guest-side address/port to be fixed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#local Domain#local}
  */
  readonly local?: DomainDevicesInterfacesSourceMcastLocal;
  /**
  * Sets the remote UDP port used for the multicast tunnel (user-provided integer port number, e.g. 5000).
  * 
  * See: <https://libvirt.org/formatdomain.html#multicast-tunnel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#port Domain#port}
  */
  readonly port?: number;
}

export function domainDevicesInterfacesSourceMcastToTerraform(struct?: DomainDevicesInterfacesSourceMcast | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
    local: domainDevicesInterfacesSourceMcastLocalToTerraform(struct!.local),
    port: cdktf.numberToTerraform(struct!.port),
  }
}


export function domainDevicesInterfacesSourceMcastToHclTerraform(struct?: DomainDevicesInterfacesSourceMcast | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    local: {
      value: domainDevicesInterfacesSourceMcastLocalToHclTerraform(struct!.local),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesInterfacesSourceMcastLocal",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesSourceMcastOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesSourceMcast | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    if (this._local?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.local = this._local?.internalValue;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesSourceMcast | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
      this._local.internalValue = undefined;
      this._port = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
      this._local.internalValue = value.local;
      this._port = value.port;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  public resetAddress() {
    this._address = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }

  // local - computed: false, optional: true, required: false
  private _local = new DomainDevicesInterfacesSourceMcastLocalOutputReference(this, "local");
  public get local() {
    return this._local;
  }
  public putLocal(value: DomainDevicesInterfacesSourceMcastLocal) {
    this._local.internalValue = value;
  }
  public resetLocal() {
    this._local.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localInput() {
    return this._local.internalValue;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }
}
export interface DomainDevicesInterfacesSourceNetwork {
  /**
  * Sets the name of an existing host bridge device to use as the backing for this network interface (user-provided bridge name, e.g. "br0").
  * 
  * See: <https://libvirt.org/formatdomain.html#bridge-to-lan>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bridge Domain#bridge}
  */
  readonly bridge?: string;
  /**
  * Sets the name of the libvirt virtual network to connect this interface to (must match a defined libvirt network name).
  * 
  * See: <https://libvirt.org/formatdomain.html#virtual-network>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#network Domain#network}
  */
  readonly network?: string;
  /**
  * Selects a specific portgroup within the referenced libvirt virtual network for this interface, typically to apply different QoS or VLAN settings (user-provided portgroup name).
  * 
  * See: <https://libvirt.org/formatnetwork.html#portgroups>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#port_group Domain#port_group}
  */
  readonly portGroup?: string;
  /**
  * Sets a backend-specific port identifier for integration with external networking (e.g. Open vSwitch or SDN controllers), using a user-provided opaque ID string.
  * 
  * See: <https://libvirt.org/formatdomain.html#virtual-network>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#port_id Domain#port_id}
  */
  readonly portId?: string;
}

export function domainDevicesInterfacesSourceNetworkToTerraform(struct?: DomainDevicesInterfacesSourceNetwork | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bridge: cdktf.stringToTerraform(struct!.bridge),
    network: cdktf.stringToTerraform(struct!.network),
    port_group: cdktf.stringToTerraform(struct!.portGroup),
    port_id: cdktf.stringToTerraform(struct!.portId),
  }
}


export function domainDevicesInterfacesSourceNetworkToHclTerraform(struct?: DomainDevicesInterfacesSourceNetwork | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bridge: {
      value: cdktf.stringToHclTerraform(struct!.bridge),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    network: {
      value: cdktf.stringToHclTerraform(struct!.network),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port_group: {
      value: cdktf.stringToHclTerraform(struct!.portGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port_id: {
      value: cdktf.stringToHclTerraform(struct!.portId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesSourceNetworkOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesSourceNetwork | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bridge !== undefined) {
      hasAnyValues = true;
      internalValueResult.bridge = this._bridge;
    }
    if (this._network !== undefined) {
      hasAnyValues = true;
      internalValueResult.network = this._network;
    }
    if (this._portGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.portGroup = this._portGroup;
    }
    if (this._portId !== undefined) {
      hasAnyValues = true;
      internalValueResult.portId = this._portId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesSourceNetwork | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bridge = undefined;
      this._network = undefined;
      this._portGroup = undefined;
      this._portId = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bridge = value.bridge;
      this._network = value.network;
      this._portGroup = value.portGroup;
      this._portId = value.portId;
    }
  }

  // bridge - computed: false, optional: true, required: false
  private _bridge?: string; 
  public get bridge() {
    return this.getStringAttribute('bridge');
  }
  public set bridge(value: string) {
    this._bridge = value;
  }
  public resetBridge() {
    this._bridge = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bridgeInput() {
    return this._bridge;
  }

  // network - computed: false, optional: true, required: false
  private _network?: string; 
  public get network() {
    return this.getStringAttribute('network');
  }
  public set network(value: string) {
    this._network = value;
  }
  public resetNetwork() {
    this._network = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkInput() {
    return this._network;
  }

  // port_group - computed: false, optional: true, required: false
  private _portGroup?: string; 
  public get portGroup() {
    return this.getStringAttribute('port_group');
  }
  public set portGroup(value: string) {
    this._portGroup = value;
  }
  public resetPortGroup() {
    this._portGroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portGroupInput() {
    return this._portGroup;
  }

  // port_id - computed: false, optional: true, required: false
  private _portId?: string; 
  public get portId() {
    return this.getStringAttribute('port_id');
  }
  public set portId(value: string) {
    this._portId = value;
  }
  public resetPortId() {
    this._portId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portIdInput() {
    return this._portId;
  }
}
export interface DomainDevicesInterfacesSourceServerLocal {
  /**
  * Sets the local IP address on which the UDP tunnel-backed interface listens; value is user-provided (e.g. "0.0.0.0" or a specific host address).
  * 
  * See: <https://libvirt.org/formatdomain.html#udp-unicast-tunnel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: string;
  /**
  * Sets the local UDP port on which the tunnel-backed interface listens; value is a user-provided non-negative integer (e.g. 5000).
  * 
  * See: <https://libvirt.org/formatdomain.html#udp-unicast-tunnel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#port Domain#port}
  */
  readonly port?: number;
}

export function domainDevicesInterfacesSourceServerLocalToTerraform(struct?: DomainDevicesInterfacesSourceServerLocal | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
    port: cdktf.numberToTerraform(struct!.port),
  }
}


export function domainDevicesInterfacesSourceServerLocalToHclTerraform(struct?: DomainDevicesInterfacesSourceServerLocal | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesSourceServerLocalOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesSourceServerLocal | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesSourceServerLocal | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
      this._port = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
      this._port = value.port;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  public resetAddress() {
    this._address = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }
}
export interface DomainDevicesInterfacesSourceServer {
  /**
  * Sets the remote or local TCP IP address for the TCP-tunnel server endpoint backing this interface (user-provided IP or hostname).
  * 
  * See: <https://libvirt.org/formatdomain.html#tcp-tunnel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: string;
  /**
  * Configures the local (listening) endpoint for a UDP tunnel-backed network interface, enabling the guest-side address/port to be fixed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#local Domain#local}
  */
  readonly local?: DomainDevicesInterfacesSourceServerLocal;
  /**
  * Sets the remote or listening TCP port used for the TCP tunnel backing this interface (user-provided integer port).
  * 
  * See: <https://libvirt.org/formatdomain.html#tcp-tunnel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#port Domain#port}
  */
  readonly port?: number;
}

export function domainDevicesInterfacesSourceServerToTerraform(struct?: DomainDevicesInterfacesSourceServer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
    local: domainDevicesInterfacesSourceServerLocalToTerraform(struct!.local),
    port: cdktf.numberToTerraform(struct!.port),
  }
}


export function domainDevicesInterfacesSourceServerToHclTerraform(struct?: DomainDevicesInterfacesSourceServer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    local: {
      value: domainDevicesInterfacesSourceServerLocalToHclTerraform(struct!.local),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesInterfacesSourceServerLocal",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesSourceServerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesSourceServer | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    if (this._local?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.local = this._local?.internalValue;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesSourceServer | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
      this._local.internalValue = undefined;
      this._port = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
      this._local.internalValue = value.local;
      this._port = value.port;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  public resetAddress() {
    this._address = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }

  // local - computed: false, optional: true, required: false
  private _local = new DomainDevicesInterfacesSourceServerLocalOutputReference(this, "local");
  public get local() {
    return this._local;
  }
  public putLocal(value: DomainDevicesInterfacesSourceServerLocal) {
    this._local.internalValue = value;
  }
  public resetLocal() {
    this._local.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localInput() {
    return this._local.internalValue;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }
}
export interface DomainDevicesInterfacesSourceUdpLocal {
  /**
  * Sets the local IP address on which the UDP tunnel-backed interface listens; value is user-provided (e.g. "0.0.0.0" or a specific host address).
  * 
  * See: <https://libvirt.org/formatdomain.html#udp-unicast-tunnel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: string;
  /**
  * Sets the local UDP port on which the tunnel-backed interface listens; value is a user-provided non-negative integer (e.g. 5000).
  * 
  * See: <https://libvirt.org/formatdomain.html#udp-unicast-tunnel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#port Domain#port}
  */
  readonly port?: number;
}

export function domainDevicesInterfacesSourceUdpLocalToTerraform(struct?: DomainDevicesInterfacesSourceUdpLocal | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
    port: cdktf.numberToTerraform(struct!.port),
  }
}


export function domainDevicesInterfacesSourceUdpLocalToHclTerraform(struct?: DomainDevicesInterfacesSourceUdpLocal | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesSourceUdpLocalOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesSourceUdpLocal | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesSourceUdpLocal | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
      this._port = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
      this._port = value.port;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  public resetAddress() {
    this._address = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }
}
export interface DomainDevicesInterfacesSourceUdp {
  /**
  * Sets the remote UDP endpoint IP address or hostname for the UDP unicast tunnel backing this interface (user-provided address).
  * 
  * See: <https://libvirt.org/formatdomain.html#udp-unicast-tunnel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: string;
  /**
  * Configures the local (listening) endpoint for a UDP tunnel-backed network interface, enabling the guest-side address/port to be fixed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#local Domain#local}
  */
  readonly local?: DomainDevicesInterfacesSourceUdpLocal;
  /**
  * Sets the remote UDP port to which the tunnel-backed network interface sends packets; value is a user-provided non-negative integer (e.g. 5000).
  * 
  * See: <https://libvirt.org/formatdomain.html#udp-unicast-tunnel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#port Domain#port}
  */
  readonly port?: number;
}

export function domainDevicesInterfacesSourceUdpToTerraform(struct?: DomainDevicesInterfacesSourceUdp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
    local: domainDevicesInterfacesSourceUdpLocalToTerraform(struct!.local),
    port: cdktf.numberToTerraform(struct!.port),
  }
}


export function domainDevicesInterfacesSourceUdpToHclTerraform(struct?: DomainDevicesInterfacesSourceUdp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    local: {
      value: domainDevicesInterfacesSourceUdpLocalToHclTerraform(struct!.local),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesInterfacesSourceUdpLocal",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesSourceUdpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesSourceUdp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    if (this._local?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.local = this._local?.internalValue;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesSourceUdp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
      this._local.internalValue = undefined;
      this._port = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
      this._local.internalValue = value.local;
      this._port = value.port;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  public resetAddress() {
    this._address = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }

  // local - computed: false, optional: true, required: false
  private _local = new DomainDevicesInterfacesSourceUdpLocalOutputReference(this, "local");
  public get local() {
    return this._local;
  }
  public putLocal(value: DomainDevicesInterfacesSourceUdpLocal) {
    this._local.internalValue = value;
  }
  public resetLocal() {
    this._local.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localInput() {
    return this._local.internalValue;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }
}
export interface DomainDevicesInterfacesSourceUser {
  /**
  * Sets an optional host-side device name or identifier for the user-mode (SLIRP) networking backend; value is user-provided and normally omitted.
  * 
  * See: <https://libvirt.org/formatdomain.html#userspace-connection-using-slirp>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dev Domain#dev}
  */
  readonly dev?: string;
}

export function domainDevicesInterfacesSourceUserToTerraform(struct?: DomainDevicesInterfacesSourceUser | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dev: cdktf.stringToTerraform(struct!.dev),
  }
}


export function domainDevicesInterfacesSourceUserToHclTerraform(struct?: DomainDevicesInterfacesSourceUser | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dev: {
      value: cdktf.stringToHclTerraform(struct!.dev),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesSourceUserOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesSourceUser | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dev !== undefined) {
      hasAnyValues = true;
      internalValueResult.dev = this._dev;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesSourceUser | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dev = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dev = value.dev;
    }
  }

  // dev - computed: false, optional: true, required: false
  private _dev?: string; 
  public get dev() {
    return this.getStringAttribute('dev');
  }
  public set dev(value: string) {
    this._dev = value;
  }
  public resetDev() {
    this._dev = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devInput() {
    return this._dev;
  }
}
export interface DomainDevicesInterfacesSourceVdpa {
  /**
  * Sets the path or name of the vDPA device (e.g. "/dev/vhost-vdpaX") used as the source for the interface; value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#vdpa-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#device Domain#device}
  */
  readonly device?: string;
}

export function domainDevicesInterfacesSourceVdpaToTerraform(struct?: DomainDevicesInterfacesSourceVdpa | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    device: cdktf.stringToTerraform(struct!.device),
  }
}


export function domainDevicesInterfacesSourceVdpaToHclTerraform(struct?: DomainDevicesInterfacesSourceVdpa | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    device: {
      value: cdktf.stringToHclTerraform(struct!.device),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesSourceVdpaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesSourceVdpa | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._device !== undefined) {
      hasAnyValues = true;
      internalValueResult.device = this._device;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesSourceVdpa | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._device = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._device = value.device;
    }
  }

  // device - computed: false, optional: true, required: false
  private _device?: string; 
  public get device() {
    return this.getStringAttribute('device');
  }
  public set device(value: string) {
    this._device = value;
  }
  public resetDevice() {
    this._device = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deviceInput() {
    return this._device;
  }
}
export interface DomainDevicesInterfacesSourceVds {
  /**
  * Sets the VDS connection identifier that associates the interface with a particular distributed switch connection; value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#vmware-distributed-switch>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#connection_id Domain#connection_id}
  */
  readonly connectionId?: number;
  /**
  * Sets the VDS port group identifier that determines which distributed port group the interface attaches to; value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#vmware-distributed-switch>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#port_group_id Domain#port_group_id}
  */
  readonly portGroupId?: string;
  /**
  * Sets a specific VDS port identifier within the distributed switch to attach this interface to; value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#vmware-distributed-switch>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#port_id Domain#port_id}
  */
  readonly portId?: number;
  /**
  * Sets the VMware Distributed Switch identifier to which the interface connects; this is required and must be a user-provided VDS ID.
  * 
  * See: <https://libvirt.org/formatdomain.html#vmware-distributed-switch>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#switch_id Domain#switch_id}
  */
  readonly switchId: string;
}

export function domainDevicesInterfacesSourceVdsToTerraform(struct?: DomainDevicesInterfacesSourceVds | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connection_id: cdktf.numberToTerraform(struct!.connectionId),
    port_group_id: cdktf.stringToTerraform(struct!.portGroupId),
    port_id: cdktf.numberToTerraform(struct!.portId),
    switch_id: cdktf.stringToTerraform(struct!.switchId),
  }
}


export function domainDevicesInterfacesSourceVdsToHclTerraform(struct?: DomainDevicesInterfacesSourceVds | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connection_id: {
      value: cdktf.numberToHclTerraform(struct!.connectionId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_group_id: {
      value: cdktf.stringToHclTerraform(struct!.portGroupId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port_id: {
      value: cdktf.numberToHclTerraform(struct!.portId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    switch_id: {
      value: cdktf.stringToHclTerraform(struct!.switchId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesSourceVdsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesSourceVds | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connectionId !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionId = this._connectionId;
    }
    if (this._portGroupId !== undefined) {
      hasAnyValues = true;
      internalValueResult.portGroupId = this._portGroupId;
    }
    if (this._portId !== undefined) {
      hasAnyValues = true;
      internalValueResult.portId = this._portId;
    }
    if (this._switchId !== undefined) {
      hasAnyValues = true;
      internalValueResult.switchId = this._switchId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesSourceVds | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connectionId = undefined;
      this._portGroupId = undefined;
      this._portId = undefined;
      this._switchId = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connectionId = value.connectionId;
      this._portGroupId = value.portGroupId;
      this._portId = value.portId;
      this._switchId = value.switchId;
    }
  }

  // connection_id - computed: false, optional: true, required: false
  private _connectionId?: number; 
  public get connectionId() {
    return this.getNumberAttribute('connection_id');
  }
  public set connectionId(value: number) {
    this._connectionId = value;
  }
  public resetConnectionId() {
    this._connectionId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionIdInput() {
    return this._connectionId;
  }

  // port_group_id - computed: false, optional: true, required: false
  private _portGroupId?: string; 
  public get portGroupId() {
    return this.getStringAttribute('port_group_id');
  }
  public set portGroupId(value: string) {
    this._portGroupId = value;
  }
  public resetPortGroupId() {
    this._portGroupId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portGroupIdInput() {
    return this._portGroupId;
  }

  // port_id - computed: false, optional: true, required: false
  private _portId?: number; 
  public get portId() {
    return this.getNumberAttribute('port_id');
  }
  public set portId(value: number) {
    this._portId = value;
  }
  public resetPortId() {
    this._portId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portIdInput() {
    return this._portId;
  }

  // switch_id - computed: false, optional: false, required: true
  private _switchId?: string; 
  public get switchId() {
    return this.getStringAttribute('switch_id');
  }
  public set switchId(value: string) {
    this._switchId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get switchIdInput() {
    return this._switchId;
  }
}
export interface DomainDevicesInterfacesSourceVhostUserChardevDbus {
  /**
  * Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#channel Domain#channel}
  */
  readonly channel?: string;
}

export function domainDevicesInterfacesSourceVhostUserChardevDbusToTerraform(struct?: DomainDevicesInterfacesSourceVhostUserChardevDbus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    channel: cdktf.stringToTerraform(struct!.channel),
  }
}


export function domainDevicesInterfacesSourceVhostUserChardevDbusToHclTerraform(struct?: DomainDevicesInterfacesSourceVhostUserChardevDbus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    channel: {
      value: cdktf.stringToHclTerraform(struct!.channel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesSourceVhostUserChardevDbusOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesSourceVhostUserChardevDbus | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._channel !== undefined) {
      hasAnyValues = true;
      internalValueResult.channel = this._channel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesSourceVhostUserChardevDbus | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._channel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._channel = value.channel;
    }
  }

  // channel - computed: false, optional: true, required: false
  private _channel?: string; 
  public get channel() {
    return this.getStringAttribute('channel');
  }
  public set channel(value: string) {
    this._channel = value;
  }
  public resetChannel() {
    this._channel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get channelInput() {
    return this._channel;
  }
}
export interface DomainDevicesInterfacesSourceVhostUserChardevDevSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesInterfacesSourceVhostUserChardevDevSecLabelToTerraform(struct?: DomainDevicesInterfacesSourceVhostUserChardevDevSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesInterfacesSourceVhostUserChardevDevSecLabelToHclTerraform(struct?: DomainDevicesInterfacesSourceVhostUserChardevDevSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesSourceVhostUserChardevDevSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesInterfacesSourceVhostUserChardevDevSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesSourceVhostUserChardevDevSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesInterfacesSourceVhostUserChardevDevSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesInterfacesSourceVhostUserChardevDevSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesInterfacesSourceVhostUserChardevDevSecLabelOutputReference {
    return new DomainDevicesInterfacesSourceVhostUserChardevDevSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesInterfacesSourceVhostUserChardevDev {
  /**
  * Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesInterfacesSourceVhostUserChardevDevSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesInterfacesSourceVhostUserChardevDevToTerraform(struct?: DomainDevicesInterfacesSourceVhostUserChardevDev | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesInterfacesSourceVhostUserChardevDevSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesInterfacesSourceVhostUserChardevDevToHclTerraform(struct?: DomainDevicesInterfacesSourceVhostUserChardevDev | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesInterfacesSourceVhostUserChardevDevSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesInterfacesSourceVhostUserChardevDevSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesSourceVhostUserChardevDevOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesSourceVhostUserChardevDev | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesSourceVhostUserChardevDev | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesInterfacesSourceVhostUserChardevDevSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesInterfacesSourceVhostUserChardevDevSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesInterfacesSourceVhostUserChardevFileSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesInterfacesSourceVhostUserChardevFileSecLabelToTerraform(struct?: DomainDevicesInterfacesSourceVhostUserChardevFileSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesInterfacesSourceVhostUserChardevFileSecLabelToHclTerraform(struct?: DomainDevicesInterfacesSourceVhostUserChardevFileSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesSourceVhostUserChardevFileSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesInterfacesSourceVhostUserChardevFileSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesSourceVhostUserChardevFileSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesInterfacesSourceVhostUserChardevFileSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesInterfacesSourceVhostUserChardevFileSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesInterfacesSourceVhostUserChardevFileSecLabelOutputReference {
    return new DomainDevicesInterfacesSourceVhostUserChardevFileSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesInterfacesSourceVhostUserChardevFile {
  /**
  * Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.
  * 
  * See: <https://libvirt.org/formatdomain.html#device-logfile>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#append Domain#append}
  */
  readonly append?: string;
  /**
  * Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesInterfacesSourceVhostUserChardevFileSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesInterfacesSourceVhostUserChardevFileToTerraform(struct?: DomainDevicesInterfacesSourceVhostUserChardevFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.stringToTerraform(struct!.append),
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesInterfacesSourceVhostUserChardevFileSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesInterfacesSourceVhostUserChardevFileToHclTerraform(struct?: DomainDevicesInterfacesSourceVhostUserChardevFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.stringToHclTerraform(struct!.append),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesInterfacesSourceVhostUserChardevFileSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesInterfacesSourceVhostUserChardevFileSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesSourceVhostUserChardevFileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesSourceVhostUserChardevFile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesSourceVhostUserChardevFile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append = value.append;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append?: string; 
  public get append() {
    return this.getStringAttribute('append');
  }
  public set append(value: string) {
    this._append = value;
  }
  public resetAppend() {
    this._append = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append;
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesInterfacesSourceVhostUserChardevFileSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesInterfacesSourceVhostUserChardevFileSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesInterfacesSourceVhostUserChardevNmdm {
  /**
  * Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.
  * 
  * See: <https://libvirt.org/formatdomain.html#nmdm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#master Domain#master}
  */
  readonly master: string;
  /**
  * Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.
  * 
  * See: <https://libvirt.org/formatdomain.html#nmdm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#slave Domain#slave}
  */
  readonly slave: string;
}

export function domainDevicesInterfacesSourceVhostUserChardevNmdmToTerraform(struct?: DomainDevicesInterfacesSourceVhostUserChardevNmdm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    master: cdktf.stringToTerraform(struct!.master),
    slave: cdktf.stringToTerraform(struct!.slave),
  }
}


export function domainDevicesInterfacesSourceVhostUserChardevNmdmToHclTerraform(struct?: DomainDevicesInterfacesSourceVhostUserChardevNmdm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    master: {
      value: cdktf.stringToHclTerraform(struct!.master),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    slave: {
      value: cdktf.stringToHclTerraform(struct!.slave),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesSourceVhostUserChardevNmdmOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesSourceVhostUserChardevNmdm | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._master !== undefined) {
      hasAnyValues = true;
      internalValueResult.master = this._master;
    }
    if (this._slave !== undefined) {
      hasAnyValues = true;
      internalValueResult.slave = this._slave;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesSourceVhostUserChardevNmdm | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._master = undefined;
      this._slave = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._master = value.master;
      this._slave = value.slave;
    }
  }

  // master - computed: false, optional: false, required: true
  private _master?: string; 
  public get master() {
    return this.getStringAttribute('master');
  }
  public set master(value: string) {
    this._master = value;
  }
  // Temporarily expose input value. Use with caution.
  public get masterInput() {
    return this._master;
  }

  // slave - computed: false, optional: false, required: true
  private _slave?: string; 
  public get slave() {
    return this.getStringAttribute('slave');
  }
  public set slave(value: string) {
    this._slave = value;
  }
  // Temporarily expose input value. Use with caution.
  public get slaveInput() {
    return this._slave;
  }
}
export interface DomainDevicesInterfacesSourceVhostUserChardevPipeSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesInterfacesSourceVhostUserChardevPipeSecLabelToTerraform(struct?: DomainDevicesInterfacesSourceVhostUserChardevPipeSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesInterfacesSourceVhostUserChardevPipeSecLabelToHclTerraform(struct?: DomainDevicesInterfacesSourceVhostUserChardevPipeSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesSourceVhostUserChardevPipeSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesInterfacesSourceVhostUserChardevPipeSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesSourceVhostUserChardevPipeSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesInterfacesSourceVhostUserChardevPipeSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesInterfacesSourceVhostUserChardevPipeSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesInterfacesSourceVhostUserChardevPipeSecLabelOutputReference {
    return new DomainDevicesInterfacesSourceVhostUserChardevPipeSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesInterfacesSourceVhostUserChardevPipe {
  /**
  * Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesInterfacesSourceVhostUserChardevPipeSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesInterfacesSourceVhostUserChardevPipeToTerraform(struct?: DomainDevicesInterfacesSourceVhostUserChardevPipe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesInterfacesSourceVhostUserChardevPipeSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesInterfacesSourceVhostUserChardevPipeToHclTerraform(struct?: DomainDevicesInterfacesSourceVhostUserChardevPipe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesInterfacesSourceVhostUserChardevPipeSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesInterfacesSourceVhostUserChardevPipeSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesInterfacesSourceVhostUserChardevPipeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesInterfacesSourceVhostUserChardevPipe | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesInterfacesSourceVhostUserChardevPipe | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesInterfacesSourceVhostUserChardevPipeSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesInterfacesSourceVhostUserChardevPipeSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
