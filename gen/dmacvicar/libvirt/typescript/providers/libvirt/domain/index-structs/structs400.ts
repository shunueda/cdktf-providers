import * as cdktf from 'cdktf';
import { DomainDevicesDisksBackingStoreSourceDataStoreFormatMetadataCacheMaxSize,
domainDevicesDisksBackingStoreSourceDataStoreFormatMetadataCacheMaxSizeToTerraform,
domainDevicesDisksBackingStoreSourceDataStoreFormatMetadataCacheMaxSizeToHclTerraform,
DomainDevicesDisksBackingStoreSourceDataStoreFormatMetadataCacheMaxSizeOutputReference,
DomainDevicesDisksBackingStoreSourceBlock,
domainDevicesDisksBackingStoreSourceBlockToTerraform,
domainDevicesDisksBackingStoreSourceBlockToHclTerraform,
DomainDevicesDisksBackingStoreSourceBlockOutputReference,
DomainDevicesDisksBackingStoreSourceCookies,
domainDevicesDisksBackingStoreSourceCookiesToTerraform,
domainDevicesDisksBackingStoreSourceCookiesToHclTerraform,
DomainDevicesDisksBackingStoreSourceCookiesOutputReference,
DomainDevicesDisksBackingStoreFormat,
domainDevicesDisksBackingStoreFormatToTerraform,
domainDevicesDisksBackingStoreFormatToHclTerraform,
DomainDevicesDisksBackingStoreFormatOutputReference } from './structs0'
export interface DomainDevicesDisksBackingStoreSourceDataStoreFormatMetadataCache {
  /**
  * Sets the maximum size of the metadata cache used by the data store format; value and unit together define the limit (for example, 64 MiB).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#max_size Domain#max_size}
  */
  readonly maxSize?: DomainDevicesDisksBackingStoreSourceDataStoreFormatMetadataCacheMaxSize;
}

export function domainDevicesDisksBackingStoreSourceDataStoreFormatMetadataCacheToTerraform(struct?: DomainDevicesDisksBackingStoreSourceDataStoreFormatMetadataCache | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_size: domainDevicesDisksBackingStoreSourceDataStoreFormatMetadataCacheMaxSizeToTerraform(struct!.maxSize),
  }
}


export function domainDevicesDisksBackingStoreSourceDataStoreFormatMetadataCacheToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceDataStoreFormatMetadataCache | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_size: {
      value: domainDevicesDisksBackingStoreSourceDataStoreFormatMetadataCacheMaxSizeToHclTerraform(struct!.maxSize),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceDataStoreFormatMetadataCacheMaxSize",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceDataStoreFormatMetadataCacheOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceDataStoreFormatMetadataCache | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxSize?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceDataStoreFormatMetadataCache | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxSize.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxSize.internalValue = value.maxSize;
    }
  }

  // max_size - computed: false, optional: true, required: false
  private _maxSize = new DomainDevicesDisksBackingStoreSourceDataStoreFormatMetadataCacheMaxSizeOutputReference(this, "max_size");
  public get maxSize() {
    return this._maxSize;
  }
  public putMaxSize(value: DomainDevicesDisksBackingStoreSourceDataStoreFormatMetadataCacheMaxSize) {
    this._maxSize.internalValue = value;
  }
  public resetMaxSize() {
    this._maxSize.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize.internalValue;
  }
}
export interface DomainDevicesDisksBackingStoreSourceDataStoreFormat {
  /**
  * Configures metadata cache behavior for the mirrored backing store’s data store format (for example, limiting the size of cached metadata).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#metadata_cache Domain#metadata_cache}
  */
  readonly metadataCache?: DomainDevicesDisksBackingStoreSourceDataStoreFormatMetadataCache;
  /**
  * Sets the data store format type for the mirrored backing store (for example, "qcow2" or "raw"); the value is user-provided and must be a valid libvirt disk format name.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type: string;
}

export function domainDevicesDisksBackingStoreSourceDataStoreFormatToTerraform(struct?: DomainDevicesDisksBackingStoreSourceDataStoreFormat | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metadata_cache: domainDevicesDisksBackingStoreSourceDataStoreFormatMetadataCacheToTerraform(struct!.metadataCache),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function domainDevicesDisksBackingStoreSourceDataStoreFormatToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceDataStoreFormat | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metadata_cache: {
      value: domainDevicesDisksBackingStoreSourceDataStoreFormatMetadataCacheToHclTerraform(struct!.metadataCache),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceDataStoreFormatMetadataCache",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceDataStoreFormatOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceDataStoreFormat | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metadataCache?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadataCache = this._metadataCache?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceDataStoreFormat | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metadataCache.internalValue = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metadataCache.internalValue = value.metadataCache;
      this._type = value.type;
    }
  }

  // metadata_cache - computed: false, optional: true, required: false
  private _metadataCache = new DomainDevicesDisksBackingStoreSourceDataStoreFormatMetadataCacheOutputReference(this, "metadata_cache");
  public get metadataCache() {
    return this._metadataCache;
  }
  public putMetadataCache(value: DomainDevicesDisksBackingStoreSourceDataStoreFormatMetadataCache) {
    this._metadataCache.internalValue = value;
  }
  public resetMetadataCache() {
    this._metadataCache.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataCacheInput() {
    return this._metadataCache.internalValue;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DomainDevicesDisksBackingStoreSourceDataStore {
  /**
  * Configures the on-disk format settings for the mirrored backing store’s data store, including format type and optional metadata cache tuning.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#format Domain#format}
  */
  readonly format?: DomainDevicesDisksBackingStoreSourceDataStoreFormat;
}

export function domainDevicesDisksBackingStoreSourceDataStoreToTerraform(struct?: DomainDevicesDisksBackingStoreSourceDataStore | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    format: domainDevicesDisksBackingStoreSourceDataStoreFormatToTerraform(struct!.format),
  }
}


export function domainDevicesDisksBackingStoreSourceDataStoreToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceDataStore | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    format: {
      value: domainDevicesDisksBackingStoreSourceDataStoreFormatToHclTerraform(struct!.format),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceDataStoreFormat",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceDataStoreOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceDataStore | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._format?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceDataStore | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._format.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._format.internalValue = value.format;
    }
  }

  // format - computed: false, optional: true, required: false
  private _format = new DomainDevicesDisksBackingStoreSourceDataStoreFormatOutputReference(this, "format");
  public get format() {
    return this._format;
  }
  public putFormat(value: DomainDevicesDisksBackingStoreSourceDataStoreFormat) {
    this._format.internalValue = value;
  }
  public resetFormat() {
    this._format.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format.internalValue;
  }
}
export interface DomainDevicesDisksBackingStoreSourceDir {
  /**
  * Sets the host directory path used as the mirrored backing store source; this must be an absolute path on the host (for example, "/var/lib/libvirt/images").
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dir Domain#dir}
  */
  readonly dir?: string;
}

export function domainDevicesDisksBackingStoreSourceDirToTerraform(struct?: DomainDevicesDisksBackingStoreSourceDir | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dir: cdktf.stringToTerraform(struct!.dir),
  }
}


export function domainDevicesDisksBackingStoreSourceDirToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceDir | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dir: {
      value: cdktf.stringToHclTerraform(struct!.dir),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceDirOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceDir | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dir !== undefined) {
      hasAnyValues = true;
      internalValueResult.dir = this._dir;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceDir | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dir = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dir = value.dir;
    }
  }

  // dir - computed: false, optional: true, required: false
  private _dir?: string; 
  public get dir() {
    return this.getStringAttribute('dir');
  }
  public set dir(value: string) {
    this._dir = value;
  }
  public resetDir() {
    this._dir = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dirInput() {
    return this._dir;
  }
}
export interface DomainDevicesDisksBackingStoreSourceEncryptionSecrets {
  /**
  * Sets how the referenced secret is identified; typical values are user-provided strings such as "uuid" or "usage" depending on how the secret is looked up.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type?: string;
  /**
  * Sets the libvirt secret usage name when referencing the iSCSI auth secret by usage; the value is a user-provided identifier such as an iSCSI target name.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#usage Domain#usage}
  */
  readonly usage?: string;
}

export function domainDevicesDisksBackingStoreSourceEncryptionSecretsToTerraform(struct?: DomainDevicesDisksBackingStoreSourceEncryptionSecrets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    type: cdktf.stringToTerraform(struct!.type),
    usage: cdktf.stringToTerraform(struct!.usage),
  }
}


export function domainDevicesDisksBackingStoreSourceEncryptionSecretsToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceEncryptionSecrets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    usage: {
      value: cdktf.stringToHclTerraform(struct!.usage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceEncryptionSecretsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceEncryptionSecrets | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._usage !== undefined) {
      hasAnyValues = true;
      internalValueResult.usage = this._usage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceEncryptionSecrets | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._type = undefined;
      this._usage = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._type = value.type;
      this._usage = value.usage;
    }
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // usage - computed: false, optional: true, required: false
  private _usage?: string; 
  public get usage() {
    return this.getStringAttribute('usage');
  }
  public set usage(value: string) {
    this._usage = value;
  }
  public resetUsage() {
    this._usage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usageInput() {
    return this._usage;
  }

  // uuid - computed: true, optional: false, required: false
  public get uuid() {
    return this.getStringAttribute('uuid');
  }
}

export class DomainDevicesDisksBackingStoreSourceEncryptionSecretsList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksBackingStoreSourceEncryptionSecrets[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksBackingStoreSourceEncryptionSecretsOutputReference {
    return new DomainDevicesDisksBackingStoreSourceEncryptionSecretsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksBackingStoreSourceEncryption {
  /**
  * Sets the encryption engine/provider to use for the disk (user-provided string, e.g. implementation-specific engine name).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#engine Domain#engine}
  */
  readonly engine?: string;
  /**
  * Sets the disk encryption format, such as "luks" or another user-provided scheme supported by libvirt/qemu.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#format Domain#format}
  */
  readonly format?: string;
  /**
  * Defines one or more secret references used to access the encrypted disk, each describing how libvirt locates the secret material.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#secrets Domain#secrets}
  */
  readonly secrets?: DomainDevicesDisksBackingStoreSourceEncryptionSecrets[] | cdktf.IResolvable;
}

export function domainDevicesDisksBackingStoreSourceEncryptionToTerraform(struct?: DomainDevicesDisksBackingStoreSourceEncryption | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    engine: cdktf.stringToTerraform(struct!.engine),
    format: cdktf.stringToTerraform(struct!.format),
    secrets: cdktf.listMapper(domainDevicesDisksBackingStoreSourceEncryptionSecretsToTerraform, false)(struct!.secrets),
  }
}


export function domainDevicesDisksBackingStoreSourceEncryptionToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceEncryption | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    engine: {
      value: cdktf.stringToHclTerraform(struct!.engine),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secrets: {
      value: cdktf.listMapperHcl(domainDevicesDisksBackingStoreSourceEncryptionSecretsToHclTerraform, false)(struct!.secrets),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksBackingStoreSourceEncryptionSecretsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceEncryptionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceEncryption | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._engine !== undefined) {
      hasAnyValues = true;
      internalValueResult.engine = this._engine;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._secrets?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secrets = this._secrets?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceEncryption | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._engine = undefined;
      this._format = undefined;
      this._secrets.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._engine = value.engine;
      this._format = value.format;
      this._secrets.internalValue = value.secrets;
    }
  }

  // engine - computed: false, optional: true, required: false
  private _engine?: string; 
  public get engine() {
    return this.getStringAttribute('engine');
  }
  public set engine(value: string) {
    this._engine = value;
  }
  public resetEngine() {
    this._engine = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get engineInput() {
    return this._engine;
  }

  // format - computed: false, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // secrets - computed: false, optional: true, required: false
  private _secrets = new DomainDevicesDisksBackingStoreSourceEncryptionSecretsList(this, "secrets", false);
  public get secrets() {
    return this._secrets;
  }
  public putSecrets(value: DomainDevicesDisksBackingStoreSourceEncryptionSecrets[] | cdktf.IResolvable) {
    this._secrets.internalValue = value;
  }
  public resetSecrets() {
    this._secrets.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretsInput() {
    return this._secrets.internalValue;
  }
}
export interface DomainDevicesDisksBackingStoreSourceFileSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksBackingStoreSourceFileSecLabelToTerraform(struct?: DomainDevicesDisksBackingStoreSourceFileSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksBackingStoreSourceFileSecLabelToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceFileSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceFileSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceFileSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceFileSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksBackingStoreSourceFileSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksBackingStoreSourceFileSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksBackingStoreSourceFileSecLabelOutputReference {
    return new DomainDevicesDisksBackingStoreSourceFileSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksBackingStoreSourceFile {
  /**
  * Sets the name of an fdgroup whose pre-opened file descriptor is used for this backing store instead of opening the file path directly; value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#fd_group Domain#fd_group}
  */
  readonly fdGroup?: string;
  /**
  * Sets the absolute path on the host to the backing file used as the source for this mirrored disk (for example, /var/lib/libvirt/images/base.qcow2).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file?: string;
  /**
  * Configures an explicit security label for the file backing store, overriding default security driver labeling for this file.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksBackingStoreSourceFileSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksBackingStoreSourceFileToTerraform(struct?: DomainDevicesDisksBackingStoreSourceFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fd_group: cdktf.stringToTerraform(struct!.fdGroup),
    file: cdktf.stringToTerraform(struct!.file),
    sec_label: cdktf.listMapper(domainDevicesDisksBackingStoreSourceFileSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksBackingStoreSourceFileToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fd_group: {
      value: cdktf.stringToHclTerraform(struct!.fdGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    file: {
      value: cdktf.stringToHclTerraform(struct!.file),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksBackingStoreSourceFileSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksBackingStoreSourceFileSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceFileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceFile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fdGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.fdGroup = this._fdGroup;
    }
    if (this._file !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceFile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fdGroup = undefined;
      this._file = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fdGroup = value.fdGroup;
      this._file = value.file;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // fd_group - computed: false, optional: true, required: false
  private _fdGroup?: string; 
  public get fdGroup() {
    return this.getStringAttribute('fd_group');
  }
  public set fdGroup(value: string) {
    this._fdGroup = value;
  }
  public resetFdGroup() {
    this._fdGroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fdGroupInput() {
    return this._fdGroup;
  }

  // file - computed: false, optional: true, required: false
  private _file?: string; 
  public get file() {
    return this.getStringAttribute('file');
  }
  public set file(value: string) {
    this._file = value;
  }
  public resetFile() {
    this._file = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksBackingStoreSourceFileSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksBackingStoreSourceFileSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksBackingStoreSourceNetworkAuthSecret {
  /**
  * Sets how the referenced secret is identified; typical values are user-provided strings such as "uuid" or "usage" depending on how the secret is looked up.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type?: string;
  /**
  * Sets the libvirt secret usage name when referencing the iSCSI auth secret by usage; the value is a user-provided identifier such as an iSCSI target name.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#usage Domain#usage}
  */
  readonly usage?: string;
}

export function domainDevicesDisksBackingStoreSourceNetworkAuthSecretToTerraform(struct?: DomainDevicesDisksBackingStoreSourceNetworkAuthSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    type: cdktf.stringToTerraform(struct!.type),
    usage: cdktf.stringToTerraform(struct!.usage),
  }
}


export function domainDevicesDisksBackingStoreSourceNetworkAuthSecretToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceNetworkAuthSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    usage: {
      value: cdktf.stringToHclTerraform(struct!.usage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceNetworkAuthSecretOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceNetworkAuthSecret | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._usage !== undefined) {
      hasAnyValues = true;
      internalValueResult.usage = this._usage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceNetworkAuthSecret | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._type = undefined;
      this._usage = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._type = value.type;
      this._usage = value.usage;
    }
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // usage - computed: false, optional: true, required: false
  private _usage?: string; 
  public get usage() {
    return this.getStringAttribute('usage');
  }
  public set usage(value: string) {
    this._usage = value;
  }
  public resetUsage() {
    this._usage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usageInput() {
    return this._usage;
  }

  // uuid - computed: true, optional: false, required: false
  public get uuid() {
    return this.getStringAttribute('uuid');
  }
}
export interface DomainDevicesDisksBackingStoreSourceNetworkAuth {
  /**
  * Configures the libvirt secret object used to hold the iSCSI authentication password for this hostdev; this references an existing libvirt secret, not the clear-text secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#secret Domain#secret}
  */
  readonly secret?: DomainDevicesDisksBackingStoreSourceNetworkAuthSecret;
  /**
  * Sets the CHAP username used when authenticating to the iSCSI target for this SCSI hostdev; the value is user-provided (for example, "chapuser1").
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#username Domain#username}
  */
  readonly username?: string;
}

export function domainDevicesDisksBackingStoreSourceNetworkAuthToTerraform(struct?: DomainDevicesDisksBackingStoreSourceNetworkAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret: domainDevicesDisksBackingStoreSourceNetworkAuthSecretToTerraform(struct!.secret),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function domainDevicesDisksBackingStoreSourceNetworkAuthToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceNetworkAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret: {
      value: domainDevicesDisksBackingStoreSourceNetworkAuthSecretToHclTerraform(struct!.secret),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceNetworkAuthSecret",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceNetworkAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceNetworkAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secret?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret?.internalValue;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceNetworkAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secret.internalValue = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secret.internalValue = value.secret;
      this._username = value.username;
    }
  }

  // secret - computed: false, optional: true, required: false
  private _secret = new DomainDevicesDisksBackingStoreSourceNetworkAuthSecretOutputReference(this, "secret");
  public get secret() {
    return this._secret;
  }
  public putSecret(value: DomainDevicesDisksBackingStoreSourceNetworkAuthSecret) {
    this._secret.internalValue = value;
  }
  public resetSecret() {
    this._secret.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret.internalValue;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface DomainDevicesDisksBackingStoreSourceNetworkConfig {
  /**
  * Sets the path to the configuration file used for the network backing store connection, such as a Ceph configuration file (/etc/ceph/ceph.conf).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file: string;
}

export function domainDevicesDisksBackingStoreSourceNetworkConfigToTerraform(struct?: DomainDevicesDisksBackingStoreSourceNetworkConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    file: cdktf.stringToTerraform(struct!.file),
  }
}


export function domainDevicesDisksBackingStoreSourceNetworkConfigToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceNetworkConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    file: {
      value: cdktf.stringToHclTerraform(struct!.file),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceNetworkConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceNetworkConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._file !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceNetworkConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._file = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._file = value.file;
    }
  }

  // file - computed: false, optional: false, required: true
  private _file?: string; 
  public get file() {
    return this.getStringAttribute('file');
  }
  public set file(value: string) {
    this._file = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file;
  }
}
export interface DomainDevicesDisksBackingStoreSourceNetworkHosts {
  /**
  * Sets the hostname or IP address of the iSCSI target portal (for example, "10.0.0.10" or "iscsi.example.com").
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name?: string;
  /**
  * Sets the TCP port of the iSCSI target portal; if omitted, libvirt/driver defaults (commonly 3260) are used.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#port Domain#port}
  */
  readonly port?: string;
  /**
  * Sets a UNIX domain socket path to connect to an iSCSI target via a local socket instead of TCP; value is a user-provided filesystem path.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#socket Domain#socket}
  */
  readonly socket?: string;
  /**
  * Sets the transport type used to reach the iSCSI target portal; valid values are user-provided strings as supported by the environment (for example, "tcp" or "iser").
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#transport Domain#transport}
  */
  readonly transport?: string;
}

export function domainDevicesDisksBackingStoreSourceNetworkHostsToTerraform(struct?: DomainDevicesDisksBackingStoreSourceNetworkHosts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    port: cdktf.stringToTerraform(struct!.port),
    socket: cdktf.stringToTerraform(struct!.socket),
    transport: cdktf.stringToTerraform(struct!.transport),
  }
}


export function domainDevicesDisksBackingStoreSourceNetworkHostsToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceNetworkHosts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.stringToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    socket: {
      value: cdktf.stringToHclTerraform(struct!.socket),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    transport: {
      value: cdktf.stringToHclTerraform(struct!.transport),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceNetworkHostsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceNetworkHosts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._socket !== undefined) {
      hasAnyValues = true;
      internalValueResult.socket = this._socket;
    }
    if (this._transport !== undefined) {
      hasAnyValues = true;
      internalValueResult.transport = this._transport;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceNetworkHosts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._port = undefined;
      this._socket = undefined;
      this._transport = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._port = value.port;
      this._socket = value.socket;
      this._transport = value.transport;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port - computed: false, optional: true, required: false
  private _port?: string; 
  public get port() {
    return this.getStringAttribute('port');
  }
  public set port(value: string) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // socket - computed: false, optional: true, required: false
  private _socket?: string; 
  public get socket() {
    return this.getStringAttribute('socket');
  }
  public set socket(value: string) {
    this._socket = value;
  }
  public resetSocket() {
    this._socket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketInput() {
    return this._socket;
  }

  // transport - computed: false, optional: true, required: false
  private _transport?: string; 
  public get transport() {
    return this.getStringAttribute('transport');
  }
  public set transport(value: string) {
    this._transport = value;
  }
  public resetTransport() {
    this._transport = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get transportInput() {
    return this._transport;
  }
}

export class DomainDevicesDisksBackingStoreSourceNetworkHostsList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksBackingStoreSourceNetworkHosts[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksBackingStoreSourceNetworkHostsOutputReference {
    return new DomainDevicesDisksBackingStoreSourceNetworkHostsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksBackingStoreSourceNetworkIdentity {
  /**
  * Sets the path to a local agent socket used for external authentication (for example, SASL or SSH agent) when connecting to the network backing store; value is a user-provided Unix socket path.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#agent_sock Domain#agent_sock}
  */
  readonly agentSock?: string;
  /**
  * Sets the group name to use for authentication or access control when connecting to the network backing store; value is user-provided and protocol-specific.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#group Domain#group}
  */
  readonly group?: string;
  /**
  * Sets the path to a private key file used for authenticating to the network backing store (for example, an SSH or TLS key); value is a user-provided filesystem path.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#keyfile Domain#keyfile}
  */
  readonly keyfile?: string;
  /**
  * Sets the user identifier used for authentication to the network backing store; value is user-provided and typically matches a remote account name.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#user Domain#user}
  */
  readonly user?: string;
  /**
  * Sets an explicit username string used for authentication to the network backing store, separate from any other user identity settings; value is user-provided (for example, "backupuser").
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#user_name Domain#user_name}
  */
  readonly userName?: string;
}

export function domainDevicesDisksBackingStoreSourceNetworkIdentityToTerraform(struct?: DomainDevicesDisksBackingStoreSourceNetworkIdentity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    agent_sock: cdktf.stringToTerraform(struct!.agentSock),
    group: cdktf.stringToTerraform(struct!.group),
    keyfile: cdktf.stringToTerraform(struct!.keyfile),
    user: cdktf.stringToTerraform(struct!.user),
    user_name: cdktf.stringToTerraform(struct!.userName),
  }
}


export function domainDevicesDisksBackingStoreSourceNetworkIdentityToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceNetworkIdentity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    agent_sock: {
      value: cdktf.stringToHclTerraform(struct!.agentSock),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    group: {
      value: cdktf.stringToHclTerraform(struct!.group),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keyfile: {
      value: cdktf.stringToHclTerraform(struct!.keyfile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user: {
      value: cdktf.stringToHclTerraform(struct!.user),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user_name: {
      value: cdktf.stringToHclTerraform(struct!.userName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceNetworkIdentityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceNetworkIdentity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._agentSock !== undefined) {
      hasAnyValues = true;
      internalValueResult.agentSock = this._agentSock;
    }
    if (this._group !== undefined) {
      hasAnyValues = true;
      internalValueResult.group = this._group;
    }
    if (this._keyfile !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyfile = this._keyfile;
    }
    if (this._user !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user;
    }
    if (this._userName !== undefined) {
      hasAnyValues = true;
      internalValueResult.userName = this._userName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceNetworkIdentity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._agentSock = undefined;
      this._group = undefined;
      this._keyfile = undefined;
      this._user = undefined;
      this._userName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._agentSock = value.agentSock;
      this._group = value.group;
      this._keyfile = value.keyfile;
      this._user = value.user;
      this._userName = value.userName;
    }
  }

  // agent_sock - computed: false, optional: true, required: false
  private _agentSock?: string; 
  public get agentSock() {
    return this.getStringAttribute('agent_sock');
  }
  public set agentSock(value: string) {
    this._agentSock = value;
  }
  public resetAgentSock() {
    this._agentSock = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get agentSockInput() {
    return this._agentSock;
  }

  // group - computed: false, optional: true, required: false
  private _group?: string; 
  public get group() {
    return this.getStringAttribute('group');
  }
  public set group(value: string) {
    this._group = value;
  }
  public resetGroup() {
    this._group = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupInput() {
    return this._group;
  }

  // keyfile - computed: false, optional: true, required: false
  private _keyfile?: string; 
  public get keyfile() {
    return this.getStringAttribute('keyfile');
  }
  public set keyfile(value: string) {
    this._keyfile = value;
  }
  public resetKeyfile() {
    this._keyfile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyfileInput() {
    return this._keyfile;
  }

  // user - computed: false, optional: true, required: false
  private _user?: string; 
  public get user() {
    return this.getStringAttribute('user');
  }
  public set user(value: string) {
    this._user = value;
  }
  public resetUser() {
    this._user = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user;
  }

  // user_name - computed: false, optional: true, required: false
  private _userName?: string; 
  public get userName() {
    return this.getStringAttribute('user_name');
  }
  public set userName(value: string) {
    this._userName = value;
  }
  public resetUserName() {
    this._userName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userNameInput() {
    return this._userName;
  }
}
export interface DomainDevicesDisksBackingStoreSourceNetworkInitiatorIqn {
  /**
  * Sets the initiator IQN string used when logging into an iSCSI target backing the mirrored disk; value must be a valid IQN (for example, iqn.2020-01.com.example:host1).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name?: string;
}

export function domainDevicesDisksBackingStoreSourceNetworkInitiatorIqnToTerraform(struct?: DomainDevicesDisksBackingStoreSourceNetworkInitiatorIqn | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function domainDevicesDisksBackingStoreSourceNetworkInitiatorIqnToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceNetworkInitiatorIqn | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceNetworkInitiatorIqnOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceNetworkInitiatorIqn | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceNetworkInitiatorIqn | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DomainDevicesDisksBackingStoreSourceNetworkInitiator {
  /**
  * Configures the iSCSI initiator IQN block for the mirrored network backing store, defining the initiator name presented to the target.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#iqn Domain#iqn}
  */
  readonly iqn?: DomainDevicesDisksBackingStoreSourceNetworkInitiatorIqn;
}

export function domainDevicesDisksBackingStoreSourceNetworkInitiatorToTerraform(struct?: DomainDevicesDisksBackingStoreSourceNetworkInitiator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    iqn: domainDevicesDisksBackingStoreSourceNetworkInitiatorIqnToTerraform(struct!.iqn),
  }
}


export function domainDevicesDisksBackingStoreSourceNetworkInitiatorToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceNetworkInitiator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    iqn: {
      value: domainDevicesDisksBackingStoreSourceNetworkInitiatorIqnToHclTerraform(struct!.iqn),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceNetworkInitiatorIqn",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceNetworkInitiatorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceNetworkInitiator | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._iqn?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.iqn = this._iqn?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceNetworkInitiator | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._iqn.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._iqn.internalValue = value.iqn;
    }
  }

  // iqn - computed: false, optional: true, required: false
  private _iqn = new DomainDevicesDisksBackingStoreSourceNetworkInitiatorIqnOutputReference(this, "iqn");
  public get iqn() {
    return this._iqn;
  }
  public putIqn(value: DomainDevicesDisksBackingStoreSourceNetworkInitiatorIqn) {
    this._iqn.internalValue = value;
  }
  public resetIqn() {
    this._iqn.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get iqnInput() {
    return this._iqn.internalValue;
  }
}
export interface DomainDevicesDisksBackingStoreSourceNetworkKnownHosts {
  /**
  * Sets the path to the known-hosts file used to verify the identity of the remote storage host; value is a required user-provided filesystem path (for example, /etc/libvirt/known_hosts).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
}

export function domainDevicesDisksBackingStoreSourceNetworkKnownHostsToTerraform(struct?: DomainDevicesDisksBackingStoreSourceNetworkKnownHosts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function domainDevicesDisksBackingStoreSourceNetworkKnownHostsToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceNetworkKnownHosts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceNetworkKnownHostsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceNetworkKnownHosts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceNetworkKnownHosts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface DomainDevicesDisksBackingStoreSourceNetworkReconnect {
  /**
  * Sets the reconnection delay (in seconds) before retrying a failed connection to the mirrored network backing store; value is a required user-provided non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#delay Domain#delay}
  */
  readonly delay: string;
}

export function domainDevicesDisksBackingStoreSourceNetworkReconnectToTerraform(struct?: DomainDevicesDisksBackingStoreSourceNetworkReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    delay: cdktf.stringToTerraform(struct!.delay),
  }
}


export function domainDevicesDisksBackingStoreSourceNetworkReconnectToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceNetworkReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    delay: {
      value: cdktf.stringToHclTerraform(struct!.delay),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceNetworkReconnectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceNetworkReconnect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._delay !== undefined) {
      hasAnyValues = true;
      internalValueResult.delay = this._delay;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceNetworkReconnect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._delay = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._delay = value.delay;
    }
  }

  // delay - computed: false, optional: false, required: true
  private _delay?: string; 
  public get delay() {
    return this.getStringAttribute('delay');
  }
  public set delay(value: string) {
    this._delay = value;
  }
  // Temporarily expose input value. Use with caution.
  public get delayInput() {
    return this._delay;
  }
}
export interface DomainDevicesDisksBackingStoreSourceNetworkSnapshot {
  /**
  * Sets the name of the network snapshot to use as the backing store for the mirrored disk’s network source; value is user-provided and must match an existing snapshot identifier on the storage backend.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
}

export function domainDevicesDisksBackingStoreSourceNetworkSnapshotToTerraform(struct?: DomainDevicesDisksBackingStoreSourceNetworkSnapshot | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function domainDevicesDisksBackingStoreSourceNetworkSnapshotToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceNetworkSnapshot | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceNetworkSnapshotOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceNetworkSnapshot | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceNetworkSnapshot | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DomainDevicesDisksBackingStoreSourceNetwork {
  /**
  * Configures CHAP authentication parameters for the iSCSI source backing an assigned SCSI host device; include this block only when the target requires authentication.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#auth Domain#auth}
  */
  readonly auth?: DomainDevicesDisksBackingStoreSourceNetworkAuth;
  /**
  * Points to an external configuration source for the network backing store (for example, an RBD or Ceph config file) that libvirt passes to the backend.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#config Domain#config}
  */
  readonly config?: DomainDevicesDisksBackingStoreSourceNetworkConfig;
  /**
  * Declares one or more network endpoints (hosts) for the backing store server, each with its own name/address and possibly additional attributes.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#hosts Domain#hosts}
  */
  readonly hosts?: DomainDevicesDisksBackingStoreSourceNetworkHosts[] | cdktf.IResolvable;
  /**
  * Configures authentication/identity parameters used when accessing the mirrored backing store over a network, such as user, group, keyfile, or agent socket, depending on the protocol.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#identity Domain#identity}
  */
  readonly identity?: DomainDevicesDisksBackingStoreSourceNetworkIdentity;
  /**
  * Configures initiator identity information (typically for iSCSI-like protocols) used when accessing the mirrored network backing store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#initiator Domain#initiator}
  */
  readonly initiator?: DomainDevicesDisksBackingStoreSourceNetworkInitiator;
  /**
  * Enables use of a known-hosts file to validate the remote host’s identity when connecting to the mirrored network backing store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#known_hosts Domain#known_hosts}
  */
  readonly knownHosts?: DomainDevicesDisksBackingStoreSourceNetworkKnownHosts;
  /**
  * Sets a name for the network source of the mirrored backing store, typically used by certain protocols (such as RBD pool or NBD export names); value is user-provided and protocol-specific.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name?: string;
  /**
  * Sets the network storage protocol used for the mirrored backing store; value is user-provided but must be a protocol supported by libvirt for network disks (for example, rbd, sheepdog, gluster, nbd).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#protocol Domain#protocol}
  */
  readonly protocol?: string;
  /**
  * Sets an optional query string or subresource specifier for the network storage URL of the mirrored backing store; value is user-provided and protocol-specific.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#query Domain#query}
  */
  readonly query?: string;
  /**
  * Configures automatic reconnection behavior for the mirrored network backing store after a connection loss.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reconnect Domain#reconnect}
  */
  readonly reconnect?: DomainDevicesDisksBackingStoreSourceNetworkReconnect;
  /**
  * Configures snapshot-related behavior for the network-based mirrored backing store, with semantics depending on the underlying protocol and storage implementation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#snapshot Domain#snapshot}
  */
  readonly snapshot?: DomainDevicesDisksBackingStoreSourceNetworkSnapshot;
  /**
  * Controls whether TLS is used for the mirrored disk’s network backing-store connection; value is user-provided and typically enabled only when the chosen protocol and backend support TLS.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tls Domain#tls}
  */
  readonly tls?: string;
  /**
  * Sets the expected TLS hostname for the mirrored disk’s network backing-store connection, used for certificate verification; value is user-provided and should match the server certificate’s hostname (for example, "storage.example.com").
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tls_hostname Domain#tls_hostname}
  */
  readonly tlsHostname?: string;
}

export function domainDevicesDisksBackingStoreSourceNetworkToTerraform(struct?: DomainDevicesDisksBackingStoreSourceNetwork | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: domainDevicesDisksBackingStoreSourceNetworkAuthToTerraform(struct!.auth),
    config: domainDevicesDisksBackingStoreSourceNetworkConfigToTerraform(struct!.config),
    hosts: cdktf.listMapper(domainDevicesDisksBackingStoreSourceNetworkHostsToTerraform, false)(struct!.hosts),
    identity: domainDevicesDisksBackingStoreSourceNetworkIdentityToTerraform(struct!.identity),
    initiator: domainDevicesDisksBackingStoreSourceNetworkInitiatorToTerraform(struct!.initiator),
    known_hosts: domainDevicesDisksBackingStoreSourceNetworkKnownHostsToTerraform(struct!.knownHosts),
    name: cdktf.stringToTerraform(struct!.name),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    query: cdktf.stringToTerraform(struct!.query),
    reconnect: domainDevicesDisksBackingStoreSourceNetworkReconnectToTerraform(struct!.reconnect),
    snapshot: domainDevicesDisksBackingStoreSourceNetworkSnapshotToTerraform(struct!.snapshot),
    tls: cdktf.stringToTerraform(struct!.tls),
    tls_hostname: cdktf.stringToTerraform(struct!.tlsHostname),
  }
}


export function domainDevicesDisksBackingStoreSourceNetworkToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceNetwork | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: domainDevicesDisksBackingStoreSourceNetworkAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceNetworkAuth",
    },
    config: {
      value: domainDevicesDisksBackingStoreSourceNetworkConfigToHclTerraform(struct!.config),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceNetworkConfig",
    },
    hosts: {
      value: cdktf.listMapperHcl(domainDevicesDisksBackingStoreSourceNetworkHostsToHclTerraform, false)(struct!.hosts),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksBackingStoreSourceNetworkHostsList",
    },
    identity: {
      value: domainDevicesDisksBackingStoreSourceNetworkIdentityToHclTerraform(struct!.identity),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceNetworkIdentity",
    },
    initiator: {
      value: domainDevicesDisksBackingStoreSourceNetworkInitiatorToHclTerraform(struct!.initiator),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceNetworkInitiator",
    },
    known_hosts: {
      value: domainDevicesDisksBackingStoreSourceNetworkKnownHostsToHclTerraform(struct!.knownHosts),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceNetworkKnownHosts",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    query: {
      value: cdktf.stringToHclTerraform(struct!.query),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reconnect: {
      value: domainDevicesDisksBackingStoreSourceNetworkReconnectToHclTerraform(struct!.reconnect),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceNetworkReconnect",
    },
    snapshot: {
      value: domainDevicesDisksBackingStoreSourceNetworkSnapshotToHclTerraform(struct!.snapshot),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceNetworkSnapshot",
    },
    tls: {
      value: cdktf.stringToHclTerraform(struct!.tls),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_hostname: {
      value: cdktf.stringToHclTerraform(struct!.tlsHostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceNetworkOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceNetwork | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._config?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.config = this._config?.internalValue;
    }
    if (this._hosts?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hosts = this._hosts?.internalValue;
    }
    if (this._identity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.identity = this._identity?.internalValue;
    }
    if (this._initiator?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.initiator = this._initiator?.internalValue;
    }
    if (this._knownHosts?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.knownHosts = this._knownHosts?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._query !== undefined) {
      hasAnyValues = true;
      internalValueResult.query = this._query;
    }
    if (this._reconnect?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.reconnect = this._reconnect?.internalValue;
    }
    if (this._snapshot?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.snapshot = this._snapshot?.internalValue;
    }
    if (this._tls !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls;
    }
    if (this._tlsHostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsHostname = this._tlsHostname;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceNetwork | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._config.internalValue = undefined;
      this._hosts.internalValue = undefined;
      this._identity.internalValue = undefined;
      this._initiator.internalValue = undefined;
      this._knownHosts.internalValue = undefined;
      this._name = undefined;
      this._protocol = undefined;
      this._query = undefined;
      this._reconnect.internalValue = undefined;
      this._snapshot.internalValue = undefined;
      this._tls = undefined;
      this._tlsHostname = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._config.internalValue = value.config;
      this._hosts.internalValue = value.hosts;
      this._identity.internalValue = value.identity;
      this._initiator.internalValue = value.initiator;
      this._knownHosts.internalValue = value.knownHosts;
      this._name = value.name;
      this._protocol = value.protocol;
      this._query = value.query;
      this._reconnect.internalValue = value.reconnect;
      this._snapshot.internalValue = value.snapshot;
      this._tls = value.tls;
      this._tlsHostname = value.tlsHostname;
    }
  }

  // auth - computed: false, optional: true, required: false
  private _auth = new DomainDevicesDisksBackingStoreSourceNetworkAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DomainDevicesDisksBackingStoreSourceNetworkAuth) {
    this._auth.internalValue = value;
  }
  public resetAuth() {
    this._auth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // config - computed: false, optional: true, required: false
  private _config = new DomainDevicesDisksBackingStoreSourceNetworkConfigOutputReference(this, "config");
  public get config() {
    return this._config;
  }
  public putConfig(value: DomainDevicesDisksBackingStoreSourceNetworkConfig) {
    this._config.internalValue = value;
  }
  public resetConfig() {
    this._config.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configInput() {
    return this._config.internalValue;
  }

  // hosts - computed: false, optional: true, required: false
  private _hosts = new DomainDevicesDisksBackingStoreSourceNetworkHostsList(this, "hosts", false);
  public get hosts() {
    return this._hosts;
  }
  public putHosts(value: DomainDevicesDisksBackingStoreSourceNetworkHosts[] | cdktf.IResolvable) {
    this._hosts.internalValue = value;
  }
  public resetHosts() {
    this._hosts.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostsInput() {
    return this._hosts.internalValue;
  }

  // identity - computed: false, optional: true, required: false
  private _identity = new DomainDevicesDisksBackingStoreSourceNetworkIdentityOutputReference(this, "identity");
  public get identity() {
    return this._identity;
  }
  public putIdentity(value: DomainDevicesDisksBackingStoreSourceNetworkIdentity) {
    this._identity.internalValue = value;
  }
  public resetIdentity() {
    this._identity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identityInput() {
    return this._identity.internalValue;
  }

  // initiator - computed: false, optional: true, required: false
  private _initiator = new DomainDevicesDisksBackingStoreSourceNetworkInitiatorOutputReference(this, "initiator");
  public get initiator() {
    return this._initiator;
  }
  public putInitiator(value: DomainDevicesDisksBackingStoreSourceNetworkInitiator) {
    this._initiator.internalValue = value;
  }
  public resetInitiator() {
    this._initiator.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initiatorInput() {
    return this._initiator.internalValue;
  }

  // known_hosts - computed: false, optional: true, required: false
  private _knownHosts = new DomainDevicesDisksBackingStoreSourceNetworkKnownHostsOutputReference(this, "known_hosts");
  public get knownHosts() {
    return this._knownHosts;
  }
  public putKnownHosts(value: DomainDevicesDisksBackingStoreSourceNetworkKnownHosts) {
    this._knownHosts.internalValue = value;
  }
  public resetKnownHosts() {
    this._knownHosts.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get knownHostsInput() {
    return this._knownHosts.internalValue;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // protocol - computed: false, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // query - computed: false, optional: true, required: false
  private _query?: string; 
  public get query() {
    return this.getStringAttribute('query');
  }
  public set query(value: string) {
    this._query = value;
  }
  public resetQuery() {
    this._query = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queryInput() {
    return this._query;
  }

  // reconnect - computed: false, optional: true, required: false
  private _reconnect = new DomainDevicesDisksBackingStoreSourceNetworkReconnectOutputReference(this, "reconnect");
  public get reconnect() {
    return this._reconnect;
  }
  public putReconnect(value: DomainDevicesDisksBackingStoreSourceNetworkReconnect) {
    this._reconnect.internalValue = value;
  }
  public resetReconnect() {
    this._reconnect.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reconnectInput() {
    return this._reconnect.internalValue;
  }

  // snapshot - computed: false, optional: true, required: false
  private _snapshot = new DomainDevicesDisksBackingStoreSourceNetworkSnapshotOutputReference(this, "snapshot");
  public get snapshot() {
    return this._snapshot;
  }
  public putSnapshot(value: DomainDevicesDisksBackingStoreSourceNetworkSnapshot) {
    this._snapshot.internalValue = value;
  }
  public resetSnapshot() {
    this._snapshot.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get snapshotInput() {
    return this._snapshot.internalValue;
  }

  // tls - computed: false, optional: true, required: false
  private _tls?: string; 
  public get tls() {
    return this.getStringAttribute('tls');
  }
  public set tls(value: string) {
    this._tls = value;
  }
  public resetTls() {
    this._tls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls;
  }

  // tls_hostname - computed: false, optional: true, required: false
  private _tlsHostname?: string; 
  public get tlsHostname() {
    return this.getStringAttribute('tls_hostname');
  }
  public set tlsHostname(value: string) {
    this._tlsHostname = value;
  }
  public resetTlsHostname() {
    this._tlsHostname = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsHostnameInput() {
    return this._tlsHostname;
  }
}
export interface DomainDevicesDisksBackingStoreSourceNvme {
}

export function domainDevicesDisksBackingStoreSourceNvmeToTerraform(struct?: DomainDevicesDisksBackingStoreSourceNvme | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function domainDevicesDisksBackingStoreSourceNvmeToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceNvme | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DomainDevicesDisksBackingStoreSourceNvmeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceNvme | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceNvme | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DomainDevicesDisksBackingStoreSourceReadahead {
  /**
  * Sets the read-ahead size for the mirrored disk’s backing store; value is a user-provided positive integer in bytes (for example, 65536 for 64 KiB).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#size Domain#size}
  */
  readonly size: string;
}

export function domainDevicesDisksBackingStoreSourceReadaheadToTerraform(struct?: DomainDevicesDisksBackingStoreSourceReadahead | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    size: cdktf.stringToTerraform(struct!.size),
  }
}


export function domainDevicesDisksBackingStoreSourceReadaheadToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceReadahead | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    size: {
      value: cdktf.stringToHclTerraform(struct!.size),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceReadaheadOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceReadahead | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._size !== undefined) {
      hasAnyValues = true;
      internalValueResult.size = this._size;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceReadahead | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._size = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._size = value.size;
    }
  }

  // size - computed: false, optional: false, required: true
  private _size?: string; 
  public get size() {
    return this.getStringAttribute('size');
  }
  public set size(value: string) {
    this._size = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sizeInput() {
    return this._size;
  }
}
export interface DomainDevicesDisksBackingStoreSourceReservationsSourceDbus {
  /**
  * Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#channel Domain#channel}
  */
  readonly channel?: string;
}

export function domainDevicesDisksBackingStoreSourceReservationsSourceDbusToTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservationsSourceDbus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    channel: cdktf.stringToTerraform(struct!.channel),
  }
}


export function domainDevicesDisksBackingStoreSourceReservationsSourceDbusToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservationsSourceDbus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    channel: {
      value: cdktf.stringToHclTerraform(struct!.channel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceReservationsSourceDbusOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceReservationsSourceDbus | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._channel !== undefined) {
      hasAnyValues = true;
      internalValueResult.channel = this._channel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceReservationsSourceDbus | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._channel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._channel = value.channel;
    }
  }

  // channel - computed: false, optional: true, required: false
  private _channel?: string; 
  public get channel() {
    return this.getStringAttribute('channel');
  }
  public set channel(value: string) {
    this._channel = value;
  }
  public resetChannel() {
    this._channel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get channelInput() {
    return this._channel;
  }
}
export interface DomainDevicesDisksBackingStoreSourceReservationsSourceDevSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksBackingStoreSourceReservationsSourceDevSecLabelToTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservationsSourceDevSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksBackingStoreSourceReservationsSourceDevSecLabelToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservationsSourceDevSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceReservationsSourceDevSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceReservationsSourceDevSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceReservationsSourceDevSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksBackingStoreSourceReservationsSourceDevSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksBackingStoreSourceReservationsSourceDevSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksBackingStoreSourceReservationsSourceDevSecLabelOutputReference {
    return new DomainDevicesDisksBackingStoreSourceReservationsSourceDevSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksBackingStoreSourceReservationsSourceDev {
  /**
  * Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksBackingStoreSourceReservationsSourceDevSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksBackingStoreSourceReservationsSourceDevToTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservationsSourceDev | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesDisksBackingStoreSourceReservationsSourceDevSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksBackingStoreSourceReservationsSourceDevToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservationsSourceDev | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksBackingStoreSourceReservationsSourceDevSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksBackingStoreSourceReservationsSourceDevSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceReservationsSourceDevOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceReservationsSourceDev | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceReservationsSourceDev | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksBackingStoreSourceReservationsSourceDevSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksBackingStoreSourceReservationsSourceDevSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksBackingStoreSourceReservationsSourceFileSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksBackingStoreSourceReservationsSourceFileSecLabelToTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservationsSourceFileSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksBackingStoreSourceReservationsSourceFileSecLabelToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservationsSourceFileSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceReservationsSourceFileSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceReservationsSourceFileSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceReservationsSourceFileSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksBackingStoreSourceReservationsSourceFileSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksBackingStoreSourceReservationsSourceFileSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksBackingStoreSourceReservationsSourceFileSecLabelOutputReference {
    return new DomainDevicesDisksBackingStoreSourceReservationsSourceFileSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksBackingStoreSourceReservationsSourceFile {
  /**
  * Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.
  * 
  * See: <https://libvirt.org/formatdomain.html#device-logfile>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#append Domain#append}
  */
  readonly append?: string;
  /**
  * Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksBackingStoreSourceReservationsSourceFileSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksBackingStoreSourceReservationsSourceFileToTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservationsSourceFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.stringToTerraform(struct!.append),
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesDisksBackingStoreSourceReservationsSourceFileSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksBackingStoreSourceReservationsSourceFileToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservationsSourceFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.stringToHclTerraform(struct!.append),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksBackingStoreSourceReservationsSourceFileSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksBackingStoreSourceReservationsSourceFileSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceReservationsSourceFileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceReservationsSourceFile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceReservationsSourceFile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append = value.append;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append?: string; 
  public get append() {
    return this.getStringAttribute('append');
  }
  public set append(value: string) {
    this._append = value;
  }
  public resetAppend() {
    this._append = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append;
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksBackingStoreSourceReservationsSourceFileSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksBackingStoreSourceReservationsSourceFileSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksBackingStoreSourceReservationsSourceNmdm {
  /**
  * Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.
  * 
  * See: <https://libvirt.org/formatdomain.html#nmdm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#master Domain#master}
  */
  readonly master: string;
  /**
  * Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.
  * 
  * See: <https://libvirt.org/formatdomain.html#nmdm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#slave Domain#slave}
  */
  readonly slave: string;
}

export function domainDevicesDisksBackingStoreSourceReservationsSourceNmdmToTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservationsSourceNmdm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    master: cdktf.stringToTerraform(struct!.master),
    slave: cdktf.stringToTerraform(struct!.slave),
  }
}


export function domainDevicesDisksBackingStoreSourceReservationsSourceNmdmToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservationsSourceNmdm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    master: {
      value: cdktf.stringToHclTerraform(struct!.master),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    slave: {
      value: cdktf.stringToHclTerraform(struct!.slave),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceReservationsSourceNmdmOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceReservationsSourceNmdm | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._master !== undefined) {
      hasAnyValues = true;
      internalValueResult.master = this._master;
    }
    if (this._slave !== undefined) {
      hasAnyValues = true;
      internalValueResult.slave = this._slave;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceReservationsSourceNmdm | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._master = undefined;
      this._slave = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._master = value.master;
      this._slave = value.slave;
    }
  }

  // master - computed: false, optional: false, required: true
  private _master?: string; 
  public get master() {
    return this.getStringAttribute('master');
  }
  public set master(value: string) {
    this._master = value;
  }
  // Temporarily expose input value. Use with caution.
  public get masterInput() {
    return this._master;
  }

  // slave - computed: false, optional: false, required: true
  private _slave?: string; 
  public get slave() {
    return this.getStringAttribute('slave');
  }
  public set slave(value: string) {
    this._slave = value;
  }
  // Temporarily expose input value. Use with caution.
  public get slaveInput() {
    return this._slave;
  }
}
export interface DomainDevicesDisksBackingStoreSourceReservationsSourcePipeSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksBackingStoreSourceReservationsSourcePipeSecLabelToTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservationsSourcePipeSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksBackingStoreSourceReservationsSourcePipeSecLabelToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservationsSourcePipeSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceReservationsSourcePipeSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceReservationsSourcePipeSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceReservationsSourcePipeSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksBackingStoreSourceReservationsSourcePipeSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksBackingStoreSourceReservationsSourcePipeSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksBackingStoreSourceReservationsSourcePipeSecLabelOutputReference {
    return new DomainDevicesDisksBackingStoreSourceReservationsSourcePipeSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksBackingStoreSourceReservationsSourcePipe {
  /**
  * Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksBackingStoreSourceReservationsSourcePipeSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksBackingStoreSourceReservationsSourcePipeToTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservationsSourcePipe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesDisksBackingStoreSourceReservationsSourcePipeSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksBackingStoreSourceReservationsSourcePipeToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservationsSourcePipe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksBackingStoreSourceReservationsSourcePipeSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksBackingStoreSourceReservationsSourcePipeSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceReservationsSourcePipeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceReservationsSourcePipe | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceReservationsSourcePipe | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksBackingStoreSourceReservationsSourcePipeSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksBackingStoreSourceReservationsSourcePipeSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksBackingStoreSourceReservationsSourcePtySecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksBackingStoreSourceReservationsSourcePtySecLabelToTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservationsSourcePtySecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksBackingStoreSourceReservationsSourcePtySecLabelToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservationsSourcePtySecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceReservationsSourcePtySecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceReservationsSourcePtySecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceReservationsSourcePtySecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksBackingStoreSourceReservationsSourcePtySecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksBackingStoreSourceReservationsSourcePtySecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksBackingStoreSourceReservationsSourcePtySecLabelOutputReference {
    return new DomainDevicesDisksBackingStoreSourceReservationsSourcePtySecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksBackingStoreSourceReservationsSourcePty {
  /**
  * Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksBackingStoreSourceReservationsSourcePtySecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksBackingStoreSourceReservationsSourcePtyToTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservationsSourcePty | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesDisksBackingStoreSourceReservationsSourcePtySecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksBackingStoreSourceReservationsSourcePtyToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservationsSourcePty | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksBackingStoreSourceReservationsSourcePtySecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksBackingStoreSourceReservationsSourcePtySecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceReservationsSourcePtyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceReservationsSourcePty | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceReservationsSourcePty | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksBackingStoreSourceReservationsSourcePtySecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksBackingStoreSourceReservationsSourcePtySecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksBackingStoreSourceReservationsSourceQemuvdAgentClipBoard {
  /**
  * Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#copy_paste Domain#copy_paste}
  */
  readonly copyPaste: string;
}

export function domainDevicesDisksBackingStoreSourceReservationsSourceQemuvdAgentClipBoardToTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservationsSourceQemuvdAgentClipBoard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    copy_paste: cdktf.stringToTerraform(struct!.copyPaste),
  }
}


export function domainDevicesDisksBackingStoreSourceReservationsSourceQemuvdAgentClipBoardToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservationsSourceQemuvdAgentClipBoard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    copy_paste: {
      value: cdktf.stringToHclTerraform(struct!.copyPaste),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceReservationsSourceQemuvdAgentClipBoardOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceReservationsSourceQemuvdAgentClipBoard | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._copyPaste !== undefined) {
      hasAnyValues = true;
      internalValueResult.copyPaste = this._copyPaste;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceReservationsSourceQemuvdAgentClipBoard | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._copyPaste = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._copyPaste = value.copyPaste;
    }
  }

  // copy_paste - computed: false, optional: false, required: true
  private _copyPaste?: string; 
  public get copyPaste() {
    return this.getStringAttribute('copy_paste');
  }
  public set copyPaste(value: string) {
    this._copyPaste = value;
  }
  // Temporarily expose input value. Use with caution.
  public get copyPasteInput() {
    return this._copyPaste;
  }
}
export interface DomainDevicesDisksBackingStoreSourceReservationsSourceQemuvdAgentMouse {
  /**
  * Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).
  * 
  * See: <https://libvirt.org/formatdomain.html#channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode: string;
}

export function domainDevicesDisksBackingStoreSourceReservationsSourceQemuvdAgentMouseToTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservationsSourceQemuvdAgentMouse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
  }
}


export function domainDevicesDisksBackingStoreSourceReservationsSourceQemuvdAgentMouseToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservationsSourceQemuvdAgentMouse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceReservationsSourceQemuvdAgentMouseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceReservationsSourceQemuvdAgentMouse | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceReservationsSourceQemuvdAgentMouse | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
    }
  }

  // mode - computed: false, optional: false, required: true
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }
}
export interface DomainDevicesDisksBackingStoreSourceReservationsSourceQemuvdAgent {
  /**
  * Configures clipboard-related behavior for the QEMU vdagent–based EGD source, controlling whether clipboard data exchange is allowed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#clip_board Domain#clip_board}
  */
  readonly clipBoard?: DomainDevicesDisksBackingStoreSourceReservationsSourceQemuvdAgentClipBoard;
  /**
  * Configures mouse integration options for the QEMU vdagent–based EGD source, such as how mouse events are handled.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mouse Domain#mouse}
  */
  readonly mouse?: DomainDevicesDisksBackingStoreSourceReservationsSourceQemuvdAgentMouse;
}

export function domainDevicesDisksBackingStoreSourceReservationsSourceQemuvdAgentToTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservationsSourceQemuvdAgent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    clip_board: domainDevicesDisksBackingStoreSourceReservationsSourceQemuvdAgentClipBoardToTerraform(struct!.clipBoard),
    mouse: domainDevicesDisksBackingStoreSourceReservationsSourceQemuvdAgentMouseToTerraform(struct!.mouse),
  }
}


export function domainDevicesDisksBackingStoreSourceReservationsSourceQemuvdAgentToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservationsSourceQemuvdAgent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    clip_board: {
      value: domainDevicesDisksBackingStoreSourceReservationsSourceQemuvdAgentClipBoardToHclTerraform(struct!.clipBoard),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceReservationsSourceQemuvdAgentClipBoard",
    },
    mouse: {
      value: domainDevicesDisksBackingStoreSourceReservationsSourceQemuvdAgentMouseToHclTerraform(struct!.mouse),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceReservationsSourceQemuvdAgentMouse",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceReservationsSourceQemuvdAgentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceReservationsSourceQemuvdAgent | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clipBoard?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clipBoard = this._clipBoard?.internalValue;
    }
    if (this._mouse?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.mouse = this._mouse?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceReservationsSourceQemuvdAgent | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clipBoard.internalValue = undefined;
      this._mouse.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clipBoard.internalValue = value.clipBoard;
      this._mouse.internalValue = value.mouse;
    }
  }

  // clip_board - computed: false, optional: true, required: false
  private _clipBoard = new DomainDevicesDisksBackingStoreSourceReservationsSourceQemuvdAgentClipBoardOutputReference(this, "clip_board");
  public get clipBoard() {
    return this._clipBoard;
  }
  public putClipBoard(value: DomainDevicesDisksBackingStoreSourceReservationsSourceQemuvdAgentClipBoard) {
    this._clipBoard.internalValue = value;
  }
  public resetClipBoard() {
    this._clipBoard.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clipBoardInput() {
    return this._clipBoard.internalValue;
  }

  // mouse - computed: false, optional: true, required: false
  private _mouse = new DomainDevicesDisksBackingStoreSourceReservationsSourceQemuvdAgentMouseOutputReference(this, "mouse");
  public get mouse() {
    return this._mouse;
  }
  public putMouse(value: DomainDevicesDisksBackingStoreSourceReservationsSourceQemuvdAgentMouse) {
    this._mouse.internalValue = value;
  }
  public resetMouse() {
    this._mouse.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mouseInput() {
    return this._mouse.internalValue;
  }
}
export interface DomainDevicesDisksBackingStoreSourceReservationsSourceSpicePort {
  /**
  * Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#channel Domain#channel}
  */
  readonly channel: string;
}

export function domainDevicesDisksBackingStoreSourceReservationsSourceSpicePortToTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservationsSourceSpicePort | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    channel: cdktf.stringToTerraform(struct!.channel),
  }
}


export function domainDevicesDisksBackingStoreSourceReservationsSourceSpicePortToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservationsSourceSpicePort | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    channel: {
      value: cdktf.stringToHclTerraform(struct!.channel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceReservationsSourceSpicePortOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceReservationsSourceSpicePort | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._channel !== undefined) {
      hasAnyValues = true;
      internalValueResult.channel = this._channel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceReservationsSourceSpicePort | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._channel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._channel = value.channel;
    }
  }

  // channel - computed: false, optional: false, required: true
  private _channel?: string; 
  public get channel() {
    return this.getStringAttribute('channel');
  }
  public set channel(value: string) {
    this._channel = value;
  }
  // Temporarily expose input value. Use with caution.
  public get channelInput() {
    return this._channel;
  }
}
export interface DomainDevicesDisksBackingStoreSourceReservationsSourceTcpReconnect {
  /**
  * Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enabled Domain#enabled}
  */
  readonly enabled: string;
  /**
  * Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#timeout Domain#timeout}
  */
  readonly timeout?: number;
}

export function domainDevicesDisksBackingStoreSourceReservationsSourceTcpReconnectToTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservationsSourceTcpReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.stringToTerraform(struct!.enabled),
    timeout: cdktf.numberToTerraform(struct!.timeout),
  }
}


export function domainDevicesDisksBackingStoreSourceReservationsSourceTcpReconnectToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservationsSourceTcpReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.stringToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.numberToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceReservationsSourceTcpReconnectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceReservationsSourceTcpReconnect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceReservationsSourceTcpReconnect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._timeout = value.timeout;
    }
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: string; 
  public get enabled() {
    return this.getStringAttribute('enabled');
  }
  public set enabled(value: string) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: number; 
  public get timeout() {
    return this.getNumberAttribute('timeout');
  }
  public set timeout(value: number) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DomainDevicesDisksBackingStoreSourceReservationsSourceTcp {
  /**
  * Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#host Domain#host}
  */
  readonly host?: string;
  /**
  * Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode?: string;
  /**
  * Enables and configures automatic reconnection behavior for a UNIX socket–based EGD entropy source; the content and attributes are user-provided according to desired policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reconnect Domain#reconnect}
  */
  readonly reconnect?: DomainDevicesDisksBackingStoreSourceReservationsSourceTcpReconnect;
  /**
  * Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#service Domain#service}
  */
  readonly service?: string;
  /**
  * Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tls Domain#tls}
  */
  readonly tls?: string;
}

export function domainDevicesDisksBackingStoreSourceReservationsSourceTcpToTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservationsSourceTcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    mode: cdktf.stringToTerraform(struct!.mode),
    reconnect: domainDevicesDisksBackingStoreSourceReservationsSourceTcpReconnectToTerraform(struct!.reconnect),
    service: cdktf.stringToTerraform(struct!.service),
    tls: cdktf.stringToTerraform(struct!.tls),
  }
}


export function domainDevicesDisksBackingStoreSourceReservationsSourceTcpToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservationsSourceTcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reconnect: {
      value: domainDevicesDisksBackingStoreSourceReservationsSourceTcpReconnectToHclTerraform(struct!.reconnect),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceReservationsSourceTcpReconnect",
    },
    service: {
      value: cdktf.stringToHclTerraform(struct!.service),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: cdktf.stringToHclTerraform(struct!.tls),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceReservationsSourceTcpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceReservationsSourceTcp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._reconnect?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.reconnect = this._reconnect?.internalValue;
    }
    if (this._service !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service;
    }
    if (this._tls !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceReservationsSourceTcp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host = undefined;
      this._mode = undefined;
      this._reconnect.internalValue = undefined;
      this._service = undefined;
      this._tls = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host = value.host;
      this._mode = value.mode;
      this._reconnect.internalValue = value.reconnect;
      this._service = value.service;
      this._tls = value.tls;
    }
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // reconnect - computed: false, optional: true, required: false
  private _reconnect = new DomainDevicesDisksBackingStoreSourceReservationsSourceTcpReconnectOutputReference(this, "reconnect");
  public get reconnect() {
    return this._reconnect;
  }
  public putReconnect(value: DomainDevicesDisksBackingStoreSourceReservationsSourceTcpReconnect) {
    this._reconnect.internalValue = value;
  }
  public resetReconnect() {
    this._reconnect.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reconnectInput() {
    return this._reconnect.internalValue;
  }

  // service - computed: false, optional: true, required: false
  private _service?: string; 
  public get service() {
    return this.getStringAttribute('service');
  }
  public set service(value: string) {
    this._service = value;
  }
  public resetService() {
    this._service = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service;
  }

  // tls - computed: false, optional: true, required: false
  private _tls?: string; 
  public get tls() {
    return this.getStringAttribute('tls');
  }
  public set tls(value: string) {
    this._tls = value;
  }
  public resetTls() {
    this._tls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls;
  }
}
export interface DomainDevicesDisksBackingStoreSourceReservationsSourceUdp {
  /**
  * Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bind_host Domain#bind_host}
  */
  readonly bindHost: string;
  /**
  * Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bind_service Domain#bind_service}
  */
  readonly bindService: string;
  /**
  * Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#connect_host Domain#connect_host}
  */
  readonly connectHost: string;
  /**
  * Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#connect_service Domain#connect_service}
  */
  readonly connectService: string;
}

export function domainDevicesDisksBackingStoreSourceReservationsSourceUdpToTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservationsSourceUdp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_host: cdktf.stringToTerraform(struct!.bindHost),
    bind_service: cdktf.stringToTerraform(struct!.bindService),
    connect_host: cdktf.stringToTerraform(struct!.connectHost),
    connect_service: cdktf.stringToTerraform(struct!.connectService),
  }
}


export function domainDevicesDisksBackingStoreSourceReservationsSourceUdpToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservationsSourceUdp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_host: {
      value: cdktf.stringToHclTerraform(struct!.bindHost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bind_service: {
      value: cdktf.stringToHclTerraform(struct!.bindService),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connect_host: {
      value: cdktf.stringToHclTerraform(struct!.connectHost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connect_service: {
      value: cdktf.stringToHclTerraform(struct!.connectService),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceReservationsSourceUdpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceReservationsSourceUdp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindHost !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindHost = this._bindHost;
    }
    if (this._bindService !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindService = this._bindService;
    }
    if (this._connectHost !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectHost = this._connectHost;
    }
    if (this._connectService !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectService = this._connectService;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceReservationsSourceUdp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bindHost = undefined;
      this._bindService = undefined;
      this._connectHost = undefined;
      this._connectService = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bindHost = value.bindHost;
      this._bindService = value.bindService;
      this._connectHost = value.connectHost;
      this._connectService = value.connectService;
    }
  }

  // bind_host - computed: false, optional: false, required: true
  private _bindHost?: string; 
  public get bindHost() {
    return this.getStringAttribute('bind_host');
  }
  public set bindHost(value: string) {
    this._bindHost = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bindHostInput() {
    return this._bindHost;
  }

  // bind_service - computed: false, optional: false, required: true
  private _bindService?: string; 
  public get bindService() {
    return this.getStringAttribute('bind_service');
  }
  public set bindService(value: string) {
    this._bindService = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bindServiceInput() {
    return this._bindService;
  }

  // connect_host - computed: false, optional: false, required: true
  private _connectHost?: string; 
  public get connectHost() {
    return this.getStringAttribute('connect_host');
  }
  public set connectHost(value: string) {
    this._connectHost = value;
  }
  // Temporarily expose input value. Use with caution.
  public get connectHostInput() {
    return this._connectHost;
  }

  // connect_service - computed: false, optional: false, required: true
  private _connectService?: string; 
  public get connectService() {
    return this.getStringAttribute('connect_service');
  }
  public set connectService(value: string) {
    this._connectService = value;
  }
  // Temporarily expose input value. Use with caution.
  public get connectServiceInput() {
    return this._connectService;
  }
}
export interface DomainDevicesDisksBackingStoreSourceReservationsSourceUnixReconnect {
  /**
  * Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enabled Domain#enabled}
  */
  readonly enabled: string;
  /**
  * Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#timeout Domain#timeout}
  */
  readonly timeout?: number;
}

export function domainDevicesDisksBackingStoreSourceReservationsSourceUnixReconnectToTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservationsSourceUnixReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.stringToTerraform(struct!.enabled),
    timeout: cdktf.numberToTerraform(struct!.timeout),
  }
}


export function domainDevicesDisksBackingStoreSourceReservationsSourceUnixReconnectToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservationsSourceUnixReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.stringToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.numberToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceReservationsSourceUnixReconnectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceReservationsSourceUnixReconnect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceReservationsSourceUnixReconnect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._timeout = value.timeout;
    }
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: string; 
  public get enabled() {
    return this.getStringAttribute('enabled');
  }
  public set enabled(value: string) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: number; 
  public get timeout() {
    return this.getNumberAttribute('timeout');
  }
  public set timeout(value: number) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DomainDevicesDisksBackingStoreSourceReservationsSourceUnixSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksBackingStoreSourceReservationsSourceUnixSecLabelToTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservationsSourceUnixSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksBackingStoreSourceReservationsSourceUnixSecLabelToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservationsSourceUnixSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceReservationsSourceUnixSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceReservationsSourceUnixSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceReservationsSourceUnixSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksBackingStoreSourceReservationsSourceUnixSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksBackingStoreSourceReservationsSourceUnixSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksBackingStoreSourceReservationsSourceUnixSecLabelOutputReference {
    return new DomainDevicesDisksBackingStoreSourceReservationsSourceUnixSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksBackingStoreSourceReservationsSourceUnix {
  /**
  * Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode?: string;
  /**
  * Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path?: string;
  /**
  * Enables and configures automatic reconnection behavior for a UNIX socket–based EGD entropy source; the content and attributes are user-provided according to desired policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reconnect Domain#reconnect}
  */
  readonly reconnect?: DomainDevicesDisksBackingStoreSourceReservationsSourceUnixReconnect;
  /**
  * Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksBackingStoreSourceReservationsSourceUnixSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksBackingStoreSourceReservationsSourceUnixToTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservationsSourceUnix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
    reconnect: domainDevicesDisksBackingStoreSourceReservationsSourceUnixReconnectToTerraform(struct!.reconnect),
    sec_label: cdktf.listMapper(domainDevicesDisksBackingStoreSourceReservationsSourceUnixSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksBackingStoreSourceReservationsSourceUnixToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservationsSourceUnix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reconnect: {
      value: domainDevicesDisksBackingStoreSourceReservationsSourceUnixReconnectToHclTerraform(struct!.reconnect),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceReservationsSourceUnixReconnect",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksBackingStoreSourceReservationsSourceUnixSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksBackingStoreSourceReservationsSourceUnixSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceReservationsSourceUnixOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceReservationsSourceUnix | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._reconnect?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.reconnect = this._reconnect?.internalValue;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceReservationsSourceUnix | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
      this._path = undefined;
      this._reconnect.internalValue = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
      this._path = value.path;
      this._reconnect.internalValue = value.reconnect;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // reconnect - computed: false, optional: true, required: false
  private _reconnect = new DomainDevicesDisksBackingStoreSourceReservationsSourceUnixReconnectOutputReference(this, "reconnect");
  public get reconnect() {
    return this._reconnect;
  }
  public putReconnect(value: DomainDevicesDisksBackingStoreSourceReservationsSourceUnixReconnect) {
    this._reconnect.internalValue = value;
  }
  public resetReconnect() {
    this._reconnect.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reconnectInput() {
    return this._reconnect.internalValue;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksBackingStoreSourceReservationsSourceUnixSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksBackingStoreSourceReservationsSourceUnixSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksBackingStoreSourceReservationsSource {
  /**
  * Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dbus Domain#dbus}
  */
  readonly dbus?: DomainDevicesDisksBackingStoreSourceReservationsSourceDbus;
  /**
  * Configures an EGD RNG backend that reads entropy from a host character device node.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dev Domain#dev}
  */
  readonly dev?: DomainDevicesDisksBackingStoreSourceReservationsSourceDev;
  /**
  * Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file?: DomainDevicesDisksBackingStoreSourceReservationsSourceFile;
  /**
  * Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#nmdm Domain#nmdm}
  */
  readonly nmdm?: DomainDevicesDisksBackingStoreSourceReservationsSourceNmdm;
  /**
  * Enables use of a null character device as the reservation backing source; when this boolean is true, a Null source is emitted and all written data is discarded.
  * 
  * See: <https://libvirt.org/formatdomain.html#null-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#null Domain#null}
  */
  readonly null?: boolean | cdktf.IResolvable;
  /**
  * Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pipe Domain#pipe}
  */
  readonly pipe?: DomainDevicesDisksBackingStoreSourceReservationsSourcePipe;
  /**
  * Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pty Domain#pty}
  */
  readonly pty?: DomainDevicesDisksBackingStoreSourceReservationsSourcePty;
  /**
  * Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#qemuvd_agent Domain#qemuvd_agent}
  */
  readonly qemuvdAgent?: DomainDevicesDisksBackingStoreSourceReservationsSourceQemuvdAgent;
  /**
  * Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#spice_port Domain#spice_port}
  */
  readonly spicePort?: DomainDevicesDisksBackingStoreSourceReservationsSourceSpicePort;
  /**
  * Enables a SPICE VMC (SPICE management channel) backend for this backing-store source; when set true the element is emitted, when false or null it is omitted.
  * 
  * See: <https://libvirt.org/formatdomain.html#spice-channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#spice_vmc Domain#spice_vmc}
  */
  readonly spiceVmc?: boolean | cdktf.IResolvable;
  /**
  * Connects the backing-store source’s character channel to the domain’s standard I/O (stdin/stdout/stderr); when true the element is emitted, when false or null it is omitted.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-interface>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#std_io Domain#std_io}
  */
  readonly stdIo?: boolean | cdktf.IResolvable;
  /**
  * Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tcp Domain#tcp}
  */
  readonly tcp?: DomainDevicesDisksBackingStoreSourceReservationsSourceTcp;
  /**
  * Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#udp Domain#udp}
  */
  readonly udp?: DomainDevicesDisksBackingStoreSourceReservationsSourceUdp;
  /**
  * Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#unix Domain#unix}
  */
  readonly unix?: DomainDevicesDisksBackingStoreSourceReservationsSourceUnix;
  /**
  * Enables use of a VC (virtual cluster or vendor-specific) reservation source when set; since this is presence-based, setting it to true emits the element and false/null omits it.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vc Domain#vc}
  */
  readonly vc?: boolean | cdktf.IResolvable;
}

export function domainDevicesDisksBackingStoreSourceReservationsSourceToTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservationsSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dbus: domainDevicesDisksBackingStoreSourceReservationsSourceDbusToTerraform(struct!.dbus),
    dev: domainDevicesDisksBackingStoreSourceReservationsSourceDevToTerraform(struct!.dev),
    file: domainDevicesDisksBackingStoreSourceReservationsSourceFileToTerraform(struct!.file),
    nmdm: domainDevicesDisksBackingStoreSourceReservationsSourceNmdmToTerraform(struct!.nmdm),
    null: cdktf.booleanToTerraform(struct!.null),
    pipe: domainDevicesDisksBackingStoreSourceReservationsSourcePipeToTerraform(struct!.pipe),
    pty: domainDevicesDisksBackingStoreSourceReservationsSourcePtyToTerraform(struct!.pty),
    qemuvd_agent: domainDevicesDisksBackingStoreSourceReservationsSourceQemuvdAgentToTerraform(struct!.qemuvdAgent),
    spice_port: domainDevicesDisksBackingStoreSourceReservationsSourceSpicePortToTerraform(struct!.spicePort),
    spice_vmc: cdktf.booleanToTerraform(struct!.spiceVmc),
    std_io: cdktf.booleanToTerraform(struct!.stdIo),
    tcp: domainDevicesDisksBackingStoreSourceReservationsSourceTcpToTerraform(struct!.tcp),
    udp: domainDevicesDisksBackingStoreSourceReservationsSourceUdpToTerraform(struct!.udp),
    unix: domainDevicesDisksBackingStoreSourceReservationsSourceUnixToTerraform(struct!.unix),
    vc: cdktf.booleanToTerraform(struct!.vc),
  }
}


export function domainDevicesDisksBackingStoreSourceReservationsSourceToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservationsSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dbus: {
      value: domainDevicesDisksBackingStoreSourceReservationsSourceDbusToHclTerraform(struct!.dbus),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceReservationsSourceDbus",
    },
    dev: {
      value: domainDevicesDisksBackingStoreSourceReservationsSourceDevToHclTerraform(struct!.dev),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceReservationsSourceDev",
    },
    file: {
      value: domainDevicesDisksBackingStoreSourceReservationsSourceFileToHclTerraform(struct!.file),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceReservationsSourceFile",
    },
    nmdm: {
      value: domainDevicesDisksBackingStoreSourceReservationsSourceNmdmToHclTerraform(struct!.nmdm),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceReservationsSourceNmdm",
    },
    null: {
      value: cdktf.booleanToHclTerraform(struct!.null),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    pipe: {
      value: domainDevicesDisksBackingStoreSourceReservationsSourcePipeToHclTerraform(struct!.pipe),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceReservationsSourcePipe",
    },
    pty: {
      value: domainDevicesDisksBackingStoreSourceReservationsSourcePtyToHclTerraform(struct!.pty),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceReservationsSourcePty",
    },
    qemuvd_agent: {
      value: domainDevicesDisksBackingStoreSourceReservationsSourceQemuvdAgentToHclTerraform(struct!.qemuvdAgent),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceReservationsSourceQemuvdAgent",
    },
    spice_port: {
      value: domainDevicesDisksBackingStoreSourceReservationsSourceSpicePortToHclTerraform(struct!.spicePort),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceReservationsSourceSpicePort",
    },
    spice_vmc: {
      value: cdktf.booleanToHclTerraform(struct!.spiceVmc),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    std_io: {
      value: cdktf.booleanToHclTerraform(struct!.stdIo),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tcp: {
      value: domainDevicesDisksBackingStoreSourceReservationsSourceTcpToHclTerraform(struct!.tcp),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceReservationsSourceTcp",
    },
    udp: {
      value: domainDevicesDisksBackingStoreSourceReservationsSourceUdpToHclTerraform(struct!.udp),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceReservationsSourceUdp",
    },
    unix: {
      value: domainDevicesDisksBackingStoreSourceReservationsSourceUnixToHclTerraform(struct!.unix),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceReservationsSourceUnix",
    },
    vc: {
      value: cdktf.booleanToHclTerraform(struct!.vc),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceReservationsSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceReservationsSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dbus?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dbus = this._dbus?.internalValue;
    }
    if (this._dev?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dev = this._dev?.internalValue;
    }
    if (this._file?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file?.internalValue;
    }
    if (this._nmdm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nmdm = this._nmdm?.internalValue;
    }
    if (this._null !== undefined) {
      hasAnyValues = true;
      internalValueResult.null = this._null;
    }
    if (this._pipe?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipe = this._pipe?.internalValue;
    }
    if (this._pty?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pty = this._pty?.internalValue;
    }
    if (this._qemuvdAgent?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.qemuvdAgent = this._qemuvdAgent?.internalValue;
    }
    if (this._spicePort?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spicePort = this._spicePort?.internalValue;
    }
    if (this._spiceVmc !== undefined) {
      hasAnyValues = true;
      internalValueResult.spiceVmc = this._spiceVmc;
    }
    if (this._stdIo !== undefined) {
      hasAnyValues = true;
      internalValueResult.stdIo = this._stdIo;
    }
    if (this._tcp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tcp = this._tcp?.internalValue;
    }
    if (this._udp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.udp = this._udp?.internalValue;
    }
    if (this._unix?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.unix = this._unix?.internalValue;
    }
    if (this._vc !== undefined) {
      hasAnyValues = true;
      internalValueResult.vc = this._vc;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceReservationsSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dbus.internalValue = undefined;
      this._dev.internalValue = undefined;
      this._file.internalValue = undefined;
      this._nmdm.internalValue = undefined;
      this._null = undefined;
      this._pipe.internalValue = undefined;
      this._pty.internalValue = undefined;
      this._qemuvdAgent.internalValue = undefined;
      this._spicePort.internalValue = undefined;
      this._spiceVmc = undefined;
      this._stdIo = undefined;
      this._tcp.internalValue = undefined;
      this._udp.internalValue = undefined;
      this._unix.internalValue = undefined;
      this._vc = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dbus.internalValue = value.dbus;
      this._dev.internalValue = value.dev;
      this._file.internalValue = value.file;
      this._nmdm.internalValue = value.nmdm;
      this._null = value.null;
      this._pipe.internalValue = value.pipe;
      this._pty.internalValue = value.pty;
      this._qemuvdAgent.internalValue = value.qemuvdAgent;
      this._spicePort.internalValue = value.spicePort;
      this._spiceVmc = value.spiceVmc;
      this._stdIo = value.stdIo;
      this._tcp.internalValue = value.tcp;
      this._udp.internalValue = value.udp;
      this._unix.internalValue = value.unix;
      this._vc = value.vc;
    }
  }

  // dbus - computed: false, optional: true, required: false
  private _dbus = new DomainDevicesDisksBackingStoreSourceReservationsSourceDbusOutputReference(this, "dbus");
  public get dbus() {
    return this._dbus;
  }
  public putDbus(value: DomainDevicesDisksBackingStoreSourceReservationsSourceDbus) {
    this._dbus.internalValue = value;
  }
  public resetDbus() {
    this._dbus.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dbusInput() {
    return this._dbus.internalValue;
  }

  // dev - computed: false, optional: true, required: false
  private _dev = new DomainDevicesDisksBackingStoreSourceReservationsSourceDevOutputReference(this, "dev");
  public get dev() {
    return this._dev;
  }
  public putDev(value: DomainDevicesDisksBackingStoreSourceReservationsSourceDev) {
    this._dev.internalValue = value;
  }
  public resetDev() {
    this._dev.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devInput() {
    return this._dev.internalValue;
  }

  // file - computed: false, optional: true, required: false
  private _file = new DomainDevicesDisksBackingStoreSourceReservationsSourceFileOutputReference(this, "file");
  public get file() {
    return this._file;
  }
  public putFile(value: DomainDevicesDisksBackingStoreSourceReservationsSourceFile) {
    this._file.internalValue = value;
  }
  public resetFile() {
    this._file.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file.internalValue;
  }

  // nmdm - computed: false, optional: true, required: false
  private _nmdm = new DomainDevicesDisksBackingStoreSourceReservationsSourceNmdmOutputReference(this, "nmdm");
  public get nmdm() {
    return this._nmdm;
  }
  public putNmdm(value: DomainDevicesDisksBackingStoreSourceReservationsSourceNmdm) {
    this._nmdm.internalValue = value;
  }
  public resetNmdm() {
    this._nmdm.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nmdmInput() {
    return this._nmdm.internalValue;
  }

  // null - computed: false, optional: true, required: false
  private _null?: boolean | cdktf.IResolvable; 
  public get null() {
    return this.getBooleanAttribute('null');
  }
  public set null(value: boolean | cdktf.IResolvable) {
    this._null = value;
  }
  public resetNull() {
    this._null = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nullInput() {
    return this._null;
  }

  // pipe - computed: false, optional: true, required: false
  private _pipe = new DomainDevicesDisksBackingStoreSourceReservationsSourcePipeOutputReference(this, "pipe");
  public get pipe() {
    return this._pipe;
  }
  public putPipe(value: DomainDevicesDisksBackingStoreSourceReservationsSourcePipe) {
    this._pipe.internalValue = value;
  }
  public resetPipe() {
    this._pipe.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipeInput() {
    return this._pipe.internalValue;
  }

  // pty - computed: false, optional: true, required: false
  private _pty = new DomainDevicesDisksBackingStoreSourceReservationsSourcePtyOutputReference(this, "pty");
  public get pty() {
    return this._pty;
  }
  public putPty(value: DomainDevicesDisksBackingStoreSourceReservationsSourcePty) {
    this._pty.internalValue = value;
  }
  public resetPty() {
    this._pty.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ptyInput() {
    return this._pty.internalValue;
  }

  // qemuvd_agent - computed: false, optional: true, required: false
  private _qemuvdAgent = new DomainDevicesDisksBackingStoreSourceReservationsSourceQemuvdAgentOutputReference(this, "qemuvd_agent");
  public get qemuvdAgent() {
    return this._qemuvdAgent;
  }
  public putQemuvdAgent(value: DomainDevicesDisksBackingStoreSourceReservationsSourceQemuvdAgent) {
    this._qemuvdAgent.internalValue = value;
  }
  public resetQemuvdAgent() {
    this._qemuvdAgent.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get qemuvdAgentInput() {
    return this._qemuvdAgent.internalValue;
  }

  // spice_port - computed: false, optional: true, required: false
  private _spicePort = new DomainDevicesDisksBackingStoreSourceReservationsSourceSpicePortOutputReference(this, "spice_port");
  public get spicePort() {
    return this._spicePort;
  }
  public putSpicePort(value: DomainDevicesDisksBackingStoreSourceReservationsSourceSpicePort) {
    this._spicePort.internalValue = value;
  }
  public resetSpicePort() {
    this._spicePort.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spicePortInput() {
    return this._spicePort.internalValue;
  }

  // spice_vmc - computed: false, optional: true, required: false
  private _spiceVmc?: boolean | cdktf.IResolvable; 
  public get spiceVmc() {
    return this.getBooleanAttribute('spice_vmc');
  }
  public set spiceVmc(value: boolean | cdktf.IResolvable) {
    this._spiceVmc = value;
  }
  public resetSpiceVmc() {
    this._spiceVmc = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spiceVmcInput() {
    return this._spiceVmc;
  }

  // std_io - computed: false, optional: true, required: false
  private _stdIo?: boolean | cdktf.IResolvable; 
  public get stdIo() {
    return this.getBooleanAttribute('std_io');
  }
  public set stdIo(value: boolean | cdktf.IResolvable) {
    this._stdIo = value;
  }
  public resetStdIo() {
    this._stdIo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stdIoInput() {
    return this._stdIo;
  }

  // tcp - computed: false, optional: true, required: false
  private _tcp = new DomainDevicesDisksBackingStoreSourceReservationsSourceTcpOutputReference(this, "tcp");
  public get tcp() {
    return this._tcp;
  }
  public putTcp(value: DomainDevicesDisksBackingStoreSourceReservationsSourceTcp) {
    this._tcp.internalValue = value;
  }
  public resetTcp() {
    this._tcp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tcpInput() {
    return this._tcp.internalValue;
  }

  // udp - computed: false, optional: true, required: false
  private _udp = new DomainDevicesDisksBackingStoreSourceReservationsSourceUdpOutputReference(this, "udp");
  public get udp() {
    return this._udp;
  }
  public putUdp(value: DomainDevicesDisksBackingStoreSourceReservationsSourceUdp) {
    this._udp.internalValue = value;
  }
  public resetUdp() {
    this._udp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get udpInput() {
    return this._udp.internalValue;
  }

  // unix - computed: false, optional: true, required: false
  private _unix = new DomainDevicesDisksBackingStoreSourceReservationsSourceUnixOutputReference(this, "unix");
  public get unix() {
    return this._unix;
  }
  public putUnix(value: DomainDevicesDisksBackingStoreSourceReservationsSourceUnix) {
    this._unix.internalValue = value;
  }
  public resetUnix() {
    this._unix.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unixInput() {
    return this._unix.internalValue;
  }

  // vc - computed: false, optional: true, required: false
  private _vc?: boolean | cdktf.IResolvable; 
  public get vc() {
    return this.getBooleanAttribute('vc');
  }
  public set vc(value: boolean | cdktf.IResolvable) {
    this._vc = value;
  }
  public resetVc() {
    this._vc = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vcInput() {
    return this._vc;
  }
}
export interface DomainDevicesDisksBackingStoreSourceReservations {
  /**
  * Controls whether persistent reservations are enabled for the mirrored disk’s backing-store source; value is user-provided and typically expects "yes" or "no" semantics per libvirt.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enabled Domain#enabled}
  */
  readonly enabled?: string;
  /**
  * Indicates whether reservations are managed by libvirt ("yes") or externally ("no"); value is provided as a string and translated to a boolean, with "yes" meaning true and "no" meaning false.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#managed Domain#managed}
  */
  readonly managed?: boolean | cdktf.IResolvable;
  /**
  * Selects the mechanism used to provide reservation control for the mirrored backing-store source, such as a D-Bus service or a device/file endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#source Domain#source}
  */
  readonly source?: DomainDevicesDisksBackingStoreSourceReservationsSource;
}

export function domainDevicesDisksBackingStoreSourceReservationsToTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.stringToTerraform(struct!.enabled),
    managed: cdktf.booleanToTerraform(struct!.managed),
    source: domainDevicesDisksBackingStoreSourceReservationsSourceToTerraform(struct!.source),
  }
}


export function domainDevicesDisksBackingStoreSourceReservationsToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceReservations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.stringToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    managed: {
      value: cdktf.booleanToHclTerraform(struct!.managed),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    source: {
      value: domainDevicesDisksBackingStoreSourceReservationsSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceReservationsSource",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceReservationsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceReservations | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._managed !== undefined) {
      hasAnyValues = true;
      internalValueResult.managed = this._managed;
    }
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceReservations | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._managed = undefined;
      this._source.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._managed = value.managed;
      this._source.internalValue = value.source;
    }
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: string; 
  public get enabled() {
    return this.getStringAttribute('enabled');
  }
  public set enabled(value: string) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // managed - computed: false, optional: true, required: false
  private _managed?: boolean | cdktf.IResolvable; 
  public get managed() {
    return this.getBooleanAttribute('managed');
  }
  public set managed(value: boolean | cdktf.IResolvable) {
    this._managed = value;
  }
  public resetManaged() {
    this._managed = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get managedInput() {
    return this._managed;
  }

  // source - computed: false, optional: true, required: false
  private _source = new DomainDevicesDisksBackingStoreSourceReservationsSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: DomainDevicesDisksBackingStoreSourceReservationsSource) {
    this._source.internalValue = value;
  }
  public resetSource() {
    this._source.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }
}
export interface DomainDevicesDisksBackingStoreSourceSlicesSlices {
  /**
  * Sets the starting offset (in bytes) of this slice within the underlying backing-store source; must be a non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#offset Domain#offset}
  */
  readonly offset: number;
  /**
  * Sets the size (in bytes) of this slice within the underlying backing-store source; must be a positive integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#size Domain#size}
  */
  readonly size: number;
  /**
  * Specifies the type of slice mapping to use for this range; the value is user‑provided and must match a type supported by the hypervisor (for example, a particular mapping or layout scheme).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type: string;
}

export function domainDevicesDisksBackingStoreSourceSlicesSlicesToTerraform(struct?: DomainDevicesDisksBackingStoreSourceSlicesSlices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    offset: cdktf.numberToTerraform(struct!.offset),
    size: cdktf.numberToTerraform(struct!.size),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function domainDevicesDisksBackingStoreSourceSlicesSlicesToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceSlicesSlices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    offset: {
      value: cdktf.numberToHclTerraform(struct!.offset),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    size: {
      value: cdktf.numberToHclTerraform(struct!.size),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceSlicesSlicesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceSlicesSlices | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._offset !== undefined) {
      hasAnyValues = true;
      internalValueResult.offset = this._offset;
    }
    if (this._size !== undefined) {
      hasAnyValues = true;
      internalValueResult.size = this._size;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceSlicesSlices | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._offset = undefined;
      this._size = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._offset = value.offset;
      this._size = value.size;
      this._type = value.type;
    }
  }

  // offset - computed: false, optional: false, required: true
  private _offset?: number; 
  public get offset() {
    return this.getNumberAttribute('offset');
  }
  public set offset(value: number) {
    this._offset = value;
  }
  // Temporarily expose input value. Use with caution.
  public get offsetInput() {
    return this._offset;
  }

  // size - computed: false, optional: false, required: true
  private _size?: number; 
  public get size() {
    return this.getNumberAttribute('size');
  }
  public set size(value: number) {
    this._size = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sizeInput() {
    return this._size;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}

export class DomainDevicesDisksBackingStoreSourceSlicesSlicesList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksBackingStoreSourceSlicesSlices[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksBackingStoreSourceSlicesSlicesOutputReference {
    return new DomainDevicesDisksBackingStoreSourceSlicesSlicesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksBackingStoreSourceSlices {
  /**
  * Configures one or more slices of the backing-store source, each describing a contiguous portion of the underlying device or file that is exposed through this mirror backing store.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#slices Domain#slices}
  */
  readonly slices?: DomainDevicesDisksBackingStoreSourceSlicesSlices[] | cdktf.IResolvable;
}

export function domainDevicesDisksBackingStoreSourceSlicesToTerraform(struct?: DomainDevicesDisksBackingStoreSourceSlices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    slices: cdktf.listMapper(domainDevicesDisksBackingStoreSourceSlicesSlicesToTerraform, false)(struct!.slices),
  }
}


export function domainDevicesDisksBackingStoreSourceSlicesToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceSlices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    slices: {
      value: cdktf.listMapperHcl(domainDevicesDisksBackingStoreSourceSlicesSlicesToHclTerraform, false)(struct!.slices),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksBackingStoreSourceSlicesSlicesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceSlicesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceSlices | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._slices?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.slices = this._slices?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceSlices | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._slices.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._slices.internalValue = value.slices;
    }
  }

  // slices - computed: false, optional: true, required: false
  private _slices = new DomainDevicesDisksBackingStoreSourceSlicesSlicesList(this, "slices", false);
  public get slices() {
    return this._slices;
  }
  public putSlices(value: DomainDevicesDisksBackingStoreSourceSlicesSlices[] | cdktf.IResolvable) {
    this._slices.internalValue = value;
  }
  public resetSlices() {
    this._slices.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get slicesInput() {
    return this._slices.internalValue;
  }
}
export interface DomainDevicesDisksBackingStoreSourceSsl {
  /**
  * Controls certificate verification for SSL/TLS access to the mirrored backing-store source; typical values are "yes" or "no" to enable or disable verification.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#verify Domain#verify}
  */
  readonly verify: string;
}

export function domainDevicesDisksBackingStoreSourceSslToTerraform(struct?: DomainDevicesDisksBackingStoreSourceSsl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    verify: cdktf.stringToTerraform(struct!.verify),
  }
}


export function domainDevicesDisksBackingStoreSourceSslToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceSsl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    verify: {
      value: cdktf.stringToHclTerraform(struct!.verify),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceSslOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceSsl | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._verify !== undefined) {
      hasAnyValues = true;
      internalValueResult.verify = this._verify;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceSsl | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._verify = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._verify = value.verify;
    }
  }

  // verify - computed: false, optional: false, required: true
  private _verify?: string; 
  public get verify() {
    return this.getStringAttribute('verify');
  }
  public set verify(value: string) {
    this._verify = value;
  }
  // Temporarily expose input value. Use with caution.
  public get verifyInput() {
    return this._verify;
  }
}
export interface DomainDevicesDisksBackingStoreSourceTimeout {
  /**
  * Sets the timeout duration in seconds for accessing the mirrored backing-store source; must be a non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#seconds Domain#seconds}
  */
  readonly seconds: string;
}

export function domainDevicesDisksBackingStoreSourceTimeoutToTerraform(struct?: DomainDevicesDisksBackingStoreSourceTimeout | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    seconds: cdktf.stringToTerraform(struct!.seconds),
  }
}


export function domainDevicesDisksBackingStoreSourceTimeoutToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceTimeout | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    seconds: {
      value: cdktf.stringToHclTerraform(struct!.seconds),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceTimeoutOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceTimeout | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._seconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.seconds = this._seconds;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceTimeout | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._seconds = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._seconds = value.seconds;
    }
  }

  // seconds - computed: false, optional: false, required: true
  private _seconds?: string; 
  public get seconds() {
    return this.getStringAttribute('seconds');
  }
  public set seconds(value: string) {
    this._seconds = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secondsInput() {
    return this._seconds;
  }
}
export interface DomainDevicesDisksBackingStoreSourceVhostUserDbus {
  /**
  * Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#channel Domain#channel}
  */
  readonly channel?: string;
}

export function domainDevicesDisksBackingStoreSourceVhostUserDbusToTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostUserDbus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    channel: cdktf.stringToTerraform(struct!.channel),
  }
}


export function domainDevicesDisksBackingStoreSourceVhostUserDbusToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostUserDbus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    channel: {
      value: cdktf.stringToHclTerraform(struct!.channel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceVhostUserDbusOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceVhostUserDbus | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._channel !== undefined) {
      hasAnyValues = true;
      internalValueResult.channel = this._channel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceVhostUserDbus | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._channel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._channel = value.channel;
    }
  }

  // channel - computed: false, optional: true, required: false
  private _channel?: string; 
  public get channel() {
    return this.getStringAttribute('channel');
  }
  public set channel(value: string) {
    this._channel = value;
  }
  public resetChannel() {
    this._channel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get channelInput() {
    return this._channel;
  }
}
export interface DomainDevicesDisksBackingStoreSourceVhostUserDevSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksBackingStoreSourceVhostUserDevSecLabelToTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostUserDevSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksBackingStoreSourceVhostUserDevSecLabelToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostUserDevSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceVhostUserDevSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceVhostUserDevSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceVhostUserDevSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksBackingStoreSourceVhostUserDevSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksBackingStoreSourceVhostUserDevSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksBackingStoreSourceVhostUserDevSecLabelOutputReference {
    return new DomainDevicesDisksBackingStoreSourceVhostUserDevSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksBackingStoreSourceVhostUserDev {
  /**
  * Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksBackingStoreSourceVhostUserDevSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksBackingStoreSourceVhostUserDevToTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostUserDev | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesDisksBackingStoreSourceVhostUserDevSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksBackingStoreSourceVhostUserDevToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostUserDev | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksBackingStoreSourceVhostUserDevSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksBackingStoreSourceVhostUserDevSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceVhostUserDevOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceVhostUserDev | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceVhostUserDev | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksBackingStoreSourceVhostUserDevSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksBackingStoreSourceVhostUserDevSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksBackingStoreSourceVhostUserFileSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksBackingStoreSourceVhostUserFileSecLabelToTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostUserFileSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksBackingStoreSourceVhostUserFileSecLabelToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostUserFileSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceVhostUserFileSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceVhostUserFileSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceVhostUserFileSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksBackingStoreSourceVhostUserFileSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksBackingStoreSourceVhostUserFileSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksBackingStoreSourceVhostUserFileSecLabelOutputReference {
    return new DomainDevicesDisksBackingStoreSourceVhostUserFileSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksBackingStoreSourceVhostUserFile {
  /**
  * Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.
  * 
  * See: <https://libvirt.org/formatdomain.html#device-logfile>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#append Domain#append}
  */
  readonly append?: string;
  /**
  * Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksBackingStoreSourceVhostUserFileSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksBackingStoreSourceVhostUserFileToTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostUserFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.stringToTerraform(struct!.append),
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesDisksBackingStoreSourceVhostUserFileSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksBackingStoreSourceVhostUserFileToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostUserFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.stringToHclTerraform(struct!.append),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksBackingStoreSourceVhostUserFileSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksBackingStoreSourceVhostUserFileSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceVhostUserFileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceVhostUserFile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceVhostUserFile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append = value.append;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append?: string; 
  public get append() {
    return this.getStringAttribute('append');
  }
  public set append(value: string) {
    this._append = value;
  }
  public resetAppend() {
    this._append = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append;
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksBackingStoreSourceVhostUserFileSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksBackingStoreSourceVhostUserFileSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksBackingStoreSourceVhostUserNmdm {
  /**
  * Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.
  * 
  * See: <https://libvirt.org/formatdomain.html#nmdm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#master Domain#master}
  */
  readonly master: string;
  /**
  * Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.
  * 
  * See: <https://libvirt.org/formatdomain.html#nmdm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#slave Domain#slave}
  */
  readonly slave: string;
}

export function domainDevicesDisksBackingStoreSourceVhostUserNmdmToTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostUserNmdm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    master: cdktf.stringToTerraform(struct!.master),
    slave: cdktf.stringToTerraform(struct!.slave),
  }
}


export function domainDevicesDisksBackingStoreSourceVhostUserNmdmToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostUserNmdm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    master: {
      value: cdktf.stringToHclTerraform(struct!.master),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    slave: {
      value: cdktf.stringToHclTerraform(struct!.slave),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceVhostUserNmdmOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceVhostUserNmdm | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._master !== undefined) {
      hasAnyValues = true;
      internalValueResult.master = this._master;
    }
    if (this._slave !== undefined) {
      hasAnyValues = true;
      internalValueResult.slave = this._slave;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceVhostUserNmdm | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._master = undefined;
      this._slave = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._master = value.master;
      this._slave = value.slave;
    }
  }

  // master - computed: false, optional: false, required: true
  private _master?: string; 
  public get master() {
    return this.getStringAttribute('master');
  }
  public set master(value: string) {
    this._master = value;
  }
  // Temporarily expose input value. Use with caution.
  public get masterInput() {
    return this._master;
  }

  // slave - computed: false, optional: false, required: true
  private _slave?: string; 
  public get slave() {
    return this.getStringAttribute('slave');
  }
  public set slave(value: string) {
    this._slave = value;
  }
  // Temporarily expose input value. Use with caution.
  public get slaveInput() {
    return this._slave;
  }
}
export interface DomainDevicesDisksBackingStoreSourceVhostUserPipeSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksBackingStoreSourceVhostUserPipeSecLabelToTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostUserPipeSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksBackingStoreSourceVhostUserPipeSecLabelToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostUserPipeSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceVhostUserPipeSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceVhostUserPipeSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceVhostUserPipeSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksBackingStoreSourceVhostUserPipeSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksBackingStoreSourceVhostUserPipeSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksBackingStoreSourceVhostUserPipeSecLabelOutputReference {
    return new DomainDevicesDisksBackingStoreSourceVhostUserPipeSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksBackingStoreSourceVhostUserPipe {
  /**
  * Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksBackingStoreSourceVhostUserPipeSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksBackingStoreSourceVhostUserPipeToTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostUserPipe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesDisksBackingStoreSourceVhostUserPipeSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksBackingStoreSourceVhostUserPipeToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostUserPipe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksBackingStoreSourceVhostUserPipeSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksBackingStoreSourceVhostUserPipeSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceVhostUserPipeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceVhostUserPipe | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceVhostUserPipe | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksBackingStoreSourceVhostUserPipeSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksBackingStoreSourceVhostUserPipeSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksBackingStoreSourceVhostUserPtySecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksBackingStoreSourceVhostUserPtySecLabelToTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostUserPtySecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksBackingStoreSourceVhostUserPtySecLabelToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostUserPtySecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceVhostUserPtySecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceVhostUserPtySecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceVhostUserPtySecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksBackingStoreSourceVhostUserPtySecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksBackingStoreSourceVhostUserPtySecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksBackingStoreSourceVhostUserPtySecLabelOutputReference {
    return new DomainDevicesDisksBackingStoreSourceVhostUserPtySecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksBackingStoreSourceVhostUserPty {
  /**
  * Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksBackingStoreSourceVhostUserPtySecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksBackingStoreSourceVhostUserPtyToTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostUserPty | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesDisksBackingStoreSourceVhostUserPtySecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksBackingStoreSourceVhostUserPtyToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostUserPty | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksBackingStoreSourceVhostUserPtySecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksBackingStoreSourceVhostUserPtySecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceVhostUserPtyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceVhostUserPty | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceVhostUserPty | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksBackingStoreSourceVhostUserPtySecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksBackingStoreSourceVhostUserPtySecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksBackingStoreSourceVhostUserQemuvdAgentClipBoard {
  /**
  * Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#copy_paste Domain#copy_paste}
  */
  readonly copyPaste: string;
}

export function domainDevicesDisksBackingStoreSourceVhostUserQemuvdAgentClipBoardToTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostUserQemuvdAgentClipBoard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    copy_paste: cdktf.stringToTerraform(struct!.copyPaste),
  }
}


export function domainDevicesDisksBackingStoreSourceVhostUserQemuvdAgentClipBoardToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostUserQemuvdAgentClipBoard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    copy_paste: {
      value: cdktf.stringToHclTerraform(struct!.copyPaste),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceVhostUserQemuvdAgentClipBoardOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceVhostUserQemuvdAgentClipBoard | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._copyPaste !== undefined) {
      hasAnyValues = true;
      internalValueResult.copyPaste = this._copyPaste;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceVhostUserQemuvdAgentClipBoard | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._copyPaste = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._copyPaste = value.copyPaste;
    }
  }

  // copy_paste - computed: false, optional: false, required: true
  private _copyPaste?: string; 
  public get copyPaste() {
    return this.getStringAttribute('copy_paste');
  }
  public set copyPaste(value: string) {
    this._copyPaste = value;
  }
  // Temporarily expose input value. Use with caution.
  public get copyPasteInput() {
    return this._copyPaste;
  }
}
export interface DomainDevicesDisksBackingStoreSourceVhostUserQemuvdAgentMouse {
  /**
  * Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).
  * 
  * See: <https://libvirt.org/formatdomain.html#channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode: string;
}

export function domainDevicesDisksBackingStoreSourceVhostUserQemuvdAgentMouseToTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostUserQemuvdAgentMouse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
  }
}


export function domainDevicesDisksBackingStoreSourceVhostUserQemuvdAgentMouseToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostUserQemuvdAgentMouse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceVhostUserQemuvdAgentMouseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceVhostUserQemuvdAgentMouse | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceVhostUserQemuvdAgentMouse | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
    }
  }

  // mode - computed: false, optional: false, required: true
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }
}
export interface DomainDevicesDisksBackingStoreSourceVhostUserQemuvdAgent {
  /**
  * Configures clipboard-related behavior for the QEMU vdagent–based EGD source, controlling whether clipboard data exchange is allowed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#clip_board Domain#clip_board}
  */
  readonly clipBoard?: DomainDevicesDisksBackingStoreSourceVhostUserQemuvdAgentClipBoard;
  /**
  * Configures mouse integration options for the QEMU vdagent–based EGD source, such as how mouse events are handled.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mouse Domain#mouse}
  */
  readonly mouse?: DomainDevicesDisksBackingStoreSourceVhostUserQemuvdAgentMouse;
}

export function domainDevicesDisksBackingStoreSourceVhostUserQemuvdAgentToTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostUserQemuvdAgent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    clip_board: domainDevicesDisksBackingStoreSourceVhostUserQemuvdAgentClipBoardToTerraform(struct!.clipBoard),
    mouse: domainDevicesDisksBackingStoreSourceVhostUserQemuvdAgentMouseToTerraform(struct!.mouse),
  }
}


export function domainDevicesDisksBackingStoreSourceVhostUserQemuvdAgentToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostUserQemuvdAgent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    clip_board: {
      value: domainDevicesDisksBackingStoreSourceVhostUserQemuvdAgentClipBoardToHclTerraform(struct!.clipBoard),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceVhostUserQemuvdAgentClipBoard",
    },
    mouse: {
      value: domainDevicesDisksBackingStoreSourceVhostUserQemuvdAgentMouseToHclTerraform(struct!.mouse),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceVhostUserQemuvdAgentMouse",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceVhostUserQemuvdAgentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceVhostUserQemuvdAgent | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clipBoard?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clipBoard = this._clipBoard?.internalValue;
    }
    if (this._mouse?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.mouse = this._mouse?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceVhostUserQemuvdAgent | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clipBoard.internalValue = undefined;
      this._mouse.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clipBoard.internalValue = value.clipBoard;
      this._mouse.internalValue = value.mouse;
    }
  }

  // clip_board - computed: false, optional: true, required: false
  private _clipBoard = new DomainDevicesDisksBackingStoreSourceVhostUserQemuvdAgentClipBoardOutputReference(this, "clip_board");
  public get clipBoard() {
    return this._clipBoard;
  }
  public putClipBoard(value: DomainDevicesDisksBackingStoreSourceVhostUserQemuvdAgentClipBoard) {
    this._clipBoard.internalValue = value;
  }
  public resetClipBoard() {
    this._clipBoard.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clipBoardInput() {
    return this._clipBoard.internalValue;
  }

  // mouse - computed: false, optional: true, required: false
  private _mouse = new DomainDevicesDisksBackingStoreSourceVhostUserQemuvdAgentMouseOutputReference(this, "mouse");
  public get mouse() {
    return this._mouse;
  }
  public putMouse(value: DomainDevicesDisksBackingStoreSourceVhostUserQemuvdAgentMouse) {
    this._mouse.internalValue = value;
  }
  public resetMouse() {
    this._mouse.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mouseInput() {
    return this._mouse.internalValue;
  }
}
export interface DomainDevicesDisksBackingStoreSourceVhostUserSpicePort {
  /**
  * Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#channel Domain#channel}
  */
  readonly channel: string;
}

export function domainDevicesDisksBackingStoreSourceVhostUserSpicePortToTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostUserSpicePort | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    channel: cdktf.stringToTerraform(struct!.channel),
  }
}


export function domainDevicesDisksBackingStoreSourceVhostUserSpicePortToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostUserSpicePort | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    channel: {
      value: cdktf.stringToHclTerraform(struct!.channel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceVhostUserSpicePortOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceVhostUserSpicePort | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._channel !== undefined) {
      hasAnyValues = true;
      internalValueResult.channel = this._channel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceVhostUserSpicePort | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._channel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._channel = value.channel;
    }
  }

  // channel - computed: false, optional: false, required: true
  private _channel?: string; 
  public get channel() {
    return this.getStringAttribute('channel');
  }
  public set channel(value: string) {
    this._channel = value;
  }
  // Temporarily expose input value. Use with caution.
  public get channelInput() {
    return this._channel;
  }
}
export interface DomainDevicesDisksBackingStoreSourceVhostUserTcpReconnect {
  /**
  * Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enabled Domain#enabled}
  */
  readonly enabled: string;
  /**
  * Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#timeout Domain#timeout}
  */
  readonly timeout?: number;
}

export function domainDevicesDisksBackingStoreSourceVhostUserTcpReconnectToTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostUserTcpReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.stringToTerraform(struct!.enabled),
    timeout: cdktf.numberToTerraform(struct!.timeout),
  }
}


export function domainDevicesDisksBackingStoreSourceVhostUserTcpReconnectToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostUserTcpReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.stringToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.numberToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceVhostUserTcpReconnectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceVhostUserTcpReconnect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceVhostUserTcpReconnect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._timeout = value.timeout;
    }
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: string; 
  public get enabled() {
    return this.getStringAttribute('enabled');
  }
  public set enabled(value: string) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: number; 
  public get timeout() {
    return this.getNumberAttribute('timeout');
  }
  public set timeout(value: number) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DomainDevicesDisksBackingStoreSourceVhostUserTcp {
  /**
  * Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#host Domain#host}
  */
  readonly host?: string;
  /**
  * Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode?: string;
  /**
  * Enables and configures automatic reconnection behavior for a UNIX socket–based EGD entropy source; the content and attributes are user-provided according to desired policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reconnect Domain#reconnect}
  */
  readonly reconnect?: DomainDevicesDisksBackingStoreSourceVhostUserTcpReconnect;
  /**
  * Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#service Domain#service}
  */
  readonly service?: string;
  /**
  * Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tls Domain#tls}
  */
  readonly tls?: string;
}

export function domainDevicesDisksBackingStoreSourceVhostUserTcpToTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostUserTcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    mode: cdktf.stringToTerraform(struct!.mode),
    reconnect: domainDevicesDisksBackingStoreSourceVhostUserTcpReconnectToTerraform(struct!.reconnect),
    service: cdktf.stringToTerraform(struct!.service),
    tls: cdktf.stringToTerraform(struct!.tls),
  }
}


export function domainDevicesDisksBackingStoreSourceVhostUserTcpToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostUserTcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reconnect: {
      value: domainDevicesDisksBackingStoreSourceVhostUserTcpReconnectToHclTerraform(struct!.reconnect),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceVhostUserTcpReconnect",
    },
    service: {
      value: cdktf.stringToHclTerraform(struct!.service),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: cdktf.stringToHclTerraform(struct!.tls),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceVhostUserTcpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceVhostUserTcp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._reconnect?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.reconnect = this._reconnect?.internalValue;
    }
    if (this._service !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service;
    }
    if (this._tls !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceVhostUserTcp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host = undefined;
      this._mode = undefined;
      this._reconnect.internalValue = undefined;
      this._service = undefined;
      this._tls = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host = value.host;
      this._mode = value.mode;
      this._reconnect.internalValue = value.reconnect;
      this._service = value.service;
      this._tls = value.tls;
    }
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // reconnect - computed: false, optional: true, required: false
  private _reconnect = new DomainDevicesDisksBackingStoreSourceVhostUserTcpReconnectOutputReference(this, "reconnect");
  public get reconnect() {
    return this._reconnect;
  }
  public putReconnect(value: DomainDevicesDisksBackingStoreSourceVhostUserTcpReconnect) {
    this._reconnect.internalValue = value;
  }
  public resetReconnect() {
    this._reconnect.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reconnectInput() {
    return this._reconnect.internalValue;
  }

  // service - computed: false, optional: true, required: false
  private _service?: string; 
  public get service() {
    return this.getStringAttribute('service');
  }
  public set service(value: string) {
    this._service = value;
  }
  public resetService() {
    this._service = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service;
  }

  // tls - computed: false, optional: true, required: false
  private _tls?: string; 
  public get tls() {
    return this.getStringAttribute('tls');
  }
  public set tls(value: string) {
    this._tls = value;
  }
  public resetTls() {
    this._tls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls;
  }
}
export interface DomainDevicesDisksBackingStoreSourceVhostUserUdp {
  /**
  * Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bind_host Domain#bind_host}
  */
  readonly bindHost: string;
  /**
  * Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bind_service Domain#bind_service}
  */
  readonly bindService: string;
  /**
  * Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#connect_host Domain#connect_host}
  */
  readonly connectHost: string;
  /**
  * Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#connect_service Domain#connect_service}
  */
  readonly connectService: string;
}

export function domainDevicesDisksBackingStoreSourceVhostUserUdpToTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostUserUdp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_host: cdktf.stringToTerraform(struct!.bindHost),
    bind_service: cdktf.stringToTerraform(struct!.bindService),
    connect_host: cdktf.stringToTerraform(struct!.connectHost),
    connect_service: cdktf.stringToTerraform(struct!.connectService),
  }
}


export function domainDevicesDisksBackingStoreSourceVhostUserUdpToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostUserUdp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_host: {
      value: cdktf.stringToHclTerraform(struct!.bindHost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bind_service: {
      value: cdktf.stringToHclTerraform(struct!.bindService),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connect_host: {
      value: cdktf.stringToHclTerraform(struct!.connectHost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connect_service: {
      value: cdktf.stringToHclTerraform(struct!.connectService),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceVhostUserUdpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceVhostUserUdp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindHost !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindHost = this._bindHost;
    }
    if (this._bindService !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindService = this._bindService;
    }
    if (this._connectHost !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectHost = this._connectHost;
    }
    if (this._connectService !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectService = this._connectService;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceVhostUserUdp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bindHost = undefined;
      this._bindService = undefined;
      this._connectHost = undefined;
      this._connectService = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bindHost = value.bindHost;
      this._bindService = value.bindService;
      this._connectHost = value.connectHost;
      this._connectService = value.connectService;
    }
  }

  // bind_host - computed: false, optional: false, required: true
  private _bindHost?: string; 
  public get bindHost() {
    return this.getStringAttribute('bind_host');
  }
  public set bindHost(value: string) {
    this._bindHost = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bindHostInput() {
    return this._bindHost;
  }

  // bind_service - computed: false, optional: false, required: true
  private _bindService?: string; 
  public get bindService() {
    return this.getStringAttribute('bind_service');
  }
  public set bindService(value: string) {
    this._bindService = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bindServiceInput() {
    return this._bindService;
  }

  // connect_host - computed: false, optional: false, required: true
  private _connectHost?: string; 
  public get connectHost() {
    return this.getStringAttribute('connect_host');
  }
  public set connectHost(value: string) {
    this._connectHost = value;
  }
  // Temporarily expose input value. Use with caution.
  public get connectHostInput() {
    return this._connectHost;
  }

  // connect_service - computed: false, optional: false, required: true
  private _connectService?: string; 
  public get connectService() {
    return this.getStringAttribute('connect_service');
  }
  public set connectService(value: string) {
    this._connectService = value;
  }
  // Temporarily expose input value. Use with caution.
  public get connectServiceInput() {
    return this._connectService;
  }
}
export interface DomainDevicesDisksBackingStoreSourceVhostUserUnixReconnect {
  /**
  * Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enabled Domain#enabled}
  */
  readonly enabled: string;
  /**
  * Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#timeout Domain#timeout}
  */
  readonly timeout?: number;
}

export function domainDevicesDisksBackingStoreSourceVhostUserUnixReconnectToTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostUserUnixReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.stringToTerraform(struct!.enabled),
    timeout: cdktf.numberToTerraform(struct!.timeout),
  }
}


export function domainDevicesDisksBackingStoreSourceVhostUserUnixReconnectToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostUserUnixReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.stringToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.numberToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceVhostUserUnixReconnectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceVhostUserUnixReconnect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceVhostUserUnixReconnect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._timeout = value.timeout;
    }
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: string; 
  public get enabled() {
    return this.getStringAttribute('enabled');
  }
  public set enabled(value: string) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: number; 
  public get timeout() {
    return this.getNumberAttribute('timeout');
  }
  public set timeout(value: number) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DomainDevicesDisksBackingStoreSourceVhostUserUnixSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksBackingStoreSourceVhostUserUnixSecLabelToTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostUserUnixSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksBackingStoreSourceVhostUserUnixSecLabelToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostUserUnixSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceVhostUserUnixSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceVhostUserUnixSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceVhostUserUnixSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksBackingStoreSourceVhostUserUnixSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksBackingStoreSourceVhostUserUnixSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksBackingStoreSourceVhostUserUnixSecLabelOutputReference {
    return new DomainDevicesDisksBackingStoreSourceVhostUserUnixSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksBackingStoreSourceVhostUserUnix {
  /**
  * Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode?: string;
  /**
  * Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path?: string;
  /**
  * Enables and configures automatic reconnection behavior for a UNIX socket–based EGD entropy source; the content and attributes are user-provided according to desired policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reconnect Domain#reconnect}
  */
  readonly reconnect?: DomainDevicesDisksBackingStoreSourceVhostUserUnixReconnect;
  /**
  * Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksBackingStoreSourceVhostUserUnixSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksBackingStoreSourceVhostUserUnixToTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostUserUnix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
    reconnect: domainDevicesDisksBackingStoreSourceVhostUserUnixReconnectToTerraform(struct!.reconnect),
    sec_label: cdktf.listMapper(domainDevicesDisksBackingStoreSourceVhostUserUnixSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksBackingStoreSourceVhostUserUnixToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostUserUnix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reconnect: {
      value: domainDevicesDisksBackingStoreSourceVhostUserUnixReconnectToHclTerraform(struct!.reconnect),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceVhostUserUnixReconnect",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksBackingStoreSourceVhostUserUnixSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksBackingStoreSourceVhostUserUnixSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceVhostUserUnixOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceVhostUserUnix | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._reconnect?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.reconnect = this._reconnect?.internalValue;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceVhostUserUnix | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
      this._path = undefined;
      this._reconnect.internalValue = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
      this._path = value.path;
      this._reconnect.internalValue = value.reconnect;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // reconnect - computed: false, optional: true, required: false
  private _reconnect = new DomainDevicesDisksBackingStoreSourceVhostUserUnixReconnectOutputReference(this, "reconnect");
  public get reconnect() {
    return this._reconnect;
  }
  public putReconnect(value: DomainDevicesDisksBackingStoreSourceVhostUserUnixReconnect) {
    this._reconnect.internalValue = value;
  }
  public resetReconnect() {
    this._reconnect.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reconnectInput() {
    return this._reconnect.internalValue;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksBackingStoreSourceVhostUserUnixSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksBackingStoreSourceVhostUserUnixSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksBackingStoreSourceVhostUser {
  /**
  * Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dbus Domain#dbus}
  */
  readonly dbus?: DomainDevicesDisksBackingStoreSourceVhostUserDbus;
  /**
  * Configures an EGD RNG backend that reads entropy from a host character device node.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dev Domain#dev}
  */
  readonly dev?: DomainDevicesDisksBackingStoreSourceVhostUserDev;
  /**
  * Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file?: DomainDevicesDisksBackingStoreSourceVhostUserFile;
  /**
  * Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#nmdm Domain#nmdm}
  */
  readonly nmdm?: DomainDevicesDisksBackingStoreSourceVhostUserNmdm;
  /**
  * When set to true, uses a null character device as the vhost-user backing-store source, discarding all output and providing no input; when false or unset, the null device is not used.
  * 
  * See: <https://libvirt.org/formatdomain.html#null-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#null Domain#null}
  */
  readonly null?: boolean | cdktf.IResolvable;
  /**
  * Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pipe Domain#pipe}
  */
  readonly pipe?: DomainDevicesDisksBackingStoreSourceVhostUserPipe;
  /**
  * Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pty Domain#pty}
  */
  readonly pty?: DomainDevicesDisksBackingStoreSourceVhostUserPty;
  /**
  * Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#qemuvd_agent Domain#qemuvd_agent}
  */
  readonly qemuvdAgent?: DomainDevicesDisksBackingStoreSourceVhostUserQemuvdAgent;
  /**
  * Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#spice_port Domain#spice_port}
  */
  readonly spicePort?: DomainDevicesDisksBackingStoreSourceVhostUserSpicePort;
  /**
  * When set to true, exposes the vhost-user backing through a SPICE virtio-serial management channel (SpiceVMC); when false or unset, the element is omitted.
  * 
  * See: <https://libvirt.org/formatdomain.html#spice-channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#spice_vmc Domain#spice_vmc}
  */
  readonly spiceVmc?: boolean | cdktf.IResolvable;
  /**
  * When set to true, connects the vhost-user backing to the domain’s standard I/O character device; when false or unset, the StdIO element is omitted.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-interface>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#std_io Domain#std_io}
  */
  readonly stdIo?: boolean | cdktf.IResolvable;
  /**
  * Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tcp Domain#tcp}
  */
  readonly tcp?: DomainDevicesDisksBackingStoreSourceVhostUserTcp;
  /**
  * Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#udp Domain#udp}
  */
  readonly udp?: DomainDevicesDisksBackingStoreSourceVhostUserUdp;
  /**
  * Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#unix Domain#unix}
  */
  readonly unix?: DomainDevicesDisksBackingStoreSourceVhostUserUnix;
  /**
  * Enables use of a vhost-user communication mechanism compatible with a VC-style (versioned capability) endpoint for the disk mirror backing store; when set true the VC element is emitted, when false or null it is omitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vc Domain#vc}
  */
  readonly vc?: boolean | cdktf.IResolvable;
}

export function domainDevicesDisksBackingStoreSourceVhostUserToTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostUser | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dbus: domainDevicesDisksBackingStoreSourceVhostUserDbusToTerraform(struct!.dbus),
    dev: domainDevicesDisksBackingStoreSourceVhostUserDevToTerraform(struct!.dev),
    file: domainDevicesDisksBackingStoreSourceVhostUserFileToTerraform(struct!.file),
    nmdm: domainDevicesDisksBackingStoreSourceVhostUserNmdmToTerraform(struct!.nmdm),
    null: cdktf.booleanToTerraform(struct!.null),
    pipe: domainDevicesDisksBackingStoreSourceVhostUserPipeToTerraform(struct!.pipe),
    pty: domainDevicesDisksBackingStoreSourceVhostUserPtyToTerraform(struct!.pty),
    qemuvd_agent: domainDevicesDisksBackingStoreSourceVhostUserQemuvdAgentToTerraform(struct!.qemuvdAgent),
    spice_port: domainDevicesDisksBackingStoreSourceVhostUserSpicePortToTerraform(struct!.spicePort),
    spice_vmc: cdktf.booleanToTerraform(struct!.spiceVmc),
    std_io: cdktf.booleanToTerraform(struct!.stdIo),
    tcp: domainDevicesDisksBackingStoreSourceVhostUserTcpToTerraform(struct!.tcp),
    udp: domainDevicesDisksBackingStoreSourceVhostUserUdpToTerraform(struct!.udp),
    unix: domainDevicesDisksBackingStoreSourceVhostUserUnixToTerraform(struct!.unix),
    vc: cdktf.booleanToTerraform(struct!.vc),
  }
}


export function domainDevicesDisksBackingStoreSourceVhostUserToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostUser | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dbus: {
      value: domainDevicesDisksBackingStoreSourceVhostUserDbusToHclTerraform(struct!.dbus),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceVhostUserDbus",
    },
    dev: {
      value: domainDevicesDisksBackingStoreSourceVhostUserDevToHclTerraform(struct!.dev),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceVhostUserDev",
    },
    file: {
      value: domainDevicesDisksBackingStoreSourceVhostUserFileToHclTerraform(struct!.file),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceVhostUserFile",
    },
    nmdm: {
      value: domainDevicesDisksBackingStoreSourceVhostUserNmdmToHclTerraform(struct!.nmdm),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceVhostUserNmdm",
    },
    null: {
      value: cdktf.booleanToHclTerraform(struct!.null),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    pipe: {
      value: domainDevicesDisksBackingStoreSourceVhostUserPipeToHclTerraform(struct!.pipe),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceVhostUserPipe",
    },
    pty: {
      value: domainDevicesDisksBackingStoreSourceVhostUserPtyToHclTerraform(struct!.pty),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceVhostUserPty",
    },
    qemuvd_agent: {
      value: domainDevicesDisksBackingStoreSourceVhostUserQemuvdAgentToHclTerraform(struct!.qemuvdAgent),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceVhostUserQemuvdAgent",
    },
    spice_port: {
      value: domainDevicesDisksBackingStoreSourceVhostUserSpicePortToHclTerraform(struct!.spicePort),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceVhostUserSpicePort",
    },
    spice_vmc: {
      value: cdktf.booleanToHclTerraform(struct!.spiceVmc),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    std_io: {
      value: cdktf.booleanToHclTerraform(struct!.stdIo),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tcp: {
      value: domainDevicesDisksBackingStoreSourceVhostUserTcpToHclTerraform(struct!.tcp),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceVhostUserTcp",
    },
    udp: {
      value: domainDevicesDisksBackingStoreSourceVhostUserUdpToHclTerraform(struct!.udp),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceVhostUserUdp",
    },
    unix: {
      value: domainDevicesDisksBackingStoreSourceVhostUserUnixToHclTerraform(struct!.unix),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceVhostUserUnix",
    },
    vc: {
      value: cdktf.booleanToHclTerraform(struct!.vc),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceVhostUserOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceVhostUser | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dbus?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dbus = this._dbus?.internalValue;
    }
    if (this._dev?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dev = this._dev?.internalValue;
    }
    if (this._file?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file?.internalValue;
    }
    if (this._nmdm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nmdm = this._nmdm?.internalValue;
    }
    if (this._null !== undefined) {
      hasAnyValues = true;
      internalValueResult.null = this._null;
    }
    if (this._pipe?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipe = this._pipe?.internalValue;
    }
    if (this._pty?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pty = this._pty?.internalValue;
    }
    if (this._qemuvdAgent?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.qemuvdAgent = this._qemuvdAgent?.internalValue;
    }
    if (this._spicePort?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spicePort = this._spicePort?.internalValue;
    }
    if (this._spiceVmc !== undefined) {
      hasAnyValues = true;
      internalValueResult.spiceVmc = this._spiceVmc;
    }
    if (this._stdIo !== undefined) {
      hasAnyValues = true;
      internalValueResult.stdIo = this._stdIo;
    }
    if (this._tcp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tcp = this._tcp?.internalValue;
    }
    if (this._udp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.udp = this._udp?.internalValue;
    }
    if (this._unix?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.unix = this._unix?.internalValue;
    }
    if (this._vc !== undefined) {
      hasAnyValues = true;
      internalValueResult.vc = this._vc;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceVhostUser | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dbus.internalValue = undefined;
      this._dev.internalValue = undefined;
      this._file.internalValue = undefined;
      this._nmdm.internalValue = undefined;
      this._null = undefined;
      this._pipe.internalValue = undefined;
      this._pty.internalValue = undefined;
      this._qemuvdAgent.internalValue = undefined;
      this._spicePort.internalValue = undefined;
      this._spiceVmc = undefined;
      this._stdIo = undefined;
      this._tcp.internalValue = undefined;
      this._udp.internalValue = undefined;
      this._unix.internalValue = undefined;
      this._vc = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dbus.internalValue = value.dbus;
      this._dev.internalValue = value.dev;
      this._file.internalValue = value.file;
      this._nmdm.internalValue = value.nmdm;
      this._null = value.null;
      this._pipe.internalValue = value.pipe;
      this._pty.internalValue = value.pty;
      this._qemuvdAgent.internalValue = value.qemuvdAgent;
      this._spicePort.internalValue = value.spicePort;
      this._spiceVmc = value.spiceVmc;
      this._stdIo = value.stdIo;
      this._tcp.internalValue = value.tcp;
      this._udp.internalValue = value.udp;
      this._unix.internalValue = value.unix;
      this._vc = value.vc;
    }
  }

  // dbus - computed: false, optional: true, required: false
  private _dbus = new DomainDevicesDisksBackingStoreSourceVhostUserDbusOutputReference(this, "dbus");
  public get dbus() {
    return this._dbus;
  }
  public putDbus(value: DomainDevicesDisksBackingStoreSourceVhostUserDbus) {
    this._dbus.internalValue = value;
  }
  public resetDbus() {
    this._dbus.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dbusInput() {
    return this._dbus.internalValue;
  }

  // dev - computed: false, optional: true, required: false
  private _dev = new DomainDevicesDisksBackingStoreSourceVhostUserDevOutputReference(this, "dev");
  public get dev() {
    return this._dev;
  }
  public putDev(value: DomainDevicesDisksBackingStoreSourceVhostUserDev) {
    this._dev.internalValue = value;
  }
  public resetDev() {
    this._dev.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devInput() {
    return this._dev.internalValue;
  }

  // file - computed: false, optional: true, required: false
  private _file = new DomainDevicesDisksBackingStoreSourceVhostUserFileOutputReference(this, "file");
  public get file() {
    return this._file;
  }
  public putFile(value: DomainDevicesDisksBackingStoreSourceVhostUserFile) {
    this._file.internalValue = value;
  }
  public resetFile() {
    this._file.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file.internalValue;
  }

  // nmdm - computed: false, optional: true, required: false
  private _nmdm = new DomainDevicesDisksBackingStoreSourceVhostUserNmdmOutputReference(this, "nmdm");
  public get nmdm() {
    return this._nmdm;
  }
  public putNmdm(value: DomainDevicesDisksBackingStoreSourceVhostUserNmdm) {
    this._nmdm.internalValue = value;
  }
  public resetNmdm() {
    this._nmdm.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nmdmInput() {
    return this._nmdm.internalValue;
  }

  // null - computed: false, optional: true, required: false
  private _null?: boolean | cdktf.IResolvable; 
  public get null() {
    return this.getBooleanAttribute('null');
  }
  public set null(value: boolean | cdktf.IResolvable) {
    this._null = value;
  }
  public resetNull() {
    this._null = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nullInput() {
    return this._null;
  }

  // pipe - computed: false, optional: true, required: false
  private _pipe = new DomainDevicesDisksBackingStoreSourceVhostUserPipeOutputReference(this, "pipe");
  public get pipe() {
    return this._pipe;
  }
  public putPipe(value: DomainDevicesDisksBackingStoreSourceVhostUserPipe) {
    this._pipe.internalValue = value;
  }
  public resetPipe() {
    this._pipe.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipeInput() {
    return this._pipe.internalValue;
  }

  // pty - computed: false, optional: true, required: false
  private _pty = new DomainDevicesDisksBackingStoreSourceVhostUserPtyOutputReference(this, "pty");
  public get pty() {
    return this._pty;
  }
  public putPty(value: DomainDevicesDisksBackingStoreSourceVhostUserPty) {
    this._pty.internalValue = value;
  }
  public resetPty() {
    this._pty.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ptyInput() {
    return this._pty.internalValue;
  }

  // qemuvd_agent - computed: false, optional: true, required: false
  private _qemuvdAgent = new DomainDevicesDisksBackingStoreSourceVhostUserQemuvdAgentOutputReference(this, "qemuvd_agent");
  public get qemuvdAgent() {
    return this._qemuvdAgent;
  }
  public putQemuvdAgent(value: DomainDevicesDisksBackingStoreSourceVhostUserQemuvdAgent) {
    this._qemuvdAgent.internalValue = value;
  }
  public resetQemuvdAgent() {
    this._qemuvdAgent.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get qemuvdAgentInput() {
    return this._qemuvdAgent.internalValue;
  }

  // spice_port - computed: false, optional: true, required: false
  private _spicePort = new DomainDevicesDisksBackingStoreSourceVhostUserSpicePortOutputReference(this, "spice_port");
  public get spicePort() {
    return this._spicePort;
  }
  public putSpicePort(value: DomainDevicesDisksBackingStoreSourceVhostUserSpicePort) {
    this._spicePort.internalValue = value;
  }
  public resetSpicePort() {
    this._spicePort.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spicePortInput() {
    return this._spicePort.internalValue;
  }

  // spice_vmc - computed: false, optional: true, required: false
  private _spiceVmc?: boolean | cdktf.IResolvable; 
  public get spiceVmc() {
    return this.getBooleanAttribute('spice_vmc');
  }
  public set spiceVmc(value: boolean | cdktf.IResolvable) {
    this._spiceVmc = value;
  }
  public resetSpiceVmc() {
    this._spiceVmc = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spiceVmcInput() {
    return this._spiceVmc;
  }

  // std_io - computed: false, optional: true, required: false
  private _stdIo?: boolean | cdktf.IResolvable; 
  public get stdIo() {
    return this.getBooleanAttribute('std_io');
  }
  public set stdIo(value: boolean | cdktf.IResolvable) {
    this._stdIo = value;
  }
  public resetStdIo() {
    this._stdIo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stdIoInput() {
    return this._stdIo;
  }

  // tcp - computed: false, optional: true, required: false
  private _tcp = new DomainDevicesDisksBackingStoreSourceVhostUserTcpOutputReference(this, "tcp");
  public get tcp() {
    return this._tcp;
  }
  public putTcp(value: DomainDevicesDisksBackingStoreSourceVhostUserTcp) {
    this._tcp.internalValue = value;
  }
  public resetTcp() {
    this._tcp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tcpInput() {
    return this._tcp.internalValue;
  }

  // udp - computed: false, optional: true, required: false
  private _udp = new DomainDevicesDisksBackingStoreSourceVhostUserUdpOutputReference(this, "udp");
  public get udp() {
    return this._udp;
  }
  public putUdp(value: DomainDevicesDisksBackingStoreSourceVhostUserUdp) {
    this._udp.internalValue = value;
  }
  public resetUdp() {
    this._udp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get udpInput() {
    return this._udp.internalValue;
  }

  // unix - computed: false, optional: true, required: false
  private _unix = new DomainDevicesDisksBackingStoreSourceVhostUserUnixOutputReference(this, "unix");
  public get unix() {
    return this._unix;
  }
  public putUnix(value: DomainDevicesDisksBackingStoreSourceVhostUserUnix) {
    this._unix.internalValue = value;
  }
  public resetUnix() {
    this._unix.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unixInput() {
    return this._unix.internalValue;
  }

  // vc - computed: false, optional: true, required: false
  private _vc?: boolean | cdktf.IResolvable; 
  public get vc() {
    return this.getBooleanAttribute('vc');
  }
  public set vc(value: boolean | cdktf.IResolvable) {
    this._vc = value;
  }
  public resetVc() {
    this._vc = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vcInput() {
    return this._vc;
  }
}
export interface DomainDevicesDisksBackingStoreSourceVhostVdpa {
  /**
  * Sets the host vDPA character device path used as the backingStore source for the mirrored disk when using a vhost-vdpa backend; the value is user-provided and must reference an existing device node (for example, /dev/vhost-vdpa0).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dev Domain#dev}
  */
  readonly dev: string;
}

export function domainDevicesDisksBackingStoreSourceVhostVdpaToTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostVdpa | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dev: cdktf.stringToTerraform(struct!.dev),
  }
}


export function domainDevicesDisksBackingStoreSourceVhostVdpaToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceVhostVdpa | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dev: {
      value: cdktf.stringToHclTerraform(struct!.dev),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceVhostVdpaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceVhostVdpa | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dev !== undefined) {
      hasAnyValues = true;
      internalValueResult.dev = this._dev;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceVhostVdpa | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dev = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dev = value.dev;
    }
  }

  // dev - computed: false, optional: false, required: true
  private _dev?: string; 
  public get dev() {
    return this.getStringAttribute('dev');
  }
  public set dev(value: string) {
    this._dev = value;
  }
  // Temporarily expose input value. Use with caution.
  public get devInput() {
    return this._dev;
  }
}
export interface DomainDevicesDisksBackingStoreSourceVolumeSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksBackingStoreSourceVolumeSecLabelToTerraform(struct?: DomainDevicesDisksBackingStoreSourceVolumeSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksBackingStoreSourceVolumeSecLabelToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceVolumeSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceVolumeSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceVolumeSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceVolumeSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksBackingStoreSourceVolumeSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksBackingStoreSourceVolumeSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksBackingStoreSourceVolumeSecLabelOutputReference {
    return new DomainDevicesDisksBackingStoreSourceVolumeSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksBackingStoreSourceVolume {
  /**
  * Sets the access mode with which the storage volume is used as the backingStore source (for example, "readOnly" or "readWrite" depending on driver support); the value is user-provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode?: string;
  /**
  * Names the storage pool that contains the backing storage volume used as the mirror backingStore source; must match an existing libvirt storage pool name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pool Domain#pool}
  */
  readonly pool?: string;
  /**
  * Configures an optional security label override applied to the backing storage volume used as the mirror backingStore source.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksBackingStoreSourceVolumeSecLabel[] | cdktf.IResolvable;
  /**
  * Sets the name of the storage volume within the specified pool that is used as the backingStore source for the mirrored disk.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#volume Domain#volume}
  */
  readonly volume?: string;
}

export function domainDevicesDisksBackingStoreSourceVolumeToTerraform(struct?: DomainDevicesDisksBackingStoreSourceVolume | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
    pool: cdktf.stringToTerraform(struct!.pool),
    sec_label: cdktf.listMapper(domainDevicesDisksBackingStoreSourceVolumeSecLabelToTerraform, false)(struct!.secLabel),
    volume: cdktf.stringToTerraform(struct!.volume),
  }
}


export function domainDevicesDisksBackingStoreSourceVolumeToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceVolume | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pool: {
      value: cdktf.stringToHclTerraform(struct!.pool),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksBackingStoreSourceVolumeSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksBackingStoreSourceVolumeSecLabelList",
    },
    volume: {
      value: cdktf.stringToHclTerraform(struct!.volume),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceVolumeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceVolume | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._pool !== undefined) {
      hasAnyValues = true;
      internalValueResult.pool = this._pool;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    if (this._volume !== undefined) {
      hasAnyValues = true;
      internalValueResult.volume = this._volume;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceVolume | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
      this._pool = undefined;
      this._secLabel.internalValue = undefined;
      this._volume = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
      this._pool = value.pool;
      this._secLabel.internalValue = value.secLabel;
      this._volume = value.volume;
    }
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // pool - computed: false, optional: true, required: false
  private _pool?: string; 
  public get pool() {
    return this.getStringAttribute('pool');
  }
  public set pool(value: string) {
    this._pool = value;
  }
  public resetPool() {
    this._pool = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get poolInput() {
    return this._pool;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksBackingStoreSourceVolumeSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksBackingStoreSourceVolumeSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }

  // volume - computed: false, optional: true, required: false
  private _volume?: string; 
  public get volume() {
    return this.getStringAttribute('volume');
  }
  public set volume(value: string) {
    this._volume = value;
  }
  public resetVolume() {
    this._volume = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get volumeInput() {
    return this._volume;
  }
}
export interface DomainDevicesDisksBackingStoreSource {
  /**
  * Describes a block device used as the source for the mirror backing store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#block Domain#block}
  */
  readonly block?: DomainDevicesDisksBackingStoreSourceBlock;
  /**
  * Provides optional cookie data associated with the mirror backing store source (for example, auth or session data), with content treated as user-provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#cookies Domain#cookies}
  */
  readonly cookies?: DomainDevicesDisksBackingStoreSourceCookies;
  /**
  * Configures a data store descriptor for the mirrored backing store, typically used with networked or advanced storage backends that expose format-specific options.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#data_store Domain#data_store}
  */
  readonly dataStore?: DomainDevicesDisksBackingStoreSourceDataStore;
  /**
  * Configures a directory-based source for the mirrored backing store, pointing to a host directory used by the backing image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dir Domain#dir}
  */
  readonly dir?: DomainDevicesDisksBackingStoreSourceDir;
  /**
  * Enables disk image encryption configuration for this disk and groups attributes defining the encryption engine, format, and secrets.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#encryption Domain#encryption}
  */
  readonly encryption?: DomainDevicesDisksBackingStoreSourceEncryption;
  /**
  * Configures a file-based backing store source for the disk mirror, defining how the backing image is accessed from the host filesystem.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file?: DomainDevicesDisksBackingStoreSourceFile;
  /**
  * Sets the index of this backing store within a backing chain, used when multiple backing layers are present; value is a user-provided non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#index Domain#index}
  */
  readonly index?: number;
  /**
  * Configures a network-based backing store source (such as NBD, iSCSI, or RBD) for the disk mirror, including authentication and host endpoints.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#network Domain#network}
  */
  readonly network?: DomainDevicesDisksBackingStoreSourceNetwork;
  /**
  * Enables using an NVMe-backed source for the mirrored disk’s backing store; when present, it selects an NVMe device or namespace as the source, with details defined by libvirt/QEMU for NVMe disks.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#nvme Domain#nvme}
  */
  readonly nvme?: DomainDevicesDisksBackingStoreSourceNvme;
  /**
  * Configures read-ahead behavior for the mirrored disk’s backing-store source, allowing tuning of how much data is pre-fetched from the backend.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#readahead Domain#readahead}
  */
  readonly readahead?: DomainDevicesDisksBackingStoreSourceReadahead;
  /**
  * Configures SCSI-style reservations or similar persistent reservation management for the mirrored disk’s backing-store source, controlling how access is coordinated across nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reservations Domain#reservations}
  */
  readonly reservations?: DomainDevicesDisksBackingStoreSourceReservations;
  /**
  * Configures optional slice or segment information for the backing store source (for example, to describe which logical slices of a device are used); content is user-provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#slices Domain#slices}
  */
  readonly slices?: DomainDevicesDisksBackingStoreSourceSlices;
  /**
  * Enables SSL/TLS parameters for accessing the mirrored backing-store source when it is provided over a secure transport.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#ssl Domain#ssl}
  */
  readonly ssl?: DomainDevicesDisksBackingStoreSourceSsl;
  /**
  * Specifies how strictly the mirrored backing-store source must be available during domain startup; valid values include "mandatory", "requisite", "optional" (user‑provided string matched by libvirt).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#startup_policy Domain#startup_policy}
  */
  readonly startupPolicy?: string;
  /**
  * Configures a timeout for connecting to or initializing the mirrored backing-store source.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#timeout Domain#timeout}
  */
  readonly timeout?: DomainDevicesDisksBackingStoreSourceTimeout;
  /**
  * Selects a vhost-user backend as the transport for the mirrored backing-store source, allowing it to be provided via a userspace process.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vhost_user Domain#vhost_user}
  */
  readonly vhostUser?: DomainDevicesDisksBackingStoreSourceVhostUser;
  /**
  * Selects a vhost-vDPA backend for the disk mirror backing store, allowing acceleration via a vDPA device; additional details are determined by libvirt and device configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vhost_vdpa Domain#vhost_vdpa}
  */
  readonly vhostVdpa?: DomainDevicesDisksBackingStoreSourceVhostVdpa;
  /**
  * Configures the backingStore source as a libvirt storage volume reference instead of a raw file/block path for the mirrored disk.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#volume Domain#volume}
  */
  readonly volume?: DomainDevicesDisksBackingStoreSourceVolume;
}

export function domainDevicesDisksBackingStoreSourceToTerraform(struct?: DomainDevicesDisksBackingStoreSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    block: domainDevicesDisksBackingStoreSourceBlockToTerraform(struct!.block),
    cookies: domainDevicesDisksBackingStoreSourceCookiesToTerraform(struct!.cookies),
    data_store: domainDevicesDisksBackingStoreSourceDataStoreToTerraform(struct!.dataStore),
    dir: domainDevicesDisksBackingStoreSourceDirToTerraform(struct!.dir),
    encryption: domainDevicesDisksBackingStoreSourceEncryptionToTerraform(struct!.encryption),
    file: domainDevicesDisksBackingStoreSourceFileToTerraform(struct!.file),
    index: cdktf.numberToTerraform(struct!.index),
    network: domainDevicesDisksBackingStoreSourceNetworkToTerraform(struct!.network),
    nvme: domainDevicesDisksBackingStoreSourceNvmeToTerraform(struct!.nvme),
    readahead: domainDevicesDisksBackingStoreSourceReadaheadToTerraform(struct!.readahead),
    reservations: domainDevicesDisksBackingStoreSourceReservationsToTerraform(struct!.reservations),
    slices: domainDevicesDisksBackingStoreSourceSlicesToTerraform(struct!.slices),
    ssl: domainDevicesDisksBackingStoreSourceSslToTerraform(struct!.ssl),
    startup_policy: cdktf.stringToTerraform(struct!.startupPolicy),
    timeout: domainDevicesDisksBackingStoreSourceTimeoutToTerraform(struct!.timeout),
    vhost_user: domainDevicesDisksBackingStoreSourceVhostUserToTerraform(struct!.vhostUser),
    vhost_vdpa: domainDevicesDisksBackingStoreSourceVhostVdpaToTerraform(struct!.vhostVdpa),
    volume: domainDevicesDisksBackingStoreSourceVolumeToTerraform(struct!.volume),
  }
}


export function domainDevicesDisksBackingStoreSourceToHclTerraform(struct?: DomainDevicesDisksBackingStoreSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    block: {
      value: domainDevicesDisksBackingStoreSourceBlockToHclTerraform(struct!.block),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceBlock",
    },
    cookies: {
      value: domainDevicesDisksBackingStoreSourceCookiesToHclTerraform(struct!.cookies),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceCookies",
    },
    data_store: {
      value: domainDevicesDisksBackingStoreSourceDataStoreToHclTerraform(struct!.dataStore),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceDataStore",
    },
    dir: {
      value: domainDevicesDisksBackingStoreSourceDirToHclTerraform(struct!.dir),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceDir",
    },
    encryption: {
      value: domainDevicesDisksBackingStoreSourceEncryptionToHclTerraform(struct!.encryption),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceEncryption",
    },
    file: {
      value: domainDevicesDisksBackingStoreSourceFileToHclTerraform(struct!.file),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceFile",
    },
    index: {
      value: cdktf.numberToHclTerraform(struct!.index),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    network: {
      value: domainDevicesDisksBackingStoreSourceNetworkToHclTerraform(struct!.network),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceNetwork",
    },
    nvme: {
      value: domainDevicesDisksBackingStoreSourceNvmeToHclTerraform(struct!.nvme),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceNvme",
    },
    readahead: {
      value: domainDevicesDisksBackingStoreSourceReadaheadToHclTerraform(struct!.readahead),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceReadahead",
    },
    reservations: {
      value: domainDevicesDisksBackingStoreSourceReservationsToHclTerraform(struct!.reservations),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceReservations",
    },
    slices: {
      value: domainDevicesDisksBackingStoreSourceSlicesToHclTerraform(struct!.slices),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceSlices",
    },
    ssl: {
      value: domainDevicesDisksBackingStoreSourceSslToHclTerraform(struct!.ssl),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceSsl",
    },
    startup_policy: {
      value: cdktf.stringToHclTerraform(struct!.startupPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: domainDevicesDisksBackingStoreSourceTimeoutToHclTerraform(struct!.timeout),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceTimeout",
    },
    vhost_user: {
      value: domainDevicesDisksBackingStoreSourceVhostUserToHclTerraform(struct!.vhostUser),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceVhostUser",
    },
    vhost_vdpa: {
      value: domainDevicesDisksBackingStoreSourceVhostVdpaToHclTerraform(struct!.vhostVdpa),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceVhostVdpa",
    },
    volume: {
      value: domainDevicesDisksBackingStoreSourceVolumeToHclTerraform(struct!.volume),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSourceVolume",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._block?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.block = this._block?.internalValue;
    }
    if (this._cookies?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cookies = this._cookies?.internalValue;
    }
    if (this._dataStore?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dataStore = this._dataStore?.internalValue;
    }
    if (this._dir?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dir = this._dir?.internalValue;
    }
    if (this._encryption?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.encryption = this._encryption?.internalValue;
    }
    if (this._file?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file?.internalValue;
    }
    if (this._index !== undefined) {
      hasAnyValues = true;
      internalValueResult.index = this._index;
    }
    if (this._network?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.network = this._network?.internalValue;
    }
    if (this._nvme?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nvme = this._nvme?.internalValue;
    }
    if (this._readahead?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.readahead = this._readahead?.internalValue;
    }
    if (this._reservations?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.reservations = this._reservations?.internalValue;
    }
    if (this._slices?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.slices = this._slices?.internalValue;
    }
    if (this._ssl?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ssl = this._ssl?.internalValue;
    }
    if (this._startupPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.startupPolicy = this._startupPolicy;
    }
    if (this._timeout?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout?.internalValue;
    }
    if (this._vhostUser?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.vhostUser = this._vhostUser?.internalValue;
    }
    if (this._vhostVdpa?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.vhostVdpa = this._vhostVdpa?.internalValue;
    }
    if (this._volume?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.volume = this._volume?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._block.internalValue = undefined;
      this._cookies.internalValue = undefined;
      this._dataStore.internalValue = undefined;
      this._dir.internalValue = undefined;
      this._encryption.internalValue = undefined;
      this._file.internalValue = undefined;
      this._index = undefined;
      this._network.internalValue = undefined;
      this._nvme.internalValue = undefined;
      this._readahead.internalValue = undefined;
      this._reservations.internalValue = undefined;
      this._slices.internalValue = undefined;
      this._ssl.internalValue = undefined;
      this._startupPolicy = undefined;
      this._timeout.internalValue = undefined;
      this._vhostUser.internalValue = undefined;
      this._vhostVdpa.internalValue = undefined;
      this._volume.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._block.internalValue = value.block;
      this._cookies.internalValue = value.cookies;
      this._dataStore.internalValue = value.dataStore;
      this._dir.internalValue = value.dir;
      this._encryption.internalValue = value.encryption;
      this._file.internalValue = value.file;
      this._index = value.index;
      this._network.internalValue = value.network;
      this._nvme.internalValue = value.nvme;
      this._readahead.internalValue = value.readahead;
      this._reservations.internalValue = value.reservations;
      this._slices.internalValue = value.slices;
      this._ssl.internalValue = value.ssl;
      this._startupPolicy = value.startupPolicy;
      this._timeout.internalValue = value.timeout;
      this._vhostUser.internalValue = value.vhostUser;
      this._vhostVdpa.internalValue = value.vhostVdpa;
      this._volume.internalValue = value.volume;
    }
  }

  // block - computed: false, optional: true, required: false
  private _block = new DomainDevicesDisksBackingStoreSourceBlockOutputReference(this, "block");
  public get block() {
    return this._block;
  }
  public putBlock(value: DomainDevicesDisksBackingStoreSourceBlock) {
    this._block.internalValue = value;
  }
  public resetBlock() {
    this._block.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get blockInput() {
    return this._block.internalValue;
  }

  // cookies - computed: false, optional: true, required: false
  private _cookies = new DomainDevicesDisksBackingStoreSourceCookiesOutputReference(this, "cookies");
  public get cookies() {
    return this._cookies;
  }
  public putCookies(value: DomainDevicesDisksBackingStoreSourceCookies) {
    this._cookies.internalValue = value;
  }
  public resetCookies() {
    this._cookies.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cookiesInput() {
    return this._cookies.internalValue;
  }

  // data_store - computed: false, optional: true, required: false
  private _dataStore = new DomainDevicesDisksBackingStoreSourceDataStoreOutputReference(this, "data_store");
  public get dataStore() {
    return this._dataStore;
  }
  public putDataStore(value: DomainDevicesDisksBackingStoreSourceDataStore) {
    this._dataStore.internalValue = value;
  }
  public resetDataStore() {
    this._dataStore.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dataStoreInput() {
    return this._dataStore.internalValue;
  }

  // dir - computed: false, optional: true, required: false
  private _dir = new DomainDevicesDisksBackingStoreSourceDirOutputReference(this, "dir");
  public get dir() {
    return this._dir;
  }
  public putDir(value: DomainDevicesDisksBackingStoreSourceDir) {
    this._dir.internalValue = value;
  }
  public resetDir() {
    this._dir.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dirInput() {
    return this._dir.internalValue;
  }

  // encryption - computed: false, optional: true, required: false
  private _encryption = new DomainDevicesDisksBackingStoreSourceEncryptionOutputReference(this, "encryption");
  public get encryption() {
    return this._encryption;
  }
  public putEncryption(value: DomainDevicesDisksBackingStoreSourceEncryption) {
    this._encryption.internalValue = value;
  }
  public resetEncryption() {
    this._encryption.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get encryptionInput() {
    return this._encryption.internalValue;
  }

  // file - computed: false, optional: true, required: false
  private _file = new DomainDevicesDisksBackingStoreSourceFileOutputReference(this, "file");
  public get file() {
    return this._file;
  }
  public putFile(value: DomainDevicesDisksBackingStoreSourceFile) {
    this._file.internalValue = value;
  }
  public resetFile() {
    this._file.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file.internalValue;
  }

  // index - computed: false, optional: true, required: false
  private _index?: number; 
  public get index() {
    return this.getNumberAttribute('index');
  }
  public set index(value: number) {
    this._index = value;
  }
  public resetIndex() {
    this._index = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get indexInput() {
    return this._index;
  }

  // network - computed: false, optional: true, required: false
  private _network = new DomainDevicesDisksBackingStoreSourceNetworkOutputReference(this, "network");
  public get network() {
    return this._network;
  }
  public putNetwork(value: DomainDevicesDisksBackingStoreSourceNetwork) {
    this._network.internalValue = value;
  }
  public resetNetwork() {
    this._network.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkInput() {
    return this._network.internalValue;
  }

  // nvme - computed: false, optional: true, required: false
  private _nvme = new DomainDevicesDisksBackingStoreSourceNvmeOutputReference(this, "nvme");
  public get nvme() {
    return this._nvme;
  }
  public putNvme(value: DomainDevicesDisksBackingStoreSourceNvme) {
    this._nvme.internalValue = value;
  }
  public resetNvme() {
    this._nvme.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nvmeInput() {
    return this._nvme.internalValue;
  }

  // readahead - computed: false, optional: true, required: false
  private _readahead = new DomainDevicesDisksBackingStoreSourceReadaheadOutputReference(this, "readahead");
  public get readahead() {
    return this._readahead;
  }
  public putReadahead(value: DomainDevicesDisksBackingStoreSourceReadahead) {
    this._readahead.internalValue = value;
  }
  public resetReadahead() {
    this._readahead.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readaheadInput() {
    return this._readahead.internalValue;
  }

  // reservations - computed: false, optional: true, required: false
  private _reservations = new DomainDevicesDisksBackingStoreSourceReservationsOutputReference(this, "reservations");
  public get reservations() {
    return this._reservations;
  }
  public putReservations(value: DomainDevicesDisksBackingStoreSourceReservations) {
    this._reservations.internalValue = value;
  }
  public resetReservations() {
    this._reservations.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reservationsInput() {
    return this._reservations.internalValue;
  }

  // slices - computed: false, optional: true, required: false
  private _slices = new DomainDevicesDisksBackingStoreSourceSlicesOutputReference(this, "slices");
  public get slices() {
    return this._slices;
  }
  public putSlices(value: DomainDevicesDisksBackingStoreSourceSlices) {
    this._slices.internalValue = value;
  }
  public resetSlices() {
    this._slices.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get slicesInput() {
    return this._slices.internalValue;
  }

  // ssl - computed: false, optional: true, required: false
  private _ssl = new DomainDevicesDisksBackingStoreSourceSslOutputReference(this, "ssl");
  public get ssl() {
    return this._ssl;
  }
  public putSsl(value: DomainDevicesDisksBackingStoreSourceSsl) {
    this._ssl.internalValue = value;
  }
  public resetSsl() {
    this._ssl.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sslInput() {
    return this._ssl.internalValue;
  }

  // startup_policy - computed: false, optional: true, required: false
  private _startupPolicy?: string; 
  public get startupPolicy() {
    return this.getStringAttribute('startup_policy');
  }
  public set startupPolicy(value: string) {
    this._startupPolicy = value;
  }
  public resetStartupPolicy() {
    this._startupPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get startupPolicyInput() {
    return this._startupPolicy;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout = new DomainDevicesDisksBackingStoreSourceTimeoutOutputReference(this, "timeout");
  public get timeout() {
    return this._timeout;
  }
  public putTimeout(value: DomainDevicesDisksBackingStoreSourceTimeout) {
    this._timeout.internalValue = value;
  }
  public resetTimeout() {
    this._timeout.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout.internalValue;
  }

  // vhost_user - computed: false, optional: true, required: false
  private _vhostUser = new DomainDevicesDisksBackingStoreSourceVhostUserOutputReference(this, "vhost_user");
  public get vhostUser() {
    return this._vhostUser;
  }
  public putVhostUser(value: DomainDevicesDisksBackingStoreSourceVhostUser) {
    this._vhostUser.internalValue = value;
  }
  public resetVhostUser() {
    this._vhostUser.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vhostUserInput() {
    return this._vhostUser.internalValue;
  }

  // vhost_vdpa - computed: false, optional: true, required: false
  private _vhostVdpa = new DomainDevicesDisksBackingStoreSourceVhostVdpaOutputReference(this, "vhost_vdpa");
  public get vhostVdpa() {
    return this._vhostVdpa;
  }
  public putVhostVdpa(value: DomainDevicesDisksBackingStoreSourceVhostVdpa) {
    this._vhostVdpa.internalValue = value;
  }
  public resetVhostVdpa() {
    this._vhostVdpa.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vhostVdpaInput() {
    return this._vhostVdpa.internalValue;
  }

  // volume - computed: false, optional: true, required: false
  private _volume = new DomainDevicesDisksBackingStoreSourceVolumeOutputReference(this, "volume");
  public get volume() {
    return this._volume;
  }
  public putVolume(value: DomainDevicesDisksBackingStoreSourceVolume) {
    this._volume.internalValue = value;
  }
  public resetVolume() {
    this._volume.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get volumeInput() {
    return this._volume.internalValue;
  }
}
export interface DomainDevicesDisksBackingStore {
  /**
  * Configures the on-disk format settings for the mirrored backing store’s data store, including format type and optional metadata cache tuning.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#format Domain#format}
  */
  readonly format?: DomainDevicesDisksBackingStoreFormat;
  /**
  * Sets the index of this backing store within the mirror’s backing chain, as an integer used to order multiple backingStore entries.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#index Domain#index}
  */
  readonly index?: number;
  /**
  * Defines the data source for the mirror backing store, such as a block device or file path.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#source Domain#source}
  */
  readonly source?: DomainDevicesDisksBackingStoreSource;
}

export function domainDevicesDisksBackingStoreToTerraform(struct?: DomainDevicesDisksBackingStore | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    format: domainDevicesDisksBackingStoreFormatToTerraform(struct!.format),
    index: cdktf.numberToTerraform(struct!.index),
    source: domainDevicesDisksBackingStoreSourceToTerraform(struct!.source),
  }
}


export function domainDevicesDisksBackingStoreToHclTerraform(struct?: DomainDevicesDisksBackingStore | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    format: {
      value: domainDevicesDisksBackingStoreFormatToHclTerraform(struct!.format),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreFormat",
    },
    index: {
      value: cdktf.numberToHclTerraform(struct!.index),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    source: {
      value: domainDevicesDisksBackingStoreSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreSource",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStore | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._format?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format?.internalValue;
    }
    if (this._index !== undefined) {
      hasAnyValues = true;
      internalValueResult.index = this._index;
    }
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStore | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._format.internalValue = undefined;
      this._index = undefined;
      this._source.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._format.internalValue = value.format;
      this._index = value.index;
      this._source.internalValue = value.source;
    }
  }

  // format - computed: false, optional: true, required: false
  private _format = new DomainDevicesDisksBackingStoreFormatOutputReference(this, "format");
  public get format() {
    return this._format;
  }
  public putFormat(value: DomainDevicesDisksBackingStoreFormat) {
    this._format.internalValue = value;
  }
  public resetFormat() {
    this._format.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format.internalValue;
  }

  // index - computed: false, optional: true, required: false
  private _index?: number; 
  public get index() {
    return this.getNumberAttribute('index');
  }
  public set index(value: number) {
    this._index = value;
  }
  public resetIndex() {
    this._index = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get indexInput() {
    return this._index;
  }

  // source - computed: false, optional: true, required: false
  private _source = new DomainDevicesDisksBackingStoreSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: DomainDevicesDisksBackingStoreSource) {
    this._source.internalValue = value;
  }
  public resetSource() {
    this._source.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }
}
export interface DomainDevicesDisksBlockIo {
  /**
  * Sets the discard (TRIM/UNMAP) granularity in bytes for this disk as seen by the guest; the value is a user-provided non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#discard_granularity Domain#discard_granularity}
  */
  readonly discardGranularity?: number;
  /**
  * Sets the logical block size in bytes that the guest sees for this disk; the value is a user-provided positive integer, commonly 512 or 4096.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#logical_block_size Domain#logical_block_size}
  */
  readonly logicalBlockSize?: number;
  /**
  * Sets the physical block size in bytes that the guest sees for this disk, typically matching the underlying storage’s hardware sector size; the value is a user-provided positive integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#physical_block_size Domain#physical_block_size}
  */
  readonly physicalBlockSize?: number;
}

export function domainDevicesDisksBlockIoToTerraform(struct?: DomainDevicesDisksBlockIo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    discard_granularity: cdktf.numberToTerraform(struct!.discardGranularity),
    logical_block_size: cdktf.numberToTerraform(struct!.logicalBlockSize),
    physical_block_size: cdktf.numberToTerraform(struct!.physicalBlockSize),
  }
}


export function domainDevicesDisksBlockIoToHclTerraform(struct?: DomainDevicesDisksBlockIo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    discard_granularity: {
      value: cdktf.numberToHclTerraform(struct!.discardGranularity),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    logical_block_size: {
      value: cdktf.numberToHclTerraform(struct!.logicalBlockSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    physical_block_size: {
      value: cdktf.numberToHclTerraform(struct!.physicalBlockSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBlockIoOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBlockIo | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._discardGranularity !== undefined) {
      hasAnyValues = true;
      internalValueResult.discardGranularity = this._discardGranularity;
    }
    if (this._logicalBlockSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.logicalBlockSize = this._logicalBlockSize;
    }
    if (this._physicalBlockSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.physicalBlockSize = this._physicalBlockSize;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBlockIo | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._discardGranularity = undefined;
      this._logicalBlockSize = undefined;
      this._physicalBlockSize = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._discardGranularity = value.discardGranularity;
      this._logicalBlockSize = value.logicalBlockSize;
      this._physicalBlockSize = value.physicalBlockSize;
    }
  }

  // discard_granularity - computed: false, optional: true, required: false
  private _discardGranularity?: number; 
  public get discardGranularity() {
    return this.getNumberAttribute('discard_granularity');
  }
  public set discardGranularity(value: number) {
    this._discardGranularity = value;
  }
  public resetDiscardGranularity() {
    this._discardGranularity = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get discardGranularityInput() {
    return this._discardGranularity;
  }

  // logical_block_size - computed: false, optional: true, required: false
  private _logicalBlockSize?: number; 
  public get logicalBlockSize() {
    return this.getNumberAttribute('logical_block_size');
  }
  public set logicalBlockSize(value: number) {
    this._logicalBlockSize = value;
  }
  public resetLogicalBlockSize() {
    this._logicalBlockSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logicalBlockSizeInput() {
    return this._logicalBlockSize;
  }

  // physical_block_size - computed: false, optional: true, required: false
  private _physicalBlockSize?: number; 
  public get physicalBlockSize() {
    return this.getNumberAttribute('physical_block_size');
  }
  public set physicalBlockSize(value: number) {
    this._physicalBlockSize = value;
  }
  public resetPhysicalBlockSize() {
    this._physicalBlockSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get physicalBlockSizeInput() {
    return this._physicalBlockSize;
  }
}
export interface DomainDevicesDisksBoot {
  /**
  * Sets an optional firmware load parameter string associated with booting from this redirected device, passed to firmware on platforms that support loadparm (e.g. s390x).
  * 
  * See: <https://libvirt.org/formatdomain.html#specifying-boot-order>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#load_parm Domain#load_parm}
  */
  readonly loadParm?: string;
  /**
  * Sets the boot priority for this redirected device, as a positive integer where lower values are tried earlier during guest boot (for example, 1 for first, 2 for second).
  * 
  * See: <https://libvirt.org/formatdomain.html#specifying-boot-order>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#order Domain#order}
  */
  readonly order: number;
}

export function domainDevicesDisksBootToTerraform(struct?: DomainDevicesDisksBoot | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    load_parm: cdktf.stringToTerraform(struct!.loadParm),
    order: cdktf.numberToTerraform(struct!.order),
  }
}


export function domainDevicesDisksBootToHclTerraform(struct?: DomainDevicesDisksBoot | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    load_parm: {
      value: cdktf.stringToHclTerraform(struct!.loadParm),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    order: {
      value: cdktf.numberToHclTerraform(struct!.order),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBootOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBoot | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._loadParm !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadParm = this._loadParm;
    }
    if (this._order !== undefined) {
      hasAnyValues = true;
      internalValueResult.order = this._order;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBoot | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._loadParm = undefined;
      this._order = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._loadParm = value.loadParm;
      this._order = value.order;
    }
  }

  // load_parm - computed: false, optional: true, required: false
  private _loadParm?: string; 
  public get loadParm() {
    return this.getStringAttribute('load_parm');
  }
  public set loadParm(value: string) {
    this._loadParm = value;
  }
  public resetLoadParm() {
    this._loadParm = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadParmInput() {
    return this._loadParm;
  }

  // order - computed: false, optional: false, required: true
  private _order?: number; 
  public get order() {
    return this.getNumberAttribute('order');
  }
  public set order(value: number) {
    this._order = value;
  }
  // Temporarily expose input value. Use with caution.
  public get orderInput() {
    return this._order;
  }
}
export interface DomainDevicesDisksDriverIoThreadsIoThreadQueues {
}

export function domainDevicesDisksDriverIoThreadsIoThreadQueuesToTerraform(struct?: DomainDevicesDisksDriverIoThreadsIoThreadQueues | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function domainDevicesDisksDriverIoThreadsIoThreadQueuesToHclTerraform(struct?: DomainDevicesDisksDriverIoThreadsIoThreadQueues | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DomainDevicesDisksDriverIoThreadsIoThreadQueuesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksDriverIoThreadsIoThreadQueues | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksDriverIoThreadsIoThreadQueues | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }

  // id - computed: true, optional: false, required: false
  public get id() {
    return this.getNumberAttribute('id');
  }
}

export class DomainDevicesDisksDriverIoThreadsIoThreadQueuesList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksDriverIoThreadsIoThreadQueues[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksDriverIoThreadsIoThreadQueuesOutputReference {
    return new DomainDevicesDisksDriverIoThreadsIoThreadQueuesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksDriverIoThreadsIoThread {
  /**
  * Lists one or more queue elements to bind specific disk queues to this IOThread; the values are user-provided queue identifiers.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#queues Domain#queues}
  */
  readonly queues?: DomainDevicesDisksDriverIoThreadsIoThreadQueues[] | cdktf.IResolvable;
}

export function domainDevicesDisksDriverIoThreadsIoThreadToTerraform(struct?: DomainDevicesDisksDriverIoThreadsIoThread | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    queues: cdktf.listMapper(domainDevicesDisksDriverIoThreadsIoThreadQueuesToTerraform, false)(struct!.queues),
  }
}


export function domainDevicesDisksDriverIoThreadsIoThreadToHclTerraform(struct?: DomainDevicesDisksDriverIoThreadsIoThread | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    queues: {
      value: cdktf.listMapperHcl(domainDevicesDisksDriverIoThreadsIoThreadQueuesToHclTerraform, false)(struct!.queues),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksDriverIoThreadsIoThreadQueuesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksDriverIoThreadsIoThreadOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksDriverIoThreadsIoThread | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._queues?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.queues = this._queues?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksDriverIoThreadsIoThread | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._queues.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._queues.internalValue = value.queues;
    }
  }

  // id - computed: true, optional: false, required: false
  public get id() {
    return this.getNumberAttribute('id');
  }

  // queues - computed: false, optional: true, required: false
  private _queues = new DomainDevicesDisksDriverIoThreadsIoThreadQueuesList(this, "queues", false);
  public get queues() {
    return this._queues;
  }
  public putQueues(value: DomainDevicesDisksDriverIoThreadsIoThreadQueues[] | cdktf.IResolvable) {
    this._queues.internalValue = value;
  }
  public resetQueues() {
    this._queues.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queuesInput() {
    return this._queues.internalValue;
  }
}

export class DomainDevicesDisksDriverIoThreadsIoThreadList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksDriverIoThreadsIoThread[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksDriverIoThreadsIoThreadOutputReference {
    return new DomainDevicesDisksDriverIoThreadsIoThreadOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksDriverIoThreads {
  /**
  * Describes a single IOThread mapping entry for this disk, potentially distributing disk queues across IOThreads.
  * 
  * See: <https://libvirt.org/formatdomain.html#iothreads-allocation>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#io_thread Domain#io_thread}
  */
  readonly ioThread?: DomainDevicesDisksDriverIoThreadsIoThread[] | cdktf.IResolvable;
}

export function domainDevicesDisksDriverIoThreadsToTerraform(struct?: DomainDevicesDisksDriverIoThreads | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    io_thread: cdktf.listMapper(domainDevicesDisksDriverIoThreadsIoThreadToTerraform, false)(struct!.ioThread),
  }
}


export function domainDevicesDisksDriverIoThreadsToHclTerraform(struct?: DomainDevicesDisksDriverIoThreads | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    io_thread: {
      value: cdktf.listMapperHcl(domainDevicesDisksDriverIoThreadsIoThreadToHclTerraform, false)(struct!.ioThread),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksDriverIoThreadsIoThreadList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksDriverIoThreadsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksDriverIoThreads | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ioThread?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ioThread = this._ioThread?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksDriverIoThreads | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ioThread.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ioThread.internalValue = value.ioThread;
    }
  }

  // io_thread - computed: false, optional: true, required: false
  private _ioThread = new DomainDevicesDisksDriverIoThreadsIoThreadList(this, "io_thread", false);
  public get ioThread() {
    return this._ioThread;
  }
  public putIoThread(value: DomainDevicesDisksDriverIoThreadsIoThread[] | cdktf.IResolvable) {
    this._ioThread.internalValue = value;
  }
  public resetIoThread() {
    this._ioThread.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ioThreadInput() {
    return this._ioThread.internalValue;
  }
}
export interface DomainDevicesDisksDriverMetadataCacheMaxSize {
  /**
  * Sets the unit used for the metadata cache maximum size; valid units follow libvirt size units such as "B", "KiB", "MiB", "GiB" and are user-chosen.
  * 
  * See: <https://libvirt.org/formatdomain.html#memory-allocation>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#unit Domain#unit}
  */
  readonly unit?: string;
  /**
  * Sets the numeric value for the metadata cache maximum size in the specified unit; this must be a positive integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#value Domain#value}
  */
  readonly value: number;
}

export function domainDevicesDisksDriverMetadataCacheMaxSizeToTerraform(struct?: DomainDevicesDisksDriverMetadataCacheMaxSize | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    unit: cdktf.stringToTerraform(struct!.unit),
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function domainDevicesDisksDriverMetadataCacheMaxSizeToHclTerraform(struct?: DomainDevicesDisksDriverMetadataCacheMaxSize | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    unit: {
      value: cdktf.stringToHclTerraform(struct!.unit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksDriverMetadataCacheMaxSizeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksDriverMetadataCacheMaxSize | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._unit !== undefined) {
      hasAnyValues = true;
      internalValueResult.unit = this._unit;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksDriverMetadataCacheMaxSize | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._unit = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._unit = value.unit;
      this._value = value.value;
    }
  }

  // unit - computed: false, optional: true, required: false
  private _unit?: string; 
  public get unit() {
    return this.getStringAttribute('unit');
  }
  public set unit(value: string) {
    this._unit = value;
  }
  public resetUnit() {
    this._unit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unitInput() {
    return this._unit;
  }

  // value - computed: false, optional: false, required: true
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DomainDevicesDisksDriverMetadataCache {
  /**
  * Sets the maximum size of the metadata cache used by the data store format; value and unit together define the limit (for example, 64 MiB).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#max_size Domain#max_size}
  */
  readonly maxSize?: DomainDevicesDisksDriverMetadataCacheMaxSize;
}

export function domainDevicesDisksDriverMetadataCacheToTerraform(struct?: DomainDevicesDisksDriverMetadataCache | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_size: domainDevicesDisksDriverMetadataCacheMaxSizeToTerraform(struct!.maxSize),
  }
}


export function domainDevicesDisksDriverMetadataCacheToHclTerraform(struct?: DomainDevicesDisksDriverMetadataCache | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_size: {
      value: domainDevicesDisksDriverMetadataCacheMaxSizeToHclTerraform(struct!.maxSize),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksDriverMetadataCacheMaxSize",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksDriverMetadataCacheOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksDriverMetadataCache | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxSize?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksDriverMetadataCache | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxSize.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxSize.internalValue = value.maxSize;
    }
  }

  // max_size - computed: false, optional: true, required: false
  private _maxSize = new DomainDevicesDisksDriverMetadataCacheMaxSizeOutputReference(this, "max_size");
  public get maxSize() {
    return this._maxSize;
  }
  public putMaxSize(value: DomainDevicesDisksDriverMetadataCacheMaxSize) {
    this._maxSize.internalValue = value;
  }
  public resetMaxSize() {
    this._maxSize.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize.internalValue;
  }
}
export interface DomainDevicesDisksDriver {
  /**
  * Configures whether the virtio disk uses Address Translation Service (ATS) on the virtio transport; accepts "on" or "off".
  * 
  * See: <https://libvirt.org/formatdomain.html#virtio-related-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#ats Domain#ats}
  */
  readonly ats?: string;
  /**
  * Sets the host-side cache mode for the disk I/O, using libvirt/QEMU cache policies such as "none", "writeback", or "writethrough"; the exact string is user-provided but must be a valid cache mode for the hypervisor.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#cache Domain#cache}
  */
  readonly cache?: string;
  /**
  * Controls the disk copy-on-read behavior (e.g. forcing data into cache when read) using a yes/no style value such as "on"/"off"; the exact string is user-provided but must be supported by the hypervisor.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#copy_on_read Domain#copy_on_read}
  */
  readonly copyOnRead?: string;
  /**
  * Sets how the disk driver handles writes of zero blocks (e.g. "on", "off", or "unmap") to allow optimization or discard; the string must be one of the modes supported by the hypervisor.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#detect_zeros Domain#detect_zeros}
  */
  readonly detectZeros?: string;
  /**
  * Configures whether and how discard/TRIM requests are passed from the guest to the backing storage (for example "unmap" or "ignore"); the value must be a discard mode supported by the hypervisor.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#discard Domain#discard}
  */
  readonly discard?: string;
  /**
  * Controls whether discard operations avoid the QEMU "unref" optimization, using a driver-specific yes/no style flag; the exact value is user-provided but must be supported by the hypervisor.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#discard_no_unref Domain#discard_no_unref}
  */
  readonly discardNoUnref?: string;
  /**
  * Sets the action taken by the hypervisor on I/O errors for this disk (for example "stop", "ignore", "enospace", or "report"); the string must be one of the error policies supported by the hypervisor.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#error_policy Domain#error_policy}
  */
  readonly errorPolicy?: string;
  /**
  * Enables or disables the virtio "event_idx" optimization for the disk, using a yes/no style value such as "on"/"off".
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#event_idx Domain#event_idx}
  */
  readonly eventIdx?: string;
  /**
  * Selects the I/O mode for accessing the disk (for example "threads" or "native"); the value is user-provided but must match a valid I/O mode supported by the hypervisor.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#io Domain#io}
  */
  readonly io?: string;
  /**
  * Controls whether ioeventfd is used for this disk device to optimize I/O notification, using a yes/no style value such as "on"/"off".
  * 
  * See: <https://libvirt.org/formatdomain.html#devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#io_event_fd Domain#io_event_fd}
  */
  readonly ioEventFd?: string;
  /**
  * Assigns the disk to a specific IOThread by numeric id, matching an IOThread defined in the domain; the value is user-provided and must reference an existing IOThread.
  * 
  * See: <https://libvirt.org/formatdomain.html#iothreads-allocation>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#io_thread Domain#io_thread}
  */
  readonly ioThread?: number;
  /**
  * Defines per-disk IOThread mapping information, allowing this disk to use one or more dedicated IOThreads instead of the default I/O path.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#io_threads Domain#io_threads}
  */
  readonly ioThreads?: DomainDevicesDisksDriverIoThreads;
  /**
  * Enables or disables use of an emulated IOMMU for this disk device on the virtio transport, using "on" or "off".
  * 
  * See: <https://libvirt.org/formatdomain.html#virtio-related-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#iommu Domain#iommu}
  */
  readonly iommu?: string;
  /**
  * Configures metadata cache behavior for the mirrored backing store’s data store format (for example, limiting the size of cached metadata).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#metadata_cache Domain#metadata_cache}
  */
  readonly metadataCache?: DomainDevicesDisksDriverMetadataCache;
  /**
  * Sets the underlying disk driver implementation name, typically a string such as "qemu" to control which backend handles the disk.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name?: string;
  /**
  * Controls whether the virtio-blk device uses packed virtqueue layout; accepts "on" or "off".
  * 
  * See: <https://libvirt.org/formatdomain.html#virtio-related-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#packed Domain#packed}
  */
  readonly packed?: string;
  /**
  * Controls whether the virtio device uses a separate page per virtqueue for virtqueue descriptors; accepts "on" or "off".
  * 
  * See: <https://libvirt.org/formatdomain.html#virtio-related-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#page_per_vq Domain#page_per_vq}
  */
  readonly pagePerVq?: string;
  /**
  * Sets the virtqueue size (number of entries) for this disk’s virtio queue as a positive integer, if supported by the driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#queue_size Domain#queue_size}
  */
  readonly queueSize?: number;
  /**
  * Sets the number of virtio I/O queues for this disk, as a positive integer, to enable multiqueue operation.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#queues Domain#queues}
  */
  readonly queues?: number;
  /**
  * Sets the policy for handling read errors on the disk, typically one of "ignore", "stop", or driver-specific values.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#rerror_policy Domain#rerror_policy}
  */
  readonly rerrorPolicy?: string;
  /**
  * Sets the on-disk image format for the disk driver, such as "raw", "qcow2", or other user-provided format strings supported by qemu.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type?: string;
}

export function domainDevicesDisksDriverToTerraform(struct?: DomainDevicesDisksDriver | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ats: cdktf.stringToTerraform(struct!.ats),
    cache: cdktf.stringToTerraform(struct!.cache),
    copy_on_read: cdktf.stringToTerraform(struct!.copyOnRead),
    detect_zeros: cdktf.stringToTerraform(struct!.detectZeros),
    discard: cdktf.stringToTerraform(struct!.discard),
    discard_no_unref: cdktf.stringToTerraform(struct!.discardNoUnref),
    error_policy: cdktf.stringToTerraform(struct!.errorPolicy),
    event_idx: cdktf.stringToTerraform(struct!.eventIdx),
    io: cdktf.stringToTerraform(struct!.io),
    io_event_fd: cdktf.stringToTerraform(struct!.ioEventFd),
    io_thread: cdktf.numberToTerraform(struct!.ioThread),
    io_threads: domainDevicesDisksDriverIoThreadsToTerraform(struct!.ioThreads),
    iommu: cdktf.stringToTerraform(struct!.iommu),
    metadata_cache: domainDevicesDisksDriverMetadataCacheToTerraform(struct!.metadataCache),
    name: cdktf.stringToTerraform(struct!.name),
    packed: cdktf.stringToTerraform(struct!.packed),
    page_per_vq: cdktf.stringToTerraform(struct!.pagePerVq),
    queue_size: cdktf.numberToTerraform(struct!.queueSize),
    queues: cdktf.numberToTerraform(struct!.queues),
    rerror_policy: cdktf.stringToTerraform(struct!.rerrorPolicy),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function domainDevicesDisksDriverToHclTerraform(struct?: DomainDevicesDisksDriver | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ats: {
      value: cdktf.stringToHclTerraform(struct!.ats),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cache: {
      value: cdktf.stringToHclTerraform(struct!.cache),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    copy_on_read: {
      value: cdktf.stringToHclTerraform(struct!.copyOnRead),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    detect_zeros: {
      value: cdktf.stringToHclTerraform(struct!.detectZeros),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    discard: {
      value: cdktf.stringToHclTerraform(struct!.discard),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    discard_no_unref: {
      value: cdktf.stringToHclTerraform(struct!.discardNoUnref),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    error_policy: {
      value: cdktf.stringToHclTerraform(struct!.errorPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    event_idx: {
      value: cdktf.stringToHclTerraform(struct!.eventIdx),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    io: {
      value: cdktf.stringToHclTerraform(struct!.io),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    io_event_fd: {
      value: cdktf.stringToHclTerraform(struct!.ioEventFd),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    io_thread: {
      value: cdktf.numberToHclTerraform(struct!.ioThread),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    io_threads: {
      value: domainDevicesDisksDriverIoThreadsToHclTerraform(struct!.ioThreads),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksDriverIoThreads",
    },
    iommu: {
      value: cdktf.stringToHclTerraform(struct!.iommu),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metadata_cache: {
      value: domainDevicesDisksDriverMetadataCacheToHclTerraform(struct!.metadataCache),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksDriverMetadataCache",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    packed: {
      value: cdktf.stringToHclTerraform(struct!.packed),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    page_per_vq: {
      value: cdktf.stringToHclTerraform(struct!.pagePerVq),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    queue_size: {
      value: cdktf.numberToHclTerraform(struct!.queueSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    queues: {
      value: cdktf.numberToHclTerraform(struct!.queues),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    rerror_policy: {
      value: cdktf.stringToHclTerraform(struct!.rerrorPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksDriverOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksDriver | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ats !== undefined) {
      hasAnyValues = true;
      internalValueResult.ats = this._ats;
    }
    if (this._cache !== undefined) {
      hasAnyValues = true;
      internalValueResult.cache = this._cache;
    }
    if (this._copyOnRead !== undefined) {
      hasAnyValues = true;
      internalValueResult.copyOnRead = this._copyOnRead;
    }
    if (this._detectZeros !== undefined) {
      hasAnyValues = true;
      internalValueResult.detectZeros = this._detectZeros;
    }
    if (this._discard !== undefined) {
      hasAnyValues = true;
      internalValueResult.discard = this._discard;
    }
    if (this._discardNoUnref !== undefined) {
      hasAnyValues = true;
      internalValueResult.discardNoUnref = this._discardNoUnref;
    }
    if (this._errorPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.errorPolicy = this._errorPolicy;
    }
    if (this._eventIdx !== undefined) {
      hasAnyValues = true;
      internalValueResult.eventIdx = this._eventIdx;
    }
    if (this._io !== undefined) {
      hasAnyValues = true;
      internalValueResult.io = this._io;
    }
    if (this._ioEventFd !== undefined) {
      hasAnyValues = true;
      internalValueResult.ioEventFd = this._ioEventFd;
    }
    if (this._ioThread !== undefined) {
      hasAnyValues = true;
      internalValueResult.ioThread = this._ioThread;
    }
    if (this._ioThreads?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ioThreads = this._ioThreads?.internalValue;
    }
    if (this._iommu !== undefined) {
      hasAnyValues = true;
      internalValueResult.iommu = this._iommu;
    }
    if (this._metadataCache?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadataCache = this._metadataCache?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._packed !== undefined) {
      hasAnyValues = true;
      internalValueResult.packed = this._packed;
    }
    if (this._pagePerVq !== undefined) {
      hasAnyValues = true;
      internalValueResult.pagePerVq = this._pagePerVq;
    }
    if (this._queueSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.queueSize = this._queueSize;
    }
    if (this._queues !== undefined) {
      hasAnyValues = true;
      internalValueResult.queues = this._queues;
    }
    if (this._rerrorPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.rerrorPolicy = this._rerrorPolicy;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksDriver | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ats = undefined;
      this._cache = undefined;
      this._copyOnRead = undefined;
      this._detectZeros = undefined;
      this._discard = undefined;
      this._discardNoUnref = undefined;
      this._errorPolicy = undefined;
      this._eventIdx = undefined;
      this._io = undefined;
      this._ioEventFd = undefined;
      this._ioThread = undefined;
      this._ioThreads.internalValue = undefined;
      this._iommu = undefined;
      this._metadataCache.internalValue = undefined;
      this._name = undefined;
      this._packed = undefined;
      this._pagePerVq = undefined;
      this._queueSize = undefined;
      this._queues = undefined;
      this._rerrorPolicy = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ats = value.ats;
      this._cache = value.cache;
      this._copyOnRead = value.copyOnRead;
      this._detectZeros = value.detectZeros;
      this._discard = value.discard;
      this._discardNoUnref = value.discardNoUnref;
      this._errorPolicy = value.errorPolicy;
      this._eventIdx = value.eventIdx;
      this._io = value.io;
      this._ioEventFd = value.ioEventFd;
      this._ioThread = value.ioThread;
      this._ioThreads.internalValue = value.ioThreads;
      this._iommu = value.iommu;
      this._metadataCache.internalValue = value.metadataCache;
      this._name = value.name;
      this._packed = value.packed;
      this._pagePerVq = value.pagePerVq;
      this._queueSize = value.queueSize;
      this._queues = value.queues;
      this._rerrorPolicy = value.rerrorPolicy;
      this._type = value.type;
    }
  }

  // ats - computed: false, optional: true, required: false
  private _ats?: string; 
  public get ats() {
    return this.getStringAttribute('ats');
  }
  public set ats(value: string) {
    this._ats = value;
  }
  public resetAts() {
    this._ats = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get atsInput() {
    return this._ats;
  }

  // cache - computed: false, optional: true, required: false
  private _cache?: string; 
  public get cache() {
    return this.getStringAttribute('cache');
  }
  public set cache(value: string) {
    this._cache = value;
  }
  public resetCache() {
    this._cache = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cacheInput() {
    return this._cache;
  }

  // copy_on_read - computed: false, optional: true, required: false
  private _copyOnRead?: string; 
  public get copyOnRead() {
    return this.getStringAttribute('copy_on_read');
  }
  public set copyOnRead(value: string) {
    this._copyOnRead = value;
  }
  public resetCopyOnRead() {
    this._copyOnRead = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get copyOnReadInput() {
    return this._copyOnRead;
  }

  // detect_zeros - computed: false, optional: true, required: false
  private _detectZeros?: string; 
  public get detectZeros() {
    return this.getStringAttribute('detect_zeros');
  }
  public set detectZeros(value: string) {
    this._detectZeros = value;
  }
  public resetDetectZeros() {
    this._detectZeros = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get detectZerosInput() {
    return this._detectZeros;
  }

  // discard - computed: false, optional: true, required: false
  private _discard?: string; 
  public get discard() {
    return this.getStringAttribute('discard');
  }
  public set discard(value: string) {
    this._discard = value;
  }
  public resetDiscard() {
    this._discard = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get discardInput() {
    return this._discard;
  }

  // discard_no_unref - computed: false, optional: true, required: false
  private _discardNoUnref?: string; 
  public get discardNoUnref() {
    return this.getStringAttribute('discard_no_unref');
  }
  public set discardNoUnref(value: string) {
    this._discardNoUnref = value;
  }
  public resetDiscardNoUnref() {
    this._discardNoUnref = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get discardNoUnrefInput() {
    return this._discardNoUnref;
  }

  // error_policy - computed: false, optional: true, required: false
  private _errorPolicy?: string; 
  public get errorPolicy() {
    return this.getStringAttribute('error_policy');
  }
  public set errorPolicy(value: string) {
    this._errorPolicy = value;
  }
  public resetErrorPolicy() {
    this._errorPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get errorPolicyInput() {
    return this._errorPolicy;
  }

  // event_idx - computed: false, optional: true, required: false
  private _eventIdx?: string; 
  public get eventIdx() {
    return this.getStringAttribute('event_idx');
  }
  public set eventIdx(value: string) {
    this._eventIdx = value;
  }
  public resetEventIdx() {
    this._eventIdx = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get eventIdxInput() {
    return this._eventIdx;
  }

  // io - computed: false, optional: true, required: false
  private _io?: string; 
  public get io() {
    return this.getStringAttribute('io');
  }
  public set io(value: string) {
    this._io = value;
  }
  public resetIo() {
    this._io = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ioInput() {
    return this._io;
  }

  // io_event_fd - computed: false, optional: true, required: false
  private _ioEventFd?: string; 
  public get ioEventFd() {
    return this.getStringAttribute('io_event_fd');
  }
  public set ioEventFd(value: string) {
    this._ioEventFd = value;
  }
  public resetIoEventFd() {
    this._ioEventFd = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ioEventFdInput() {
    return this._ioEventFd;
  }

  // io_thread - computed: false, optional: true, required: false
  private _ioThread?: number; 
  public get ioThread() {
    return this.getNumberAttribute('io_thread');
  }
  public set ioThread(value: number) {
    this._ioThread = value;
  }
  public resetIoThread() {
    this._ioThread = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ioThreadInput() {
    return this._ioThread;
  }

  // io_threads - computed: false, optional: true, required: false
  private _ioThreads = new DomainDevicesDisksDriverIoThreadsOutputReference(this, "io_threads");
  public get ioThreads() {
    return this._ioThreads;
  }
  public putIoThreads(value: DomainDevicesDisksDriverIoThreads) {
    this._ioThreads.internalValue = value;
  }
  public resetIoThreads() {
    this._ioThreads.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ioThreadsInput() {
    return this._ioThreads.internalValue;
  }

  // iommu - computed: false, optional: true, required: false
  private _iommu?: string; 
  public get iommu() {
    return this.getStringAttribute('iommu');
  }
  public set iommu(value: string) {
    this._iommu = value;
  }
  public resetIommu() {
    this._iommu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get iommuInput() {
    return this._iommu;
  }

  // metadata_cache - computed: false, optional: true, required: false
  private _metadataCache = new DomainDevicesDisksDriverMetadataCacheOutputReference(this, "metadata_cache");
  public get metadataCache() {
    return this._metadataCache;
  }
  public putMetadataCache(value: DomainDevicesDisksDriverMetadataCache) {
    this._metadataCache.internalValue = value;
  }
  public resetMetadataCache() {
    this._metadataCache.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataCacheInput() {
    return this._metadataCache.internalValue;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // packed - computed: false, optional: true, required: false
  private _packed?: string; 
  public get packed() {
    return this.getStringAttribute('packed');
  }
  public set packed(value: string) {
    this._packed = value;
  }
  public resetPacked() {
    this._packed = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get packedInput() {
    return this._packed;
  }

  // page_per_vq - computed: false, optional: true, required: false
  private _pagePerVq?: string; 
  public get pagePerVq() {
    return this.getStringAttribute('page_per_vq');
  }
  public set pagePerVq(value: string) {
    this._pagePerVq = value;
  }
  public resetPagePerVq() {
    this._pagePerVq = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pagePerVqInput() {
    return this._pagePerVq;
  }

  // queue_size - computed: false, optional: true, required: false
  private _queueSize?: number; 
  public get queueSize() {
    return this.getNumberAttribute('queue_size');
  }
  public set queueSize(value: number) {
    this._queueSize = value;
  }
  public resetQueueSize() {
    this._queueSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queueSizeInput() {
    return this._queueSize;
  }

  // queues - computed: false, optional: true, required: false
  private _queues?: number; 
  public get queues() {
    return this.getNumberAttribute('queues');
  }
  public set queues(value: number) {
    this._queues = value;
  }
  public resetQueues() {
    this._queues = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queuesInput() {
    return this._queues;
  }

  // rerror_policy - computed: false, optional: true, required: false
  private _rerrorPolicy?: string; 
  public get rerrorPolicy() {
    return this.getStringAttribute('rerror_policy');
  }
  public set rerrorPolicy(value: string) {
    this._rerrorPolicy = value;
  }
  public resetRerrorPolicy() {
    this._rerrorPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rerrorPolicyInput() {
    return this._rerrorPolicy;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DomainDevicesDisksEncryptionSecrets {
  /**
  * Sets how the referenced secret is identified; typical values are user-provided strings such as "uuid" or "usage" depending on how the secret is looked up.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type?: string;
  /**
  * Sets the libvirt secret usage name when referencing the iSCSI auth secret by usage; the value is a user-provided identifier such as an iSCSI target name.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#usage Domain#usage}
  */
  readonly usage?: string;
}

export function domainDevicesDisksEncryptionSecretsToTerraform(struct?: DomainDevicesDisksEncryptionSecrets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    type: cdktf.stringToTerraform(struct!.type),
    usage: cdktf.stringToTerraform(struct!.usage),
  }
}


export function domainDevicesDisksEncryptionSecretsToHclTerraform(struct?: DomainDevicesDisksEncryptionSecrets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    usage: {
      value: cdktf.stringToHclTerraform(struct!.usage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksEncryptionSecretsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksEncryptionSecrets | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._usage !== undefined) {
      hasAnyValues = true;
      internalValueResult.usage = this._usage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksEncryptionSecrets | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._type = undefined;
      this._usage = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._type = value.type;
      this._usage = value.usage;
    }
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // usage - computed: false, optional: true, required: false
  private _usage?: string; 
  public get usage() {
    return this.getStringAttribute('usage');
  }
  public set usage(value: string) {
    this._usage = value;
  }
  public resetUsage() {
    this._usage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usageInput() {
    return this._usage;
  }

  // uuid - computed: true, optional: false, required: false
  public get uuid() {
    return this.getStringAttribute('uuid');
  }
}

export class DomainDevicesDisksEncryptionSecretsList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksEncryptionSecrets[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksEncryptionSecretsOutputReference {
    return new DomainDevicesDisksEncryptionSecretsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksEncryption {
  /**
  * Sets the encryption engine/provider to use for the disk (user-provided string, e.g. implementation-specific engine name).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#engine Domain#engine}
  */
  readonly engine?: string;
  /**
  * Sets the disk encryption format, such as "luks" or another user-provided scheme supported by libvirt/qemu.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#format Domain#format}
  */
  readonly format?: string;
  /**
  * Defines one or more secret references used to access the encrypted disk, each describing how libvirt locates the secret material.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#secrets Domain#secrets}
  */
  readonly secrets?: DomainDevicesDisksEncryptionSecrets[] | cdktf.IResolvable;
}

export function domainDevicesDisksEncryptionToTerraform(struct?: DomainDevicesDisksEncryption | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    engine: cdktf.stringToTerraform(struct!.engine),
    format: cdktf.stringToTerraform(struct!.format),
    secrets: cdktf.listMapper(domainDevicesDisksEncryptionSecretsToTerraform, false)(struct!.secrets),
  }
}


export function domainDevicesDisksEncryptionToHclTerraform(struct?: DomainDevicesDisksEncryption | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    engine: {
      value: cdktf.stringToHclTerraform(struct!.engine),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secrets: {
      value: cdktf.listMapperHcl(domainDevicesDisksEncryptionSecretsToHclTerraform, false)(struct!.secrets),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksEncryptionSecretsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksEncryptionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksEncryption | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._engine !== undefined) {
      hasAnyValues = true;
      internalValueResult.engine = this._engine;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._secrets?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secrets = this._secrets?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksEncryption | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._engine = undefined;
      this._format = undefined;
      this._secrets.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._engine = value.engine;
      this._format = value.format;
      this._secrets.internalValue = value.secrets;
    }
  }

  // engine - computed: false, optional: true, required: false
  private _engine?: string; 
  public get engine() {
    return this.getStringAttribute('engine');
  }
  public set engine(value: string) {
    this._engine = value;
  }
  public resetEngine() {
    this._engine = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get engineInput() {
    return this._engine;
  }

  // format - computed: false, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // secrets - computed: false, optional: true, required: false
  private _secrets = new DomainDevicesDisksEncryptionSecretsList(this, "secrets", false);
  public get secrets() {
    return this._secrets;
  }
  public putSecrets(value: DomainDevicesDisksEncryptionSecrets[] | cdktf.IResolvable) {
    this._secrets.internalValue = value;
  }
  public resetSecrets() {
    this._secrets.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretsInput() {
    return this._secrets.internalValue;
  }
}
export interface DomainDevicesDisksGeometry {
  /**
  * Sets the number of cylinders in the emulated disk geometry as a positive integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#cylinders Domain#cylinders}
  */
  readonly cylinders: number;
  /**
  * Sets the number of heads in the emulated disk geometry as a positive integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#headers Domain#headers}
  */
  readonly headers: number;
  /**
  * Sets the number of sectors per track in the emulated disk geometry as a positive integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sectors Domain#sectors}
  */
  readonly sectors: number;
  /**
  * Sets the translation mode for mapping logical CHS geometry to physical layout, with user-provided values such as "auto", "none", or hypervisor-specific modes.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#trans Domain#trans}
  */
  readonly trans?: string;
}

export function domainDevicesDisksGeometryToTerraform(struct?: DomainDevicesDisksGeometry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cylinders: cdktf.numberToTerraform(struct!.cylinders),
    headers: cdktf.numberToTerraform(struct!.headers),
    sectors: cdktf.numberToTerraform(struct!.sectors),
    trans: cdktf.stringToTerraform(struct!.trans),
  }
}


export function domainDevicesDisksGeometryToHclTerraform(struct?: DomainDevicesDisksGeometry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cylinders: {
      value: cdktf.numberToHclTerraform(struct!.cylinders),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    headers: {
      value: cdktf.numberToHclTerraform(struct!.headers),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    sectors: {
      value: cdktf.numberToHclTerraform(struct!.sectors),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    trans: {
      value: cdktf.stringToHclTerraform(struct!.trans),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksGeometryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksGeometry | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cylinders !== undefined) {
      hasAnyValues = true;
      internalValueResult.cylinders = this._cylinders;
    }
    if (this._headers !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers;
    }
    if (this._sectors !== undefined) {
      hasAnyValues = true;
      internalValueResult.sectors = this._sectors;
    }
    if (this._trans !== undefined) {
      hasAnyValues = true;
      internalValueResult.trans = this._trans;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksGeometry | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cylinders = undefined;
      this._headers = undefined;
      this._sectors = undefined;
      this._trans = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cylinders = value.cylinders;
      this._headers = value.headers;
      this._sectors = value.sectors;
      this._trans = value.trans;
    }
  }

  // cylinders - computed: false, optional: false, required: true
  private _cylinders?: number; 
  public get cylinders() {
    return this.getNumberAttribute('cylinders');
  }
  public set cylinders(value: number) {
    this._cylinders = value;
  }
  // Temporarily expose input value. Use with caution.
  public get cylindersInput() {
    return this._cylinders;
  }

  // headers - computed: false, optional: false, required: true
  private _headers?: number; 
  public get headers() {
    return this.getNumberAttribute('headers');
  }
  public set headers(value: number) {
    this._headers = value;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers;
  }

  // sectors - computed: false, optional: false, required: true
  private _sectors?: number; 
  public get sectors() {
    return this.getNumberAttribute('sectors');
  }
  public set sectors(value: number) {
    this._sectors = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sectorsInput() {
    return this._sectors;
  }

  // trans - computed: false, optional: true, required: false
  private _trans?: string; 
  public get trans() {
    return this.getStringAttribute('trans');
  }
  public set trans(value: string) {
    this._trans = value;
  }
  public resetTrans() {
    this._trans = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get transInput() {
    return this._trans;
  }
}
export interface DomainDevicesDisksIoTune {
  /**
  * Sets the name of the libvirt disk throttle group that this disk’s I/O limits belong to, allowing multiple disks to share combined throttling; the value is user-provided and must match a defined throttle group if used.
  * 
  * See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#group_name Domain#group_name}
  */
  readonly groupName?: string;
  /**
  * Sets the sustained limit, in bytes per second, for read operations on this disk; value is a user-provided non‑negative integer (e.g. 10485760 for 10 MiB/s).
  * 
  * See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#read_bytes_sec Domain#read_bytes_sec}
  */
  readonly readBytesSec?: number;
  /**
  * Sets the maximum burst read bandwidth limit, in bytes per second, that can be used when bursting above the sustained read_bytes_sec rate; value is a user-provided non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#read_bytes_sec_max Domain#read_bytes_sec_max}
  */
  readonly readBytesSecMax?: number;
  /**
  * Sets the duration, in seconds, over which the read_bytes_sec_max burst bandwidth may be applied; value is a user-provided non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#read_bytes_sec_max_length Domain#read_bytes_sec_max_length}
  */
  readonly readBytesSecMaxLength?: number;
  /**
  * Sets the sustained limit, in I/O operations per second, for read operations on this disk; value is a user-provided non‑negative integer (e.g. 1000 for 1000 read IOPS).
  * 
  * See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#read_iops_sec Domain#read_iops_sec}
  */
  readonly readIopsSec?: number;
  /**
  * Sets the maximum burst read IOPS limit, in operations per second, that can be used when bursting above the sustained read_iops_sec rate; value is a user-provided non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#read_iops_sec_max Domain#read_iops_sec_max}
  */
  readonly readIopsSecMax?: number;
  /**
  * Sets the duration, in seconds, over which the read_iops_sec_max burst IOPS may be applied; value is a user-provided non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#read_iops_sec_max_length Domain#read_iops_sec_max_length}
  */
  readonly readIopsSecMaxLength?: number;
  /**
  * Sets the minimum request size, in bytes, that counts as a single I/O when enforcing IOPS limits (smaller requests may be aggregated); value is a user-provided non‑negative integer (e.g. 4096 for 4 KiB).
  * 
  * See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#size_iops_sec Domain#size_iops_sec}
  */
  readonly sizeIopsSec?: number;
  /**
  * Sets the sustained combined limit, in bytes per second, for both read and write operations on this disk; value is a user-provided non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#total_bytes_sec Domain#total_bytes_sec}
  */
  readonly totalBytesSec?: number;
  /**
  * Sets the maximum burst combined bandwidth limit, in bytes per second, for both reads and writes when bursting above total_bytes_sec; value is a user-provided non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#total_bytes_sec_max Domain#total_bytes_sec_max}
  */
  readonly totalBytesSecMax?: number;
  /**
  * Sets the duration, in seconds, over which the total_bytes_sec_max burst combined bandwidth may be applied; value is a user-provided non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#total_bytes_sec_max_length Domain#total_bytes_sec_max_length}
  */
  readonly totalBytesSecMaxLength?: number;
  /**
  * Sets the sustained combined limit, in I/O operations per second, for both read and write operations on this disk; value is a user-provided non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#total_iops_sec Domain#total_iops_sec}
  */
  readonly totalIopsSec?: number;
  /**
  * Sets the maximum burst combined IOPS limit, in operations per second, for both reads and writes when bursting above total_iops_sec; value is a user-provided non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#total_iops_sec_max Domain#total_iops_sec_max}
  */
  readonly totalIopsSecMax?: number;
  /**
  * Sets the duration, in seconds, over which the total_iops_sec_max burst combined IOPS may be applied; value is a user-provided non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#total_iops_sec_max_length Domain#total_iops_sec_max_length}
  */
  readonly totalIopsSecMaxLength?: number;
  /**
  * Sets the sustained limit, in bytes per second, for write operations on this disk; value is a user-provided non‑negative integer (e.g. 5242880 for 5 MiB/s).
  * 
  * See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#write_bytes_sec Domain#write_bytes_sec}
  */
  readonly writeBytesSec?: number;
  /**
  * Sets the maximum burst write bandwidth limit, in bytes per second, that can be used when bursting above the sustained write_bytes_sec rate; value is a user-provided non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#write_bytes_sec_max Domain#write_bytes_sec_max}
  */
  readonly writeBytesSecMax?: number;
  /**
  * Sets the duration, in seconds, over which the write_bytes_sec_max burst bandwidth may be applied; value is a user-provided non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#write_bytes_sec_max_length Domain#write_bytes_sec_max_length}
  */
  readonly writeBytesSecMaxLength?: number;
  /**
  * Sets the sustained limit, in I/O operations per second, for write operations on this disk; value is a user-provided non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#write_iops_sec Domain#write_iops_sec}
  */
  readonly writeIopsSec?: number;
  /**
  * Sets the maximum burst write IOPS limit, in operations per second, that can be used when bursting above the sustained write_iops_sec rate; value is a user-provided non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#write_iops_sec_max Domain#write_iops_sec_max}
  */
  readonly writeIopsSecMax?: number;
  /**
  * Sets the maximum length of a temporary burst period for the write IOPS limit, in seconds, used together with write_iops_sec_max to control short-term spikes in disk write operations.
  * 
  * See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#write_iops_sec_max_length Domain#write_iops_sec_max_length}
  */
  readonly writeIopsSecMaxLength?: number;
}

export function domainDevicesDisksIoTuneToTerraform(struct?: DomainDevicesDisksIoTune | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    group_name: cdktf.stringToTerraform(struct!.groupName),
    read_bytes_sec: cdktf.numberToTerraform(struct!.readBytesSec),
    read_bytes_sec_max: cdktf.numberToTerraform(struct!.readBytesSecMax),
    read_bytes_sec_max_length: cdktf.numberToTerraform(struct!.readBytesSecMaxLength),
    read_iops_sec: cdktf.numberToTerraform(struct!.readIopsSec),
    read_iops_sec_max: cdktf.numberToTerraform(struct!.readIopsSecMax),
    read_iops_sec_max_length: cdktf.numberToTerraform(struct!.readIopsSecMaxLength),
    size_iops_sec: cdktf.numberToTerraform(struct!.sizeIopsSec),
    total_bytes_sec: cdktf.numberToTerraform(struct!.totalBytesSec),
    total_bytes_sec_max: cdktf.numberToTerraform(struct!.totalBytesSecMax),
    total_bytes_sec_max_length: cdktf.numberToTerraform(struct!.totalBytesSecMaxLength),
    total_iops_sec: cdktf.numberToTerraform(struct!.totalIopsSec),
    total_iops_sec_max: cdktf.numberToTerraform(struct!.totalIopsSecMax),
    total_iops_sec_max_length: cdktf.numberToTerraform(struct!.totalIopsSecMaxLength),
    write_bytes_sec: cdktf.numberToTerraform(struct!.writeBytesSec),
    write_bytes_sec_max: cdktf.numberToTerraform(struct!.writeBytesSecMax),
    write_bytes_sec_max_length: cdktf.numberToTerraform(struct!.writeBytesSecMaxLength),
    write_iops_sec: cdktf.numberToTerraform(struct!.writeIopsSec),
    write_iops_sec_max: cdktf.numberToTerraform(struct!.writeIopsSecMax),
    write_iops_sec_max_length: cdktf.numberToTerraform(struct!.writeIopsSecMaxLength),
  }
}


export function domainDevicesDisksIoTuneToHclTerraform(struct?: DomainDevicesDisksIoTune | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    group_name: {
      value: cdktf.stringToHclTerraform(struct!.groupName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    read_bytes_sec: {
      value: cdktf.numberToHclTerraform(struct!.readBytesSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    read_bytes_sec_max: {
      value: cdktf.numberToHclTerraform(struct!.readBytesSecMax),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    read_bytes_sec_max_length: {
      value: cdktf.numberToHclTerraform(struct!.readBytesSecMaxLength),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    read_iops_sec: {
      value: cdktf.numberToHclTerraform(struct!.readIopsSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    read_iops_sec_max: {
      value: cdktf.numberToHclTerraform(struct!.readIopsSecMax),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    read_iops_sec_max_length: {
      value: cdktf.numberToHclTerraform(struct!.readIopsSecMaxLength),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    size_iops_sec: {
      value: cdktf.numberToHclTerraform(struct!.sizeIopsSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    total_bytes_sec: {
      value: cdktf.numberToHclTerraform(struct!.totalBytesSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    total_bytes_sec_max: {
      value: cdktf.numberToHclTerraform(struct!.totalBytesSecMax),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    total_bytes_sec_max_length: {
      value: cdktf.numberToHclTerraform(struct!.totalBytesSecMaxLength),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    total_iops_sec: {
      value: cdktf.numberToHclTerraform(struct!.totalIopsSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    total_iops_sec_max: {
      value: cdktf.numberToHclTerraform(struct!.totalIopsSecMax),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    total_iops_sec_max_length: {
      value: cdktf.numberToHclTerraform(struct!.totalIopsSecMaxLength),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    write_bytes_sec: {
      value: cdktf.numberToHclTerraform(struct!.writeBytesSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    write_bytes_sec_max: {
      value: cdktf.numberToHclTerraform(struct!.writeBytesSecMax),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    write_bytes_sec_max_length: {
      value: cdktf.numberToHclTerraform(struct!.writeBytesSecMaxLength),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    write_iops_sec: {
      value: cdktf.numberToHclTerraform(struct!.writeIopsSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    write_iops_sec_max: {
      value: cdktf.numberToHclTerraform(struct!.writeIopsSecMax),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    write_iops_sec_max_length: {
      value: cdktf.numberToHclTerraform(struct!.writeIopsSecMaxLength),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksIoTuneOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksIoTune | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._groupName !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupName = this._groupName;
    }
    if (this._readBytesSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.readBytesSec = this._readBytesSec;
    }
    if (this._readBytesSecMax !== undefined) {
      hasAnyValues = true;
      internalValueResult.readBytesSecMax = this._readBytesSecMax;
    }
    if (this._readBytesSecMaxLength !== undefined) {
      hasAnyValues = true;
      internalValueResult.readBytesSecMaxLength = this._readBytesSecMaxLength;
    }
    if (this._readIopsSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.readIopsSec = this._readIopsSec;
    }
    if (this._readIopsSecMax !== undefined) {
      hasAnyValues = true;
      internalValueResult.readIopsSecMax = this._readIopsSecMax;
    }
    if (this._readIopsSecMaxLength !== undefined) {
      hasAnyValues = true;
      internalValueResult.readIopsSecMaxLength = this._readIopsSecMaxLength;
    }
    if (this._sizeIopsSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.sizeIopsSec = this._sizeIopsSec;
    }
    if (this._totalBytesSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.totalBytesSec = this._totalBytesSec;
    }
    if (this._totalBytesSecMax !== undefined) {
      hasAnyValues = true;
      internalValueResult.totalBytesSecMax = this._totalBytesSecMax;
    }
    if (this._totalBytesSecMaxLength !== undefined) {
      hasAnyValues = true;
      internalValueResult.totalBytesSecMaxLength = this._totalBytesSecMaxLength;
    }
    if (this._totalIopsSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.totalIopsSec = this._totalIopsSec;
    }
    if (this._totalIopsSecMax !== undefined) {
      hasAnyValues = true;
      internalValueResult.totalIopsSecMax = this._totalIopsSecMax;
    }
    if (this._totalIopsSecMaxLength !== undefined) {
      hasAnyValues = true;
      internalValueResult.totalIopsSecMaxLength = this._totalIopsSecMaxLength;
    }
    if (this._writeBytesSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeBytesSec = this._writeBytesSec;
    }
    if (this._writeBytesSecMax !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeBytesSecMax = this._writeBytesSecMax;
    }
    if (this._writeBytesSecMaxLength !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeBytesSecMaxLength = this._writeBytesSecMaxLength;
    }
    if (this._writeIopsSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeIopsSec = this._writeIopsSec;
    }
    if (this._writeIopsSecMax !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeIopsSecMax = this._writeIopsSecMax;
    }
    if (this._writeIopsSecMaxLength !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeIopsSecMaxLength = this._writeIopsSecMaxLength;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksIoTune | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._groupName = undefined;
      this._readBytesSec = undefined;
      this._readBytesSecMax = undefined;
      this._readBytesSecMaxLength = undefined;
      this._readIopsSec = undefined;
      this._readIopsSecMax = undefined;
      this._readIopsSecMaxLength = undefined;
      this._sizeIopsSec = undefined;
      this._totalBytesSec = undefined;
      this._totalBytesSecMax = undefined;
      this._totalBytesSecMaxLength = undefined;
      this._totalIopsSec = undefined;
      this._totalIopsSecMax = undefined;
      this._totalIopsSecMaxLength = undefined;
      this._writeBytesSec = undefined;
      this._writeBytesSecMax = undefined;
      this._writeBytesSecMaxLength = undefined;
      this._writeIopsSec = undefined;
      this._writeIopsSecMax = undefined;
      this._writeIopsSecMaxLength = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._groupName = value.groupName;
      this._readBytesSec = value.readBytesSec;
      this._readBytesSecMax = value.readBytesSecMax;
      this._readBytesSecMaxLength = value.readBytesSecMaxLength;
      this._readIopsSec = value.readIopsSec;
      this._readIopsSecMax = value.readIopsSecMax;
      this._readIopsSecMaxLength = value.readIopsSecMaxLength;
      this._sizeIopsSec = value.sizeIopsSec;
      this._totalBytesSec = value.totalBytesSec;
      this._totalBytesSecMax = value.totalBytesSecMax;
      this._totalBytesSecMaxLength = value.totalBytesSecMaxLength;
      this._totalIopsSec = value.totalIopsSec;
      this._totalIopsSecMax = value.totalIopsSecMax;
      this._totalIopsSecMaxLength = value.totalIopsSecMaxLength;
      this._writeBytesSec = value.writeBytesSec;
      this._writeBytesSecMax = value.writeBytesSecMax;
      this._writeBytesSecMaxLength = value.writeBytesSecMaxLength;
      this._writeIopsSec = value.writeIopsSec;
      this._writeIopsSecMax = value.writeIopsSecMax;
      this._writeIopsSecMaxLength = value.writeIopsSecMaxLength;
    }
  }

  // group_name - computed: false, optional: true, required: false
  private _groupName?: string; 
  public get groupName() {
    return this.getStringAttribute('group_name');
  }
  public set groupName(value: string) {
    this._groupName = value;
  }
  public resetGroupName() {
    this._groupName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupNameInput() {
    return this._groupName;
  }

  // read_bytes_sec - computed: false, optional: true, required: false
  private _readBytesSec?: number; 
  public get readBytesSec() {
    return this.getNumberAttribute('read_bytes_sec');
  }
  public set readBytesSec(value: number) {
    this._readBytesSec = value;
  }
  public resetReadBytesSec() {
    this._readBytesSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readBytesSecInput() {
    return this._readBytesSec;
  }

  // read_bytes_sec_max - computed: false, optional: true, required: false
  private _readBytesSecMax?: number; 
  public get readBytesSecMax() {
    return this.getNumberAttribute('read_bytes_sec_max');
  }
  public set readBytesSecMax(value: number) {
    this._readBytesSecMax = value;
  }
  public resetReadBytesSecMax() {
    this._readBytesSecMax = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readBytesSecMaxInput() {
    return this._readBytesSecMax;
  }

  // read_bytes_sec_max_length - computed: false, optional: true, required: false
  private _readBytesSecMaxLength?: number; 
  public get readBytesSecMaxLength() {
    return this.getNumberAttribute('read_bytes_sec_max_length');
  }
  public set readBytesSecMaxLength(value: number) {
    this._readBytesSecMaxLength = value;
  }
  public resetReadBytesSecMaxLength() {
    this._readBytesSecMaxLength = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readBytesSecMaxLengthInput() {
    return this._readBytesSecMaxLength;
  }

  // read_iops_sec - computed: false, optional: true, required: false
  private _readIopsSec?: number; 
  public get readIopsSec() {
    return this.getNumberAttribute('read_iops_sec');
  }
  public set readIopsSec(value: number) {
    this._readIopsSec = value;
  }
  public resetReadIopsSec() {
    this._readIopsSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readIopsSecInput() {
    return this._readIopsSec;
  }

  // read_iops_sec_max - computed: false, optional: true, required: false
  private _readIopsSecMax?: number; 
  public get readIopsSecMax() {
    return this.getNumberAttribute('read_iops_sec_max');
  }
  public set readIopsSecMax(value: number) {
    this._readIopsSecMax = value;
  }
  public resetReadIopsSecMax() {
    this._readIopsSecMax = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readIopsSecMaxInput() {
    return this._readIopsSecMax;
  }

  // read_iops_sec_max_length - computed: false, optional: true, required: false
  private _readIopsSecMaxLength?: number; 
  public get readIopsSecMaxLength() {
    return this.getNumberAttribute('read_iops_sec_max_length');
  }
  public set readIopsSecMaxLength(value: number) {
    this._readIopsSecMaxLength = value;
  }
  public resetReadIopsSecMaxLength() {
    this._readIopsSecMaxLength = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readIopsSecMaxLengthInput() {
    return this._readIopsSecMaxLength;
  }

  // size_iops_sec - computed: false, optional: true, required: false
  private _sizeIopsSec?: number; 
  public get sizeIopsSec() {
    return this.getNumberAttribute('size_iops_sec');
  }
  public set sizeIopsSec(value: number) {
    this._sizeIopsSec = value;
  }
  public resetSizeIopsSec() {
    this._sizeIopsSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sizeIopsSecInput() {
    return this._sizeIopsSec;
  }

  // total_bytes_sec - computed: false, optional: true, required: false
  private _totalBytesSec?: number; 
  public get totalBytesSec() {
    return this.getNumberAttribute('total_bytes_sec');
  }
  public set totalBytesSec(value: number) {
    this._totalBytesSec = value;
  }
  public resetTotalBytesSec() {
    this._totalBytesSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get totalBytesSecInput() {
    return this._totalBytesSec;
  }

  // total_bytes_sec_max - computed: false, optional: true, required: false
  private _totalBytesSecMax?: number; 
  public get totalBytesSecMax() {
    return this.getNumberAttribute('total_bytes_sec_max');
  }
  public set totalBytesSecMax(value: number) {
    this._totalBytesSecMax = value;
  }
  public resetTotalBytesSecMax() {
    this._totalBytesSecMax = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get totalBytesSecMaxInput() {
    return this._totalBytesSecMax;
  }

  // total_bytes_sec_max_length - computed: false, optional: true, required: false
  private _totalBytesSecMaxLength?: number; 
  public get totalBytesSecMaxLength() {
    return this.getNumberAttribute('total_bytes_sec_max_length');
  }
  public set totalBytesSecMaxLength(value: number) {
    this._totalBytesSecMaxLength = value;
  }
  public resetTotalBytesSecMaxLength() {
    this._totalBytesSecMaxLength = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get totalBytesSecMaxLengthInput() {
    return this._totalBytesSecMaxLength;
  }

  // total_iops_sec - computed: false, optional: true, required: false
  private _totalIopsSec?: number; 
  public get totalIopsSec() {
    return this.getNumberAttribute('total_iops_sec');
  }
  public set totalIopsSec(value: number) {
    this._totalIopsSec = value;
  }
  public resetTotalIopsSec() {
    this._totalIopsSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get totalIopsSecInput() {
    return this._totalIopsSec;
  }

  // total_iops_sec_max - computed: false, optional: true, required: false
  private _totalIopsSecMax?: number; 
  public get totalIopsSecMax() {
    return this.getNumberAttribute('total_iops_sec_max');
  }
  public set totalIopsSecMax(value: number) {
    this._totalIopsSecMax = value;
  }
  public resetTotalIopsSecMax() {
    this._totalIopsSecMax = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get totalIopsSecMaxInput() {
    return this._totalIopsSecMax;
  }

  // total_iops_sec_max_length - computed: false, optional: true, required: false
  private _totalIopsSecMaxLength?: number; 
  public get totalIopsSecMaxLength() {
    return this.getNumberAttribute('total_iops_sec_max_length');
  }
  public set totalIopsSecMaxLength(value: number) {
    this._totalIopsSecMaxLength = value;
  }
  public resetTotalIopsSecMaxLength() {
    this._totalIopsSecMaxLength = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get totalIopsSecMaxLengthInput() {
    return this._totalIopsSecMaxLength;
  }

  // write_bytes_sec - computed: false, optional: true, required: false
  private _writeBytesSec?: number; 
  public get writeBytesSec() {
    return this.getNumberAttribute('write_bytes_sec');
  }
  public set writeBytesSec(value: number) {
    this._writeBytesSec = value;
  }
  public resetWriteBytesSec() {
    this._writeBytesSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeBytesSecInput() {
    return this._writeBytesSec;
  }

  // write_bytes_sec_max - computed: false, optional: true, required: false
  private _writeBytesSecMax?: number; 
  public get writeBytesSecMax() {
    return this.getNumberAttribute('write_bytes_sec_max');
  }
  public set writeBytesSecMax(value: number) {
    this._writeBytesSecMax = value;
  }
  public resetWriteBytesSecMax() {
    this._writeBytesSecMax = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeBytesSecMaxInput() {
    return this._writeBytesSecMax;
  }

  // write_bytes_sec_max_length - computed: false, optional: true, required: false
  private _writeBytesSecMaxLength?: number; 
  public get writeBytesSecMaxLength() {
    return this.getNumberAttribute('write_bytes_sec_max_length');
  }
  public set writeBytesSecMaxLength(value: number) {
    this._writeBytesSecMaxLength = value;
  }
  public resetWriteBytesSecMaxLength() {
    this._writeBytesSecMaxLength = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeBytesSecMaxLengthInput() {
    return this._writeBytesSecMaxLength;
  }

  // write_iops_sec - computed: false, optional: true, required: false
  private _writeIopsSec?: number; 
  public get writeIopsSec() {
    return this.getNumberAttribute('write_iops_sec');
  }
  public set writeIopsSec(value: number) {
    this._writeIopsSec = value;
  }
  public resetWriteIopsSec() {
    this._writeIopsSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeIopsSecInput() {
    return this._writeIopsSec;
  }

  // write_iops_sec_max - computed: false, optional: true, required: false
  private _writeIopsSecMax?: number; 
  public get writeIopsSecMax() {
    return this.getNumberAttribute('write_iops_sec_max');
  }
  public set writeIopsSecMax(value: number) {
    this._writeIopsSecMax = value;
  }
  public resetWriteIopsSecMax() {
    this._writeIopsSecMax = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeIopsSecMaxInput() {
    return this._writeIopsSecMax;
  }

  // write_iops_sec_max_length - computed: false, optional: true, required: false
  private _writeIopsSecMaxLength?: number; 
  public get writeIopsSecMaxLength() {
    return this.getNumberAttribute('write_iops_sec_max_length');
  }
  public set writeIopsSecMaxLength(value: number) {
    this._writeIopsSecMaxLength = value;
  }
  public resetWriteIopsSecMaxLength() {
    this._writeIopsSecMaxLength = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeIopsSecMaxLengthInput() {
    return this._writeIopsSecMaxLength;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreFormatMetadataCacheMaxSize {
  /**
  * Sets the unit used for the metadata cache maximum size; valid units follow libvirt size units such as "B", "KiB", "MiB", "GiB" and are user-chosen.
  * 
  * See: <https://libvirt.org/formatdomain.html#memory-allocation>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#unit Domain#unit}
  */
  readonly unit?: string;
  /**
  * Sets the numeric value for the metadata cache maximum size in the specified unit; this must be a positive integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#value Domain#value}
  */
  readonly value: number;
}

export function domainDevicesDisksMirrorBackingStoreFormatMetadataCacheMaxSizeToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreFormatMetadataCacheMaxSize | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    unit: cdktf.stringToTerraform(struct!.unit),
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function domainDevicesDisksMirrorBackingStoreFormatMetadataCacheMaxSizeToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreFormatMetadataCacheMaxSize | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    unit: {
      value: cdktf.stringToHclTerraform(struct!.unit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreFormatMetadataCacheMaxSizeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreFormatMetadataCacheMaxSize | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._unit !== undefined) {
      hasAnyValues = true;
      internalValueResult.unit = this._unit;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreFormatMetadataCacheMaxSize | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._unit = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._unit = value.unit;
      this._value = value.value;
    }
  }

  // unit - computed: false, optional: true, required: false
  private _unit?: string; 
  public get unit() {
    return this.getStringAttribute('unit');
  }
  public set unit(value: string) {
    this._unit = value;
  }
  public resetUnit() {
    this._unit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unitInput() {
    return this._unit;
  }

  // value - computed: false, optional: false, required: true
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreFormatMetadataCache {
  /**
  * Sets the maximum size of the metadata cache used by the data store format; value and unit together define the limit (for example, 64 MiB).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#max_size Domain#max_size}
  */
  readonly maxSize?: DomainDevicesDisksMirrorBackingStoreFormatMetadataCacheMaxSize;
}

export function domainDevicesDisksMirrorBackingStoreFormatMetadataCacheToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreFormatMetadataCache | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_size: domainDevicesDisksMirrorBackingStoreFormatMetadataCacheMaxSizeToTerraform(struct!.maxSize),
  }
}


export function domainDevicesDisksMirrorBackingStoreFormatMetadataCacheToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreFormatMetadataCache | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_size: {
      value: domainDevicesDisksMirrorBackingStoreFormatMetadataCacheMaxSizeToHclTerraform(struct!.maxSize),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreFormatMetadataCacheMaxSize",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreFormatMetadataCacheOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreFormatMetadataCache | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxSize?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreFormatMetadataCache | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxSize.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxSize.internalValue = value.maxSize;
    }
  }

  // max_size - computed: false, optional: true, required: false
  private _maxSize = new DomainDevicesDisksMirrorBackingStoreFormatMetadataCacheMaxSizeOutputReference(this, "max_size");
  public get maxSize() {
    return this._maxSize;
  }
  public putMaxSize(value: DomainDevicesDisksMirrorBackingStoreFormatMetadataCacheMaxSize) {
    this._maxSize.internalValue = value;
  }
  public resetMaxSize() {
    this._maxSize.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize.internalValue;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreFormat {
  /**
  * Configures metadata cache behavior for the mirrored backing store’s data store format (for example, limiting the size of cached metadata).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#metadata_cache Domain#metadata_cache}
  */
  readonly metadataCache?: DomainDevicesDisksMirrorBackingStoreFormatMetadataCache;
  /**
  * Sets the data store format type for the mirrored backing store (for example, "qcow2" or "raw"); the value is user-provided and must be a valid libvirt disk format name.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type: string;
}

export function domainDevicesDisksMirrorBackingStoreFormatToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreFormat | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metadata_cache: domainDevicesDisksMirrorBackingStoreFormatMetadataCacheToTerraform(struct!.metadataCache),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function domainDevicesDisksMirrorBackingStoreFormatToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreFormat | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metadata_cache: {
      value: domainDevicesDisksMirrorBackingStoreFormatMetadataCacheToHclTerraform(struct!.metadataCache),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreFormatMetadataCache",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreFormatOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreFormat | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metadataCache?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadataCache = this._metadataCache?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreFormat | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metadataCache.internalValue = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metadataCache.internalValue = value.metadataCache;
      this._type = value.type;
    }
  }

  // metadata_cache - computed: false, optional: true, required: false
  private _metadataCache = new DomainDevicesDisksMirrorBackingStoreFormatMetadataCacheOutputReference(this, "metadata_cache");
  public get metadataCache() {
    return this._metadataCache;
  }
  public putMetadataCache(value: DomainDevicesDisksMirrorBackingStoreFormatMetadataCache) {
    this._metadataCache.internalValue = value;
  }
  public resetMetadataCache() {
    this._metadataCache.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataCacheInput() {
    return this._metadataCache.internalValue;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceBlockSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceBlockSecLabelToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceBlockSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceBlockSecLabelToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceBlockSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceBlockSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceBlockSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceBlockSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksMirrorBackingStoreSourceBlockSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksMirrorBackingStoreSourceBlockSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksMirrorBackingStoreSourceBlockSecLabelOutputReference {
    return new DomainDevicesDisksMirrorBackingStoreSourceBlockSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceBlock {
  /**
  * Sets the host block device path used as the mirror backing store source (for example "/dev/sdb1"); the value is user-provided and must reference an existing block device.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dev Domain#dev}
  */
  readonly dev?: string;
  /**
  * Configures an optional security label for the block-device backing store of the mirror, controlling how security drivers label this source.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksMirrorBackingStoreSourceBlockSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksMirrorBackingStoreSourceBlockToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceBlock | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dev: cdktf.stringToTerraform(struct!.dev),
    sec_label: cdktf.listMapper(domainDevicesDisksMirrorBackingStoreSourceBlockSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceBlockToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceBlock | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dev: {
      value: cdktf.stringToHclTerraform(struct!.dev),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksMirrorBackingStoreSourceBlockSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceBlockSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceBlockOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceBlock | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dev !== undefined) {
      hasAnyValues = true;
      internalValueResult.dev = this._dev;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceBlock | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dev = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dev = value.dev;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // dev - computed: false, optional: true, required: false
  private _dev?: string; 
  public get dev() {
    return this.getStringAttribute('dev');
  }
  public set dev(value: string) {
    this._dev = value;
  }
  public resetDev() {
    this._dev = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devInput() {
    return this._dev;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksMirrorBackingStoreSourceBlockSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksMirrorBackingStoreSourceBlockSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceCookiesCookies {
  /**
  * Sets the cookie name for this backing store HTTP cookie; the value is user-provided and must be non-empty (for example, "sessionid").
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
  /**
  * Sets the cookie value for this backing store HTTP cookie; the value is user-provided and must be non-empty (for example, "abc123").
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#value Domain#value}
  */
  readonly value: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceCookiesCookiesToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceCookiesCookies | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceCookiesCookiesToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceCookiesCookies | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceCookiesCookiesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceCookiesCookies | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceCookiesCookies | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DomainDevicesDisksMirrorBackingStoreSourceCookiesCookiesList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksMirrorBackingStoreSourceCookiesCookies[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksMirrorBackingStoreSourceCookiesCookiesOutputReference {
    return new DomainDevicesDisksMirrorBackingStoreSourceCookiesCookiesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceCookies {
  /**
  * Configures one or more HTTP cookies to be sent when accessing the mirrored backing store over a network protocol that supports cookies (for example, HTTPS or HTTP-based storage).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#cookies Domain#cookies}
  */
  readonly cookies?: DomainDevicesDisksMirrorBackingStoreSourceCookiesCookies[] | cdktf.IResolvable;
}

export function domainDevicesDisksMirrorBackingStoreSourceCookiesToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceCookies | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cookies: cdktf.listMapper(domainDevicesDisksMirrorBackingStoreSourceCookiesCookiesToTerraform, false)(struct!.cookies),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceCookiesToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceCookies | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cookies: {
      value: cdktf.listMapperHcl(domainDevicesDisksMirrorBackingStoreSourceCookiesCookiesToHclTerraform, false)(struct!.cookies),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceCookiesCookiesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceCookiesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceCookies | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cookies?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cookies = this._cookies?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceCookies | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cookies.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cookies.internalValue = value.cookies;
    }
  }

  // cookies - computed: false, optional: true, required: false
  private _cookies = new DomainDevicesDisksMirrorBackingStoreSourceCookiesCookiesList(this, "cookies", false);
  public get cookies() {
    return this._cookies;
  }
  public putCookies(value: DomainDevicesDisksMirrorBackingStoreSourceCookiesCookies[] | cdktf.IResolvable) {
    this._cookies.internalValue = value;
  }
  public resetCookies() {
    this._cookies.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cookiesInput() {
    return this._cookies.internalValue;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceDataStoreFormatMetadataCacheMaxSize {
  /**
  * Sets the unit used for the metadata cache maximum size; valid units follow libvirt size units such as "B", "KiB", "MiB", "GiB" and are user-chosen.
  * 
  * See: <https://libvirt.org/formatdomain.html#memory-allocation>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#unit Domain#unit}
  */
  readonly unit?: string;
  /**
  * Sets the numeric value for the metadata cache maximum size in the specified unit; this must be a positive integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#value Domain#value}
  */
  readonly value: number;
}

export function domainDevicesDisksMirrorBackingStoreSourceDataStoreFormatMetadataCacheMaxSizeToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceDataStoreFormatMetadataCacheMaxSize | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    unit: cdktf.stringToTerraform(struct!.unit),
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceDataStoreFormatMetadataCacheMaxSizeToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceDataStoreFormatMetadataCacheMaxSize | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    unit: {
      value: cdktf.stringToHclTerraform(struct!.unit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceDataStoreFormatMetadataCacheMaxSizeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceDataStoreFormatMetadataCacheMaxSize | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._unit !== undefined) {
      hasAnyValues = true;
      internalValueResult.unit = this._unit;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceDataStoreFormatMetadataCacheMaxSize | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._unit = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._unit = value.unit;
      this._value = value.value;
    }
  }

  // unit - computed: false, optional: true, required: false
  private _unit?: string; 
  public get unit() {
    return this.getStringAttribute('unit');
  }
  public set unit(value: string) {
    this._unit = value;
  }
  public resetUnit() {
    this._unit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unitInput() {
    return this._unit;
  }

  // value - computed: false, optional: false, required: true
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceDataStoreFormatMetadataCache {
  /**
  * Sets the maximum size of the metadata cache used by the data store format; value and unit together define the limit (for example, 64 MiB).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#max_size Domain#max_size}
  */
  readonly maxSize?: DomainDevicesDisksMirrorBackingStoreSourceDataStoreFormatMetadataCacheMaxSize;
}

export function domainDevicesDisksMirrorBackingStoreSourceDataStoreFormatMetadataCacheToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceDataStoreFormatMetadataCache | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_size: domainDevicesDisksMirrorBackingStoreSourceDataStoreFormatMetadataCacheMaxSizeToTerraform(struct!.maxSize),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceDataStoreFormatMetadataCacheToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceDataStoreFormatMetadataCache | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_size: {
      value: domainDevicesDisksMirrorBackingStoreSourceDataStoreFormatMetadataCacheMaxSizeToHclTerraform(struct!.maxSize),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceDataStoreFormatMetadataCacheMaxSize",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceDataStoreFormatMetadataCacheOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceDataStoreFormatMetadataCache | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxSize?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceDataStoreFormatMetadataCache | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxSize.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxSize.internalValue = value.maxSize;
    }
  }

  // max_size - computed: false, optional: true, required: false
  private _maxSize = new DomainDevicesDisksMirrorBackingStoreSourceDataStoreFormatMetadataCacheMaxSizeOutputReference(this, "max_size");
  public get maxSize() {
    return this._maxSize;
  }
  public putMaxSize(value: DomainDevicesDisksMirrorBackingStoreSourceDataStoreFormatMetadataCacheMaxSize) {
    this._maxSize.internalValue = value;
  }
  public resetMaxSize() {
    this._maxSize.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize.internalValue;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceDataStoreFormat {
  /**
  * Configures metadata cache behavior for the mirrored backing store’s data store format (for example, limiting the size of cached metadata).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#metadata_cache Domain#metadata_cache}
  */
  readonly metadataCache?: DomainDevicesDisksMirrorBackingStoreSourceDataStoreFormatMetadataCache;
  /**
  * Sets the data store format type for the mirrored backing store (for example, "qcow2" or "raw"); the value is user-provided and must be a valid libvirt disk format name.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceDataStoreFormatToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceDataStoreFormat | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metadata_cache: domainDevicesDisksMirrorBackingStoreSourceDataStoreFormatMetadataCacheToTerraform(struct!.metadataCache),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceDataStoreFormatToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceDataStoreFormat | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metadata_cache: {
      value: domainDevicesDisksMirrorBackingStoreSourceDataStoreFormatMetadataCacheToHclTerraform(struct!.metadataCache),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceDataStoreFormatMetadataCache",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceDataStoreFormatOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceDataStoreFormat | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metadataCache?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadataCache = this._metadataCache?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceDataStoreFormat | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metadataCache.internalValue = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metadataCache.internalValue = value.metadataCache;
      this._type = value.type;
    }
  }

  // metadata_cache - computed: false, optional: true, required: false
  private _metadataCache = new DomainDevicesDisksMirrorBackingStoreSourceDataStoreFormatMetadataCacheOutputReference(this, "metadata_cache");
  public get metadataCache() {
    return this._metadataCache;
  }
  public putMetadataCache(value: DomainDevicesDisksMirrorBackingStoreSourceDataStoreFormatMetadataCache) {
    this._metadataCache.internalValue = value;
  }
  public resetMetadataCache() {
    this._metadataCache.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataCacheInput() {
    return this._metadataCache.internalValue;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceDataStore {
  /**
  * Configures the on-disk format settings for the mirrored backing store’s data store, including format type and optional metadata cache tuning.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#format Domain#format}
  */
  readonly format?: DomainDevicesDisksMirrorBackingStoreSourceDataStoreFormat;
}

export function domainDevicesDisksMirrorBackingStoreSourceDataStoreToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceDataStore | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    format: domainDevicesDisksMirrorBackingStoreSourceDataStoreFormatToTerraform(struct!.format),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceDataStoreToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceDataStore | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    format: {
      value: domainDevicesDisksMirrorBackingStoreSourceDataStoreFormatToHclTerraform(struct!.format),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceDataStoreFormat",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceDataStoreOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceDataStore | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._format?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceDataStore | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._format.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._format.internalValue = value.format;
    }
  }

  // format - computed: false, optional: true, required: false
  private _format = new DomainDevicesDisksMirrorBackingStoreSourceDataStoreFormatOutputReference(this, "format");
  public get format() {
    return this._format;
  }
  public putFormat(value: DomainDevicesDisksMirrorBackingStoreSourceDataStoreFormat) {
    this._format.internalValue = value;
  }
  public resetFormat() {
    this._format.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format.internalValue;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceDir {
  /**
  * Sets the host directory path used as the mirrored backing store source; this must be an absolute path on the host (for example, "/var/lib/libvirt/images").
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dir Domain#dir}
  */
  readonly dir?: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceDirToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceDir | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dir: cdktf.stringToTerraform(struct!.dir),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceDirToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceDir | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dir: {
      value: cdktf.stringToHclTerraform(struct!.dir),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceDirOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceDir | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dir !== undefined) {
      hasAnyValues = true;
      internalValueResult.dir = this._dir;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceDir | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dir = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dir = value.dir;
    }
  }

  // dir - computed: false, optional: true, required: false
  private _dir?: string; 
  public get dir() {
    return this.getStringAttribute('dir');
  }
  public set dir(value: string) {
    this._dir = value;
  }
  public resetDir() {
    this._dir = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dirInput() {
    return this._dir;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceEncryptionSecrets {
  /**
  * Sets how the referenced secret is identified; typical values are user-provided strings such as "uuid" or "usage" depending on how the secret is looked up.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type?: string;
  /**
  * Sets the libvirt secret usage name when referencing the iSCSI auth secret by usage; the value is a user-provided identifier such as an iSCSI target name.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#usage Domain#usage}
  */
  readonly usage?: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceEncryptionSecretsToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceEncryptionSecrets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    type: cdktf.stringToTerraform(struct!.type),
    usage: cdktf.stringToTerraform(struct!.usage),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceEncryptionSecretsToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceEncryptionSecrets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    usage: {
      value: cdktf.stringToHclTerraform(struct!.usage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceEncryptionSecretsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceEncryptionSecrets | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._usage !== undefined) {
      hasAnyValues = true;
      internalValueResult.usage = this._usage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceEncryptionSecrets | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._type = undefined;
      this._usage = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._type = value.type;
      this._usage = value.usage;
    }
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // usage - computed: false, optional: true, required: false
  private _usage?: string; 
  public get usage() {
    return this.getStringAttribute('usage');
  }
  public set usage(value: string) {
    this._usage = value;
  }
  public resetUsage() {
    this._usage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usageInput() {
    return this._usage;
  }

  // uuid - computed: true, optional: false, required: false
  public get uuid() {
    return this.getStringAttribute('uuid');
  }
}

export class DomainDevicesDisksMirrorBackingStoreSourceEncryptionSecretsList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksMirrorBackingStoreSourceEncryptionSecrets[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksMirrorBackingStoreSourceEncryptionSecretsOutputReference {
    return new DomainDevicesDisksMirrorBackingStoreSourceEncryptionSecretsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceEncryption {
  /**
  * Sets the encryption engine/provider to use for the disk (user-provided string, e.g. implementation-specific engine name).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#engine Domain#engine}
  */
  readonly engine?: string;
  /**
  * Sets the disk encryption format, such as "luks" or another user-provided scheme supported by libvirt/qemu.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#format Domain#format}
  */
  readonly format?: string;
  /**
  * Defines one or more secret references used to access the encrypted disk, each describing how libvirt locates the secret material.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#secrets Domain#secrets}
  */
  readonly secrets?: DomainDevicesDisksMirrorBackingStoreSourceEncryptionSecrets[] | cdktf.IResolvable;
}

export function domainDevicesDisksMirrorBackingStoreSourceEncryptionToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceEncryption | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    engine: cdktf.stringToTerraform(struct!.engine),
    format: cdktf.stringToTerraform(struct!.format),
    secrets: cdktf.listMapper(domainDevicesDisksMirrorBackingStoreSourceEncryptionSecretsToTerraform, false)(struct!.secrets),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceEncryptionToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceEncryption | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    engine: {
      value: cdktf.stringToHclTerraform(struct!.engine),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secrets: {
      value: cdktf.listMapperHcl(domainDevicesDisksMirrorBackingStoreSourceEncryptionSecretsToHclTerraform, false)(struct!.secrets),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceEncryptionSecretsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceEncryptionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceEncryption | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._engine !== undefined) {
      hasAnyValues = true;
      internalValueResult.engine = this._engine;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._secrets?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secrets = this._secrets?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceEncryption | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._engine = undefined;
      this._format = undefined;
      this._secrets.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._engine = value.engine;
      this._format = value.format;
      this._secrets.internalValue = value.secrets;
    }
  }

  // engine - computed: false, optional: true, required: false
  private _engine?: string; 
  public get engine() {
    return this.getStringAttribute('engine');
  }
  public set engine(value: string) {
    this._engine = value;
  }
  public resetEngine() {
    this._engine = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get engineInput() {
    return this._engine;
  }

  // format - computed: false, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // secrets - computed: false, optional: true, required: false
  private _secrets = new DomainDevicesDisksMirrorBackingStoreSourceEncryptionSecretsList(this, "secrets", false);
  public get secrets() {
    return this._secrets;
  }
  public putSecrets(value: DomainDevicesDisksMirrorBackingStoreSourceEncryptionSecrets[] | cdktf.IResolvable) {
    this._secrets.internalValue = value;
  }
  public resetSecrets() {
    this._secrets.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretsInput() {
    return this._secrets.internalValue;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceFileSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceFileSecLabelToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceFileSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceFileSecLabelToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceFileSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceFileSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceFileSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceFileSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksMirrorBackingStoreSourceFileSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksMirrorBackingStoreSourceFileSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksMirrorBackingStoreSourceFileSecLabelOutputReference {
    return new DomainDevicesDisksMirrorBackingStoreSourceFileSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceFile {
  /**
  * Sets the name of an fdgroup whose pre-opened file descriptor is used for this backing store instead of opening the file path directly; value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#fd_group Domain#fd_group}
  */
  readonly fdGroup?: string;
  /**
  * Sets the absolute path on the host to the backing file used as the source for this mirrored disk (for example, /var/lib/libvirt/images/base.qcow2).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file?: string;
  /**
  * Configures an explicit security label for the file backing store, overriding default security driver labeling for this file.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksMirrorBackingStoreSourceFileSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksMirrorBackingStoreSourceFileToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fd_group: cdktf.stringToTerraform(struct!.fdGroup),
    file: cdktf.stringToTerraform(struct!.file),
    sec_label: cdktf.listMapper(domainDevicesDisksMirrorBackingStoreSourceFileSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceFileToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fd_group: {
      value: cdktf.stringToHclTerraform(struct!.fdGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    file: {
      value: cdktf.stringToHclTerraform(struct!.file),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksMirrorBackingStoreSourceFileSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceFileSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceFileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceFile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fdGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.fdGroup = this._fdGroup;
    }
    if (this._file !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceFile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fdGroup = undefined;
      this._file = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fdGroup = value.fdGroup;
      this._file = value.file;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // fd_group - computed: false, optional: true, required: false
  private _fdGroup?: string; 
  public get fdGroup() {
    return this.getStringAttribute('fd_group');
  }
  public set fdGroup(value: string) {
    this._fdGroup = value;
  }
  public resetFdGroup() {
    this._fdGroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fdGroupInput() {
    return this._fdGroup;
  }

  // file - computed: false, optional: true, required: false
  private _file?: string; 
  public get file() {
    return this.getStringAttribute('file');
  }
  public set file(value: string) {
    this._file = value;
  }
  public resetFile() {
    this._file = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksMirrorBackingStoreSourceFileSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksMirrorBackingStoreSourceFileSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceNetworkAuthSecret {
  /**
  * Sets how the referenced secret is identified; typical values are user-provided strings such as "uuid" or "usage" depending on how the secret is looked up.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type?: string;
  /**
  * Sets the libvirt secret usage name when referencing the iSCSI auth secret by usage; the value is a user-provided identifier such as an iSCSI target name.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#usage Domain#usage}
  */
  readonly usage?: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceNetworkAuthSecretToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceNetworkAuthSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    type: cdktf.stringToTerraform(struct!.type),
    usage: cdktf.stringToTerraform(struct!.usage),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceNetworkAuthSecretToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceNetworkAuthSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    usage: {
      value: cdktf.stringToHclTerraform(struct!.usage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceNetworkAuthSecretOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceNetworkAuthSecret | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._usage !== undefined) {
      hasAnyValues = true;
      internalValueResult.usage = this._usage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceNetworkAuthSecret | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._type = undefined;
      this._usage = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._type = value.type;
      this._usage = value.usage;
    }
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // usage - computed: false, optional: true, required: false
  private _usage?: string; 
  public get usage() {
    return this.getStringAttribute('usage');
  }
  public set usage(value: string) {
    this._usage = value;
  }
  public resetUsage() {
    this._usage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usageInput() {
    return this._usage;
  }

  // uuid - computed: true, optional: false, required: false
  public get uuid() {
    return this.getStringAttribute('uuid');
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceNetworkAuth {
  /**
  * Configures the libvirt secret object used to hold the iSCSI authentication password for this hostdev; this references an existing libvirt secret, not the clear-text secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#secret Domain#secret}
  */
  readonly secret?: DomainDevicesDisksMirrorBackingStoreSourceNetworkAuthSecret;
  /**
  * Sets the CHAP username used when authenticating to the iSCSI target for this SCSI hostdev; the value is user-provided (for example, "chapuser1").
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#username Domain#username}
  */
  readonly username?: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceNetworkAuthToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceNetworkAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret: domainDevicesDisksMirrorBackingStoreSourceNetworkAuthSecretToTerraform(struct!.secret),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceNetworkAuthToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceNetworkAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret: {
      value: domainDevicesDisksMirrorBackingStoreSourceNetworkAuthSecretToHclTerraform(struct!.secret),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceNetworkAuthSecret",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceNetworkAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceNetworkAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secret?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret?.internalValue;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceNetworkAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secret.internalValue = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secret.internalValue = value.secret;
      this._username = value.username;
    }
  }

  // secret - computed: false, optional: true, required: false
  private _secret = new DomainDevicesDisksMirrorBackingStoreSourceNetworkAuthSecretOutputReference(this, "secret");
  public get secret() {
    return this._secret;
  }
  public putSecret(value: DomainDevicesDisksMirrorBackingStoreSourceNetworkAuthSecret) {
    this._secret.internalValue = value;
  }
  public resetSecret() {
    this._secret.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret.internalValue;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceNetworkConfig {
  /**
  * Sets the path to the configuration file used for the network backing store connection, such as a Ceph configuration file (/etc/ceph/ceph.conf).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceNetworkConfigToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceNetworkConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    file: cdktf.stringToTerraform(struct!.file),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceNetworkConfigToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceNetworkConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    file: {
      value: cdktf.stringToHclTerraform(struct!.file),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceNetworkConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceNetworkConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._file !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceNetworkConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._file = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._file = value.file;
    }
  }

  // file - computed: false, optional: false, required: true
  private _file?: string; 
  public get file() {
    return this.getStringAttribute('file');
  }
  public set file(value: string) {
    this._file = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceNetworkHosts {
  /**
  * Sets the hostname or IP address of the iSCSI target portal (for example, "10.0.0.10" or "iscsi.example.com").
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name?: string;
  /**
  * Sets the TCP port of the iSCSI target portal; if omitted, libvirt/driver defaults (commonly 3260) are used.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#port Domain#port}
  */
  readonly port?: string;
  /**
  * Sets a UNIX domain socket path to connect to an iSCSI target via a local socket instead of TCP; value is a user-provided filesystem path.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#socket Domain#socket}
  */
  readonly socket?: string;
  /**
  * Sets the transport type used to reach the iSCSI target portal; valid values are user-provided strings as supported by the environment (for example, "tcp" or "iser").
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#transport Domain#transport}
  */
  readonly transport?: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceNetworkHostsToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceNetworkHosts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    port: cdktf.stringToTerraform(struct!.port),
    socket: cdktf.stringToTerraform(struct!.socket),
    transport: cdktf.stringToTerraform(struct!.transport),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceNetworkHostsToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceNetworkHosts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.stringToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    socket: {
      value: cdktf.stringToHclTerraform(struct!.socket),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    transport: {
      value: cdktf.stringToHclTerraform(struct!.transport),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceNetworkHostsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceNetworkHosts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._socket !== undefined) {
      hasAnyValues = true;
      internalValueResult.socket = this._socket;
    }
    if (this._transport !== undefined) {
      hasAnyValues = true;
      internalValueResult.transport = this._transport;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceNetworkHosts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._port = undefined;
      this._socket = undefined;
      this._transport = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._port = value.port;
      this._socket = value.socket;
      this._transport = value.transport;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port - computed: false, optional: true, required: false
  private _port?: string; 
  public get port() {
    return this.getStringAttribute('port');
  }
  public set port(value: string) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // socket - computed: false, optional: true, required: false
  private _socket?: string; 
  public get socket() {
    return this.getStringAttribute('socket');
  }
  public set socket(value: string) {
    this._socket = value;
  }
  public resetSocket() {
    this._socket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketInput() {
    return this._socket;
  }

  // transport - computed: false, optional: true, required: false
  private _transport?: string; 
  public get transport() {
    return this.getStringAttribute('transport');
  }
  public set transport(value: string) {
    this._transport = value;
  }
  public resetTransport() {
    this._transport = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get transportInput() {
    return this._transport;
  }
}

export class DomainDevicesDisksMirrorBackingStoreSourceNetworkHostsList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksMirrorBackingStoreSourceNetworkHosts[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksMirrorBackingStoreSourceNetworkHostsOutputReference {
    return new DomainDevicesDisksMirrorBackingStoreSourceNetworkHostsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceNetworkIdentity {
  /**
  * Sets the path to a local agent socket used for external authentication (for example, SASL or SSH agent) when connecting to the network backing store; value is a user-provided Unix socket path.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#agent_sock Domain#agent_sock}
  */
  readonly agentSock?: string;
  /**
  * Sets the group name to use for authentication or access control when connecting to the network backing store; value is user-provided and protocol-specific.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#group Domain#group}
  */
  readonly group?: string;
  /**
  * Sets the path to a private key file used for authenticating to the network backing store (for example, an SSH or TLS key); value is a user-provided filesystem path.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#keyfile Domain#keyfile}
  */
  readonly keyfile?: string;
  /**
  * Sets the user identifier used for authentication to the network backing store; value is user-provided and typically matches a remote account name.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#user Domain#user}
  */
  readonly user?: string;
  /**
  * Sets an explicit username string used for authentication to the network backing store, separate from any other user identity settings; value is user-provided (for example, "backupuser").
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#user_name Domain#user_name}
  */
  readonly userName?: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceNetworkIdentityToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceNetworkIdentity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    agent_sock: cdktf.stringToTerraform(struct!.agentSock),
    group: cdktf.stringToTerraform(struct!.group),
    keyfile: cdktf.stringToTerraform(struct!.keyfile),
    user: cdktf.stringToTerraform(struct!.user),
    user_name: cdktf.stringToTerraform(struct!.userName),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceNetworkIdentityToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceNetworkIdentity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    agent_sock: {
      value: cdktf.stringToHclTerraform(struct!.agentSock),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    group: {
      value: cdktf.stringToHclTerraform(struct!.group),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keyfile: {
      value: cdktf.stringToHclTerraform(struct!.keyfile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user: {
      value: cdktf.stringToHclTerraform(struct!.user),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user_name: {
      value: cdktf.stringToHclTerraform(struct!.userName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceNetworkIdentityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceNetworkIdentity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._agentSock !== undefined) {
      hasAnyValues = true;
      internalValueResult.agentSock = this._agentSock;
    }
    if (this._group !== undefined) {
      hasAnyValues = true;
      internalValueResult.group = this._group;
    }
    if (this._keyfile !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyfile = this._keyfile;
    }
    if (this._user !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user;
    }
    if (this._userName !== undefined) {
      hasAnyValues = true;
      internalValueResult.userName = this._userName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceNetworkIdentity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._agentSock = undefined;
      this._group = undefined;
      this._keyfile = undefined;
      this._user = undefined;
      this._userName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._agentSock = value.agentSock;
      this._group = value.group;
      this._keyfile = value.keyfile;
      this._user = value.user;
      this._userName = value.userName;
    }
  }

  // agent_sock - computed: false, optional: true, required: false
  private _agentSock?: string; 
  public get agentSock() {
    return this.getStringAttribute('agent_sock');
  }
  public set agentSock(value: string) {
    this._agentSock = value;
  }
  public resetAgentSock() {
    this._agentSock = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get agentSockInput() {
    return this._agentSock;
  }

  // group - computed: false, optional: true, required: false
  private _group?: string; 
  public get group() {
    return this.getStringAttribute('group');
  }
  public set group(value: string) {
    this._group = value;
  }
  public resetGroup() {
    this._group = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupInput() {
    return this._group;
  }

  // keyfile - computed: false, optional: true, required: false
  private _keyfile?: string; 
  public get keyfile() {
    return this.getStringAttribute('keyfile');
  }
  public set keyfile(value: string) {
    this._keyfile = value;
  }
  public resetKeyfile() {
    this._keyfile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyfileInput() {
    return this._keyfile;
  }

  // user - computed: false, optional: true, required: false
  private _user?: string; 
  public get user() {
    return this.getStringAttribute('user');
  }
  public set user(value: string) {
    this._user = value;
  }
  public resetUser() {
    this._user = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user;
  }

  // user_name - computed: false, optional: true, required: false
  private _userName?: string; 
  public get userName() {
    return this.getStringAttribute('user_name');
  }
  public set userName(value: string) {
    this._userName = value;
  }
  public resetUserName() {
    this._userName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userNameInput() {
    return this._userName;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceNetworkInitiatorIqn {
  /**
  * Sets the initiator IQN string used when logging into an iSCSI target backing the mirrored disk; value must be a valid IQN (for example, iqn.2020-01.com.example:host1).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name?: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceNetworkInitiatorIqnToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceNetworkInitiatorIqn | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceNetworkInitiatorIqnToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceNetworkInitiatorIqn | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceNetworkInitiatorIqnOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceNetworkInitiatorIqn | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceNetworkInitiatorIqn | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceNetworkInitiator {
  /**
  * Configures the iSCSI initiator IQN block for the mirrored network backing store, defining the initiator name presented to the target.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#iqn Domain#iqn}
  */
  readonly iqn?: DomainDevicesDisksMirrorBackingStoreSourceNetworkInitiatorIqn;
}

export function domainDevicesDisksMirrorBackingStoreSourceNetworkInitiatorToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceNetworkInitiator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    iqn: domainDevicesDisksMirrorBackingStoreSourceNetworkInitiatorIqnToTerraform(struct!.iqn),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceNetworkInitiatorToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceNetworkInitiator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    iqn: {
      value: domainDevicesDisksMirrorBackingStoreSourceNetworkInitiatorIqnToHclTerraform(struct!.iqn),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceNetworkInitiatorIqn",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceNetworkInitiatorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceNetworkInitiator | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._iqn?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.iqn = this._iqn?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceNetworkInitiator | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._iqn.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._iqn.internalValue = value.iqn;
    }
  }

  // iqn - computed: false, optional: true, required: false
  private _iqn = new DomainDevicesDisksMirrorBackingStoreSourceNetworkInitiatorIqnOutputReference(this, "iqn");
  public get iqn() {
    return this._iqn;
  }
  public putIqn(value: DomainDevicesDisksMirrorBackingStoreSourceNetworkInitiatorIqn) {
    this._iqn.internalValue = value;
  }
  public resetIqn() {
    this._iqn.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get iqnInput() {
    return this._iqn.internalValue;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceNetworkKnownHosts {
  /**
  * Sets the path to the known-hosts file used to verify the identity of the remote storage host; value is a required user-provided filesystem path (for example, /etc/libvirt/known_hosts).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceNetworkKnownHostsToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceNetworkKnownHosts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceNetworkKnownHostsToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceNetworkKnownHosts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceNetworkKnownHostsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceNetworkKnownHosts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceNetworkKnownHosts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceNetworkReconnect {
  /**
  * Sets the reconnection delay (in seconds) before retrying a failed connection to the mirrored network backing store; value is a required user-provided non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#delay Domain#delay}
  */
  readonly delay: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceNetworkReconnectToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceNetworkReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    delay: cdktf.stringToTerraform(struct!.delay),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceNetworkReconnectToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceNetworkReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    delay: {
      value: cdktf.stringToHclTerraform(struct!.delay),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceNetworkReconnectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceNetworkReconnect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._delay !== undefined) {
      hasAnyValues = true;
      internalValueResult.delay = this._delay;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceNetworkReconnect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._delay = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._delay = value.delay;
    }
  }

  // delay - computed: false, optional: false, required: true
  private _delay?: string; 
  public get delay() {
    return this.getStringAttribute('delay');
  }
  public set delay(value: string) {
    this._delay = value;
  }
  // Temporarily expose input value. Use with caution.
  public get delayInput() {
    return this._delay;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceNetworkSnapshot {
  /**
  * Sets the name of the network snapshot to use as the backing store for the mirrored disk’s network source; value is user-provided and must match an existing snapshot identifier on the storage backend.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceNetworkSnapshotToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceNetworkSnapshot | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceNetworkSnapshotToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceNetworkSnapshot | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceNetworkSnapshotOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceNetworkSnapshot | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceNetworkSnapshot | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceNetwork {
  /**
  * Configures CHAP authentication parameters for the iSCSI source backing an assigned SCSI host device; include this block only when the target requires authentication.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#auth Domain#auth}
  */
  readonly auth?: DomainDevicesDisksMirrorBackingStoreSourceNetworkAuth;
  /**
  * Points to an external configuration source for the network backing store (for example, an RBD or Ceph config file) that libvirt passes to the backend.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#config Domain#config}
  */
  readonly config?: DomainDevicesDisksMirrorBackingStoreSourceNetworkConfig;
  /**
  * Declares one or more network endpoints (hosts) for the backing store server, each with its own name/address and possibly additional attributes.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#hosts Domain#hosts}
  */
  readonly hosts?: DomainDevicesDisksMirrorBackingStoreSourceNetworkHosts[] | cdktf.IResolvable;
  /**
  * Configures authentication/identity parameters used when accessing the mirrored backing store over a network, such as user, group, keyfile, or agent socket, depending on the protocol.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#identity Domain#identity}
  */
  readonly identity?: DomainDevicesDisksMirrorBackingStoreSourceNetworkIdentity;
  /**
  * Configures initiator identity information (typically for iSCSI-like protocols) used when accessing the mirrored network backing store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#initiator Domain#initiator}
  */
  readonly initiator?: DomainDevicesDisksMirrorBackingStoreSourceNetworkInitiator;
  /**
  * Enables use of a known-hosts file to validate the remote host’s identity when connecting to the mirrored network backing store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#known_hosts Domain#known_hosts}
  */
  readonly knownHosts?: DomainDevicesDisksMirrorBackingStoreSourceNetworkKnownHosts;
  /**
  * Sets a name for the network source of the mirrored backing store, typically used by certain protocols (such as RBD pool or NBD export names); value is user-provided and protocol-specific.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name?: string;
  /**
  * Sets the network storage protocol used for the mirrored backing store; value is user-provided but must be a protocol supported by libvirt for network disks (for example, rbd, sheepdog, gluster, nbd).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#protocol Domain#protocol}
  */
  readonly protocol?: string;
  /**
  * Sets an optional query string or subresource specifier for the network storage URL of the mirrored backing store; value is user-provided and protocol-specific.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#query Domain#query}
  */
  readonly query?: string;
  /**
  * Configures automatic reconnection behavior for the mirrored network backing store after a connection loss.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reconnect Domain#reconnect}
  */
  readonly reconnect?: DomainDevicesDisksMirrorBackingStoreSourceNetworkReconnect;
  /**
  * Configures snapshot-related behavior for the network-based mirrored backing store, with semantics depending on the underlying protocol and storage implementation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#snapshot Domain#snapshot}
  */
  readonly snapshot?: DomainDevicesDisksMirrorBackingStoreSourceNetworkSnapshot;
  /**
  * Controls whether TLS is used for the mirrored disk’s network backing-store connection; value is user-provided and typically enabled only when the chosen protocol and backend support TLS.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tls Domain#tls}
  */
  readonly tls?: string;
  /**
  * Sets the expected TLS hostname for the mirrored disk’s network backing-store connection, used for certificate verification; value is user-provided and should match the server certificate’s hostname (for example, "storage.example.com").
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tls_hostname Domain#tls_hostname}
  */
  readonly tlsHostname?: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceNetworkToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceNetwork | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: domainDevicesDisksMirrorBackingStoreSourceNetworkAuthToTerraform(struct!.auth),
    config: domainDevicesDisksMirrorBackingStoreSourceNetworkConfigToTerraform(struct!.config),
    hosts: cdktf.listMapper(domainDevicesDisksMirrorBackingStoreSourceNetworkHostsToTerraform, false)(struct!.hosts),
    identity: domainDevicesDisksMirrorBackingStoreSourceNetworkIdentityToTerraform(struct!.identity),
    initiator: domainDevicesDisksMirrorBackingStoreSourceNetworkInitiatorToTerraform(struct!.initiator),
    known_hosts: domainDevicesDisksMirrorBackingStoreSourceNetworkKnownHostsToTerraform(struct!.knownHosts),
    name: cdktf.stringToTerraform(struct!.name),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    query: cdktf.stringToTerraform(struct!.query),
    reconnect: domainDevicesDisksMirrorBackingStoreSourceNetworkReconnectToTerraform(struct!.reconnect),
    snapshot: domainDevicesDisksMirrorBackingStoreSourceNetworkSnapshotToTerraform(struct!.snapshot),
    tls: cdktf.stringToTerraform(struct!.tls),
    tls_hostname: cdktf.stringToTerraform(struct!.tlsHostname),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceNetworkToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceNetwork | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: domainDevicesDisksMirrorBackingStoreSourceNetworkAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceNetworkAuth",
    },
    config: {
      value: domainDevicesDisksMirrorBackingStoreSourceNetworkConfigToHclTerraform(struct!.config),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceNetworkConfig",
    },
    hosts: {
      value: cdktf.listMapperHcl(domainDevicesDisksMirrorBackingStoreSourceNetworkHostsToHclTerraform, false)(struct!.hosts),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceNetworkHostsList",
    },
    identity: {
      value: domainDevicesDisksMirrorBackingStoreSourceNetworkIdentityToHclTerraform(struct!.identity),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceNetworkIdentity",
    },
    initiator: {
      value: domainDevicesDisksMirrorBackingStoreSourceNetworkInitiatorToHclTerraform(struct!.initiator),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceNetworkInitiator",
    },
    known_hosts: {
      value: domainDevicesDisksMirrorBackingStoreSourceNetworkKnownHostsToHclTerraform(struct!.knownHosts),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceNetworkKnownHosts",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    query: {
      value: cdktf.stringToHclTerraform(struct!.query),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reconnect: {
      value: domainDevicesDisksMirrorBackingStoreSourceNetworkReconnectToHclTerraform(struct!.reconnect),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceNetworkReconnect",
    },
    snapshot: {
      value: domainDevicesDisksMirrorBackingStoreSourceNetworkSnapshotToHclTerraform(struct!.snapshot),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceNetworkSnapshot",
    },
    tls: {
      value: cdktf.stringToHclTerraform(struct!.tls),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_hostname: {
      value: cdktf.stringToHclTerraform(struct!.tlsHostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceNetworkOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceNetwork | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._config?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.config = this._config?.internalValue;
    }
    if (this._hosts?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hosts = this._hosts?.internalValue;
    }
    if (this._identity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.identity = this._identity?.internalValue;
    }
    if (this._initiator?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.initiator = this._initiator?.internalValue;
    }
    if (this._knownHosts?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.knownHosts = this._knownHosts?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._query !== undefined) {
      hasAnyValues = true;
      internalValueResult.query = this._query;
    }
    if (this._reconnect?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.reconnect = this._reconnect?.internalValue;
    }
    if (this._snapshot?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.snapshot = this._snapshot?.internalValue;
    }
    if (this._tls !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls;
    }
    if (this._tlsHostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsHostname = this._tlsHostname;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceNetwork | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._config.internalValue = undefined;
      this._hosts.internalValue = undefined;
      this._identity.internalValue = undefined;
      this._initiator.internalValue = undefined;
      this._knownHosts.internalValue = undefined;
      this._name = undefined;
      this._protocol = undefined;
      this._query = undefined;
      this._reconnect.internalValue = undefined;
      this._snapshot.internalValue = undefined;
      this._tls = undefined;
      this._tlsHostname = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._config.internalValue = value.config;
      this._hosts.internalValue = value.hosts;
      this._identity.internalValue = value.identity;
      this._initiator.internalValue = value.initiator;
      this._knownHosts.internalValue = value.knownHosts;
      this._name = value.name;
      this._protocol = value.protocol;
      this._query = value.query;
      this._reconnect.internalValue = value.reconnect;
      this._snapshot.internalValue = value.snapshot;
      this._tls = value.tls;
      this._tlsHostname = value.tlsHostname;
    }
  }

  // auth - computed: false, optional: true, required: false
  private _auth = new DomainDevicesDisksMirrorBackingStoreSourceNetworkAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DomainDevicesDisksMirrorBackingStoreSourceNetworkAuth) {
    this._auth.internalValue = value;
  }
  public resetAuth() {
    this._auth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // config - computed: false, optional: true, required: false
  private _config = new DomainDevicesDisksMirrorBackingStoreSourceNetworkConfigOutputReference(this, "config");
  public get config() {
    return this._config;
  }
  public putConfig(value: DomainDevicesDisksMirrorBackingStoreSourceNetworkConfig) {
    this._config.internalValue = value;
  }
  public resetConfig() {
    this._config.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configInput() {
    return this._config.internalValue;
  }

  // hosts - computed: false, optional: true, required: false
  private _hosts = new DomainDevicesDisksMirrorBackingStoreSourceNetworkHostsList(this, "hosts", false);
  public get hosts() {
    return this._hosts;
  }
  public putHosts(value: DomainDevicesDisksMirrorBackingStoreSourceNetworkHosts[] | cdktf.IResolvable) {
    this._hosts.internalValue = value;
  }
  public resetHosts() {
    this._hosts.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostsInput() {
    return this._hosts.internalValue;
  }

  // identity - computed: false, optional: true, required: false
  private _identity = new DomainDevicesDisksMirrorBackingStoreSourceNetworkIdentityOutputReference(this, "identity");
  public get identity() {
    return this._identity;
  }
  public putIdentity(value: DomainDevicesDisksMirrorBackingStoreSourceNetworkIdentity) {
    this._identity.internalValue = value;
  }
  public resetIdentity() {
    this._identity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identityInput() {
    return this._identity.internalValue;
  }

  // initiator - computed: false, optional: true, required: false
  private _initiator = new DomainDevicesDisksMirrorBackingStoreSourceNetworkInitiatorOutputReference(this, "initiator");
  public get initiator() {
    return this._initiator;
  }
  public putInitiator(value: DomainDevicesDisksMirrorBackingStoreSourceNetworkInitiator) {
    this._initiator.internalValue = value;
  }
  public resetInitiator() {
    this._initiator.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initiatorInput() {
    return this._initiator.internalValue;
  }

  // known_hosts - computed: false, optional: true, required: false
  private _knownHosts = new DomainDevicesDisksMirrorBackingStoreSourceNetworkKnownHostsOutputReference(this, "known_hosts");
  public get knownHosts() {
    return this._knownHosts;
  }
  public putKnownHosts(value: DomainDevicesDisksMirrorBackingStoreSourceNetworkKnownHosts) {
    this._knownHosts.internalValue = value;
  }
  public resetKnownHosts() {
    this._knownHosts.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get knownHostsInput() {
    return this._knownHosts.internalValue;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // protocol - computed: false, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // query - computed: false, optional: true, required: false
  private _query?: string; 
  public get query() {
    return this.getStringAttribute('query');
  }
  public set query(value: string) {
    this._query = value;
  }
  public resetQuery() {
    this._query = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queryInput() {
    return this._query;
  }

  // reconnect - computed: false, optional: true, required: false
  private _reconnect = new DomainDevicesDisksMirrorBackingStoreSourceNetworkReconnectOutputReference(this, "reconnect");
  public get reconnect() {
    return this._reconnect;
  }
  public putReconnect(value: DomainDevicesDisksMirrorBackingStoreSourceNetworkReconnect) {
    this._reconnect.internalValue = value;
  }
  public resetReconnect() {
    this._reconnect.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reconnectInput() {
    return this._reconnect.internalValue;
  }

  // snapshot - computed: false, optional: true, required: false
  private _snapshot = new DomainDevicesDisksMirrorBackingStoreSourceNetworkSnapshotOutputReference(this, "snapshot");
  public get snapshot() {
    return this._snapshot;
  }
  public putSnapshot(value: DomainDevicesDisksMirrorBackingStoreSourceNetworkSnapshot) {
    this._snapshot.internalValue = value;
  }
  public resetSnapshot() {
    this._snapshot.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get snapshotInput() {
    return this._snapshot.internalValue;
  }

  // tls - computed: false, optional: true, required: false
  private _tls?: string; 
  public get tls() {
    return this.getStringAttribute('tls');
  }
  public set tls(value: string) {
    this._tls = value;
  }
  public resetTls() {
    this._tls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls;
  }

  // tls_hostname - computed: false, optional: true, required: false
  private _tlsHostname?: string; 
  public get tlsHostname() {
    return this.getStringAttribute('tls_hostname');
  }
  public set tlsHostname(value: string) {
    this._tlsHostname = value;
  }
  public resetTlsHostname() {
    this._tlsHostname = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsHostnameInput() {
    return this._tlsHostname;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceNvme {
}

export function domainDevicesDisksMirrorBackingStoreSourceNvmeToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceNvme | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceNvmeToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceNvme | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DomainDevicesDisksMirrorBackingStoreSourceNvmeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceNvme | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceNvme | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceReadahead {
  /**
  * Sets the read-ahead size for the mirrored disk’s backing store; value is a user-provided positive integer in bytes (for example, 65536 for 64 KiB).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#size Domain#size}
  */
  readonly size: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceReadaheadToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReadahead | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    size: cdktf.stringToTerraform(struct!.size),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceReadaheadToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReadahead | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    size: {
      value: cdktf.stringToHclTerraform(struct!.size),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceReadaheadOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceReadahead | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._size !== undefined) {
      hasAnyValues = true;
      internalValueResult.size = this._size;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceReadahead | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._size = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._size = value.size;
    }
  }

  // size - computed: false, optional: false, required: true
  private _size?: string; 
  public get size() {
    return this.getStringAttribute('size');
  }
  public set size(value: string) {
    this._size = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sizeInput() {
    return this._size;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceDbus {
  /**
  * Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#channel Domain#channel}
  */
  readonly channel?: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceReservationsSourceDbusToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceDbus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    channel: cdktf.stringToTerraform(struct!.channel),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceReservationsSourceDbusToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceDbus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    channel: {
      value: cdktf.stringToHclTerraform(struct!.channel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceDbusOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceDbus | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._channel !== undefined) {
      hasAnyValues = true;
      internalValueResult.channel = this._channel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceDbus | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._channel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._channel = value.channel;
    }
  }

  // channel - computed: false, optional: true, required: false
  private _channel?: string; 
  public get channel() {
    return this.getStringAttribute('channel');
  }
  public set channel(value: string) {
    this._channel = value;
  }
  public resetChannel() {
    this._channel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get channelInput() {
    return this._channel;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceDevSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceReservationsSourceDevSecLabelToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceDevSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceReservationsSourceDevSecLabelToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceDevSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceDevSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceDevSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceDevSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceDevSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceDevSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceDevSecLabelOutputReference {
    return new DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceDevSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceDev {
  /**
  * Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceDevSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksMirrorBackingStoreSourceReservationsSourceDevToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceDev | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesDisksMirrorBackingStoreSourceReservationsSourceDevSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceReservationsSourceDevToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceDev | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksMirrorBackingStoreSourceReservationsSourceDevSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceDevSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceDevOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceDev | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceDev | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceDevSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceDevSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceFileSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceReservationsSourceFileSecLabelToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceFileSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceReservationsSourceFileSecLabelToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceFileSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceFileSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceFileSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceFileSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceFileSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceFileSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceFileSecLabelOutputReference {
    return new DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceFileSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceFile {
  /**
  * Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.
  * 
  * See: <https://libvirt.org/formatdomain.html#device-logfile>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#append Domain#append}
  */
  readonly append?: string;
  /**
  * Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceFileSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksMirrorBackingStoreSourceReservationsSourceFileToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.stringToTerraform(struct!.append),
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesDisksMirrorBackingStoreSourceReservationsSourceFileSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceReservationsSourceFileToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.stringToHclTerraform(struct!.append),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksMirrorBackingStoreSourceReservationsSourceFileSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceFileSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceFileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceFile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceFile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append = value.append;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append?: string; 
  public get append() {
    return this.getStringAttribute('append');
  }
  public set append(value: string) {
    this._append = value;
  }
  public resetAppend() {
    this._append = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append;
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceFileSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceFileSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceNmdm {
  /**
  * Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.
  * 
  * See: <https://libvirt.org/formatdomain.html#nmdm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#master Domain#master}
  */
  readonly master: string;
  /**
  * Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.
  * 
  * See: <https://libvirt.org/formatdomain.html#nmdm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#slave Domain#slave}
  */
  readonly slave: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceReservationsSourceNmdmToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceNmdm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    master: cdktf.stringToTerraform(struct!.master),
    slave: cdktf.stringToTerraform(struct!.slave),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceReservationsSourceNmdmToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceNmdm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    master: {
      value: cdktf.stringToHclTerraform(struct!.master),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    slave: {
      value: cdktf.stringToHclTerraform(struct!.slave),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceNmdmOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceNmdm | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._master !== undefined) {
      hasAnyValues = true;
      internalValueResult.master = this._master;
    }
    if (this._slave !== undefined) {
      hasAnyValues = true;
      internalValueResult.slave = this._slave;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceNmdm | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._master = undefined;
      this._slave = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._master = value.master;
      this._slave = value.slave;
    }
  }

  // master - computed: false, optional: false, required: true
  private _master?: string; 
  public get master() {
    return this.getStringAttribute('master');
  }
  public set master(value: string) {
    this._master = value;
  }
  // Temporarily expose input value. Use with caution.
  public get masterInput() {
    return this._master;
  }

  // slave - computed: false, optional: false, required: true
  private _slave?: string; 
  public get slave() {
    return this.getStringAttribute('slave');
  }
  public set slave(value: string) {
    this._slave = value;
  }
  // Temporarily expose input value. Use with caution.
  public get slaveInput() {
    return this._slave;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePipeSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceReservationsSourcePipeSecLabelToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePipeSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceReservationsSourcePipeSecLabelToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePipeSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePipeSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePipeSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePipeSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePipeSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePipeSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePipeSecLabelOutputReference {
    return new DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePipeSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePipe {
  /**
  * Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePipeSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksMirrorBackingStoreSourceReservationsSourcePipeToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePipe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesDisksMirrorBackingStoreSourceReservationsSourcePipeSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceReservationsSourcePipeToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePipe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksMirrorBackingStoreSourceReservationsSourcePipeSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePipeSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePipeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePipe | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePipe | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePipeSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePipeSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePtySecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceReservationsSourcePtySecLabelToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePtySecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceReservationsSourcePtySecLabelToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePtySecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePtySecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePtySecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePtySecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePtySecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePtySecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePtySecLabelOutputReference {
    return new DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePtySecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePty {
  /**
  * Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePtySecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksMirrorBackingStoreSourceReservationsSourcePtyToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePty | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesDisksMirrorBackingStoreSourceReservationsSourcePtySecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceReservationsSourcePtyToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePty | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksMirrorBackingStoreSourceReservationsSourcePtySecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePtySecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePtyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePty | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePty | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePtySecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePtySecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceQemuvdAgentClipBoard {
  /**
  * Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#copy_paste Domain#copy_paste}
  */
  readonly copyPaste: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceReservationsSourceQemuvdAgentClipBoardToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceQemuvdAgentClipBoard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    copy_paste: cdktf.stringToTerraform(struct!.copyPaste),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceReservationsSourceQemuvdAgentClipBoardToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceQemuvdAgentClipBoard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    copy_paste: {
      value: cdktf.stringToHclTerraform(struct!.copyPaste),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceQemuvdAgentClipBoardOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceQemuvdAgentClipBoard | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._copyPaste !== undefined) {
      hasAnyValues = true;
      internalValueResult.copyPaste = this._copyPaste;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceQemuvdAgentClipBoard | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._copyPaste = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._copyPaste = value.copyPaste;
    }
  }

  // copy_paste - computed: false, optional: false, required: true
  private _copyPaste?: string; 
  public get copyPaste() {
    return this.getStringAttribute('copy_paste');
  }
  public set copyPaste(value: string) {
    this._copyPaste = value;
  }
  // Temporarily expose input value. Use with caution.
  public get copyPasteInput() {
    return this._copyPaste;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceQemuvdAgentMouse {
  /**
  * Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).
  * 
  * See: <https://libvirt.org/formatdomain.html#channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceReservationsSourceQemuvdAgentMouseToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceQemuvdAgentMouse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceReservationsSourceQemuvdAgentMouseToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceQemuvdAgentMouse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceQemuvdAgentMouseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceQemuvdAgentMouse | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceQemuvdAgentMouse | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
    }
  }

  // mode - computed: false, optional: false, required: true
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceQemuvdAgent {
  /**
  * Configures clipboard-related behavior for the QEMU vdagent–based EGD source, controlling whether clipboard data exchange is allowed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#clip_board Domain#clip_board}
  */
  readonly clipBoard?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceQemuvdAgentClipBoard;
  /**
  * Configures mouse integration options for the QEMU vdagent–based EGD source, such as how mouse events are handled.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mouse Domain#mouse}
  */
  readonly mouse?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceQemuvdAgentMouse;
}

export function domainDevicesDisksMirrorBackingStoreSourceReservationsSourceQemuvdAgentToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceQemuvdAgent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    clip_board: domainDevicesDisksMirrorBackingStoreSourceReservationsSourceQemuvdAgentClipBoardToTerraform(struct!.clipBoard),
    mouse: domainDevicesDisksMirrorBackingStoreSourceReservationsSourceQemuvdAgentMouseToTerraform(struct!.mouse),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceReservationsSourceQemuvdAgentToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceQemuvdAgent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    clip_board: {
      value: domainDevicesDisksMirrorBackingStoreSourceReservationsSourceQemuvdAgentClipBoardToHclTerraform(struct!.clipBoard),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceQemuvdAgentClipBoard",
    },
    mouse: {
      value: domainDevicesDisksMirrorBackingStoreSourceReservationsSourceQemuvdAgentMouseToHclTerraform(struct!.mouse),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceQemuvdAgentMouse",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceQemuvdAgentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceQemuvdAgent | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clipBoard?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clipBoard = this._clipBoard?.internalValue;
    }
    if (this._mouse?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.mouse = this._mouse?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceQemuvdAgent | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clipBoard.internalValue = undefined;
      this._mouse.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clipBoard.internalValue = value.clipBoard;
      this._mouse.internalValue = value.mouse;
    }
  }

  // clip_board - computed: false, optional: true, required: false
  private _clipBoard = new DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceQemuvdAgentClipBoardOutputReference(this, "clip_board");
  public get clipBoard() {
    return this._clipBoard;
  }
  public putClipBoard(value: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceQemuvdAgentClipBoard) {
    this._clipBoard.internalValue = value;
  }
  public resetClipBoard() {
    this._clipBoard.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clipBoardInput() {
    return this._clipBoard.internalValue;
  }

  // mouse - computed: false, optional: true, required: false
  private _mouse = new DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceQemuvdAgentMouseOutputReference(this, "mouse");
  public get mouse() {
    return this._mouse;
  }
  public putMouse(value: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceQemuvdAgentMouse) {
    this._mouse.internalValue = value;
  }
  public resetMouse() {
    this._mouse.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mouseInput() {
    return this._mouse.internalValue;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceSpicePort {
  /**
  * Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#channel Domain#channel}
  */
  readonly channel: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceReservationsSourceSpicePortToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceSpicePort | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    channel: cdktf.stringToTerraform(struct!.channel),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceReservationsSourceSpicePortToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceSpicePort | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    channel: {
      value: cdktf.stringToHclTerraform(struct!.channel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceSpicePortOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceSpicePort | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._channel !== undefined) {
      hasAnyValues = true;
      internalValueResult.channel = this._channel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceSpicePort | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._channel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._channel = value.channel;
    }
  }

  // channel - computed: false, optional: false, required: true
  private _channel?: string; 
  public get channel() {
    return this.getStringAttribute('channel');
  }
  public set channel(value: string) {
    this._channel = value;
  }
  // Temporarily expose input value. Use with caution.
  public get channelInput() {
    return this._channel;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceTcpReconnect {
  /**
  * Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enabled Domain#enabled}
  */
  readonly enabled: string;
  /**
  * Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#timeout Domain#timeout}
  */
  readonly timeout?: number;
}

export function domainDevicesDisksMirrorBackingStoreSourceReservationsSourceTcpReconnectToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceTcpReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.stringToTerraform(struct!.enabled),
    timeout: cdktf.numberToTerraform(struct!.timeout),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceReservationsSourceTcpReconnectToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceTcpReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.stringToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.numberToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceTcpReconnectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceTcpReconnect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceTcpReconnect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._timeout = value.timeout;
    }
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: string; 
  public get enabled() {
    return this.getStringAttribute('enabled');
  }
  public set enabled(value: string) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: number; 
  public get timeout() {
    return this.getNumberAttribute('timeout');
  }
  public set timeout(value: number) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceTcp {
  /**
  * Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#host Domain#host}
  */
  readonly host?: string;
  /**
  * Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode?: string;
  /**
  * Enables and configures automatic reconnection behavior for a UNIX socket–based EGD entropy source; the content and attributes are user-provided according to desired policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reconnect Domain#reconnect}
  */
  readonly reconnect?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceTcpReconnect;
  /**
  * Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#service Domain#service}
  */
  readonly service?: string;
  /**
  * Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tls Domain#tls}
  */
  readonly tls?: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceReservationsSourceTcpToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceTcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    mode: cdktf.stringToTerraform(struct!.mode),
    reconnect: domainDevicesDisksMirrorBackingStoreSourceReservationsSourceTcpReconnectToTerraform(struct!.reconnect),
    service: cdktf.stringToTerraform(struct!.service),
    tls: cdktf.stringToTerraform(struct!.tls),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceReservationsSourceTcpToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceTcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reconnect: {
      value: domainDevicesDisksMirrorBackingStoreSourceReservationsSourceTcpReconnectToHclTerraform(struct!.reconnect),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceTcpReconnect",
    },
    service: {
      value: cdktf.stringToHclTerraform(struct!.service),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: cdktf.stringToHclTerraform(struct!.tls),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceTcpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceTcp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._reconnect?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.reconnect = this._reconnect?.internalValue;
    }
    if (this._service !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service;
    }
    if (this._tls !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceTcp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host = undefined;
      this._mode = undefined;
      this._reconnect.internalValue = undefined;
      this._service = undefined;
      this._tls = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host = value.host;
      this._mode = value.mode;
      this._reconnect.internalValue = value.reconnect;
      this._service = value.service;
      this._tls = value.tls;
    }
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // reconnect - computed: false, optional: true, required: false
  private _reconnect = new DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceTcpReconnectOutputReference(this, "reconnect");
  public get reconnect() {
    return this._reconnect;
  }
  public putReconnect(value: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceTcpReconnect) {
    this._reconnect.internalValue = value;
  }
  public resetReconnect() {
    this._reconnect.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reconnectInput() {
    return this._reconnect.internalValue;
  }

  // service - computed: false, optional: true, required: false
  private _service?: string; 
  public get service() {
    return this.getStringAttribute('service');
  }
  public set service(value: string) {
    this._service = value;
  }
  public resetService() {
    this._service = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service;
  }

  // tls - computed: false, optional: true, required: false
  private _tls?: string; 
  public get tls() {
    return this.getStringAttribute('tls');
  }
  public set tls(value: string) {
    this._tls = value;
  }
  public resetTls() {
    this._tls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUdp {
  /**
  * Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bind_host Domain#bind_host}
  */
  readonly bindHost: string;
  /**
  * Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bind_service Domain#bind_service}
  */
  readonly bindService: string;
  /**
  * Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#connect_host Domain#connect_host}
  */
  readonly connectHost: string;
  /**
  * Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#connect_service Domain#connect_service}
  */
  readonly connectService: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceReservationsSourceUdpToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUdp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_host: cdktf.stringToTerraform(struct!.bindHost),
    bind_service: cdktf.stringToTerraform(struct!.bindService),
    connect_host: cdktf.stringToTerraform(struct!.connectHost),
    connect_service: cdktf.stringToTerraform(struct!.connectService),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceReservationsSourceUdpToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUdp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_host: {
      value: cdktf.stringToHclTerraform(struct!.bindHost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bind_service: {
      value: cdktf.stringToHclTerraform(struct!.bindService),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connect_host: {
      value: cdktf.stringToHclTerraform(struct!.connectHost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connect_service: {
      value: cdktf.stringToHclTerraform(struct!.connectService),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUdpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUdp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindHost !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindHost = this._bindHost;
    }
    if (this._bindService !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindService = this._bindService;
    }
    if (this._connectHost !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectHost = this._connectHost;
    }
    if (this._connectService !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectService = this._connectService;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUdp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bindHost = undefined;
      this._bindService = undefined;
      this._connectHost = undefined;
      this._connectService = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bindHost = value.bindHost;
      this._bindService = value.bindService;
      this._connectHost = value.connectHost;
      this._connectService = value.connectService;
    }
  }

  // bind_host - computed: false, optional: false, required: true
  private _bindHost?: string; 
  public get bindHost() {
    return this.getStringAttribute('bind_host');
  }
  public set bindHost(value: string) {
    this._bindHost = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bindHostInput() {
    return this._bindHost;
  }

  // bind_service - computed: false, optional: false, required: true
  private _bindService?: string; 
  public get bindService() {
    return this.getStringAttribute('bind_service');
  }
  public set bindService(value: string) {
    this._bindService = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bindServiceInput() {
    return this._bindService;
  }

  // connect_host - computed: false, optional: false, required: true
  private _connectHost?: string; 
  public get connectHost() {
    return this.getStringAttribute('connect_host');
  }
  public set connectHost(value: string) {
    this._connectHost = value;
  }
  // Temporarily expose input value. Use with caution.
  public get connectHostInput() {
    return this._connectHost;
  }

  // connect_service - computed: false, optional: false, required: true
  private _connectService?: string; 
  public get connectService() {
    return this.getStringAttribute('connect_service');
  }
  public set connectService(value: string) {
    this._connectService = value;
  }
  // Temporarily expose input value. Use with caution.
  public get connectServiceInput() {
    return this._connectService;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnixReconnect {
  /**
  * Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enabled Domain#enabled}
  */
  readonly enabled: string;
  /**
  * Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#timeout Domain#timeout}
  */
  readonly timeout?: number;
}

export function domainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnixReconnectToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnixReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.stringToTerraform(struct!.enabled),
    timeout: cdktf.numberToTerraform(struct!.timeout),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnixReconnectToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnixReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.stringToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.numberToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnixReconnectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnixReconnect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnixReconnect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._timeout = value.timeout;
    }
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: string; 
  public get enabled() {
    return this.getStringAttribute('enabled');
  }
  public set enabled(value: string) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: number; 
  public get timeout() {
    return this.getNumberAttribute('timeout');
  }
  public set timeout(value: number) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnixSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnixSecLabelToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnixSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnixSecLabelToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnixSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnixSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnixSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnixSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnixSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnixSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnixSecLabelOutputReference {
    return new DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnixSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnix {
  /**
  * Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode?: string;
  /**
  * Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path?: string;
  /**
  * Enables and configures automatic reconnection behavior for a UNIX socket–based EGD entropy source; the content and attributes are user-provided according to desired policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reconnect Domain#reconnect}
  */
  readonly reconnect?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnixReconnect;
  /**
  * Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnixSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnixToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
    reconnect: domainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnixReconnectToTerraform(struct!.reconnect),
    sec_label: cdktf.listMapper(domainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnixSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnixToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reconnect: {
      value: domainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnixReconnectToHclTerraform(struct!.reconnect),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnixReconnect",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnixSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnixSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnixOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnix | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._reconnect?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.reconnect = this._reconnect?.internalValue;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnix | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
      this._path = undefined;
      this._reconnect.internalValue = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
      this._path = value.path;
      this._reconnect.internalValue = value.reconnect;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // reconnect - computed: false, optional: true, required: false
  private _reconnect = new DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnixReconnectOutputReference(this, "reconnect");
  public get reconnect() {
    return this._reconnect;
  }
  public putReconnect(value: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnixReconnect) {
    this._reconnect.internalValue = value;
  }
  public resetReconnect() {
    this._reconnect.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reconnectInput() {
    return this._reconnect.internalValue;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnixSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnixSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceReservationsSource {
  /**
  * Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dbus Domain#dbus}
  */
  readonly dbus?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceDbus;
  /**
  * Configures an EGD RNG backend that reads entropy from a host character device node.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dev Domain#dev}
  */
  readonly dev?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceDev;
  /**
  * Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceFile;
  /**
  * Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#nmdm Domain#nmdm}
  */
  readonly nmdm?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceNmdm;
  /**
  * Enables use of a null character device as the reservation backing source; when this boolean is true, a Null source is emitted and all written data is discarded.
  * 
  * See: <https://libvirt.org/formatdomain.html#null-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#null Domain#null}
  */
  readonly null?: boolean | cdktf.IResolvable;
  /**
  * Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pipe Domain#pipe}
  */
  readonly pipe?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePipe;
  /**
  * Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pty Domain#pty}
  */
  readonly pty?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePty;
  /**
  * Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#qemuvd_agent Domain#qemuvd_agent}
  */
  readonly qemuvdAgent?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceQemuvdAgent;
  /**
  * Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#spice_port Domain#spice_port}
  */
  readonly spicePort?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceSpicePort;
  /**
  * Enables a SPICE VMC (SPICE management channel) backend for this backing-store source; when set true the element is emitted, when false or null it is omitted.
  * 
  * See: <https://libvirt.org/formatdomain.html#spice-channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#spice_vmc Domain#spice_vmc}
  */
  readonly spiceVmc?: boolean | cdktf.IResolvable;
  /**
  * Connects the backing-store source’s character channel to the domain’s standard I/O (stdin/stdout/stderr); when true the element is emitted, when false or null it is omitted.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-interface>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#std_io Domain#std_io}
  */
  readonly stdIo?: boolean | cdktf.IResolvable;
  /**
  * Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tcp Domain#tcp}
  */
  readonly tcp?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceTcp;
  /**
  * Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#udp Domain#udp}
  */
  readonly udp?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUdp;
  /**
  * Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#unix Domain#unix}
  */
  readonly unix?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnix;
  /**
  * Enables use of a VC (virtual cluster or vendor-specific) reservation source when set; since this is presence-based, setting it to true emits the element and false/null omits it.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vc Domain#vc}
  */
  readonly vc?: boolean | cdktf.IResolvable;
}

export function domainDevicesDisksMirrorBackingStoreSourceReservationsSourceToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dbus: domainDevicesDisksMirrorBackingStoreSourceReservationsSourceDbusToTerraform(struct!.dbus),
    dev: domainDevicesDisksMirrorBackingStoreSourceReservationsSourceDevToTerraform(struct!.dev),
    file: domainDevicesDisksMirrorBackingStoreSourceReservationsSourceFileToTerraform(struct!.file),
    nmdm: domainDevicesDisksMirrorBackingStoreSourceReservationsSourceNmdmToTerraform(struct!.nmdm),
    null: cdktf.booleanToTerraform(struct!.null),
    pipe: domainDevicesDisksMirrorBackingStoreSourceReservationsSourcePipeToTerraform(struct!.pipe),
    pty: domainDevicesDisksMirrorBackingStoreSourceReservationsSourcePtyToTerraform(struct!.pty),
    qemuvd_agent: domainDevicesDisksMirrorBackingStoreSourceReservationsSourceQemuvdAgentToTerraform(struct!.qemuvdAgent),
    spice_port: domainDevicesDisksMirrorBackingStoreSourceReservationsSourceSpicePortToTerraform(struct!.spicePort),
    spice_vmc: cdktf.booleanToTerraform(struct!.spiceVmc),
    std_io: cdktf.booleanToTerraform(struct!.stdIo),
    tcp: domainDevicesDisksMirrorBackingStoreSourceReservationsSourceTcpToTerraform(struct!.tcp),
    udp: domainDevicesDisksMirrorBackingStoreSourceReservationsSourceUdpToTerraform(struct!.udp),
    unix: domainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnixToTerraform(struct!.unix),
    vc: cdktf.booleanToTerraform(struct!.vc),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceReservationsSourceToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dbus: {
      value: domainDevicesDisksMirrorBackingStoreSourceReservationsSourceDbusToHclTerraform(struct!.dbus),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceDbus",
    },
    dev: {
      value: domainDevicesDisksMirrorBackingStoreSourceReservationsSourceDevToHclTerraform(struct!.dev),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceDev",
    },
    file: {
      value: domainDevicesDisksMirrorBackingStoreSourceReservationsSourceFileToHclTerraform(struct!.file),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceFile",
    },
    nmdm: {
      value: domainDevicesDisksMirrorBackingStoreSourceReservationsSourceNmdmToHclTerraform(struct!.nmdm),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceNmdm",
    },
    null: {
      value: cdktf.booleanToHclTerraform(struct!.null),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    pipe: {
      value: domainDevicesDisksMirrorBackingStoreSourceReservationsSourcePipeToHclTerraform(struct!.pipe),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePipe",
    },
    pty: {
      value: domainDevicesDisksMirrorBackingStoreSourceReservationsSourcePtyToHclTerraform(struct!.pty),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePty",
    },
    qemuvd_agent: {
      value: domainDevicesDisksMirrorBackingStoreSourceReservationsSourceQemuvdAgentToHclTerraform(struct!.qemuvdAgent),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceQemuvdAgent",
    },
    spice_port: {
      value: domainDevicesDisksMirrorBackingStoreSourceReservationsSourceSpicePortToHclTerraform(struct!.spicePort),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceSpicePort",
    },
    spice_vmc: {
      value: cdktf.booleanToHclTerraform(struct!.spiceVmc),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    std_io: {
      value: cdktf.booleanToHclTerraform(struct!.stdIo),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tcp: {
      value: domainDevicesDisksMirrorBackingStoreSourceReservationsSourceTcpToHclTerraform(struct!.tcp),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceTcp",
    },
    udp: {
      value: domainDevicesDisksMirrorBackingStoreSourceReservationsSourceUdpToHclTerraform(struct!.udp),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUdp",
    },
    unix: {
      value: domainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnixToHclTerraform(struct!.unix),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnix",
    },
    vc: {
      value: cdktf.booleanToHclTerraform(struct!.vc),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceReservationsSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dbus?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dbus = this._dbus?.internalValue;
    }
    if (this._dev?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dev = this._dev?.internalValue;
    }
    if (this._file?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file?.internalValue;
    }
    if (this._nmdm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nmdm = this._nmdm?.internalValue;
    }
    if (this._null !== undefined) {
      hasAnyValues = true;
      internalValueResult.null = this._null;
    }
    if (this._pipe?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipe = this._pipe?.internalValue;
    }
    if (this._pty?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pty = this._pty?.internalValue;
    }
    if (this._qemuvdAgent?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.qemuvdAgent = this._qemuvdAgent?.internalValue;
    }
    if (this._spicePort?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spicePort = this._spicePort?.internalValue;
    }
    if (this._spiceVmc !== undefined) {
      hasAnyValues = true;
      internalValueResult.spiceVmc = this._spiceVmc;
    }
    if (this._stdIo !== undefined) {
      hasAnyValues = true;
      internalValueResult.stdIo = this._stdIo;
    }
    if (this._tcp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tcp = this._tcp?.internalValue;
    }
    if (this._udp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.udp = this._udp?.internalValue;
    }
    if (this._unix?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.unix = this._unix?.internalValue;
    }
    if (this._vc !== undefined) {
      hasAnyValues = true;
      internalValueResult.vc = this._vc;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceReservationsSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dbus.internalValue = undefined;
      this._dev.internalValue = undefined;
      this._file.internalValue = undefined;
      this._nmdm.internalValue = undefined;
      this._null = undefined;
      this._pipe.internalValue = undefined;
      this._pty.internalValue = undefined;
      this._qemuvdAgent.internalValue = undefined;
      this._spicePort.internalValue = undefined;
      this._spiceVmc = undefined;
      this._stdIo = undefined;
      this._tcp.internalValue = undefined;
      this._udp.internalValue = undefined;
      this._unix.internalValue = undefined;
      this._vc = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dbus.internalValue = value.dbus;
      this._dev.internalValue = value.dev;
      this._file.internalValue = value.file;
      this._nmdm.internalValue = value.nmdm;
      this._null = value.null;
      this._pipe.internalValue = value.pipe;
      this._pty.internalValue = value.pty;
      this._qemuvdAgent.internalValue = value.qemuvdAgent;
      this._spicePort.internalValue = value.spicePort;
      this._spiceVmc = value.spiceVmc;
      this._stdIo = value.stdIo;
      this._tcp.internalValue = value.tcp;
      this._udp.internalValue = value.udp;
      this._unix.internalValue = value.unix;
      this._vc = value.vc;
    }
  }

  // dbus - computed: false, optional: true, required: false
  private _dbus = new DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceDbusOutputReference(this, "dbus");
  public get dbus() {
    return this._dbus;
  }
  public putDbus(value: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceDbus) {
    this._dbus.internalValue = value;
  }
  public resetDbus() {
    this._dbus.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dbusInput() {
    return this._dbus.internalValue;
  }

  // dev - computed: false, optional: true, required: false
  private _dev = new DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceDevOutputReference(this, "dev");
  public get dev() {
    return this._dev;
  }
  public putDev(value: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceDev) {
    this._dev.internalValue = value;
  }
  public resetDev() {
    this._dev.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devInput() {
    return this._dev.internalValue;
  }

  // file - computed: false, optional: true, required: false
  private _file = new DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceFileOutputReference(this, "file");
  public get file() {
    return this._file;
  }
  public putFile(value: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceFile) {
    this._file.internalValue = value;
  }
  public resetFile() {
    this._file.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file.internalValue;
  }

  // nmdm - computed: false, optional: true, required: false
  private _nmdm = new DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceNmdmOutputReference(this, "nmdm");
  public get nmdm() {
    return this._nmdm;
  }
  public putNmdm(value: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceNmdm) {
    this._nmdm.internalValue = value;
  }
  public resetNmdm() {
    this._nmdm.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nmdmInput() {
    return this._nmdm.internalValue;
  }

  // null - computed: false, optional: true, required: false
  private _null?: boolean | cdktf.IResolvable; 
  public get null() {
    return this.getBooleanAttribute('null');
  }
  public set null(value: boolean | cdktf.IResolvable) {
    this._null = value;
  }
  public resetNull() {
    this._null = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nullInput() {
    return this._null;
  }

  // pipe - computed: false, optional: true, required: false
  private _pipe = new DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePipeOutputReference(this, "pipe");
  public get pipe() {
    return this._pipe;
  }
  public putPipe(value: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePipe) {
    this._pipe.internalValue = value;
  }
  public resetPipe() {
    this._pipe.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipeInput() {
    return this._pipe.internalValue;
  }

  // pty - computed: false, optional: true, required: false
  private _pty = new DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePtyOutputReference(this, "pty");
  public get pty() {
    return this._pty;
  }
  public putPty(value: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourcePty) {
    this._pty.internalValue = value;
  }
  public resetPty() {
    this._pty.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ptyInput() {
    return this._pty.internalValue;
  }

  // qemuvd_agent - computed: false, optional: true, required: false
  private _qemuvdAgent = new DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceQemuvdAgentOutputReference(this, "qemuvd_agent");
  public get qemuvdAgent() {
    return this._qemuvdAgent;
  }
  public putQemuvdAgent(value: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceQemuvdAgent) {
    this._qemuvdAgent.internalValue = value;
  }
  public resetQemuvdAgent() {
    this._qemuvdAgent.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get qemuvdAgentInput() {
    return this._qemuvdAgent.internalValue;
  }

  // spice_port - computed: false, optional: true, required: false
  private _spicePort = new DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceSpicePortOutputReference(this, "spice_port");
  public get spicePort() {
    return this._spicePort;
  }
  public putSpicePort(value: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceSpicePort) {
    this._spicePort.internalValue = value;
  }
  public resetSpicePort() {
    this._spicePort.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spicePortInput() {
    return this._spicePort.internalValue;
  }

  // spice_vmc - computed: false, optional: true, required: false
  private _spiceVmc?: boolean | cdktf.IResolvable; 
  public get spiceVmc() {
    return this.getBooleanAttribute('spice_vmc');
  }
  public set spiceVmc(value: boolean | cdktf.IResolvable) {
    this._spiceVmc = value;
  }
  public resetSpiceVmc() {
    this._spiceVmc = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spiceVmcInput() {
    return this._spiceVmc;
  }

  // std_io - computed: false, optional: true, required: false
  private _stdIo?: boolean | cdktf.IResolvable; 
  public get stdIo() {
    return this.getBooleanAttribute('std_io');
  }
  public set stdIo(value: boolean | cdktf.IResolvable) {
    this._stdIo = value;
  }
  public resetStdIo() {
    this._stdIo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stdIoInput() {
    return this._stdIo;
  }

  // tcp - computed: false, optional: true, required: false
  private _tcp = new DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceTcpOutputReference(this, "tcp");
  public get tcp() {
    return this._tcp;
  }
  public putTcp(value: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceTcp) {
    this._tcp.internalValue = value;
  }
  public resetTcp() {
    this._tcp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tcpInput() {
    return this._tcp.internalValue;
  }

  // udp - computed: false, optional: true, required: false
  private _udp = new DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUdpOutputReference(this, "udp");
  public get udp() {
    return this._udp;
  }
  public putUdp(value: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUdp) {
    this._udp.internalValue = value;
  }
  public resetUdp() {
    this._udp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get udpInput() {
    return this._udp.internalValue;
  }

  // unix - computed: false, optional: true, required: false
  private _unix = new DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnixOutputReference(this, "unix");
  public get unix() {
    return this._unix;
  }
  public putUnix(value: DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceUnix) {
    this._unix.internalValue = value;
  }
  public resetUnix() {
    this._unix.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unixInput() {
    return this._unix.internalValue;
  }

  // vc - computed: false, optional: true, required: false
  private _vc?: boolean | cdktf.IResolvable; 
  public get vc() {
    return this.getBooleanAttribute('vc');
  }
  public set vc(value: boolean | cdktf.IResolvable) {
    this._vc = value;
  }
  public resetVc() {
    this._vc = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vcInput() {
    return this._vc;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceReservations {
  /**
  * Controls whether persistent reservations are enabled for the mirrored disk’s backing-store source; value is user-provided and typically expects "yes" or "no" semantics per libvirt.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enabled Domain#enabled}
  */
  readonly enabled?: string;
  /**
  * Indicates whether reservations are managed by libvirt ("yes") or externally ("no"); value is provided as a string and translated to a boolean, with "yes" meaning true and "no" meaning false.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#managed Domain#managed}
  */
  readonly managed?: boolean | cdktf.IResolvable;
  /**
  * Selects the mechanism used to provide reservation control for the mirrored backing-store source, such as a D-Bus service or a device/file endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#source Domain#source}
  */
  readonly source?: DomainDevicesDisksMirrorBackingStoreSourceReservationsSource;
}

export function domainDevicesDisksMirrorBackingStoreSourceReservationsToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.stringToTerraform(struct!.enabled),
    managed: cdktf.booleanToTerraform(struct!.managed),
    source: domainDevicesDisksMirrorBackingStoreSourceReservationsSourceToTerraform(struct!.source),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceReservationsToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceReservations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.stringToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    managed: {
      value: cdktf.booleanToHclTerraform(struct!.managed),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    source: {
      value: domainDevicesDisksMirrorBackingStoreSourceReservationsSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceReservationsSource",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceReservationsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceReservations | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._managed !== undefined) {
      hasAnyValues = true;
      internalValueResult.managed = this._managed;
    }
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceReservations | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._managed = undefined;
      this._source.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._managed = value.managed;
      this._source.internalValue = value.source;
    }
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: string; 
  public get enabled() {
    return this.getStringAttribute('enabled');
  }
  public set enabled(value: string) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // managed - computed: false, optional: true, required: false
  private _managed?: boolean | cdktf.IResolvable; 
  public get managed() {
    return this.getBooleanAttribute('managed');
  }
  public set managed(value: boolean | cdktf.IResolvable) {
    this._managed = value;
  }
  public resetManaged() {
    this._managed = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get managedInput() {
    return this._managed;
  }

  // source - computed: false, optional: true, required: false
  private _source = new DomainDevicesDisksMirrorBackingStoreSourceReservationsSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: DomainDevicesDisksMirrorBackingStoreSourceReservationsSource) {
    this._source.internalValue = value;
  }
  public resetSource() {
    this._source.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceSlicesSlices {
  /**
  * Sets the starting offset (in bytes) of this slice within the underlying backing-store source; must be a non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#offset Domain#offset}
  */
  readonly offset: number;
  /**
  * Sets the size (in bytes) of this slice within the underlying backing-store source; must be a positive integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#size Domain#size}
  */
  readonly size: number;
  /**
  * Specifies the type of slice mapping to use for this range; the value is user‑provided and must match a type supported by the hypervisor (for example, a particular mapping or layout scheme).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceSlicesSlicesToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceSlicesSlices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    offset: cdktf.numberToTerraform(struct!.offset),
    size: cdktf.numberToTerraform(struct!.size),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceSlicesSlicesToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceSlicesSlices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    offset: {
      value: cdktf.numberToHclTerraform(struct!.offset),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    size: {
      value: cdktf.numberToHclTerraform(struct!.size),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceSlicesSlicesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceSlicesSlices | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._offset !== undefined) {
      hasAnyValues = true;
      internalValueResult.offset = this._offset;
    }
    if (this._size !== undefined) {
      hasAnyValues = true;
      internalValueResult.size = this._size;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceSlicesSlices | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._offset = undefined;
      this._size = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._offset = value.offset;
      this._size = value.size;
      this._type = value.type;
    }
  }

  // offset - computed: false, optional: false, required: true
  private _offset?: number; 
  public get offset() {
    return this.getNumberAttribute('offset');
  }
  public set offset(value: number) {
    this._offset = value;
  }
  // Temporarily expose input value. Use with caution.
  public get offsetInput() {
    return this._offset;
  }

  // size - computed: false, optional: false, required: true
  private _size?: number; 
  public get size() {
    return this.getNumberAttribute('size');
  }
  public set size(value: number) {
    this._size = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sizeInput() {
    return this._size;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}

export class DomainDevicesDisksMirrorBackingStoreSourceSlicesSlicesList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksMirrorBackingStoreSourceSlicesSlices[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksMirrorBackingStoreSourceSlicesSlicesOutputReference {
    return new DomainDevicesDisksMirrorBackingStoreSourceSlicesSlicesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceSlices {
  /**
  * Configures one or more slices of the backing-store source, each describing a contiguous portion of the underlying device or file that is exposed through this mirror backing store.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#slices Domain#slices}
  */
  readonly slices?: DomainDevicesDisksMirrorBackingStoreSourceSlicesSlices[] | cdktf.IResolvable;
}

export function domainDevicesDisksMirrorBackingStoreSourceSlicesToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceSlices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    slices: cdktf.listMapper(domainDevicesDisksMirrorBackingStoreSourceSlicesSlicesToTerraform, false)(struct!.slices),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceSlicesToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceSlices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    slices: {
      value: cdktf.listMapperHcl(domainDevicesDisksMirrorBackingStoreSourceSlicesSlicesToHclTerraform, false)(struct!.slices),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceSlicesSlicesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceSlicesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceSlices | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._slices?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.slices = this._slices?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceSlices | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._slices.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._slices.internalValue = value.slices;
    }
  }

  // slices - computed: false, optional: true, required: false
  private _slices = new DomainDevicesDisksMirrorBackingStoreSourceSlicesSlicesList(this, "slices", false);
  public get slices() {
    return this._slices;
  }
  public putSlices(value: DomainDevicesDisksMirrorBackingStoreSourceSlicesSlices[] | cdktf.IResolvable) {
    this._slices.internalValue = value;
  }
  public resetSlices() {
    this._slices.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get slicesInput() {
    return this._slices.internalValue;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceSsl {
  /**
  * Controls certificate verification for SSL/TLS access to the mirrored backing-store source; typical values are "yes" or "no" to enable or disable verification.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#verify Domain#verify}
  */
  readonly verify: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceSslToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceSsl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    verify: cdktf.stringToTerraform(struct!.verify),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceSslToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceSsl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    verify: {
      value: cdktf.stringToHclTerraform(struct!.verify),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceSslOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceSsl | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._verify !== undefined) {
      hasAnyValues = true;
      internalValueResult.verify = this._verify;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceSsl | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._verify = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._verify = value.verify;
    }
  }

  // verify - computed: false, optional: false, required: true
  private _verify?: string; 
  public get verify() {
    return this.getStringAttribute('verify');
  }
  public set verify(value: string) {
    this._verify = value;
  }
  // Temporarily expose input value. Use with caution.
  public get verifyInput() {
    return this._verify;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceTimeout {
  /**
  * Sets the timeout duration in seconds for accessing the mirrored backing-store source; must be a non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#seconds Domain#seconds}
  */
  readonly seconds: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceTimeoutToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceTimeout | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    seconds: cdktf.stringToTerraform(struct!.seconds),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceTimeoutToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceTimeout | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    seconds: {
      value: cdktf.stringToHclTerraform(struct!.seconds),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceTimeoutOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceTimeout | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._seconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.seconds = this._seconds;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceTimeout | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._seconds = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._seconds = value.seconds;
    }
  }

  // seconds - computed: false, optional: false, required: true
  private _seconds?: string; 
  public get seconds() {
    return this.getStringAttribute('seconds');
  }
  public set seconds(value: string) {
    this._seconds = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secondsInput() {
    return this._seconds;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceVhostUserDbus {
  /**
  * Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#channel Domain#channel}
  */
  readonly channel?: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceVhostUserDbusToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserDbus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    channel: cdktf.stringToTerraform(struct!.channel),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceVhostUserDbusToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserDbus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    channel: {
      value: cdktf.stringToHclTerraform(struct!.channel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceVhostUserDbusOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceVhostUserDbus | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._channel !== undefined) {
      hasAnyValues = true;
      internalValueResult.channel = this._channel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceVhostUserDbus | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._channel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._channel = value.channel;
    }
  }

  // channel - computed: false, optional: true, required: false
  private _channel?: string; 
  public get channel() {
    return this.getStringAttribute('channel');
  }
  public set channel(value: string) {
    this._channel = value;
  }
  public resetChannel() {
    this._channel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get channelInput() {
    return this._channel;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceVhostUserDevSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceVhostUserDevSecLabelToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserDevSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceVhostUserDevSecLabelToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserDevSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceVhostUserDevSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceVhostUserDevSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceVhostUserDevSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksMirrorBackingStoreSourceVhostUserDevSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksMirrorBackingStoreSourceVhostUserDevSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksMirrorBackingStoreSourceVhostUserDevSecLabelOutputReference {
    return new DomainDevicesDisksMirrorBackingStoreSourceVhostUserDevSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceVhostUserDev {
  /**
  * Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserDevSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksMirrorBackingStoreSourceVhostUserDevToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserDev | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesDisksMirrorBackingStoreSourceVhostUserDevSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceVhostUserDevToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserDev | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksMirrorBackingStoreSourceVhostUserDevSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceVhostUserDevSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceVhostUserDevOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceVhostUserDev | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceVhostUserDev | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksMirrorBackingStoreSourceVhostUserDevSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksMirrorBackingStoreSourceVhostUserDevSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceVhostUserFileSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceVhostUserFileSecLabelToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserFileSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceVhostUserFileSecLabelToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserFileSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceVhostUserFileSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceVhostUserFileSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceVhostUserFileSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksMirrorBackingStoreSourceVhostUserFileSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksMirrorBackingStoreSourceVhostUserFileSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksMirrorBackingStoreSourceVhostUserFileSecLabelOutputReference {
    return new DomainDevicesDisksMirrorBackingStoreSourceVhostUserFileSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceVhostUserFile {
  /**
  * Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.
  * 
  * See: <https://libvirt.org/formatdomain.html#device-logfile>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#append Domain#append}
  */
  readonly append?: string;
  /**
  * Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserFileSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksMirrorBackingStoreSourceVhostUserFileToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.stringToTerraform(struct!.append),
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesDisksMirrorBackingStoreSourceVhostUserFileSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceVhostUserFileToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.stringToHclTerraform(struct!.append),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksMirrorBackingStoreSourceVhostUserFileSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceVhostUserFileSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceVhostUserFileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceVhostUserFile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceVhostUserFile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append = value.append;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append?: string; 
  public get append() {
    return this.getStringAttribute('append');
  }
  public set append(value: string) {
    this._append = value;
  }
  public resetAppend() {
    this._append = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append;
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksMirrorBackingStoreSourceVhostUserFileSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksMirrorBackingStoreSourceVhostUserFileSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceVhostUserNmdm {
  /**
  * Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.
  * 
  * See: <https://libvirt.org/formatdomain.html#nmdm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#master Domain#master}
  */
  readonly master: string;
  /**
  * Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.
  * 
  * See: <https://libvirt.org/formatdomain.html#nmdm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#slave Domain#slave}
  */
  readonly slave: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceVhostUserNmdmToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserNmdm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    master: cdktf.stringToTerraform(struct!.master),
    slave: cdktf.stringToTerraform(struct!.slave),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceVhostUserNmdmToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserNmdm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    master: {
      value: cdktf.stringToHclTerraform(struct!.master),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    slave: {
      value: cdktf.stringToHclTerraform(struct!.slave),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceVhostUserNmdmOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceVhostUserNmdm | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._master !== undefined) {
      hasAnyValues = true;
      internalValueResult.master = this._master;
    }
    if (this._slave !== undefined) {
      hasAnyValues = true;
      internalValueResult.slave = this._slave;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceVhostUserNmdm | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._master = undefined;
      this._slave = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._master = value.master;
      this._slave = value.slave;
    }
  }

  // master - computed: false, optional: false, required: true
  private _master?: string; 
  public get master() {
    return this.getStringAttribute('master');
  }
  public set master(value: string) {
    this._master = value;
  }
  // Temporarily expose input value. Use with caution.
  public get masterInput() {
    return this._master;
  }

  // slave - computed: false, optional: false, required: true
  private _slave?: string; 
  public get slave() {
    return this.getStringAttribute('slave');
  }
  public set slave(value: string) {
    this._slave = value;
  }
  // Temporarily expose input value. Use with caution.
  public get slaveInput() {
    return this._slave;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceVhostUserPipeSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceVhostUserPipeSecLabelToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserPipeSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceVhostUserPipeSecLabelToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserPipeSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceVhostUserPipeSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceVhostUserPipeSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceVhostUserPipeSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksMirrorBackingStoreSourceVhostUserPipeSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksMirrorBackingStoreSourceVhostUserPipeSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksMirrorBackingStoreSourceVhostUserPipeSecLabelOutputReference {
    return new DomainDevicesDisksMirrorBackingStoreSourceVhostUserPipeSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceVhostUserPipe {
  /**
  * Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserPipeSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksMirrorBackingStoreSourceVhostUserPipeToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserPipe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesDisksMirrorBackingStoreSourceVhostUserPipeSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceVhostUserPipeToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserPipe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksMirrorBackingStoreSourceVhostUserPipeSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceVhostUserPipeSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceVhostUserPipeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceVhostUserPipe | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceVhostUserPipe | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksMirrorBackingStoreSourceVhostUserPipeSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksMirrorBackingStoreSourceVhostUserPipeSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceVhostUserPtySecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceVhostUserPtySecLabelToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserPtySecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceVhostUserPtySecLabelToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserPtySecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceVhostUserPtySecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceVhostUserPtySecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceVhostUserPtySecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksMirrorBackingStoreSourceVhostUserPtySecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksMirrorBackingStoreSourceVhostUserPtySecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksMirrorBackingStoreSourceVhostUserPtySecLabelOutputReference {
    return new DomainDevicesDisksMirrorBackingStoreSourceVhostUserPtySecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceVhostUserPty {
  /**
  * Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserPtySecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksMirrorBackingStoreSourceVhostUserPtyToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserPty | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesDisksMirrorBackingStoreSourceVhostUserPtySecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceVhostUserPtyToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserPty | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksMirrorBackingStoreSourceVhostUserPtySecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceVhostUserPtySecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceVhostUserPtyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceVhostUserPty | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceVhostUserPty | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksMirrorBackingStoreSourceVhostUserPtySecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksMirrorBackingStoreSourceVhostUserPtySecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceVhostUserQemuvdAgentClipBoard {
  /**
  * Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#copy_paste Domain#copy_paste}
  */
  readonly copyPaste: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceVhostUserQemuvdAgentClipBoardToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserQemuvdAgentClipBoard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    copy_paste: cdktf.stringToTerraform(struct!.copyPaste),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceVhostUserQemuvdAgentClipBoardToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserQemuvdAgentClipBoard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    copy_paste: {
      value: cdktf.stringToHclTerraform(struct!.copyPaste),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceVhostUserQemuvdAgentClipBoardOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceVhostUserQemuvdAgentClipBoard | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._copyPaste !== undefined) {
      hasAnyValues = true;
      internalValueResult.copyPaste = this._copyPaste;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceVhostUserQemuvdAgentClipBoard | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._copyPaste = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._copyPaste = value.copyPaste;
    }
  }

  // copy_paste - computed: false, optional: false, required: true
  private _copyPaste?: string; 
  public get copyPaste() {
    return this.getStringAttribute('copy_paste');
  }
  public set copyPaste(value: string) {
    this._copyPaste = value;
  }
  // Temporarily expose input value. Use with caution.
  public get copyPasteInput() {
    return this._copyPaste;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceVhostUserQemuvdAgentMouse {
  /**
  * Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).
  * 
  * See: <https://libvirt.org/formatdomain.html#channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceVhostUserQemuvdAgentMouseToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserQemuvdAgentMouse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceVhostUserQemuvdAgentMouseToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserQemuvdAgentMouse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceVhostUserQemuvdAgentMouseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceVhostUserQemuvdAgentMouse | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceVhostUserQemuvdAgentMouse | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
    }
  }

  // mode - computed: false, optional: false, required: true
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceVhostUserQemuvdAgent {
  /**
  * Configures clipboard-related behavior for the QEMU vdagent–based EGD source, controlling whether clipboard data exchange is allowed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#clip_board Domain#clip_board}
  */
  readonly clipBoard?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserQemuvdAgentClipBoard;
  /**
  * Configures mouse integration options for the QEMU vdagent–based EGD source, such as how mouse events are handled.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mouse Domain#mouse}
  */
  readonly mouse?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserQemuvdAgentMouse;
}

export function domainDevicesDisksMirrorBackingStoreSourceVhostUserQemuvdAgentToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserQemuvdAgent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    clip_board: domainDevicesDisksMirrorBackingStoreSourceVhostUserQemuvdAgentClipBoardToTerraform(struct!.clipBoard),
    mouse: domainDevicesDisksMirrorBackingStoreSourceVhostUserQemuvdAgentMouseToTerraform(struct!.mouse),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceVhostUserQemuvdAgentToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserQemuvdAgent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    clip_board: {
      value: domainDevicesDisksMirrorBackingStoreSourceVhostUserQemuvdAgentClipBoardToHclTerraform(struct!.clipBoard),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceVhostUserQemuvdAgentClipBoard",
    },
    mouse: {
      value: domainDevicesDisksMirrorBackingStoreSourceVhostUserQemuvdAgentMouseToHclTerraform(struct!.mouse),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceVhostUserQemuvdAgentMouse",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceVhostUserQemuvdAgentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceVhostUserQemuvdAgent | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clipBoard?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clipBoard = this._clipBoard?.internalValue;
    }
    if (this._mouse?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.mouse = this._mouse?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceVhostUserQemuvdAgent | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clipBoard.internalValue = undefined;
      this._mouse.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clipBoard.internalValue = value.clipBoard;
      this._mouse.internalValue = value.mouse;
    }
  }

  // clip_board - computed: false, optional: true, required: false
  private _clipBoard = new DomainDevicesDisksMirrorBackingStoreSourceVhostUserQemuvdAgentClipBoardOutputReference(this, "clip_board");
  public get clipBoard() {
    return this._clipBoard;
  }
  public putClipBoard(value: DomainDevicesDisksMirrorBackingStoreSourceVhostUserQemuvdAgentClipBoard) {
    this._clipBoard.internalValue = value;
  }
  public resetClipBoard() {
    this._clipBoard.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clipBoardInput() {
    return this._clipBoard.internalValue;
  }

  // mouse - computed: false, optional: true, required: false
  private _mouse = new DomainDevicesDisksMirrorBackingStoreSourceVhostUserQemuvdAgentMouseOutputReference(this, "mouse");
  public get mouse() {
    return this._mouse;
  }
  public putMouse(value: DomainDevicesDisksMirrorBackingStoreSourceVhostUserQemuvdAgentMouse) {
    this._mouse.internalValue = value;
  }
  public resetMouse() {
    this._mouse.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mouseInput() {
    return this._mouse.internalValue;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceVhostUserSpicePort {
  /**
  * Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#channel Domain#channel}
  */
  readonly channel: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceVhostUserSpicePortToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserSpicePort | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    channel: cdktf.stringToTerraform(struct!.channel),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceVhostUserSpicePortToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserSpicePort | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    channel: {
      value: cdktf.stringToHclTerraform(struct!.channel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceVhostUserSpicePortOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceVhostUserSpicePort | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._channel !== undefined) {
      hasAnyValues = true;
      internalValueResult.channel = this._channel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceVhostUserSpicePort | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._channel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._channel = value.channel;
    }
  }

  // channel - computed: false, optional: false, required: true
  private _channel?: string; 
  public get channel() {
    return this.getStringAttribute('channel');
  }
  public set channel(value: string) {
    this._channel = value;
  }
  // Temporarily expose input value. Use with caution.
  public get channelInput() {
    return this._channel;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceVhostUserTcpReconnect {
  /**
  * Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enabled Domain#enabled}
  */
  readonly enabled: string;
  /**
  * Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#timeout Domain#timeout}
  */
  readonly timeout?: number;
}

export function domainDevicesDisksMirrorBackingStoreSourceVhostUserTcpReconnectToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserTcpReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.stringToTerraform(struct!.enabled),
    timeout: cdktf.numberToTerraform(struct!.timeout),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceVhostUserTcpReconnectToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserTcpReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.stringToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.numberToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceVhostUserTcpReconnectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceVhostUserTcpReconnect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceVhostUserTcpReconnect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._timeout = value.timeout;
    }
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: string; 
  public get enabled() {
    return this.getStringAttribute('enabled');
  }
  public set enabled(value: string) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: number; 
  public get timeout() {
    return this.getNumberAttribute('timeout');
  }
  public set timeout(value: number) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceVhostUserTcp {
  /**
  * Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#host Domain#host}
  */
  readonly host?: string;
  /**
  * Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode?: string;
  /**
  * Enables and configures automatic reconnection behavior for a UNIX socket–based EGD entropy source; the content and attributes are user-provided according to desired policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reconnect Domain#reconnect}
  */
  readonly reconnect?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserTcpReconnect;
  /**
  * Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#service Domain#service}
  */
  readonly service?: string;
  /**
  * Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tls Domain#tls}
  */
  readonly tls?: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceVhostUserTcpToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserTcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    mode: cdktf.stringToTerraform(struct!.mode),
    reconnect: domainDevicesDisksMirrorBackingStoreSourceVhostUserTcpReconnectToTerraform(struct!.reconnect),
    service: cdktf.stringToTerraform(struct!.service),
    tls: cdktf.stringToTerraform(struct!.tls),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceVhostUserTcpToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserTcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reconnect: {
      value: domainDevicesDisksMirrorBackingStoreSourceVhostUserTcpReconnectToHclTerraform(struct!.reconnect),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceVhostUserTcpReconnect",
    },
    service: {
      value: cdktf.stringToHclTerraform(struct!.service),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: cdktf.stringToHclTerraform(struct!.tls),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceVhostUserTcpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceVhostUserTcp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._reconnect?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.reconnect = this._reconnect?.internalValue;
    }
    if (this._service !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service;
    }
    if (this._tls !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceVhostUserTcp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host = undefined;
      this._mode = undefined;
      this._reconnect.internalValue = undefined;
      this._service = undefined;
      this._tls = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host = value.host;
      this._mode = value.mode;
      this._reconnect.internalValue = value.reconnect;
      this._service = value.service;
      this._tls = value.tls;
    }
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // reconnect - computed: false, optional: true, required: false
  private _reconnect = new DomainDevicesDisksMirrorBackingStoreSourceVhostUserTcpReconnectOutputReference(this, "reconnect");
  public get reconnect() {
    return this._reconnect;
  }
  public putReconnect(value: DomainDevicesDisksMirrorBackingStoreSourceVhostUserTcpReconnect) {
    this._reconnect.internalValue = value;
  }
  public resetReconnect() {
    this._reconnect.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reconnectInput() {
    return this._reconnect.internalValue;
  }

  // service - computed: false, optional: true, required: false
  private _service?: string; 
  public get service() {
    return this.getStringAttribute('service');
  }
  public set service(value: string) {
    this._service = value;
  }
  public resetService() {
    this._service = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service;
  }

  // tls - computed: false, optional: true, required: false
  private _tls?: string; 
  public get tls() {
    return this.getStringAttribute('tls');
  }
  public set tls(value: string) {
    this._tls = value;
  }
  public resetTls() {
    this._tls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceVhostUserUdp {
  /**
  * Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bind_host Domain#bind_host}
  */
  readonly bindHost: string;
  /**
  * Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bind_service Domain#bind_service}
  */
  readonly bindService: string;
  /**
  * Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#connect_host Domain#connect_host}
  */
  readonly connectHost: string;
  /**
  * Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#connect_service Domain#connect_service}
  */
  readonly connectService: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceVhostUserUdpToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserUdp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_host: cdktf.stringToTerraform(struct!.bindHost),
    bind_service: cdktf.stringToTerraform(struct!.bindService),
    connect_host: cdktf.stringToTerraform(struct!.connectHost),
    connect_service: cdktf.stringToTerraform(struct!.connectService),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceVhostUserUdpToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserUdp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_host: {
      value: cdktf.stringToHclTerraform(struct!.bindHost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bind_service: {
      value: cdktf.stringToHclTerraform(struct!.bindService),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connect_host: {
      value: cdktf.stringToHclTerraform(struct!.connectHost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connect_service: {
      value: cdktf.stringToHclTerraform(struct!.connectService),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceVhostUserUdpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceVhostUserUdp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindHost !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindHost = this._bindHost;
    }
    if (this._bindService !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindService = this._bindService;
    }
    if (this._connectHost !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectHost = this._connectHost;
    }
    if (this._connectService !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectService = this._connectService;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceVhostUserUdp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bindHost = undefined;
      this._bindService = undefined;
      this._connectHost = undefined;
      this._connectService = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bindHost = value.bindHost;
      this._bindService = value.bindService;
      this._connectHost = value.connectHost;
      this._connectService = value.connectService;
    }
  }

  // bind_host - computed: false, optional: false, required: true
  private _bindHost?: string; 
  public get bindHost() {
    return this.getStringAttribute('bind_host');
  }
  public set bindHost(value: string) {
    this._bindHost = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bindHostInput() {
    return this._bindHost;
  }

  // bind_service - computed: false, optional: false, required: true
  private _bindService?: string; 
  public get bindService() {
    return this.getStringAttribute('bind_service');
  }
  public set bindService(value: string) {
    this._bindService = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bindServiceInput() {
    return this._bindService;
  }

  // connect_host - computed: false, optional: false, required: true
  private _connectHost?: string; 
  public get connectHost() {
    return this.getStringAttribute('connect_host');
  }
  public set connectHost(value: string) {
    this._connectHost = value;
  }
  // Temporarily expose input value. Use with caution.
  public get connectHostInput() {
    return this._connectHost;
  }

  // connect_service - computed: false, optional: false, required: true
  private _connectService?: string; 
  public get connectService() {
    return this.getStringAttribute('connect_service');
  }
  public set connectService(value: string) {
    this._connectService = value;
  }
  // Temporarily expose input value. Use with caution.
  public get connectServiceInput() {
    return this._connectService;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceVhostUserUnixReconnect {
  /**
  * Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enabled Domain#enabled}
  */
  readonly enabled: string;
  /**
  * Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#timeout Domain#timeout}
  */
  readonly timeout?: number;
}

export function domainDevicesDisksMirrorBackingStoreSourceVhostUserUnixReconnectToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserUnixReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.stringToTerraform(struct!.enabled),
    timeout: cdktf.numberToTerraform(struct!.timeout),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceVhostUserUnixReconnectToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserUnixReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.stringToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.numberToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceVhostUserUnixReconnectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceVhostUserUnixReconnect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceVhostUserUnixReconnect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._timeout = value.timeout;
    }
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: string; 
  public get enabled() {
    return this.getStringAttribute('enabled');
  }
  public set enabled(value: string) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: number; 
  public get timeout() {
    return this.getNumberAttribute('timeout');
  }
  public set timeout(value: number) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceVhostUserUnixSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceVhostUserUnixSecLabelToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserUnixSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceVhostUserUnixSecLabelToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserUnixSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceVhostUserUnixSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceVhostUserUnixSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceVhostUserUnixSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksMirrorBackingStoreSourceVhostUserUnixSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksMirrorBackingStoreSourceVhostUserUnixSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksMirrorBackingStoreSourceVhostUserUnixSecLabelOutputReference {
    return new DomainDevicesDisksMirrorBackingStoreSourceVhostUserUnixSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceVhostUserUnix {
  /**
  * Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode?: string;
  /**
  * Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path?: string;
  /**
  * Enables and configures automatic reconnection behavior for a UNIX socket–based EGD entropy source; the content and attributes are user-provided according to desired policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reconnect Domain#reconnect}
  */
  readonly reconnect?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserUnixReconnect;
  /**
  * Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserUnixSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksMirrorBackingStoreSourceVhostUserUnixToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserUnix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
    reconnect: domainDevicesDisksMirrorBackingStoreSourceVhostUserUnixReconnectToTerraform(struct!.reconnect),
    sec_label: cdktf.listMapper(domainDevicesDisksMirrorBackingStoreSourceVhostUserUnixSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceVhostUserUnixToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserUnix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reconnect: {
      value: domainDevicesDisksMirrorBackingStoreSourceVhostUserUnixReconnectToHclTerraform(struct!.reconnect),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceVhostUserUnixReconnect",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksMirrorBackingStoreSourceVhostUserUnixSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceVhostUserUnixSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceVhostUserUnixOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceVhostUserUnix | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._reconnect?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.reconnect = this._reconnect?.internalValue;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceVhostUserUnix | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
      this._path = undefined;
      this._reconnect.internalValue = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
      this._path = value.path;
      this._reconnect.internalValue = value.reconnect;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // reconnect - computed: false, optional: true, required: false
  private _reconnect = new DomainDevicesDisksMirrorBackingStoreSourceVhostUserUnixReconnectOutputReference(this, "reconnect");
  public get reconnect() {
    return this._reconnect;
  }
  public putReconnect(value: DomainDevicesDisksMirrorBackingStoreSourceVhostUserUnixReconnect) {
    this._reconnect.internalValue = value;
  }
  public resetReconnect() {
    this._reconnect.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reconnectInput() {
    return this._reconnect.internalValue;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksMirrorBackingStoreSourceVhostUserUnixSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksMirrorBackingStoreSourceVhostUserUnixSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceVhostUser {
  /**
  * Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dbus Domain#dbus}
  */
  readonly dbus?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserDbus;
  /**
  * Configures an EGD RNG backend that reads entropy from a host character device node.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dev Domain#dev}
  */
  readonly dev?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserDev;
  /**
  * Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserFile;
  /**
  * Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#nmdm Domain#nmdm}
  */
  readonly nmdm?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserNmdm;
  /**
  * When set to true, uses a null character device as the vhost-user backing-store source, discarding all output and providing no input; when false or unset, the null device is not used.
  * 
  * See: <https://libvirt.org/formatdomain.html#null-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#null Domain#null}
  */
  readonly null?: boolean | cdktf.IResolvable;
  /**
  * Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pipe Domain#pipe}
  */
  readonly pipe?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserPipe;
  /**
  * Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pty Domain#pty}
  */
  readonly pty?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserPty;
  /**
  * Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#qemuvd_agent Domain#qemuvd_agent}
  */
  readonly qemuvdAgent?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserQemuvdAgent;
  /**
  * Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#spice_port Domain#spice_port}
  */
  readonly spicePort?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserSpicePort;
  /**
  * When set to true, exposes the vhost-user backing through a SPICE virtio-serial management channel (SpiceVMC); when false or unset, the element is omitted.
  * 
  * See: <https://libvirt.org/formatdomain.html#spice-channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#spice_vmc Domain#spice_vmc}
  */
  readonly spiceVmc?: boolean | cdktf.IResolvable;
  /**
  * When set to true, connects the vhost-user backing to the domain’s standard I/O character device; when false or unset, the StdIO element is omitted.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-interface>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#std_io Domain#std_io}
  */
  readonly stdIo?: boolean | cdktf.IResolvable;
  /**
  * Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tcp Domain#tcp}
  */
  readonly tcp?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserTcp;
  /**
  * Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#udp Domain#udp}
  */
  readonly udp?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserUdp;
  /**
  * Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#unix Domain#unix}
  */
  readonly unix?: DomainDevicesDisksMirrorBackingStoreSourceVhostUserUnix;
  /**
  * Enables use of a vhost-user communication mechanism compatible with a VC-style (versioned capability) endpoint for the disk mirror backing store; when set true the VC element is emitted, when false or null it is omitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vc Domain#vc}
  */
  readonly vc?: boolean | cdktf.IResolvable;
}

export function domainDevicesDisksMirrorBackingStoreSourceVhostUserToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostUser | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dbus: domainDevicesDisksMirrorBackingStoreSourceVhostUserDbusToTerraform(struct!.dbus),
    dev: domainDevicesDisksMirrorBackingStoreSourceVhostUserDevToTerraform(struct!.dev),
    file: domainDevicesDisksMirrorBackingStoreSourceVhostUserFileToTerraform(struct!.file),
    nmdm: domainDevicesDisksMirrorBackingStoreSourceVhostUserNmdmToTerraform(struct!.nmdm),
    null: cdktf.booleanToTerraform(struct!.null),
    pipe: domainDevicesDisksMirrorBackingStoreSourceVhostUserPipeToTerraform(struct!.pipe),
    pty: domainDevicesDisksMirrorBackingStoreSourceVhostUserPtyToTerraform(struct!.pty),
    qemuvd_agent: domainDevicesDisksMirrorBackingStoreSourceVhostUserQemuvdAgentToTerraform(struct!.qemuvdAgent),
    spice_port: domainDevicesDisksMirrorBackingStoreSourceVhostUserSpicePortToTerraform(struct!.spicePort),
    spice_vmc: cdktf.booleanToTerraform(struct!.spiceVmc),
    std_io: cdktf.booleanToTerraform(struct!.stdIo),
    tcp: domainDevicesDisksMirrorBackingStoreSourceVhostUserTcpToTerraform(struct!.tcp),
    udp: domainDevicesDisksMirrorBackingStoreSourceVhostUserUdpToTerraform(struct!.udp),
    unix: domainDevicesDisksMirrorBackingStoreSourceVhostUserUnixToTerraform(struct!.unix),
    vc: cdktf.booleanToTerraform(struct!.vc),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceVhostUserToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostUser | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dbus: {
      value: domainDevicesDisksMirrorBackingStoreSourceVhostUserDbusToHclTerraform(struct!.dbus),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceVhostUserDbus",
    },
    dev: {
      value: domainDevicesDisksMirrorBackingStoreSourceVhostUserDevToHclTerraform(struct!.dev),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceVhostUserDev",
    },
    file: {
      value: domainDevicesDisksMirrorBackingStoreSourceVhostUserFileToHclTerraform(struct!.file),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceVhostUserFile",
    },
    nmdm: {
      value: domainDevicesDisksMirrorBackingStoreSourceVhostUserNmdmToHclTerraform(struct!.nmdm),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceVhostUserNmdm",
    },
    null: {
      value: cdktf.booleanToHclTerraform(struct!.null),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    pipe: {
      value: domainDevicesDisksMirrorBackingStoreSourceVhostUserPipeToHclTerraform(struct!.pipe),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceVhostUserPipe",
    },
    pty: {
      value: domainDevicesDisksMirrorBackingStoreSourceVhostUserPtyToHclTerraform(struct!.pty),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceVhostUserPty",
    },
    qemuvd_agent: {
      value: domainDevicesDisksMirrorBackingStoreSourceVhostUserQemuvdAgentToHclTerraform(struct!.qemuvdAgent),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceVhostUserQemuvdAgent",
    },
    spice_port: {
      value: domainDevicesDisksMirrorBackingStoreSourceVhostUserSpicePortToHclTerraform(struct!.spicePort),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceVhostUserSpicePort",
    },
    spice_vmc: {
      value: cdktf.booleanToHclTerraform(struct!.spiceVmc),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    std_io: {
      value: cdktf.booleanToHclTerraform(struct!.stdIo),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tcp: {
      value: domainDevicesDisksMirrorBackingStoreSourceVhostUserTcpToHclTerraform(struct!.tcp),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceVhostUserTcp",
    },
    udp: {
      value: domainDevicesDisksMirrorBackingStoreSourceVhostUserUdpToHclTerraform(struct!.udp),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceVhostUserUdp",
    },
    unix: {
      value: domainDevicesDisksMirrorBackingStoreSourceVhostUserUnixToHclTerraform(struct!.unix),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceVhostUserUnix",
    },
    vc: {
      value: cdktf.booleanToHclTerraform(struct!.vc),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceVhostUserOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceVhostUser | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dbus?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dbus = this._dbus?.internalValue;
    }
    if (this._dev?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dev = this._dev?.internalValue;
    }
    if (this._file?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file?.internalValue;
    }
    if (this._nmdm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nmdm = this._nmdm?.internalValue;
    }
    if (this._null !== undefined) {
      hasAnyValues = true;
      internalValueResult.null = this._null;
    }
    if (this._pipe?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipe = this._pipe?.internalValue;
    }
    if (this._pty?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pty = this._pty?.internalValue;
    }
    if (this._qemuvdAgent?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.qemuvdAgent = this._qemuvdAgent?.internalValue;
    }
    if (this._spicePort?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spicePort = this._spicePort?.internalValue;
    }
    if (this._spiceVmc !== undefined) {
      hasAnyValues = true;
      internalValueResult.spiceVmc = this._spiceVmc;
    }
    if (this._stdIo !== undefined) {
      hasAnyValues = true;
      internalValueResult.stdIo = this._stdIo;
    }
    if (this._tcp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tcp = this._tcp?.internalValue;
    }
    if (this._udp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.udp = this._udp?.internalValue;
    }
    if (this._unix?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.unix = this._unix?.internalValue;
    }
    if (this._vc !== undefined) {
      hasAnyValues = true;
      internalValueResult.vc = this._vc;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceVhostUser | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dbus.internalValue = undefined;
      this._dev.internalValue = undefined;
      this._file.internalValue = undefined;
      this._nmdm.internalValue = undefined;
      this._null = undefined;
      this._pipe.internalValue = undefined;
      this._pty.internalValue = undefined;
      this._qemuvdAgent.internalValue = undefined;
      this._spicePort.internalValue = undefined;
      this._spiceVmc = undefined;
      this._stdIo = undefined;
      this._tcp.internalValue = undefined;
      this._udp.internalValue = undefined;
      this._unix.internalValue = undefined;
      this._vc = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dbus.internalValue = value.dbus;
      this._dev.internalValue = value.dev;
      this._file.internalValue = value.file;
      this._nmdm.internalValue = value.nmdm;
      this._null = value.null;
      this._pipe.internalValue = value.pipe;
      this._pty.internalValue = value.pty;
      this._qemuvdAgent.internalValue = value.qemuvdAgent;
      this._spicePort.internalValue = value.spicePort;
      this._spiceVmc = value.spiceVmc;
      this._stdIo = value.stdIo;
      this._tcp.internalValue = value.tcp;
      this._udp.internalValue = value.udp;
      this._unix.internalValue = value.unix;
      this._vc = value.vc;
    }
  }

  // dbus - computed: false, optional: true, required: false
  private _dbus = new DomainDevicesDisksMirrorBackingStoreSourceVhostUserDbusOutputReference(this, "dbus");
  public get dbus() {
    return this._dbus;
  }
  public putDbus(value: DomainDevicesDisksMirrorBackingStoreSourceVhostUserDbus) {
    this._dbus.internalValue = value;
  }
  public resetDbus() {
    this._dbus.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dbusInput() {
    return this._dbus.internalValue;
  }

  // dev - computed: false, optional: true, required: false
  private _dev = new DomainDevicesDisksMirrorBackingStoreSourceVhostUserDevOutputReference(this, "dev");
  public get dev() {
    return this._dev;
  }
  public putDev(value: DomainDevicesDisksMirrorBackingStoreSourceVhostUserDev) {
    this._dev.internalValue = value;
  }
  public resetDev() {
    this._dev.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devInput() {
    return this._dev.internalValue;
  }

  // file - computed: false, optional: true, required: false
  private _file = new DomainDevicesDisksMirrorBackingStoreSourceVhostUserFileOutputReference(this, "file");
  public get file() {
    return this._file;
  }
  public putFile(value: DomainDevicesDisksMirrorBackingStoreSourceVhostUserFile) {
    this._file.internalValue = value;
  }
  public resetFile() {
    this._file.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file.internalValue;
  }

  // nmdm - computed: false, optional: true, required: false
  private _nmdm = new DomainDevicesDisksMirrorBackingStoreSourceVhostUserNmdmOutputReference(this, "nmdm");
  public get nmdm() {
    return this._nmdm;
  }
  public putNmdm(value: DomainDevicesDisksMirrorBackingStoreSourceVhostUserNmdm) {
    this._nmdm.internalValue = value;
  }
  public resetNmdm() {
    this._nmdm.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nmdmInput() {
    return this._nmdm.internalValue;
  }

  // null - computed: false, optional: true, required: false
  private _null?: boolean | cdktf.IResolvable; 
  public get null() {
    return this.getBooleanAttribute('null');
  }
  public set null(value: boolean | cdktf.IResolvable) {
    this._null = value;
  }
  public resetNull() {
    this._null = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nullInput() {
    return this._null;
  }

  // pipe - computed: false, optional: true, required: false
  private _pipe = new DomainDevicesDisksMirrorBackingStoreSourceVhostUserPipeOutputReference(this, "pipe");
  public get pipe() {
    return this._pipe;
  }
  public putPipe(value: DomainDevicesDisksMirrorBackingStoreSourceVhostUserPipe) {
    this._pipe.internalValue = value;
  }
  public resetPipe() {
    this._pipe.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipeInput() {
    return this._pipe.internalValue;
  }

  // pty - computed: false, optional: true, required: false
  private _pty = new DomainDevicesDisksMirrorBackingStoreSourceVhostUserPtyOutputReference(this, "pty");
  public get pty() {
    return this._pty;
  }
  public putPty(value: DomainDevicesDisksMirrorBackingStoreSourceVhostUserPty) {
    this._pty.internalValue = value;
  }
  public resetPty() {
    this._pty.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ptyInput() {
    return this._pty.internalValue;
  }

  // qemuvd_agent - computed: false, optional: true, required: false
  private _qemuvdAgent = new DomainDevicesDisksMirrorBackingStoreSourceVhostUserQemuvdAgentOutputReference(this, "qemuvd_agent");
  public get qemuvdAgent() {
    return this._qemuvdAgent;
  }
  public putQemuvdAgent(value: DomainDevicesDisksMirrorBackingStoreSourceVhostUserQemuvdAgent) {
    this._qemuvdAgent.internalValue = value;
  }
  public resetQemuvdAgent() {
    this._qemuvdAgent.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get qemuvdAgentInput() {
    return this._qemuvdAgent.internalValue;
  }

  // spice_port - computed: false, optional: true, required: false
  private _spicePort = new DomainDevicesDisksMirrorBackingStoreSourceVhostUserSpicePortOutputReference(this, "spice_port");
  public get spicePort() {
    return this._spicePort;
  }
  public putSpicePort(value: DomainDevicesDisksMirrorBackingStoreSourceVhostUserSpicePort) {
    this._spicePort.internalValue = value;
  }
  public resetSpicePort() {
    this._spicePort.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spicePortInput() {
    return this._spicePort.internalValue;
  }

  // spice_vmc - computed: false, optional: true, required: false
  private _spiceVmc?: boolean | cdktf.IResolvable; 
  public get spiceVmc() {
    return this.getBooleanAttribute('spice_vmc');
  }
  public set spiceVmc(value: boolean | cdktf.IResolvable) {
    this._spiceVmc = value;
  }
  public resetSpiceVmc() {
    this._spiceVmc = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spiceVmcInput() {
    return this._spiceVmc;
  }

  // std_io - computed: false, optional: true, required: false
  private _stdIo?: boolean | cdktf.IResolvable; 
  public get stdIo() {
    return this.getBooleanAttribute('std_io');
  }
  public set stdIo(value: boolean | cdktf.IResolvable) {
    this._stdIo = value;
  }
  public resetStdIo() {
    this._stdIo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stdIoInput() {
    return this._stdIo;
  }

  // tcp - computed: false, optional: true, required: false
  private _tcp = new DomainDevicesDisksMirrorBackingStoreSourceVhostUserTcpOutputReference(this, "tcp");
  public get tcp() {
    return this._tcp;
  }
  public putTcp(value: DomainDevicesDisksMirrorBackingStoreSourceVhostUserTcp) {
    this._tcp.internalValue = value;
  }
  public resetTcp() {
    this._tcp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tcpInput() {
    return this._tcp.internalValue;
  }

  // udp - computed: false, optional: true, required: false
  private _udp = new DomainDevicesDisksMirrorBackingStoreSourceVhostUserUdpOutputReference(this, "udp");
  public get udp() {
    return this._udp;
  }
  public putUdp(value: DomainDevicesDisksMirrorBackingStoreSourceVhostUserUdp) {
    this._udp.internalValue = value;
  }
  public resetUdp() {
    this._udp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get udpInput() {
    return this._udp.internalValue;
  }

  // unix - computed: false, optional: true, required: false
  private _unix = new DomainDevicesDisksMirrorBackingStoreSourceVhostUserUnixOutputReference(this, "unix");
  public get unix() {
    return this._unix;
  }
  public putUnix(value: DomainDevicesDisksMirrorBackingStoreSourceVhostUserUnix) {
    this._unix.internalValue = value;
  }
  public resetUnix() {
    this._unix.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unixInput() {
    return this._unix.internalValue;
  }

  // vc - computed: false, optional: true, required: false
  private _vc?: boolean | cdktf.IResolvable; 
  public get vc() {
    return this.getBooleanAttribute('vc');
  }
  public set vc(value: boolean | cdktf.IResolvable) {
    this._vc = value;
  }
  public resetVc() {
    this._vc = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vcInput() {
    return this._vc;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceVhostVdpa {
  /**
  * Sets the host vDPA character device path used as the backingStore source for the mirrored disk when using a vhost-vdpa backend; the value is user-provided and must reference an existing device node (for example, /dev/vhost-vdpa0).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dev Domain#dev}
  */
  readonly dev: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceVhostVdpaToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostVdpa | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dev: cdktf.stringToTerraform(struct!.dev),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceVhostVdpaToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVhostVdpa | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dev: {
      value: cdktf.stringToHclTerraform(struct!.dev),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceVhostVdpaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceVhostVdpa | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dev !== undefined) {
      hasAnyValues = true;
      internalValueResult.dev = this._dev;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceVhostVdpa | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dev = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dev = value.dev;
    }
  }

  // dev - computed: false, optional: false, required: true
  private _dev?: string; 
  public get dev() {
    return this.getStringAttribute('dev');
  }
  public set dev(value: string) {
    this._dev = value;
  }
  // Temporarily expose input value. Use with caution.
  public get devInput() {
    return this._dev;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceVolumeSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceVolumeSecLabelToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVolumeSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceVolumeSecLabelToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVolumeSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceVolumeSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceVolumeSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceVolumeSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksMirrorBackingStoreSourceVolumeSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksMirrorBackingStoreSourceVolumeSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksMirrorBackingStoreSourceVolumeSecLabelOutputReference {
    return new DomainDevicesDisksMirrorBackingStoreSourceVolumeSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSourceVolume {
  /**
  * Sets the access mode with which the storage volume is used as the backingStore source (for example, "readOnly" or "readWrite" depending on driver support); the value is user-provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode?: string;
  /**
  * Names the storage pool that contains the backing storage volume used as the mirror backingStore source; must match an existing libvirt storage pool name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pool Domain#pool}
  */
  readonly pool?: string;
  /**
  * Configures an optional security label override applied to the backing storage volume used as the mirror backingStore source.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksMirrorBackingStoreSourceVolumeSecLabel[] | cdktf.IResolvable;
  /**
  * Sets the name of the storage volume within the specified pool that is used as the backingStore source for the mirrored disk.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#volume Domain#volume}
  */
  readonly volume?: string;
}

export function domainDevicesDisksMirrorBackingStoreSourceVolumeToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVolume | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
    pool: cdktf.stringToTerraform(struct!.pool),
    sec_label: cdktf.listMapper(domainDevicesDisksMirrorBackingStoreSourceVolumeSecLabelToTerraform, false)(struct!.secLabel),
    volume: cdktf.stringToTerraform(struct!.volume),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceVolumeToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSourceVolume | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pool: {
      value: cdktf.stringToHclTerraform(struct!.pool),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksMirrorBackingStoreSourceVolumeSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceVolumeSecLabelList",
    },
    volume: {
      value: cdktf.stringToHclTerraform(struct!.volume),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceVolumeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSourceVolume | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._pool !== undefined) {
      hasAnyValues = true;
      internalValueResult.pool = this._pool;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    if (this._volume !== undefined) {
      hasAnyValues = true;
      internalValueResult.volume = this._volume;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSourceVolume | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
      this._pool = undefined;
      this._secLabel.internalValue = undefined;
      this._volume = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
      this._pool = value.pool;
      this._secLabel.internalValue = value.secLabel;
      this._volume = value.volume;
    }
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // pool - computed: false, optional: true, required: false
  private _pool?: string; 
  public get pool() {
    return this.getStringAttribute('pool');
  }
  public set pool(value: string) {
    this._pool = value;
  }
  public resetPool() {
    this._pool = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get poolInput() {
    return this._pool;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksMirrorBackingStoreSourceVolumeSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksMirrorBackingStoreSourceVolumeSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }

  // volume - computed: false, optional: true, required: false
  private _volume?: string; 
  public get volume() {
    return this.getStringAttribute('volume');
  }
  public set volume(value: string) {
    this._volume = value;
  }
  public resetVolume() {
    this._volume = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get volumeInput() {
    return this._volume;
  }
}
export interface DomainDevicesDisksMirrorBackingStoreSource {
  /**
  * Describes a block device used as the source for the mirror backing store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#block Domain#block}
  */
  readonly block?: DomainDevicesDisksMirrorBackingStoreSourceBlock;
  /**
  * Provides optional cookie data associated with the mirror backing store source (for example, auth or session data), with content treated as user-provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#cookies Domain#cookies}
  */
  readonly cookies?: DomainDevicesDisksMirrorBackingStoreSourceCookies;
  /**
  * Configures a data store descriptor for the mirrored backing store, typically used with networked or advanced storage backends that expose format-specific options.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#data_store Domain#data_store}
  */
  readonly dataStore?: DomainDevicesDisksMirrorBackingStoreSourceDataStore;
  /**
  * Configures a directory-based source for the mirrored backing store, pointing to a host directory used by the backing image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dir Domain#dir}
  */
  readonly dir?: DomainDevicesDisksMirrorBackingStoreSourceDir;
  /**
  * Enables disk image encryption configuration for this disk and groups attributes defining the encryption engine, format, and secrets.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#encryption Domain#encryption}
  */
  readonly encryption?: DomainDevicesDisksMirrorBackingStoreSourceEncryption;
  /**
  * Configures a file-based backing store source for the disk mirror, defining how the backing image is accessed from the host filesystem.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file?: DomainDevicesDisksMirrorBackingStoreSourceFile;
  /**
  * Sets the index of this backing store within a backing chain, used when multiple backing layers are present; value is a user-provided non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#index Domain#index}
  */
  readonly index?: number;
  /**
  * Configures a network-based backing store source (such as NBD, iSCSI, or RBD) for the disk mirror, including authentication and host endpoints.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#network Domain#network}
  */
  readonly network?: DomainDevicesDisksMirrorBackingStoreSourceNetwork;
  /**
  * Enables using an NVMe-backed source for the mirrored disk’s backing store; when present, it selects an NVMe device or namespace as the source, with details defined by libvirt/QEMU for NVMe disks.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#nvme Domain#nvme}
  */
  readonly nvme?: DomainDevicesDisksMirrorBackingStoreSourceNvme;
  /**
  * Configures read-ahead behavior for the mirrored disk’s backing-store source, allowing tuning of how much data is pre-fetched from the backend.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#readahead Domain#readahead}
  */
  readonly readahead?: DomainDevicesDisksMirrorBackingStoreSourceReadahead;
  /**
  * Configures SCSI-style reservations or similar persistent reservation management for the mirrored disk’s backing-store source, controlling how access is coordinated across nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reservations Domain#reservations}
  */
  readonly reservations?: DomainDevicesDisksMirrorBackingStoreSourceReservations;
  /**
  * Configures optional slice or segment information for the backing store source (for example, to describe which logical slices of a device are used); content is user-provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#slices Domain#slices}
  */
  readonly slices?: DomainDevicesDisksMirrorBackingStoreSourceSlices;
  /**
  * Enables SSL/TLS parameters for accessing the mirrored backing-store source when it is provided over a secure transport.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#ssl Domain#ssl}
  */
  readonly ssl?: DomainDevicesDisksMirrorBackingStoreSourceSsl;
  /**
  * Specifies how strictly the mirrored backing-store source must be available during domain startup; valid values include "mandatory", "requisite", "optional" (user‑provided string matched by libvirt).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#startup_policy Domain#startup_policy}
  */
  readonly startupPolicy?: string;
  /**
  * Configures a timeout for connecting to or initializing the mirrored backing-store source.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#timeout Domain#timeout}
  */
  readonly timeout?: DomainDevicesDisksMirrorBackingStoreSourceTimeout;
  /**
  * Selects a vhost-user backend as the transport for the mirrored backing-store source, allowing it to be provided via a userspace process.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vhost_user Domain#vhost_user}
  */
  readonly vhostUser?: DomainDevicesDisksMirrorBackingStoreSourceVhostUser;
  /**
  * Selects a vhost-vDPA backend for the disk mirror backing store, allowing acceleration via a vDPA device; additional details are determined by libvirt and device configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vhost_vdpa Domain#vhost_vdpa}
  */
  readonly vhostVdpa?: DomainDevicesDisksMirrorBackingStoreSourceVhostVdpa;
  /**
  * Configures the backingStore source as a libvirt storage volume reference instead of a raw file/block path for the mirrored disk.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#volume Domain#volume}
  */
  readonly volume?: DomainDevicesDisksMirrorBackingStoreSourceVolume;
}

export function domainDevicesDisksMirrorBackingStoreSourceToTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    block: domainDevicesDisksMirrorBackingStoreSourceBlockToTerraform(struct!.block),
    cookies: domainDevicesDisksMirrorBackingStoreSourceCookiesToTerraform(struct!.cookies),
    data_store: domainDevicesDisksMirrorBackingStoreSourceDataStoreToTerraform(struct!.dataStore),
    dir: domainDevicesDisksMirrorBackingStoreSourceDirToTerraform(struct!.dir),
    encryption: domainDevicesDisksMirrorBackingStoreSourceEncryptionToTerraform(struct!.encryption),
    file: domainDevicesDisksMirrorBackingStoreSourceFileToTerraform(struct!.file),
    index: cdktf.numberToTerraform(struct!.index),
    network: domainDevicesDisksMirrorBackingStoreSourceNetworkToTerraform(struct!.network),
    nvme: domainDevicesDisksMirrorBackingStoreSourceNvmeToTerraform(struct!.nvme),
    readahead: domainDevicesDisksMirrorBackingStoreSourceReadaheadToTerraform(struct!.readahead),
    reservations: domainDevicesDisksMirrorBackingStoreSourceReservationsToTerraform(struct!.reservations),
    slices: domainDevicesDisksMirrorBackingStoreSourceSlicesToTerraform(struct!.slices),
    ssl: domainDevicesDisksMirrorBackingStoreSourceSslToTerraform(struct!.ssl),
    startup_policy: cdktf.stringToTerraform(struct!.startupPolicy),
    timeout: domainDevicesDisksMirrorBackingStoreSourceTimeoutToTerraform(struct!.timeout),
    vhost_user: domainDevicesDisksMirrorBackingStoreSourceVhostUserToTerraform(struct!.vhostUser),
    vhost_vdpa: domainDevicesDisksMirrorBackingStoreSourceVhostVdpaToTerraform(struct!.vhostVdpa),
    volume: domainDevicesDisksMirrorBackingStoreSourceVolumeToTerraform(struct!.volume),
  }
}


export function domainDevicesDisksMirrorBackingStoreSourceToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStoreSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    block: {
      value: domainDevicesDisksMirrorBackingStoreSourceBlockToHclTerraform(struct!.block),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceBlock",
    },
    cookies: {
      value: domainDevicesDisksMirrorBackingStoreSourceCookiesToHclTerraform(struct!.cookies),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceCookies",
    },
    data_store: {
      value: domainDevicesDisksMirrorBackingStoreSourceDataStoreToHclTerraform(struct!.dataStore),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceDataStore",
    },
    dir: {
      value: domainDevicesDisksMirrorBackingStoreSourceDirToHclTerraform(struct!.dir),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceDir",
    },
    encryption: {
      value: domainDevicesDisksMirrorBackingStoreSourceEncryptionToHclTerraform(struct!.encryption),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceEncryption",
    },
    file: {
      value: domainDevicesDisksMirrorBackingStoreSourceFileToHclTerraform(struct!.file),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceFile",
    },
    index: {
      value: cdktf.numberToHclTerraform(struct!.index),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    network: {
      value: domainDevicesDisksMirrorBackingStoreSourceNetworkToHclTerraform(struct!.network),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceNetwork",
    },
    nvme: {
      value: domainDevicesDisksMirrorBackingStoreSourceNvmeToHclTerraform(struct!.nvme),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceNvme",
    },
    readahead: {
      value: domainDevicesDisksMirrorBackingStoreSourceReadaheadToHclTerraform(struct!.readahead),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceReadahead",
    },
    reservations: {
      value: domainDevicesDisksMirrorBackingStoreSourceReservationsToHclTerraform(struct!.reservations),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceReservations",
    },
    slices: {
      value: domainDevicesDisksMirrorBackingStoreSourceSlicesToHclTerraform(struct!.slices),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceSlices",
    },
    ssl: {
      value: domainDevicesDisksMirrorBackingStoreSourceSslToHclTerraform(struct!.ssl),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceSsl",
    },
    startup_policy: {
      value: cdktf.stringToHclTerraform(struct!.startupPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: domainDevicesDisksMirrorBackingStoreSourceTimeoutToHclTerraform(struct!.timeout),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceTimeout",
    },
    vhost_user: {
      value: domainDevicesDisksMirrorBackingStoreSourceVhostUserToHclTerraform(struct!.vhostUser),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceVhostUser",
    },
    vhost_vdpa: {
      value: domainDevicesDisksMirrorBackingStoreSourceVhostVdpaToHclTerraform(struct!.vhostVdpa),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceVhostVdpa",
    },
    volume: {
      value: domainDevicesDisksMirrorBackingStoreSourceVolumeToHclTerraform(struct!.volume),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSourceVolume",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStoreSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._block?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.block = this._block?.internalValue;
    }
    if (this._cookies?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cookies = this._cookies?.internalValue;
    }
    if (this._dataStore?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dataStore = this._dataStore?.internalValue;
    }
    if (this._dir?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dir = this._dir?.internalValue;
    }
    if (this._encryption?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.encryption = this._encryption?.internalValue;
    }
    if (this._file?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file?.internalValue;
    }
    if (this._index !== undefined) {
      hasAnyValues = true;
      internalValueResult.index = this._index;
    }
    if (this._network?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.network = this._network?.internalValue;
    }
    if (this._nvme?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nvme = this._nvme?.internalValue;
    }
    if (this._readahead?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.readahead = this._readahead?.internalValue;
    }
    if (this._reservations?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.reservations = this._reservations?.internalValue;
    }
    if (this._slices?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.slices = this._slices?.internalValue;
    }
    if (this._ssl?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ssl = this._ssl?.internalValue;
    }
    if (this._startupPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.startupPolicy = this._startupPolicy;
    }
    if (this._timeout?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout?.internalValue;
    }
    if (this._vhostUser?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.vhostUser = this._vhostUser?.internalValue;
    }
    if (this._vhostVdpa?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.vhostVdpa = this._vhostVdpa?.internalValue;
    }
    if (this._volume?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.volume = this._volume?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStoreSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._block.internalValue = undefined;
      this._cookies.internalValue = undefined;
      this._dataStore.internalValue = undefined;
      this._dir.internalValue = undefined;
      this._encryption.internalValue = undefined;
      this._file.internalValue = undefined;
      this._index = undefined;
      this._network.internalValue = undefined;
      this._nvme.internalValue = undefined;
      this._readahead.internalValue = undefined;
      this._reservations.internalValue = undefined;
      this._slices.internalValue = undefined;
      this._ssl.internalValue = undefined;
      this._startupPolicy = undefined;
      this._timeout.internalValue = undefined;
      this._vhostUser.internalValue = undefined;
      this._vhostVdpa.internalValue = undefined;
      this._volume.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._block.internalValue = value.block;
      this._cookies.internalValue = value.cookies;
      this._dataStore.internalValue = value.dataStore;
      this._dir.internalValue = value.dir;
      this._encryption.internalValue = value.encryption;
      this._file.internalValue = value.file;
      this._index = value.index;
      this._network.internalValue = value.network;
      this._nvme.internalValue = value.nvme;
      this._readahead.internalValue = value.readahead;
      this._reservations.internalValue = value.reservations;
      this._slices.internalValue = value.slices;
      this._ssl.internalValue = value.ssl;
      this._startupPolicy = value.startupPolicy;
      this._timeout.internalValue = value.timeout;
      this._vhostUser.internalValue = value.vhostUser;
      this._vhostVdpa.internalValue = value.vhostVdpa;
      this._volume.internalValue = value.volume;
    }
  }

  // block - computed: false, optional: true, required: false
  private _block = new DomainDevicesDisksMirrorBackingStoreSourceBlockOutputReference(this, "block");
  public get block() {
    return this._block;
  }
  public putBlock(value: DomainDevicesDisksMirrorBackingStoreSourceBlock) {
    this._block.internalValue = value;
  }
  public resetBlock() {
    this._block.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get blockInput() {
    return this._block.internalValue;
  }

  // cookies - computed: false, optional: true, required: false
  private _cookies = new DomainDevicesDisksMirrorBackingStoreSourceCookiesOutputReference(this, "cookies");
  public get cookies() {
    return this._cookies;
  }
  public putCookies(value: DomainDevicesDisksMirrorBackingStoreSourceCookies) {
    this._cookies.internalValue = value;
  }
  public resetCookies() {
    this._cookies.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cookiesInput() {
    return this._cookies.internalValue;
  }

  // data_store - computed: false, optional: true, required: false
  private _dataStore = new DomainDevicesDisksMirrorBackingStoreSourceDataStoreOutputReference(this, "data_store");
  public get dataStore() {
    return this._dataStore;
  }
  public putDataStore(value: DomainDevicesDisksMirrorBackingStoreSourceDataStore) {
    this._dataStore.internalValue = value;
  }
  public resetDataStore() {
    this._dataStore.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dataStoreInput() {
    return this._dataStore.internalValue;
  }

  // dir - computed: false, optional: true, required: false
  private _dir = new DomainDevicesDisksMirrorBackingStoreSourceDirOutputReference(this, "dir");
  public get dir() {
    return this._dir;
  }
  public putDir(value: DomainDevicesDisksMirrorBackingStoreSourceDir) {
    this._dir.internalValue = value;
  }
  public resetDir() {
    this._dir.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dirInput() {
    return this._dir.internalValue;
  }

  // encryption - computed: false, optional: true, required: false
  private _encryption = new DomainDevicesDisksMirrorBackingStoreSourceEncryptionOutputReference(this, "encryption");
  public get encryption() {
    return this._encryption;
  }
  public putEncryption(value: DomainDevicesDisksMirrorBackingStoreSourceEncryption) {
    this._encryption.internalValue = value;
  }
  public resetEncryption() {
    this._encryption.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get encryptionInput() {
    return this._encryption.internalValue;
  }

  // file - computed: false, optional: true, required: false
  private _file = new DomainDevicesDisksMirrorBackingStoreSourceFileOutputReference(this, "file");
  public get file() {
    return this._file;
  }
  public putFile(value: DomainDevicesDisksMirrorBackingStoreSourceFile) {
    this._file.internalValue = value;
  }
  public resetFile() {
    this._file.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file.internalValue;
  }

  // index - computed: false, optional: true, required: false
  private _index?: number; 
  public get index() {
    return this.getNumberAttribute('index');
  }
  public set index(value: number) {
    this._index = value;
  }
  public resetIndex() {
    this._index = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get indexInput() {
    return this._index;
  }

  // network - computed: false, optional: true, required: false
  private _network = new DomainDevicesDisksMirrorBackingStoreSourceNetworkOutputReference(this, "network");
  public get network() {
    return this._network;
  }
  public putNetwork(value: DomainDevicesDisksMirrorBackingStoreSourceNetwork) {
    this._network.internalValue = value;
  }
  public resetNetwork() {
    this._network.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkInput() {
    return this._network.internalValue;
  }

  // nvme - computed: false, optional: true, required: false
  private _nvme = new DomainDevicesDisksMirrorBackingStoreSourceNvmeOutputReference(this, "nvme");
  public get nvme() {
    return this._nvme;
  }
  public putNvme(value: DomainDevicesDisksMirrorBackingStoreSourceNvme) {
    this._nvme.internalValue = value;
  }
  public resetNvme() {
    this._nvme.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nvmeInput() {
    return this._nvme.internalValue;
  }

  // readahead - computed: false, optional: true, required: false
  private _readahead = new DomainDevicesDisksMirrorBackingStoreSourceReadaheadOutputReference(this, "readahead");
  public get readahead() {
    return this._readahead;
  }
  public putReadahead(value: DomainDevicesDisksMirrorBackingStoreSourceReadahead) {
    this._readahead.internalValue = value;
  }
  public resetReadahead() {
    this._readahead.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readaheadInput() {
    return this._readahead.internalValue;
  }

  // reservations - computed: false, optional: true, required: false
  private _reservations = new DomainDevicesDisksMirrorBackingStoreSourceReservationsOutputReference(this, "reservations");
  public get reservations() {
    return this._reservations;
  }
  public putReservations(value: DomainDevicesDisksMirrorBackingStoreSourceReservations) {
    this._reservations.internalValue = value;
  }
  public resetReservations() {
    this._reservations.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reservationsInput() {
    return this._reservations.internalValue;
  }

  // slices - computed: false, optional: true, required: false
  private _slices = new DomainDevicesDisksMirrorBackingStoreSourceSlicesOutputReference(this, "slices");
  public get slices() {
    return this._slices;
  }
  public putSlices(value: DomainDevicesDisksMirrorBackingStoreSourceSlices) {
    this._slices.internalValue = value;
  }
  public resetSlices() {
    this._slices.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get slicesInput() {
    return this._slices.internalValue;
  }

  // ssl - computed: false, optional: true, required: false
  private _ssl = new DomainDevicesDisksMirrorBackingStoreSourceSslOutputReference(this, "ssl");
  public get ssl() {
    return this._ssl;
  }
  public putSsl(value: DomainDevicesDisksMirrorBackingStoreSourceSsl) {
    this._ssl.internalValue = value;
  }
  public resetSsl() {
    this._ssl.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sslInput() {
    return this._ssl.internalValue;
  }

  // startup_policy - computed: false, optional: true, required: false
  private _startupPolicy?: string; 
  public get startupPolicy() {
    return this.getStringAttribute('startup_policy');
  }
  public set startupPolicy(value: string) {
    this._startupPolicy = value;
  }
  public resetStartupPolicy() {
    this._startupPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get startupPolicyInput() {
    return this._startupPolicy;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout = new DomainDevicesDisksMirrorBackingStoreSourceTimeoutOutputReference(this, "timeout");
  public get timeout() {
    return this._timeout;
  }
  public putTimeout(value: DomainDevicesDisksMirrorBackingStoreSourceTimeout) {
    this._timeout.internalValue = value;
  }
  public resetTimeout() {
    this._timeout.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout.internalValue;
  }

  // vhost_user - computed: false, optional: true, required: false
  private _vhostUser = new DomainDevicesDisksMirrorBackingStoreSourceVhostUserOutputReference(this, "vhost_user");
  public get vhostUser() {
    return this._vhostUser;
  }
  public putVhostUser(value: DomainDevicesDisksMirrorBackingStoreSourceVhostUser) {
    this._vhostUser.internalValue = value;
  }
  public resetVhostUser() {
    this._vhostUser.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vhostUserInput() {
    return this._vhostUser.internalValue;
  }

  // vhost_vdpa - computed: false, optional: true, required: false
  private _vhostVdpa = new DomainDevicesDisksMirrorBackingStoreSourceVhostVdpaOutputReference(this, "vhost_vdpa");
  public get vhostVdpa() {
    return this._vhostVdpa;
  }
  public putVhostVdpa(value: DomainDevicesDisksMirrorBackingStoreSourceVhostVdpa) {
    this._vhostVdpa.internalValue = value;
  }
  public resetVhostVdpa() {
    this._vhostVdpa.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vhostVdpaInput() {
    return this._vhostVdpa.internalValue;
  }

  // volume - computed: false, optional: true, required: false
  private _volume = new DomainDevicesDisksMirrorBackingStoreSourceVolumeOutputReference(this, "volume");
  public get volume() {
    return this._volume;
  }
  public putVolume(value: DomainDevicesDisksMirrorBackingStoreSourceVolume) {
    this._volume.internalValue = value;
  }
  public resetVolume() {
    this._volume.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get volumeInput() {
    return this._volume.internalValue;
  }
}
