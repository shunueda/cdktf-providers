import * as cdktf from 'cdktf';
import { DomainFeaturesKvmDirtyRing,
domainFeaturesKvmDirtyRingToTerraform,
domainFeaturesKvmDirtyRingToHclTerraform,
DomainFeaturesKvmDirtyRingOutputReference,
DomainFeaturesKvmHidden,
domainFeaturesKvmHiddenToTerraform,
domainFeaturesKvmHiddenToHclTerraform,
DomainFeaturesKvmHiddenOutputReference,
DomainFeaturesKvmHintDedicated,
domainFeaturesKvmHintDedicatedToTerraform,
domainFeaturesKvmHintDedicatedToHclTerraform,
DomainFeaturesKvmHintDedicatedOutputReference,
DomainFeaturesKvmPollControl,
domainFeaturesKvmPollControlToTerraform,
domainFeaturesKvmPollControlToHclTerraform,
DomainFeaturesKvmPollControlOutputReference,
DomainFeaturesKvmPvipi,
domainFeaturesKvmPvipiToTerraform,
domainFeaturesKvmPvipiToHclTerraform,
DomainFeaturesKvmPvipiOutputReference,
DomainFeaturesAia,
domainFeaturesAiaToTerraform,
domainFeaturesAiaToHclTerraform,
DomainFeaturesAiaOutputReference,
DomainFeaturesApic,
domainFeaturesApicToTerraform,
domainFeaturesApicToHclTerraform,
DomainFeaturesApicOutputReference,
DomainFeaturesAsyncTeardown,
domainFeaturesAsyncTeardownToTerraform,
domainFeaturesAsyncTeardownToHclTerraform,
DomainFeaturesAsyncTeardownOutputReference,
DomainFeaturesCapabilities,
domainFeaturesCapabilitiesToTerraform,
domainFeaturesCapabilitiesToHclTerraform,
DomainFeaturesCapabilitiesOutputReference,
DomainFeaturesCcfAssist,
domainFeaturesCcfAssistToTerraform,
domainFeaturesCcfAssistToHclTerraform,
DomainFeaturesCcfAssistOutputReference,
DomainFeaturesCfpc,
domainFeaturesCfpcToTerraform,
domainFeaturesCfpcToHclTerraform,
DomainFeaturesCfpcOutputReference,
DomainFeaturesGic,
domainFeaturesGicToTerraform,
domainFeaturesGicToHclTerraform,
DomainFeaturesGicOutputReference,
DomainFeaturesHap,
domainFeaturesHapToTerraform,
domainFeaturesHapToHclTerraform,
DomainFeaturesHapOutputReference,
DomainFeaturesHpt,
domainFeaturesHptToTerraform,
domainFeaturesHptToHclTerraform,
DomainFeaturesHptOutputReference,
DomainFeaturesHtm,
domainFeaturesHtmToTerraform,
domainFeaturesHtmToHclTerraform,
DomainFeaturesHtmOutputReference,
DomainFeaturesHyperV,
domainFeaturesHyperVToTerraform,
domainFeaturesHyperVToHclTerraform,
DomainFeaturesHyperVOutputReference,
DomainFeaturesIbs,
domainFeaturesIbsToTerraform,
domainFeaturesIbsToHclTerraform,
DomainFeaturesIbsOutputReference,
DomainFeaturesIoapic,
domainFeaturesIoapicToTerraform,
domainFeaturesIoapicToHclTerraform,
DomainFeaturesIoapicOutputReference } from './structs2000'
export interface DomainFeaturesKvm {
  /**
  * Configures the KVM dirty-ring feature for tracking guest memory changes via a ring buffer instead of legacy dirty logging, enabling more efficient live migration and dirty-page tracking when supported by the host.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dirty_ring Domain#dirty_ring}
  */
  readonly dirtyRing?: DomainFeaturesKvmDirtyRing;
  /**
  * Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#hidden Domain#hidden}
  */
  readonly hidden?: DomainFeaturesKvmHidden;
  /**
  * Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#hint_dedicated Domain#hint_dedicated}
  */
  readonly hintDedicated?: DomainFeaturesKvmHintDedicated;
  /**
  * Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#poll_control Domain#poll_control}
  */
  readonly pollControl?: DomainFeaturesKvmPollControl;
  /**
  * Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pvipi Domain#pvipi}
  */
  readonly pvipi?: DomainFeaturesKvmPvipi;
}

export function domainFeaturesKvmToTerraform(struct?: DomainFeaturesKvm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dirty_ring: domainFeaturesKvmDirtyRingToTerraform(struct!.dirtyRing),
    hidden: domainFeaturesKvmHiddenToTerraform(struct!.hidden),
    hint_dedicated: domainFeaturesKvmHintDedicatedToTerraform(struct!.hintDedicated),
    poll_control: domainFeaturesKvmPollControlToTerraform(struct!.pollControl),
    pvipi: domainFeaturesKvmPvipiToTerraform(struct!.pvipi),
  }
}


export function domainFeaturesKvmToHclTerraform(struct?: DomainFeaturesKvm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dirty_ring: {
      value: domainFeaturesKvmDirtyRingToHclTerraform(struct!.dirtyRing),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesKvmDirtyRing",
    },
    hidden: {
      value: domainFeaturesKvmHiddenToHclTerraform(struct!.hidden),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesKvmHidden",
    },
    hint_dedicated: {
      value: domainFeaturesKvmHintDedicatedToHclTerraform(struct!.hintDedicated),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesKvmHintDedicated",
    },
    poll_control: {
      value: domainFeaturesKvmPollControlToHclTerraform(struct!.pollControl),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesKvmPollControl",
    },
    pvipi: {
      value: domainFeaturesKvmPvipiToHclTerraform(struct!.pvipi),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesKvmPvipi",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesKvmOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesKvm | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dirtyRing?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dirtyRing = this._dirtyRing?.internalValue;
    }
    if (this._hidden?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hidden = this._hidden?.internalValue;
    }
    if (this._hintDedicated?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hintDedicated = this._hintDedicated?.internalValue;
    }
    if (this._pollControl?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pollControl = this._pollControl?.internalValue;
    }
    if (this._pvipi?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pvipi = this._pvipi?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesKvm | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dirtyRing.internalValue = undefined;
      this._hidden.internalValue = undefined;
      this._hintDedicated.internalValue = undefined;
      this._pollControl.internalValue = undefined;
      this._pvipi.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dirtyRing.internalValue = value.dirtyRing;
      this._hidden.internalValue = value.hidden;
      this._hintDedicated.internalValue = value.hintDedicated;
      this._pollControl.internalValue = value.pollControl;
      this._pvipi.internalValue = value.pvipi;
    }
  }

  // dirty_ring - computed: false, optional: true, required: false
  private _dirtyRing = new DomainFeaturesKvmDirtyRingOutputReference(this, "dirty_ring");
  public get dirtyRing() {
    return this._dirtyRing;
  }
  public putDirtyRing(value: DomainFeaturesKvmDirtyRing) {
    this._dirtyRing.internalValue = value;
  }
  public resetDirtyRing() {
    this._dirtyRing.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dirtyRingInput() {
    return this._dirtyRing.internalValue;
  }

  // hidden - computed: false, optional: true, required: false
  private _hidden = new DomainFeaturesKvmHiddenOutputReference(this, "hidden");
  public get hidden() {
    return this._hidden;
  }
  public putHidden(value: DomainFeaturesKvmHidden) {
    this._hidden.internalValue = value;
  }
  public resetHidden() {
    this._hidden.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hiddenInput() {
    return this._hidden.internalValue;
  }

  // hint_dedicated - computed: false, optional: true, required: false
  private _hintDedicated = new DomainFeaturesKvmHintDedicatedOutputReference(this, "hint_dedicated");
  public get hintDedicated() {
    return this._hintDedicated;
  }
  public putHintDedicated(value: DomainFeaturesKvmHintDedicated) {
    this._hintDedicated.internalValue = value;
  }
  public resetHintDedicated() {
    this._hintDedicated.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hintDedicatedInput() {
    return this._hintDedicated.internalValue;
  }

  // poll_control - computed: false, optional: true, required: false
  private _pollControl = new DomainFeaturesKvmPollControlOutputReference(this, "poll_control");
  public get pollControl() {
    return this._pollControl;
  }
  public putPollControl(value: DomainFeaturesKvmPollControl) {
    this._pollControl.internalValue = value;
  }
  public resetPollControl() {
    this._pollControl.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pollControlInput() {
    return this._pollControl.internalValue;
  }

  // pvipi - computed: false, optional: true, required: false
  private _pvipi = new DomainFeaturesKvmPvipiOutputReference(this, "pvipi");
  public get pvipi() {
    return this._pvipi;
  }
  public putPvipi(value: DomainFeaturesKvmPvipi) {
    this._pvipi.internalValue = value;
  }
  public resetPvipi() {
    this._pvipi.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pvipiInput() {
    return this._pvipi.internalValue;
  }
}
export interface DomainFeaturesMsrs {
  /**
  * Sets the policy for unknown MSR accesses by the guest; valid values are driver-specific (commonly "ignore", "warn", or "fault") and must be provided explicitly.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#unknown Domain#unknown}
  */
  readonly unknown: string;
}

export function domainFeaturesMsrsToTerraform(struct?: DomainFeaturesMsrs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    unknown: cdktf.stringToTerraform(struct!.unknown),
  }
}


export function domainFeaturesMsrsToHclTerraform(struct?: DomainFeaturesMsrs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    unknown: {
      value: cdktf.stringToHclTerraform(struct!.unknown),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesMsrsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesMsrs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._unknown !== undefined) {
      hasAnyValues = true;
      internalValueResult.unknown = this._unknown;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesMsrs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._unknown = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._unknown = value.unknown;
    }
  }

  // unknown - computed: false, optional: false, required: true
  private _unknown?: string; 
  public get unknown() {
    return this.getStringAttribute('unknown');
  }
  public set unknown(value: string) {
    this._unknown = value;
  }
  // Temporarily expose input value. Use with caution.
  public get unknownInput() {
    return this._unknown;
  }
}
export interface DomainFeaturesNestedHv {
  /**
  * Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesNestedHvToTerraform(struct?: DomainFeaturesNestedHv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesNestedHvToHclTerraform(struct?: DomainFeaturesNestedHv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesNestedHvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesNestedHv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesNestedHv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesPmu {
  /**
  * Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesPmuToTerraform(struct?: DomainFeaturesPmu | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesPmuToHclTerraform(struct?: DomainFeaturesPmu | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesPmuOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesPmu | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesPmu | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesPs2 {
  /**
  * Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesPs2ToTerraform(struct?: DomainFeaturesPs2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesPs2ToHclTerraform(struct?: DomainFeaturesPs2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesPs2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesPs2 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesPs2 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesPvSpinlock {
  /**
  * Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesPvSpinlockToTerraform(struct?: DomainFeaturesPvSpinlock | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesPvSpinlockToHclTerraform(struct?: DomainFeaturesPvSpinlock | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesPvSpinlockOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesPvSpinlock | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesPvSpinlock | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesRas {
  /**
  * Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesRasToTerraform(struct?: DomainFeaturesRas | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesRasToHclTerraform(struct?: DomainFeaturesRas | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesRasOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesRas | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesRas | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesSbbc {
  /**
  * Sets the SBBC mitigation mode as a user-provided value (for example "on", "off", or a model-specific keyword, depending on hypervisor support); this attribute is required when sbbc is present.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#value Domain#value}
  */
  readonly value: string;
}

export function domainFeaturesSbbcToTerraform(struct?: DomainFeaturesSbbc | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function domainFeaturesSbbcToHclTerraform(struct?: DomainFeaturesSbbc | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesSbbcOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesSbbc | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesSbbc | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._value = value.value;
    }
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DomainFeaturesSmm {
  /**
  * Controls whether SMM is enabled via a state flag (typically "on" or "off"; the exact accepted values are hypervisor-dependent).
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
  /**
  * Sets the size of the TSEG (SMRAM) memory area used by SMM, with the numeric quantity paired with tseg_unit (for example 64 with unit "MiB").
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tseg Domain#tseg}
  */
  readonly tseg?: number;
  /**
  * Specifies the unit used for the SMM TSEG size, paired with smm.tseg (for example "KiB", "MiB", or "GiB"); the concrete unit string is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tseg_unit Domain#tseg_unit}
  */
  readonly tsegUnit?: string;
}

export function domainFeaturesSmmToTerraform(struct?: DomainFeaturesSmm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
    tseg: cdktf.numberToTerraform(struct!.tseg),
    tseg_unit: cdktf.stringToTerraform(struct!.tsegUnit),
  }
}


export function domainFeaturesSmmToHclTerraform(struct?: DomainFeaturesSmm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tseg: {
      value: cdktf.numberToHclTerraform(struct!.tseg),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    tseg_unit: {
      value: cdktf.stringToHclTerraform(struct!.tsegUnit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesSmmOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesSmm | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    if (this._tseg !== undefined) {
      hasAnyValues = true;
      internalValueResult.tseg = this._tseg;
    }
    if (this._tsegUnit !== undefined) {
      hasAnyValues = true;
      internalValueResult.tsegUnit = this._tsegUnit;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesSmm | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
      this._tseg = undefined;
      this._tsegUnit = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
      this._tseg = value.tseg;
      this._tsegUnit = value.tsegUnit;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }

  // tseg - computed: false, optional: true, required: false
  private _tseg?: number; 
  public get tseg() {
    return this.getNumberAttribute('tseg');
  }
  public set tseg(value: number) {
    this._tseg = value;
  }
  public resetTseg() {
    this._tseg = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tsegInput() {
    return this._tseg;
  }

  // tseg_unit - computed: false, optional: true, required: false
  private _tsegUnit?: string; 
  public get tsegUnit() {
    return this.getStringAttribute('tseg_unit');
  }
  public set tsegUnit(value: string) {
    this._tsegUnit = value;
  }
  public resetTsegUnit() {
    this._tsegUnit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tsegUnitInput() {
    return this._tsegUnit;
  }
}
export interface DomainFeaturesTcg {
  /**
  * Sets the size of the TCG translation block cache, with the numeric value paired with tb_cache_unit (for example 128 with unit "MiB").
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tb_cache Domain#tb_cache}
  */
  readonly tbCache?: number;
  /**
  * Specifies the unit used for the TCG translation block cache size, paired with tcg.tb_cache (for example "KiB", "MiB", or "GiB"); the exact unit string is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tb_cache_unit Domain#tb_cache_unit}
  */
  readonly tbCacheUnit?: string;
}

export function domainFeaturesTcgToTerraform(struct?: DomainFeaturesTcg | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    tb_cache: cdktf.numberToTerraform(struct!.tbCache),
    tb_cache_unit: cdktf.stringToTerraform(struct!.tbCacheUnit),
  }
}


export function domainFeaturesTcgToHclTerraform(struct?: DomainFeaturesTcg | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    tb_cache: {
      value: cdktf.numberToHclTerraform(struct!.tbCache),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    tb_cache_unit: {
      value: cdktf.stringToHclTerraform(struct!.tbCacheUnit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesTcgOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesTcg | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._tbCache !== undefined) {
      hasAnyValues = true;
      internalValueResult.tbCache = this._tbCache;
    }
    if (this._tbCacheUnit !== undefined) {
      hasAnyValues = true;
      internalValueResult.tbCacheUnit = this._tbCacheUnit;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesTcg | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._tbCache = undefined;
      this._tbCacheUnit = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._tbCache = value.tbCache;
      this._tbCacheUnit = value.tbCacheUnit;
    }
  }

  // tb_cache - computed: false, optional: true, required: false
  private _tbCache?: number; 
  public get tbCache() {
    return this.getNumberAttribute('tb_cache');
  }
  public set tbCache(value: number) {
    this._tbCache = value;
  }
  public resetTbCache() {
    this._tbCache = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tbCacheInput() {
    return this._tbCache;
  }

  // tb_cache_unit - computed: false, optional: true, required: false
  private _tbCacheUnit?: string; 
  public get tbCacheUnit() {
    return this.getStringAttribute('tb_cache_unit');
  }
  public set tbCacheUnit(value: string) {
    this._tbCacheUnit = value;
  }
  public resetTbCacheUnit() {
    this._tbCacheUnit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tbCacheUnitInput() {
    return this._tbCacheUnit;
  }
}
export interface DomainFeaturesVmCoreInfo {
  /**
  * Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesVmCoreInfoToTerraform(struct?: DomainFeaturesVmCoreInfo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesVmCoreInfoToHclTerraform(struct?: DomainFeaturesVmCoreInfo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesVmCoreInfoOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesVmCoreInfo | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesVmCoreInfo | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesVmPort {
  /**
  * Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesVmPortToTerraform(struct?: DomainFeaturesVmPort | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesVmPortToHclTerraform(struct?: DomainFeaturesVmPort | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesVmPortOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesVmPort | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesVmPort | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesXenE820Host {
  /**
  * Sets whether the Xen e820_host feature is enabled for the guest; accepts the string values "on" or "off" and is required when the xen.e820host feature is present.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state: string;
}

export function domainFeaturesXenE820HostToTerraform(struct?: DomainFeaturesXenE820Host | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesXenE820HostToHclTerraform(struct?: DomainFeaturesXenE820Host | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesXenE820HostOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesXenE820Host | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesXenE820Host | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: false, required: true
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesXenPassthrough {
  /**
  * Sets the Xen passthrough mode for the domain; the value is user-provided and must be a valid mode string recognized by the underlying Xen/libvirt version (for example, a specific IOMMU or passthrough mode).
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode?: string;
  /**
  * Sets whether Xen passthrough is enabled; accepts the string values "on" or "off" when the passthrough block is defined.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesXenPassthroughToTerraform(struct?: DomainFeaturesXenPassthrough | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesXenPassthroughToHclTerraform(struct?: DomainFeaturesXenPassthrough | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesXenPassthroughOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesXenPassthrough | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesXenPassthrough | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
      this._state = value.state;
    }
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesXen {
  /**
  * Enables or disables use of the hosts E820 memory map when exposing Xen emulation to the guest, typically as a yes/no style toggle (value is user-provided such as "on"/"off").
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#e820host Domain#e820host}
  */
  readonly e820Host?: DomainFeaturesXenE820Host;
  /**
  * Enables configuration of Xen passthrough-related features for the domain; presence of this block determines whether passthrough suboptions can be set.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#passthrough Domain#passthrough}
  */
  readonly passthrough?: DomainFeaturesXenPassthrough;
}

export function domainFeaturesXenToTerraform(struct?: DomainFeaturesXen | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    e820host: domainFeaturesXenE820HostToTerraform(struct!.e820Host),
    passthrough: domainFeaturesXenPassthroughToTerraform(struct!.passthrough),
  }
}


export function domainFeaturesXenToHclTerraform(struct?: DomainFeaturesXen | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    e820host: {
      value: domainFeaturesXenE820HostToHclTerraform(struct!.e820Host),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesXenE820Host",
    },
    passthrough: {
      value: domainFeaturesXenPassthroughToHclTerraform(struct!.passthrough),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesXenPassthrough",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesXenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesXen | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._e820Host?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.e820Host = this._e820Host?.internalValue;
    }
    if (this._passthrough?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.passthrough = this._passthrough?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesXen | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._e820Host.internalValue = undefined;
      this._passthrough.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._e820Host.internalValue = value.e820Host;
      this._passthrough.internalValue = value.passthrough;
    }
  }

  // e820host - computed: false, optional: true, required: false
  private _e820Host = new DomainFeaturesXenE820HostOutputReference(this, "e820host");
  public get e820Host() {
    return this._e820Host;
  }
  public putE820Host(value: DomainFeaturesXenE820Host) {
    this._e820Host.internalValue = value;
  }
  public resetE820Host() {
    this._e820Host.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get e820HostInput() {
    return this._e820Host.internalValue;
  }

  // passthrough - computed: false, optional: true, required: false
  private _passthrough = new DomainFeaturesXenPassthroughOutputReference(this, "passthrough");
  public get passthrough() {
    return this._passthrough;
  }
  public putPassthrough(value: DomainFeaturesXenPassthrough) {
    this._passthrough.internalValue = value;
  }
  public resetPassthrough() {
    this._passthrough.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passthroughInput() {
    return this._passthrough.internalValue;
  }
}
export interface DomainFeatures {
  /**
  * Controls exposure of ACPI support to the guest; presence of this element enables ACPI, while its omission leaves it at libvirts default behavior.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#acpi Domain#acpi}
  */
  readonly acpi?: boolean | cdktf.IResolvable;
  /**
  * Configures the Advanced Interrupt Architecture (AIA) feature for the guest CPU/machine, with the specific mode or value being userprovided according to hypervisor support.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#aia Domain#aia}
  */
  readonly aia?: DomainFeaturesAia;
  /**
  * Enables inclusion of the APIC (Advanced Programmable Interrupt Controller) feature block for the guest; presence of this block allows configuring APIC-related behavior such as end-of-interrupt handling.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#apic Domain#apic}
  */
  readonly apic?: DomainFeaturesApic;
  /**
  * Enables configuration of asynchronous teardown support for the guest; when present, it allows controlling whether the hypervisor uses async teardown semantics.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#async_teardown Domain#async_teardown}
  */
  readonly asyncTeardown?: DomainFeaturesAsyncTeardown;
  /**
  * Configures per-domain Linux capability controls, allowing fine-grained enabling or disabling of specific capabilities inside the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#capabilities Domain#capabilities}
  */
  readonly capabilities?: DomainFeaturesCapabilities;
  /**
  * Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#ccf_assist Domain#ccf_assist}
  */
  readonly ccfAssist?: DomainFeaturesCcfAssist;
  /**
  * Configures the "cfpc" CPU feature (a speculative-execution/flush-control mitigation) policy for the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#cfpc Domain#cfpc}
  */
  readonly cfpc?: DomainFeaturesCfpc;
  /**
  * Configures the ARM Generic Interrupt Controller (GIC) feature for the guest, allowing selection or control of the emulated GIC model.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#gic Domain#gic}
  */
  readonly gic?: DomainFeaturesGic;
  /**
  * Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#hap Domain#hap}
  */
  readonly hap?: DomainFeaturesHap;
  /**
  * Configures the hashed page table (HPT) feature used by some PowerPC guests, including its size and resizing behavior.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#hpt Domain#hpt}
  */
  readonly hpt?: DomainFeaturesHpt;
  /**
  * Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#htm Domain#htm}
  */
  readonly htm?: DomainFeaturesHtm;
  /**
  * Enables configuration of Hyper-V enlightenment features for the guest when running on a Hyper-V-capable hypervisor.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#hyper_v Domain#hyper_v}
  */
  readonly hyperV?: DomainFeaturesHyperV;
  /**
  * Enables configuration of the Instruction Based Sampling (IBS) CPU feature on supported AMD guests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#ibs Domain#ibs}
  */
  readonly ibs?: DomainFeaturesIbs;
  /**
  * Configures the emulation mode for the virtual IOAPIC used for interrupt routing in the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#ioapic Domain#ioapic}
  */
  readonly ioapic?: DomainFeaturesIoapic;
  /**
  * Enables configuration of KVM-specific CPU or machine features via its child elements (for example, toggling individual KVM feature flags).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#kvm Domain#kvm}
  */
  readonly kvm?: DomainFeaturesKvm;
  /**
  * Configures handling of unknown/unsupported model-specific registers (MSRs) encountered in the guest, controlling whether guest MSR accesses can be ignored or cause failures.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#msrs Domain#msrs}
  */
  readonly msrs?: DomainFeaturesMsrs;
  /**
  * Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#nested_hv Domain#nested_hv}
  */
  readonly nestedHv?: DomainFeaturesNestedHv;
  /**
  * Enables or disables Physical Address Extension (PAE) support for the guest; when set true the PAE feature element is emitted, when false or unset it is omitted.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pae Domain#pae}
  */
  readonly pae?: boolean | cdktf.IResolvable;
  /**
  * Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pmu Domain#pmu}
  */
  readonly pmu?: DomainFeaturesPmu;
  /**
  * Enables or disables the hypervisors private networking feature for the guest; when set true the privnet feature element is emitted, when false or unset it is omitted.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#priv_net Domain#priv_net}
  */
  readonly privNet?: boolean | cdktf.IResolvable;
  /**
  * Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#ps2 Domain#ps2}
  */
  readonly ps2?: DomainFeaturesPs2;
  /**
  * Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pv_spinlock Domain#pv_spinlock}
  */
  readonly pvSpinlock?: DomainFeaturesPvSpinlock;
  /**
  * Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#ras Domain#ras}
  */
  readonly ras?: DomainFeaturesRas;
  /**
  * Configures the Spectre-Boundary-Branch-Control (SBBC) mitigation feature for the guest CPU.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sbbc Domain#sbbc}
  */
  readonly sbbc?: DomainFeaturesSbbc;
  /**
  * Configures System Management Mode (SMM) support for the guest, which is required for features like UEFI Secure Boot on some machine types.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#smm Domain#smm}
  */
  readonly smm?: DomainFeaturesSmm;
  /**
  * Configures QEMUs TCG (software CPU emulation) feature block for fine-grained tuning of emulation behavior when TCG is in use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tcg Domain#tcg}
  */
  readonly tcg?: DomainFeaturesTcg;
  /**
  * Enables or disables the Viridian (Hyper-V enlightenment) feature block for the guest; when this presence-boolean is true the viridian feature element is emitted, otherwise it is omitted.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#viridian Domain#viridian}
  */
  readonly viridian?: boolean | cdktf.IResolvable;
  /**
  * Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vm_core_info Domain#vm_core_info}
  */
  readonly vmCoreInfo?: DomainFeaturesVmCoreInfo;
  /**
  * Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vm_port Domain#vm_port}
  */
  readonly vmPort?: DomainFeaturesVmPort;
  /**
  * Configures Xen-specific paravirtualization compatibility features for the guest when running under QEMU/KVM with Xen emulation options.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#xen Domain#xen}
  */
  readonly xen?: DomainFeaturesXen;
}

export function domainFeaturesToTerraform(struct?: DomainFeatures | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    acpi: cdktf.booleanToTerraform(struct!.acpi),
    aia: domainFeaturesAiaToTerraform(struct!.aia),
    apic: domainFeaturesApicToTerraform(struct!.apic),
    async_teardown: domainFeaturesAsyncTeardownToTerraform(struct!.asyncTeardown),
    capabilities: domainFeaturesCapabilitiesToTerraform(struct!.capabilities),
    ccf_assist: domainFeaturesCcfAssistToTerraform(struct!.ccfAssist),
    cfpc: domainFeaturesCfpcToTerraform(struct!.cfpc),
    gic: domainFeaturesGicToTerraform(struct!.gic),
    hap: domainFeaturesHapToTerraform(struct!.hap),
    hpt: domainFeaturesHptToTerraform(struct!.hpt),
    htm: domainFeaturesHtmToTerraform(struct!.htm),
    hyper_v: domainFeaturesHyperVToTerraform(struct!.hyperV),
    ibs: domainFeaturesIbsToTerraform(struct!.ibs),
    ioapic: domainFeaturesIoapicToTerraform(struct!.ioapic),
    kvm: domainFeaturesKvmToTerraform(struct!.kvm),
    msrs: domainFeaturesMsrsToTerraform(struct!.msrs),
    nested_hv: domainFeaturesNestedHvToTerraform(struct!.nestedHv),
    pae: cdktf.booleanToTerraform(struct!.pae),
    pmu: domainFeaturesPmuToTerraform(struct!.pmu),
    priv_net: cdktf.booleanToTerraform(struct!.privNet),
    ps2: domainFeaturesPs2ToTerraform(struct!.ps2),
    pv_spinlock: domainFeaturesPvSpinlockToTerraform(struct!.pvSpinlock),
    ras: domainFeaturesRasToTerraform(struct!.ras),
    sbbc: domainFeaturesSbbcToTerraform(struct!.sbbc),
    smm: domainFeaturesSmmToTerraform(struct!.smm),
    tcg: domainFeaturesTcgToTerraform(struct!.tcg),
    viridian: cdktf.booleanToTerraform(struct!.viridian),
    vm_core_info: domainFeaturesVmCoreInfoToTerraform(struct!.vmCoreInfo),
    vm_port: domainFeaturesVmPortToTerraform(struct!.vmPort),
    xen: domainFeaturesXenToTerraform(struct!.xen),
  }
}


export function domainFeaturesToHclTerraform(struct?: DomainFeatures | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    acpi: {
      value: cdktf.booleanToHclTerraform(struct!.acpi),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    aia: {
      value: domainFeaturesAiaToHclTerraform(struct!.aia),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesAia",
    },
    apic: {
      value: domainFeaturesApicToHclTerraform(struct!.apic),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesApic",
    },
    async_teardown: {
      value: domainFeaturesAsyncTeardownToHclTerraform(struct!.asyncTeardown),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesAsyncTeardown",
    },
    capabilities: {
      value: domainFeaturesCapabilitiesToHclTerraform(struct!.capabilities),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesCapabilities",
    },
    ccf_assist: {
      value: domainFeaturesCcfAssistToHclTerraform(struct!.ccfAssist),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesCcfAssist",
    },
    cfpc: {
      value: domainFeaturesCfpcToHclTerraform(struct!.cfpc),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesCfpc",
    },
    gic: {
      value: domainFeaturesGicToHclTerraform(struct!.gic),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesGic",
    },
    hap: {
      value: domainFeaturesHapToHclTerraform(struct!.hap),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesHap",
    },
    hpt: {
      value: domainFeaturesHptToHclTerraform(struct!.hpt),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesHpt",
    },
    htm: {
      value: domainFeaturesHtmToHclTerraform(struct!.htm),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesHtm",
    },
    hyper_v: {
      value: domainFeaturesHyperVToHclTerraform(struct!.hyperV),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesHyperV",
    },
    ibs: {
      value: domainFeaturesIbsToHclTerraform(struct!.ibs),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesIbs",
    },
    ioapic: {
      value: domainFeaturesIoapicToHclTerraform(struct!.ioapic),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesIoapic",
    },
    kvm: {
      value: domainFeaturesKvmToHclTerraform(struct!.kvm),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesKvm",
    },
    msrs: {
      value: domainFeaturesMsrsToHclTerraform(struct!.msrs),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesMsrs",
    },
    nested_hv: {
      value: domainFeaturesNestedHvToHclTerraform(struct!.nestedHv),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesNestedHv",
    },
    pae: {
      value: cdktf.booleanToHclTerraform(struct!.pae),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    pmu: {
      value: domainFeaturesPmuToHclTerraform(struct!.pmu),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesPmu",
    },
    priv_net: {
      value: cdktf.booleanToHclTerraform(struct!.privNet),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    ps2: {
      value: domainFeaturesPs2ToHclTerraform(struct!.ps2),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesPs2",
    },
    pv_spinlock: {
      value: domainFeaturesPvSpinlockToHclTerraform(struct!.pvSpinlock),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesPvSpinlock",
    },
    ras: {
      value: domainFeaturesRasToHclTerraform(struct!.ras),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesRas",
    },
    sbbc: {
      value: domainFeaturesSbbcToHclTerraform(struct!.sbbc),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesSbbc",
    },
    smm: {
      value: domainFeaturesSmmToHclTerraform(struct!.smm),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesSmm",
    },
    tcg: {
      value: domainFeaturesTcgToHclTerraform(struct!.tcg),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesTcg",
    },
    viridian: {
      value: cdktf.booleanToHclTerraform(struct!.viridian),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    vm_core_info: {
      value: domainFeaturesVmCoreInfoToHclTerraform(struct!.vmCoreInfo),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesVmCoreInfo",
    },
    vm_port: {
      value: domainFeaturesVmPortToHclTerraform(struct!.vmPort),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesVmPort",
    },
    xen: {
      value: domainFeaturesXenToHclTerraform(struct!.xen),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesXen",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeatures | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._acpi !== undefined) {
      hasAnyValues = true;
      internalValueResult.acpi = this._acpi;
    }
    if (this._aia?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.aia = this._aia?.internalValue;
    }
    if (this._apic?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.apic = this._apic?.internalValue;
    }
    if (this._asyncTeardown?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.asyncTeardown = this._asyncTeardown?.internalValue;
    }
    if (this._capabilities?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.capabilities = this._capabilities?.internalValue;
    }
    if (this._ccfAssist?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ccfAssist = this._ccfAssist?.internalValue;
    }
    if (this._cfpc?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cfpc = this._cfpc?.internalValue;
    }
    if (this._gic?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.gic = this._gic?.internalValue;
    }
    if (this._hap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hap = this._hap?.internalValue;
    }
    if (this._hpt?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hpt = this._hpt?.internalValue;
    }
    if (this._htm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.htm = this._htm?.internalValue;
    }
    if (this._hyperV?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hyperV = this._hyperV?.internalValue;
    }
    if (this._ibs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ibs = this._ibs?.internalValue;
    }
    if (this._ioapic?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ioapic = this._ioapic?.internalValue;
    }
    if (this._kvm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kvm = this._kvm?.internalValue;
    }
    if (this._msrs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.msrs = this._msrs?.internalValue;
    }
    if (this._nestedHv?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nestedHv = this._nestedHv?.internalValue;
    }
    if (this._pae !== undefined) {
      hasAnyValues = true;
      internalValueResult.pae = this._pae;
    }
    if (this._pmu?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pmu = this._pmu?.internalValue;
    }
    if (this._privNet !== undefined) {
      hasAnyValues = true;
      internalValueResult.privNet = this._privNet;
    }
    if (this._ps2?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ps2 = this._ps2?.internalValue;
    }
    if (this._pvSpinlock?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pvSpinlock = this._pvSpinlock?.internalValue;
    }
    if (this._ras?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ras = this._ras?.internalValue;
    }
    if (this._sbbc?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sbbc = this._sbbc?.internalValue;
    }
    if (this._smm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.smm = this._smm?.internalValue;
    }
    if (this._tcg?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tcg = this._tcg?.internalValue;
    }
    if (this._viridian !== undefined) {
      hasAnyValues = true;
      internalValueResult.viridian = this._viridian;
    }
    if (this._vmCoreInfo?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.vmCoreInfo = this._vmCoreInfo?.internalValue;
    }
    if (this._vmPort?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.vmPort = this._vmPort?.internalValue;
    }
    if (this._xen?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.xen = this._xen?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeatures | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._acpi = undefined;
      this._aia.internalValue = undefined;
      this._apic.internalValue = undefined;
      this._asyncTeardown.internalValue = undefined;
      this._capabilities.internalValue = undefined;
      this._ccfAssist.internalValue = undefined;
      this._cfpc.internalValue = undefined;
      this._gic.internalValue = undefined;
      this._hap.internalValue = undefined;
      this._hpt.internalValue = undefined;
      this._htm.internalValue = undefined;
      this._hyperV.internalValue = undefined;
      this._ibs.internalValue = undefined;
      this._ioapic.internalValue = undefined;
      this._kvm.internalValue = undefined;
      this._msrs.internalValue = undefined;
      this._nestedHv.internalValue = undefined;
      this._pae = undefined;
      this._pmu.internalValue = undefined;
      this._privNet = undefined;
      this._ps2.internalValue = undefined;
      this._pvSpinlock.internalValue = undefined;
      this._ras.internalValue = undefined;
      this._sbbc.internalValue = undefined;
      this._smm.internalValue = undefined;
      this._tcg.internalValue = undefined;
      this._viridian = undefined;
      this._vmCoreInfo.internalValue = undefined;
      this._vmPort.internalValue = undefined;
      this._xen.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._acpi = value.acpi;
      this._aia.internalValue = value.aia;
      this._apic.internalValue = value.apic;
      this._asyncTeardown.internalValue = value.asyncTeardown;
      this._capabilities.internalValue = value.capabilities;
      this._ccfAssist.internalValue = value.ccfAssist;
      this._cfpc.internalValue = value.cfpc;
      this._gic.internalValue = value.gic;
      this._hap.internalValue = value.hap;
      this._hpt.internalValue = value.hpt;
      this._htm.internalValue = value.htm;
      this._hyperV.internalValue = value.hyperV;
      this._ibs.internalValue = value.ibs;
      this._ioapic.internalValue = value.ioapic;
      this._kvm.internalValue = value.kvm;
      this._msrs.internalValue = value.msrs;
      this._nestedHv.internalValue = value.nestedHv;
      this._pae = value.pae;
      this._pmu.internalValue = value.pmu;
      this._privNet = value.privNet;
      this._ps2.internalValue = value.ps2;
      this._pvSpinlock.internalValue = value.pvSpinlock;
      this._ras.internalValue = value.ras;
      this._sbbc.internalValue = value.sbbc;
      this._smm.internalValue = value.smm;
      this._tcg.internalValue = value.tcg;
      this._viridian = value.viridian;
      this._vmCoreInfo.internalValue = value.vmCoreInfo;
      this._vmPort.internalValue = value.vmPort;
      this._xen.internalValue = value.xen;
    }
  }

  // acpi - computed: false, optional: true, required: false
  private _acpi?: boolean | cdktf.IResolvable; 
  public get acpi() {
    return this.getBooleanAttribute('acpi');
  }
  public set acpi(value: boolean | cdktf.IResolvable) {
    this._acpi = value;
  }
  public resetAcpi() {
    this._acpi = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get acpiInput() {
    return this._acpi;
  }

  // aia - computed: false, optional: true, required: false
  private _aia = new DomainFeaturesAiaOutputReference(this, "aia");
  public get aia() {
    return this._aia;
  }
  public putAia(value: DomainFeaturesAia) {
    this._aia.internalValue = value;
  }
  public resetAia() {
    this._aia.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aiaInput() {
    return this._aia.internalValue;
  }

  // apic - computed: false, optional: true, required: false
  private _apic = new DomainFeaturesApicOutputReference(this, "apic");
  public get apic() {
    return this._apic;
  }
  public putApic(value: DomainFeaturesApic) {
    this._apic.internalValue = value;
  }
  public resetApic() {
    this._apic.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apicInput() {
    return this._apic.internalValue;
  }

  // async_teardown - computed: false, optional: true, required: false
  private _asyncTeardown = new DomainFeaturesAsyncTeardownOutputReference(this, "async_teardown");
  public get asyncTeardown() {
    return this._asyncTeardown;
  }
  public putAsyncTeardown(value: DomainFeaturesAsyncTeardown) {
    this._asyncTeardown.internalValue = value;
  }
  public resetAsyncTeardown() {
    this._asyncTeardown.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asyncTeardownInput() {
    return this._asyncTeardown.internalValue;
  }

  // capabilities - computed: false, optional: true, required: false
  private _capabilities = new DomainFeaturesCapabilitiesOutputReference(this, "capabilities");
  public get capabilities() {
    return this._capabilities;
  }
  public putCapabilities(value: DomainFeaturesCapabilities) {
    this._capabilities.internalValue = value;
  }
  public resetCapabilities() {
    this._capabilities.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get capabilitiesInput() {
    return this._capabilities.internalValue;
  }

  // ccf_assist - computed: false, optional: true, required: false
  private _ccfAssist = new DomainFeaturesCcfAssistOutputReference(this, "ccf_assist");
  public get ccfAssist() {
    return this._ccfAssist;
  }
  public putCcfAssist(value: DomainFeaturesCcfAssist) {
    this._ccfAssist.internalValue = value;
  }
  public resetCcfAssist() {
    this._ccfAssist.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ccfAssistInput() {
    return this._ccfAssist.internalValue;
  }

  // cfpc - computed: false, optional: true, required: false
  private _cfpc = new DomainFeaturesCfpcOutputReference(this, "cfpc");
  public get cfpc() {
    return this._cfpc;
  }
  public putCfpc(value: DomainFeaturesCfpc) {
    this._cfpc.internalValue = value;
  }
  public resetCfpc() {
    this._cfpc.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cfpcInput() {
    return this._cfpc.internalValue;
  }

  // gic - computed: false, optional: true, required: false
  private _gic = new DomainFeaturesGicOutputReference(this, "gic");
  public get gic() {
    return this._gic;
  }
  public putGic(value: DomainFeaturesGic) {
    this._gic.internalValue = value;
  }
  public resetGic() {
    this._gic.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gicInput() {
    return this._gic.internalValue;
  }

  // hap - computed: false, optional: true, required: false
  private _hap = new DomainFeaturesHapOutputReference(this, "hap");
  public get hap() {
    return this._hap;
  }
  public putHap(value: DomainFeaturesHap) {
    this._hap.internalValue = value;
  }
  public resetHap() {
    this._hap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hapInput() {
    return this._hap.internalValue;
  }

  // hpt - computed: false, optional: true, required: false
  private _hpt = new DomainFeaturesHptOutputReference(this, "hpt");
  public get hpt() {
    return this._hpt;
  }
  public putHpt(value: DomainFeaturesHpt) {
    this._hpt.internalValue = value;
  }
  public resetHpt() {
    this._hpt.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hptInput() {
    return this._hpt.internalValue;
  }

  // htm - computed: false, optional: true, required: false
  private _htm = new DomainFeaturesHtmOutputReference(this, "htm");
  public get htm() {
    return this._htm;
  }
  public putHtm(value: DomainFeaturesHtm) {
    this._htm.internalValue = value;
  }
  public resetHtm() {
    this._htm.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get htmInput() {
    return this._htm.internalValue;
  }

  // hyper_v - computed: false, optional: true, required: false
  private _hyperV = new DomainFeaturesHyperVOutputReference(this, "hyper_v");
  public get hyperV() {
    return this._hyperV;
  }
  public putHyperV(value: DomainFeaturesHyperV) {
    this._hyperV.internalValue = value;
  }
  public resetHyperV() {
    this._hyperV.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hyperVInput() {
    return this._hyperV.internalValue;
  }

  // ibs - computed: false, optional: true, required: false
  private _ibs = new DomainFeaturesIbsOutputReference(this, "ibs");
  public get ibs() {
    return this._ibs;
  }
  public putIbs(value: DomainFeaturesIbs) {
    this._ibs.internalValue = value;
  }
  public resetIbs() {
    this._ibs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ibsInput() {
    return this._ibs.internalValue;
  }

  // ioapic - computed: false, optional: true, required: false
  private _ioapic = new DomainFeaturesIoapicOutputReference(this, "ioapic");
  public get ioapic() {
    return this._ioapic;
  }
  public putIoapic(value: DomainFeaturesIoapic) {
    this._ioapic.internalValue = value;
  }
  public resetIoapic() {
    this._ioapic.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ioapicInput() {
    return this._ioapic.internalValue;
  }

  // kvm - computed: false, optional: true, required: false
  private _kvm = new DomainFeaturesKvmOutputReference(this, "kvm");
  public get kvm() {
    return this._kvm;
  }
  public putKvm(value: DomainFeaturesKvm) {
    this._kvm.internalValue = value;
  }
  public resetKvm() {
    this._kvm.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kvmInput() {
    return this._kvm.internalValue;
  }

  // msrs - computed: false, optional: true, required: false
  private _msrs = new DomainFeaturesMsrsOutputReference(this, "msrs");
  public get msrs() {
    return this._msrs;
  }
  public putMsrs(value: DomainFeaturesMsrs) {
    this._msrs.internalValue = value;
  }
  public resetMsrs() {
    this._msrs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get msrsInput() {
    return this._msrs.internalValue;
  }

  // nested_hv - computed: false, optional: true, required: false
  private _nestedHv = new DomainFeaturesNestedHvOutputReference(this, "nested_hv");
  public get nestedHv() {
    return this._nestedHv;
  }
  public putNestedHv(value: DomainFeaturesNestedHv) {
    this._nestedHv.internalValue = value;
  }
  public resetNestedHv() {
    this._nestedHv.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nestedHvInput() {
    return this._nestedHv.internalValue;
  }

  // pae - computed: false, optional: true, required: false
  private _pae?: boolean | cdktf.IResolvable; 
  public get pae() {
    return this.getBooleanAttribute('pae');
  }
  public set pae(value: boolean | cdktf.IResolvable) {
    this._pae = value;
  }
  public resetPae() {
    this._pae = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get paeInput() {
    return this._pae;
  }

  // pmu - computed: false, optional: true, required: false
  private _pmu = new DomainFeaturesPmuOutputReference(this, "pmu");
  public get pmu() {
    return this._pmu;
  }
  public putPmu(value: DomainFeaturesPmu) {
    this._pmu.internalValue = value;
  }
  public resetPmu() {
    this._pmu.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pmuInput() {
    return this._pmu.internalValue;
  }

  // priv_net - computed: false, optional: true, required: false
  private _privNet?: boolean | cdktf.IResolvable; 
  public get privNet() {
    return this.getBooleanAttribute('priv_net');
  }
  public set privNet(value: boolean | cdktf.IResolvable) {
    this._privNet = value;
  }
  public resetPrivNet() {
    this._privNet = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privNetInput() {
    return this._privNet;
  }

  // ps2 - computed: false, optional: true, required: false
  private _ps2 = new DomainFeaturesPs2OutputReference(this, "ps2");
  public get ps2() {
    return this._ps2;
  }
  public putPs2(value: DomainFeaturesPs2) {
    this._ps2.internalValue = value;
  }
  public resetPs2() {
    this._ps2.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ps2Input() {
    return this._ps2.internalValue;
  }

  // pv_spinlock - computed: false, optional: true, required: false
  private _pvSpinlock = new DomainFeaturesPvSpinlockOutputReference(this, "pv_spinlock");
  public get pvSpinlock() {
    return this._pvSpinlock;
  }
  public putPvSpinlock(value: DomainFeaturesPvSpinlock) {
    this._pvSpinlock.internalValue = value;
  }
  public resetPvSpinlock() {
    this._pvSpinlock.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pvSpinlockInput() {
    return this._pvSpinlock.internalValue;
  }

  // ras - computed: false, optional: true, required: false
  private _ras = new DomainFeaturesRasOutputReference(this, "ras");
  public get ras() {
    return this._ras;
  }
  public putRas(value: DomainFeaturesRas) {
    this._ras.internalValue = value;
  }
  public resetRas() {
    this._ras.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rasInput() {
    return this._ras.internalValue;
  }

  // sbbc - computed: false, optional: true, required: false
  private _sbbc = new DomainFeaturesSbbcOutputReference(this, "sbbc");
  public get sbbc() {
    return this._sbbc;
  }
  public putSbbc(value: DomainFeaturesSbbc) {
    this._sbbc.internalValue = value;
  }
  public resetSbbc() {
    this._sbbc.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sbbcInput() {
    return this._sbbc.internalValue;
  }

  // smm - computed: false, optional: true, required: false
  private _smm = new DomainFeaturesSmmOutputReference(this, "smm");
  public get smm() {
    return this._smm;
  }
  public putSmm(value: DomainFeaturesSmm) {
    this._smm.internalValue = value;
  }
  public resetSmm() {
    this._smm.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get smmInput() {
    return this._smm.internalValue;
  }

  // tcg - computed: false, optional: true, required: false
  private _tcg = new DomainFeaturesTcgOutputReference(this, "tcg");
  public get tcg() {
    return this._tcg;
  }
  public putTcg(value: DomainFeaturesTcg) {
    this._tcg.internalValue = value;
  }
  public resetTcg() {
    this._tcg.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tcgInput() {
    return this._tcg.internalValue;
  }

  // viridian - computed: false, optional: true, required: false
  private _viridian?: boolean | cdktf.IResolvable; 
  public get viridian() {
    return this.getBooleanAttribute('viridian');
  }
  public set viridian(value: boolean | cdktf.IResolvable) {
    this._viridian = value;
  }
  public resetViridian() {
    this._viridian = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get viridianInput() {
    return this._viridian;
  }

  // vm_core_info - computed: false, optional: true, required: false
  private _vmCoreInfo = new DomainFeaturesVmCoreInfoOutputReference(this, "vm_core_info");
  public get vmCoreInfo() {
    return this._vmCoreInfo;
  }
  public putVmCoreInfo(value: DomainFeaturesVmCoreInfo) {
    this._vmCoreInfo.internalValue = value;
  }
  public resetVmCoreInfo() {
    this._vmCoreInfo.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vmCoreInfoInput() {
    return this._vmCoreInfo.internalValue;
  }

  // vm_port - computed: false, optional: true, required: false
  private _vmPort = new DomainFeaturesVmPortOutputReference(this, "vm_port");
  public get vmPort() {
    return this._vmPort;
  }
  public putVmPort(value: DomainFeaturesVmPort) {
    this._vmPort.internalValue = value;
  }
  public resetVmPort() {
    this._vmPort.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vmPortInput() {
    return this._vmPort.internalValue;
  }

  // xen - computed: false, optional: true, required: false
  private _xen = new DomainFeaturesXenOutputReference(this, "xen");
  public get xen() {
    return this._xen;
  }
  public putXen(value: DomainFeaturesXen) {
    this._xen.internalValue = value;
  }
  public resetXen() {
    this._xen.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get xenInput() {
    return this._xen.internalValue;
  }
}
export interface DomainIdMapGiDs {
  /**
  * Sets the number of consecutive GIDs in this mapping range; must be a positive integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#container-boot>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#count Domain#count}
  */
  readonly count: number;
  /**
  * Sets the starting guest GID for this mapping range; must be a non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#container-boot>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#start Domain#start}
  */
  readonly start: number;
  /**
  * Sets the starting host GID that the guest GIDs in this range are mapped to; must be a non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#container-boot>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#target Domain#target}
  */
  readonly target: number;
}

export function domainIdMapGiDsToTerraform(struct?: DomainIdMapGiDs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    count: cdktf.numberToTerraform(struct!.count),
    start: cdktf.numberToTerraform(struct!.start),
    target: cdktf.numberToTerraform(struct!.target),
  }
}


export function domainIdMapGiDsToHclTerraform(struct?: DomainIdMapGiDs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    count: {
      value: cdktf.numberToHclTerraform(struct!.count),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    start: {
      value: cdktf.numberToHclTerraform(struct!.start),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    target: {
      value: cdktf.numberToHclTerraform(struct!.target),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainIdMapGiDsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainIdMapGiDs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._count !== undefined) {
      hasAnyValues = true;
      internalValueResult.count = this._count;
    }
    if (this._start !== undefined) {
      hasAnyValues = true;
      internalValueResult.start = this._start;
    }
    if (this._target !== undefined) {
      hasAnyValues = true;
      internalValueResult.target = this._target;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainIdMapGiDs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._count = undefined;
      this._start = undefined;
      this._target = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._count = value.count;
      this._start = value.start;
      this._target = value.target;
    }
  }

  // count - computed: false, optional: false, required: true
  private _count?: number; 
  public get count() {
    return this.getNumberAttribute('count');
  }
  public set count(value: number) {
    this._count = value;
  }
  // Temporarily expose input value. Use with caution.
  public get countInput() {
    return this._count;
  }

  // start - computed: false, optional: false, required: true
  private _start?: number; 
  public get start() {
    return this.getNumberAttribute('start');
  }
  public set start(value: number) {
    this._start = value;
  }
  // Temporarily expose input value. Use with caution.
  public get startInput() {
    return this._start;
  }

  // target - computed: false, optional: false, required: true
  private _target?: number; 
  public get target() {
    return this.getNumberAttribute('target');
  }
  public set target(value: number) {
    this._target = value;
  }
  // Temporarily expose input value. Use with caution.
  public get targetInput() {
    return this._target;
  }
}

export class DomainIdMapGiDsList extends cdktf.ComplexList {
  public internalValue? : DomainIdMapGiDs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainIdMapGiDsOutputReference {
    return new DomainIdMapGiDsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainIdMapUiDs {
  /**
  * Sets the number of consecutive GIDs in this mapping range; must be a positive integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#container-boot>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#count Domain#count}
  */
  readonly count: number;
  /**
  * Sets the starting guest GID for this mapping range; must be a non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#container-boot>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#start Domain#start}
  */
  readonly start: number;
  /**
  * Sets the starting host GID that the guest GIDs in this range are mapped to; must be a non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#container-boot>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#target Domain#target}
  */
  readonly target: number;
}

export function domainIdMapUiDsToTerraform(struct?: DomainIdMapUiDs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    count: cdktf.numberToTerraform(struct!.count),
    start: cdktf.numberToTerraform(struct!.start),
    target: cdktf.numberToTerraform(struct!.target),
  }
}


export function domainIdMapUiDsToHclTerraform(struct?: DomainIdMapUiDs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    count: {
      value: cdktf.numberToHclTerraform(struct!.count),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    start: {
      value: cdktf.numberToHclTerraform(struct!.start),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    target: {
      value: cdktf.numberToHclTerraform(struct!.target),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainIdMapUiDsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainIdMapUiDs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._count !== undefined) {
      hasAnyValues = true;
      internalValueResult.count = this._count;
    }
    if (this._start !== undefined) {
      hasAnyValues = true;
      internalValueResult.start = this._start;
    }
    if (this._target !== undefined) {
      hasAnyValues = true;
      internalValueResult.target = this._target;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainIdMapUiDs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._count = undefined;
      this._start = undefined;
      this._target = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._count = value.count;
      this._start = value.start;
      this._target = value.target;
    }
  }

  // count - computed: false, optional: false, required: true
  private _count?: number; 
  public get count() {
    return this.getNumberAttribute('count');
  }
  public set count(value: number) {
    this._count = value;
  }
  // Temporarily expose input value. Use with caution.
  public get countInput() {
    return this._count;
  }

  // start - computed: false, optional: false, required: true
  private _start?: number; 
  public get start() {
    return this.getNumberAttribute('start');
  }
  public set start(value: number) {
    this._start = value;
  }
  // Temporarily expose input value. Use with caution.
  public get startInput() {
    return this._start;
  }

  // target - computed: false, optional: false, required: true
  private _target?: number; 
  public get target() {
    return this.getNumberAttribute('target');
  }
  public set target(value: number) {
    this._target = value;
  }
  // Temporarily expose input value. Use with caution.
  public get targetInput() {
    return this._target;
  }
}

export class DomainIdMapUiDsList extends cdktf.ComplexList {
  public internalValue? : DomainIdMapUiDs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainIdMapUiDsOutputReference {
    return new DomainIdMapUiDsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainIdMap {
  /**
  * Defines one or more guest-to-host GID mapping ranges used for ID translation; each entry specifies a contiguous gid range.
  * 
  * See: <https://libvirt.org/formatdomain.html#container-boot>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#gi_ds Domain#gi_ds}
  */
  readonly giDs?: DomainIdMapGiDs[] | cdktf.IResolvable;
  /**
  * Defines one or more guest-to-host UID mapping ranges used for ID translation; each entry specifies a contiguous uid range.
  * 
  * See: <https://libvirt.org/formatdomain.html#container-boot>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#ui_ds Domain#ui_ds}
  */
  readonly uiDs?: DomainIdMapUiDs[] | cdktf.IResolvable;
}

export function domainIdMapToTerraform(struct?: DomainIdMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    gi_ds: cdktf.listMapper(domainIdMapGiDsToTerraform, false)(struct!.giDs),
    ui_ds: cdktf.listMapper(domainIdMapUiDsToTerraform, false)(struct!.uiDs),
  }
}


export function domainIdMapToHclTerraform(struct?: DomainIdMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    gi_ds: {
      value: cdktf.listMapperHcl(domainIdMapGiDsToHclTerraform, false)(struct!.giDs),
      isBlock: true,
      type: "list",
      storageClassType: "DomainIdMapGiDsList",
    },
    ui_ds: {
      value: cdktf.listMapperHcl(domainIdMapUiDsToHclTerraform, false)(struct!.uiDs),
      isBlock: true,
      type: "list",
      storageClassType: "DomainIdMapUiDsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainIdMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainIdMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._giDs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.giDs = this._giDs?.internalValue;
    }
    if (this._uiDs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.uiDs = this._uiDs?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainIdMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._giDs.internalValue = undefined;
      this._uiDs.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._giDs.internalValue = value.giDs;
      this._uiDs.internalValue = value.uiDs;
    }
  }

  // gi_ds - computed: false, optional: true, required: false
  private _giDs = new DomainIdMapGiDsList(this, "gi_ds", false);
  public get giDs() {
    return this._giDs;
  }
  public putGiDs(value: DomainIdMapGiDs[] | cdktf.IResolvable) {
    this._giDs.internalValue = value;
  }
  public resetGiDs() {
    this._giDs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get giDsInput() {
    return this._giDs.internalValue;
  }

  // ui_ds - computed: false, optional: true, required: false
  private _uiDs = new DomainIdMapUiDsList(this, "ui_ds", false);
  public get uiDs() {
    return this._uiDs;
  }
  public putUiDs(value: DomainIdMapUiDs[] | cdktf.IResolvable) {
    this._uiDs.internalValue = value;
  }
  public resetUiDs() {
    this._uiDs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get uiDsInput() {
    return this._uiDs.internalValue;
  }
}
export interface DomainIoThreadIDsIoThreadsPoll {
  /**
  * Sets the per-IOThread poll configurations grow threshold, controlling how aggressively the IOThread poll mode ramps up; the value is user-provided (typically a nonnegative integer).
  * 
  * See: <https://libvirt.org/formatdomain.html#iothreads-allocation>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#grow Domain#grow}
  */
  readonly grow?: number;
  /**
  * Sets the maximum polling threshold for the IOThread, limiting how far the poll mode can scale; the value is user-provided (typically a nonnegative integer).
  * 
  * See: <https://libvirt.org/formatdomain.html#iothreads-allocation>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#max Domain#max}
  */
  readonly max?: number;
  /**
  * Sets the per-IOThread poll configurations shrink threshold, controlling how quickly the IOThread backs off from poll mode; the value is user-provided (typically a nonnegative integer).
  * 
  * See: <https://libvirt.org/formatdomain.html#iothreads-allocation>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#shrink Domain#shrink}
  */
  readonly shrink?: number;
}

export function domainIoThreadIDsIoThreadsPollToTerraform(struct?: DomainIoThreadIDsIoThreadsPoll | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    grow: cdktf.numberToTerraform(struct!.grow),
    max: cdktf.numberToTerraform(struct!.max),
    shrink: cdktf.numberToTerraform(struct!.shrink),
  }
}


export function domainIoThreadIDsIoThreadsPollToHclTerraform(struct?: DomainIoThreadIDsIoThreadsPoll | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    grow: {
      value: cdktf.numberToHclTerraform(struct!.grow),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max: {
      value: cdktf.numberToHclTerraform(struct!.max),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    shrink: {
      value: cdktf.numberToHclTerraform(struct!.shrink),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainIoThreadIDsIoThreadsPollOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainIoThreadIDsIoThreadsPoll | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._grow !== undefined) {
      hasAnyValues = true;
      internalValueResult.grow = this._grow;
    }
    if (this._max !== undefined) {
      hasAnyValues = true;
      internalValueResult.max = this._max;
    }
    if (this._shrink !== undefined) {
      hasAnyValues = true;
      internalValueResult.shrink = this._shrink;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainIoThreadIDsIoThreadsPoll | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._grow = undefined;
      this._max = undefined;
      this._shrink = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._grow = value.grow;
      this._max = value.max;
      this._shrink = value.shrink;
    }
  }

  // grow - computed: false, optional: true, required: false
  private _grow?: number; 
  public get grow() {
    return this.getNumberAttribute('grow');
  }
  public set grow(value: number) {
    this._grow = value;
  }
  public resetGrow() {
    this._grow = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get growInput() {
    return this._grow;
  }

  // max - computed: false, optional: true, required: false
  private _max?: number; 
  public get max() {
    return this.getNumberAttribute('max');
  }
  public set max(value: number) {
    this._max = value;
  }
  public resetMax() {
    this._max = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxInput() {
    return this._max;
  }

  // shrink - computed: false, optional: true, required: false
  private _shrink?: number; 
  public get shrink() {
    return this.getNumberAttribute('shrink');
  }
  public set shrink(value: number) {
    this._shrink = value;
  }
  public resetShrink() {
    this._shrink = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shrinkInput() {
    return this._shrink;
  }
}
export interface DomainIoThreadIDsIoThreads {
  /**
  * Sets the polling configuration for this IOThread (for example enabling or tuning busy-poll behavior); value is user-provided and must be a valid polling specification supported by libvirt/QEMU.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#poll Domain#poll}
  */
  readonly poll?: DomainIoThreadIDsIoThreadsPoll;
  /**
  * Sets the maximum size of the IOThreads internal poll thread pool via thread_pool_max; the value is userprovided (typically a positive integer).
  * 
  * See: <https://libvirt.org/formatdomain.html#iothreads-allocation>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pool_max Domain#pool_max}
  */
  readonly poolMax?: number;
  /**
  * Sets the minimum size of the IOThreads internal poll thread pool via thread_pool_min; the value is userprovided (typically a nonnegative integer).
  * 
  * See: <https://libvirt.org/formatdomain.html#iothreads-allocation>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pool_min Domain#pool_min}
  */
  readonly poolMin?: number;
}

export function domainIoThreadIDsIoThreadsToTerraform(struct?: DomainIoThreadIDsIoThreads | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    poll: domainIoThreadIDsIoThreadsPollToTerraform(struct!.poll),
    pool_max: cdktf.numberToTerraform(struct!.poolMax),
    pool_min: cdktf.numberToTerraform(struct!.poolMin),
  }
}


export function domainIoThreadIDsIoThreadsToHclTerraform(struct?: DomainIoThreadIDsIoThreads | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    poll: {
      value: domainIoThreadIDsIoThreadsPollToHclTerraform(struct!.poll),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainIoThreadIDsIoThreadsPoll",
    },
    pool_max: {
      value: cdktf.numberToHclTerraform(struct!.poolMax),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pool_min: {
      value: cdktf.numberToHclTerraform(struct!.poolMin),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainIoThreadIDsIoThreadsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainIoThreadIDsIoThreads | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._poll?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.poll = this._poll?.internalValue;
    }
    if (this._poolMax !== undefined) {
      hasAnyValues = true;
      internalValueResult.poolMax = this._poolMax;
    }
    if (this._poolMin !== undefined) {
      hasAnyValues = true;
      internalValueResult.poolMin = this._poolMin;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainIoThreadIDsIoThreads | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._poll.internalValue = undefined;
      this._poolMax = undefined;
      this._poolMin = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._poll.internalValue = value.poll;
      this._poolMax = value.poolMax;
      this._poolMin = value.poolMin;
    }
  }

  // id - computed: true, optional: false, required: false
  public get id() {
    return this.getNumberAttribute('id');
  }

  // poll - computed: false, optional: true, required: false
  private _poll = new DomainIoThreadIDsIoThreadsPollOutputReference(this, "poll");
  public get poll() {
    return this._poll;
  }
  public putPoll(value: DomainIoThreadIDsIoThreadsPoll) {
    this._poll.internalValue = value;
  }
  public resetPoll() {
    this._poll.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pollInput() {
    return this._poll.internalValue;
  }

  // pool_max - computed: false, optional: true, required: false
  private _poolMax?: number; 
  public get poolMax() {
    return this.getNumberAttribute('pool_max');
  }
  public set poolMax(value: number) {
    this._poolMax = value;
  }
  public resetPoolMax() {
    this._poolMax = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get poolMaxInput() {
    return this._poolMax;
  }

  // pool_min - computed: false, optional: true, required: false
  private _poolMin?: number; 
  public get poolMin() {
    return this.getNumberAttribute('pool_min');
  }
  public set poolMin(value: number) {
    this._poolMin = value;
  }
  public resetPoolMin() {
    this._poolMin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get poolMinInput() {
    return this._poolMin;
  }
}

export class DomainIoThreadIDsIoThreadsList extends cdktf.ComplexList {
  public internalValue? : DomainIoThreadIDsIoThreads[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainIoThreadIDsIoThreadsOutputReference {
    return new DomainIoThreadIDsIoThreadsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainIoThreadIDs {
  /**
  * Defines an individual IOThread entry within the IOThread ID set, optionally with per-thread tuning such as polling.
  * 
  * See: <https://libvirt.org/formatdomain.html#iothreads-allocation>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#io_threads Domain#io_threads}
  */
  readonly ioThreads?: DomainIoThreadIDsIoThreads[] | cdktf.IResolvable;
}

export function domainIoThreadIDsToTerraform(struct?: DomainIoThreadIDs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    io_threads: cdktf.listMapper(domainIoThreadIDsIoThreadsToTerraform, false)(struct!.ioThreads),
  }
}


export function domainIoThreadIDsToHclTerraform(struct?: DomainIoThreadIDs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    io_threads: {
      value: cdktf.listMapperHcl(domainIoThreadIDsIoThreadsToHclTerraform, false)(struct!.ioThreads),
      isBlock: true,
      type: "list",
      storageClassType: "DomainIoThreadIDsIoThreadsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainIoThreadIDsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainIoThreadIDs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ioThreads?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ioThreads = this._ioThreads?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainIoThreadIDs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ioThreads.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ioThreads.internalValue = value.ioThreads;
    }
  }

  // io_threads - computed: false, optional: true, required: false
  private _ioThreads = new DomainIoThreadIDsIoThreadsList(this, "io_threads", false);
  public get ioThreads() {
    return this._ioThreads;
  }
  public putIoThreads(value: DomainIoThreadIDsIoThreads[] | cdktf.IResolvable) {
    this._ioThreads.internalValue = value;
  }
  public resetIoThreads() {
    this._ioThreads.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ioThreadsInput() {
    return this._ioThreads.internalValue;
  }
}
export interface DomainKeyWrapCiphers {
  /**
  * Sets the cipher name used for s390 key-wrapping, typically aes or dea; the value is required and must match a cipher supported by the host/firmware.
  * 
  * See: <https://libvirt.org/formatdomain.html#key-wrap>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
  /**
  * Sets whether the given key-wrap cipher is enabled or disabled, using the required values "on" or "off".
  * 
  * See: <https://libvirt.org/formatdomain.html#key-wrap>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state: string;
}

export function domainKeyWrapCiphersToTerraform(struct?: DomainKeyWrapCiphers | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainKeyWrapCiphersToHclTerraform(struct?: DomainKeyWrapCiphers | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainKeyWrapCiphersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainKeyWrapCiphers | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainKeyWrapCiphers | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._state = value.state;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // state - computed: false, optional: false, required: true
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}

export class DomainKeyWrapCiphersList extends cdktf.ComplexList {
  public internalValue? : DomainKeyWrapCiphers[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainKeyWrapCiphersOutputReference {
    return new DomainKeyWrapCiphersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainKeyWrap {
  /**
  * Defines one or more ciphers that can be used for s390 key-wrapping operations, each with its own name and enable/disable state.
  * 
  * See: <https://libvirt.org/formatdomain.html#key-wrap>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#ciphers Domain#ciphers}
  */
  readonly ciphers?: DomainKeyWrapCiphers[] | cdktf.IResolvable;
}

export function domainKeyWrapToTerraform(struct?: DomainKeyWrap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ciphers: cdktf.listMapper(domainKeyWrapCiphersToTerraform, false)(struct!.ciphers),
  }
}


export function domainKeyWrapToHclTerraform(struct?: DomainKeyWrap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ciphers: {
      value: cdktf.listMapperHcl(domainKeyWrapCiphersToHclTerraform, false)(struct!.ciphers),
      isBlock: true,
      type: "list",
      storageClassType: "DomainKeyWrapCiphersList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainKeyWrapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainKeyWrap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ciphers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ciphers = this._ciphers?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainKeyWrap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ciphers.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ciphers.internalValue = value.ciphers;
    }
  }

  // ciphers - computed: false, optional: true, required: false
  private _ciphers = new DomainKeyWrapCiphersList(this, "ciphers", false);
  public get ciphers() {
    return this._ciphers;
  }
  public putCiphers(value: DomainKeyWrapCiphers[] | cdktf.IResolvable) {
    this._ciphers.internalValue = value;
  }
  public resetCiphers() {
    this._ciphers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ciphersInput() {
    return this._ciphers.internalValue;
  }
}
export interface DomainLaunchSecuritySev {
  /**
  * Sets the Cbit position for AMD SEV, indicating which guest-physical address bit marks encrypted memory; the value is userprovided (typically an integer matching host configuration).
  * 
  * See: <https://libvirt.org/formatdomain.html#launch-security>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#cbit_pos Domain#cbit_pos}
  */
  readonly cbitPos?: number;
  /**
  * Provides the required DiffieHellman certificate blob for establishing an SEV launch session; the value is userprovided (e.g., base64 or binary content as required by the SEV tooling).
  * 
  * See: <https://libvirt.org/formatdomain.html#launch-security>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dh_cert Domain#dh_cert}
  */
  readonly dhCert: string;
  /**
  * Enables or disables validation of kernel hashes for SEV by specifying a kernelHashes attribute value; the value is userprovided (commonly "yes"/"no" or an implementation-defined flag).
  * 
  * See: <https://libvirt.org/formatdomain.html#launch-security>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#kernel_hashes Domain#kernel_hashes}
  */
  readonly kernelHashes?: string;
  /**
  * Sets the SEV policy value controlling allowed guest behaviors (e.g., debugging, migration); the value is userprovided, often as a bitmask or integer from SEV documentation.
  * 
  * See: <https://libvirt.org/formatdomain.html#launch-security>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#policy Domain#policy}
  */
  readonly policy?: number;
  /**
  * Sets the number of reduced physical address bits for SEV, aligning guest addressing with host SEV constraints; the value is userprovided (typically an integer).
  * 
  * See: <https://libvirt.org/formatdomain.html#launch-security>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reduced_phys_bits Domain#reduced_phys_bits}
  */
  readonly reducedPhysBits?: number;
  /**
  * Provides the required SEV session blob (e.g., launch session parameters or ticket) used to establish a protected guest; the value is userprovided according to SEV tooling.
  * 
  * See: <https://libvirt.org/formatdomain.html#launch-security>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#session Domain#session}
  */
  readonly session: string;
}

export function domainLaunchSecuritySevToTerraform(struct?: DomainLaunchSecuritySev | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cbit_pos: cdktf.numberToTerraform(struct!.cbitPos),
    dh_cert: cdktf.stringToTerraform(struct!.dhCert),
    kernel_hashes: cdktf.stringToTerraform(struct!.kernelHashes),
    policy: cdktf.numberToTerraform(struct!.policy),
    reduced_phys_bits: cdktf.numberToTerraform(struct!.reducedPhysBits),
    session: cdktf.stringToTerraform(struct!.session),
  }
}


export function domainLaunchSecuritySevToHclTerraform(struct?: DomainLaunchSecuritySev | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cbit_pos: {
      value: cdktf.numberToHclTerraform(struct!.cbitPos),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    dh_cert: {
      value: cdktf.stringToHclTerraform(struct!.dhCert),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kernel_hashes: {
      value: cdktf.stringToHclTerraform(struct!.kernelHashes),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    policy: {
      value: cdktf.numberToHclTerraform(struct!.policy),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    reduced_phys_bits: {
      value: cdktf.numberToHclTerraform(struct!.reducedPhysBits),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    session: {
      value: cdktf.stringToHclTerraform(struct!.session),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainLaunchSecuritySevOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainLaunchSecuritySev | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cbitPos !== undefined) {
      hasAnyValues = true;
      internalValueResult.cbitPos = this._cbitPos;
    }
    if (this._dhCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.dhCert = this._dhCert;
    }
    if (this._kernelHashes !== undefined) {
      hasAnyValues = true;
      internalValueResult.kernelHashes = this._kernelHashes;
    }
    if (this._policy !== undefined) {
      hasAnyValues = true;
      internalValueResult.policy = this._policy;
    }
    if (this._reducedPhysBits !== undefined) {
      hasAnyValues = true;
      internalValueResult.reducedPhysBits = this._reducedPhysBits;
    }
    if (this._session !== undefined) {
      hasAnyValues = true;
      internalValueResult.session = this._session;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainLaunchSecuritySev | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cbitPos = undefined;
      this._dhCert = undefined;
      this._kernelHashes = undefined;
      this._policy = undefined;
      this._reducedPhysBits = undefined;
      this._session = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cbitPos = value.cbitPos;
      this._dhCert = value.dhCert;
      this._kernelHashes = value.kernelHashes;
      this._policy = value.policy;
      this._reducedPhysBits = value.reducedPhysBits;
      this._session = value.session;
    }
  }

  // cbit_pos - computed: false, optional: true, required: false
  private _cbitPos?: number; 
  public get cbitPos() {
    return this.getNumberAttribute('cbit_pos');
  }
  public set cbitPos(value: number) {
    this._cbitPos = value;
  }
  public resetCbitPos() {
    this._cbitPos = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cbitPosInput() {
    return this._cbitPos;
  }

  // dh_cert - computed: false, optional: false, required: true
  private _dhCert?: string; 
  public get dhCert() {
    return this.getStringAttribute('dh_cert');
  }
  public set dhCert(value: string) {
    this._dhCert = value;
  }
  // Temporarily expose input value. Use with caution.
  public get dhCertInput() {
    return this._dhCert;
  }

  // kernel_hashes - computed: false, optional: true, required: false
  private _kernelHashes?: string; 
  public get kernelHashes() {
    return this.getStringAttribute('kernel_hashes');
  }
  public set kernelHashes(value: string) {
    this._kernelHashes = value;
  }
  public resetKernelHashes() {
    this._kernelHashes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kernelHashesInput() {
    return this._kernelHashes;
  }

  // policy - computed: false, optional: true, required: false
  private _policy?: number; 
  public get policy() {
    return this.getNumberAttribute('policy');
  }
  public set policy(value: number) {
    this._policy = value;
  }
  public resetPolicy() {
    this._policy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get policyInput() {
    return this._policy;
  }

  // reduced_phys_bits - computed: false, optional: true, required: false
  private _reducedPhysBits?: number; 
  public get reducedPhysBits() {
    return this.getNumberAttribute('reduced_phys_bits');
  }
  public set reducedPhysBits(value: number) {
    this._reducedPhysBits = value;
  }
  public resetReducedPhysBits() {
    this._reducedPhysBits = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reducedPhysBitsInput() {
    return this._reducedPhysBits;
  }

  // session - computed: false, optional: false, required: true
  private _session?: string; 
  public get session() {
    return this.getStringAttribute('session');
  }
  public set session(value: string) {
    this._session = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sessionInput() {
    return this._session;
  }
}
export interface DomainLaunchSecuritySevsnp {
  /**
  * Sets the SEV-SNP author key blob used to validate the guests identity when SEV-SNP launch security is enabled; the value is user-provided binary data (typically base64-encoded).
  * 
  * See: <https://libvirt.org/formatdomain.html#launch-security>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#author_key Domain#author_key}
  */
  readonly authorKey?: string;
  /**
  * Sets the SEV-SNP C-bit position (cbitpos) indicating which guest-physical address bit marks encrypted memory; value is user-provided and must match the host SEV-SNP configuration.
  * 
  * See: <https://libvirt.org/formatdomain.html#launch-security>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#cbit_pos Domain#cbit_pos}
  */
  readonly cbitPos?: number;
  /**
  * Sets the SEV-SNP guestVisibleWorkarounds flag or bitmap controlling which SEV-SNP hardware or microcode workarounds are exposed to the guest; value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#launch-security>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#guest_visible_workarounds Domain#guest_visible_workarounds}
  */
  readonly guestVisibleWorkarounds?: string;
  /**
  * Provides an optional SEV-SNP hostData blob passed into the SEV-SNP launch flow for attestation purposes; the value is user-provided binary data (commonly base64-encoded).
  * 
  * See: <https://libvirt.org/formatdomain.html#launch-security>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#host_data Domain#host_data}
  */
  readonly hostData?: string;
  /**
  * Supplies the SEV-SNP idAuth structure used to authenticate the guests identity as part of the SEV-SNP launch; value is user-provided binary data from the SEV tooling.
  * 
  * See: <https://libvirt.org/formatdomain.html#launch-security>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#id_auth Domain#id_auth}
  */
  readonly idAuth?: string;
  /**
  * Supplies the SEV-SNP idBlock structure defining the guest identity and policy for SEV-SNP launch; value is user-provided binary data from the SEV tooling.
  * 
  * See: <https://libvirt.org/formatdomain.html#launch-security>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#id_block Domain#id_block}
  */
  readonly idBlock?: string;
  /**
  * Points to a file containing kernel hash metadata for SEV-SNP attestation when SEV-SNP launch security is enabled; value is a user-provided path string.
  * 
  * See: <https://libvirt.org/formatdomain.html#launch-security>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#kernel_hashes Domain#kernel_hashes}
  */
  readonly kernelHashes?: string;
  /**
  * Sets the SEV-SNP guest policy value (bitfield) governing allowed debug, migration, and other behaviors; value is user-provided, commonly expressed as an integer or hex string.
  * 
  * See: <https://libvirt.org/formatdomain.html#launch-security>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#policy Domain#policy}
  */
  readonly policy?: number;
  /**
  * Sets the number of reduced physical address bits (reducedPhysBits) for SEV-SNP, matching the host configuration; value is a user-provided non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#launch-security>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reduced_phys_bits Domain#reduced_phys_bits}
  */
  readonly reducedPhysBits?: number;
  /**
  * Points to a file with the SEV-SNP VCEK (Versioned Chip Endorsement Key) certificate used for attestation; value is a user-provided path string.
  * 
  * See: <https://libvirt.org/formatdomain.html#launch-security>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vcek Domain#vcek}
  */
  readonly vcek?: string;
}

export function domainLaunchSecuritySevsnpToTerraform(struct?: DomainLaunchSecuritySevsnp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    author_key: cdktf.stringToTerraform(struct!.authorKey),
    cbit_pos: cdktf.numberToTerraform(struct!.cbitPos),
    guest_visible_workarounds: cdktf.stringToTerraform(struct!.guestVisibleWorkarounds),
    host_data: cdktf.stringToTerraform(struct!.hostData),
    id_auth: cdktf.stringToTerraform(struct!.idAuth),
    id_block: cdktf.stringToTerraform(struct!.idBlock),
    kernel_hashes: cdktf.stringToTerraform(struct!.kernelHashes),
    policy: cdktf.numberToTerraform(struct!.policy),
    reduced_phys_bits: cdktf.numberToTerraform(struct!.reducedPhysBits),
    vcek: cdktf.stringToTerraform(struct!.vcek),
  }
}


export function domainLaunchSecuritySevsnpToHclTerraform(struct?: DomainLaunchSecuritySevsnp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    author_key: {
      value: cdktf.stringToHclTerraform(struct!.authorKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cbit_pos: {
      value: cdktf.numberToHclTerraform(struct!.cbitPos),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    guest_visible_workarounds: {
      value: cdktf.stringToHclTerraform(struct!.guestVisibleWorkarounds),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host_data: {
      value: cdktf.stringToHclTerraform(struct!.hostData),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id_auth: {
      value: cdktf.stringToHclTerraform(struct!.idAuth),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id_block: {
      value: cdktf.stringToHclTerraform(struct!.idBlock),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kernel_hashes: {
      value: cdktf.stringToHclTerraform(struct!.kernelHashes),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    policy: {
      value: cdktf.numberToHclTerraform(struct!.policy),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    reduced_phys_bits: {
      value: cdktf.numberToHclTerraform(struct!.reducedPhysBits),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    vcek: {
      value: cdktf.stringToHclTerraform(struct!.vcek),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainLaunchSecuritySevsnpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainLaunchSecuritySevsnp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authorKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.authorKey = this._authorKey;
    }
    if (this._cbitPos !== undefined) {
      hasAnyValues = true;
      internalValueResult.cbitPos = this._cbitPos;
    }
    if (this._guestVisibleWorkarounds !== undefined) {
      hasAnyValues = true;
      internalValueResult.guestVisibleWorkarounds = this._guestVisibleWorkarounds;
    }
    if (this._hostData !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostData = this._hostData;
    }
    if (this._idAuth !== undefined) {
      hasAnyValues = true;
      internalValueResult.idAuth = this._idAuth;
    }
    if (this._idBlock !== undefined) {
      hasAnyValues = true;
      internalValueResult.idBlock = this._idBlock;
    }
    if (this._kernelHashes !== undefined) {
      hasAnyValues = true;
      internalValueResult.kernelHashes = this._kernelHashes;
    }
    if (this._policy !== undefined) {
      hasAnyValues = true;
      internalValueResult.policy = this._policy;
    }
    if (this._reducedPhysBits !== undefined) {
      hasAnyValues = true;
      internalValueResult.reducedPhysBits = this._reducedPhysBits;
    }
    if (this._vcek !== undefined) {
      hasAnyValues = true;
      internalValueResult.vcek = this._vcek;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainLaunchSecuritySevsnp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authorKey = undefined;
      this._cbitPos = undefined;
      this._guestVisibleWorkarounds = undefined;
      this._hostData = undefined;
      this._idAuth = undefined;
      this._idBlock = undefined;
      this._kernelHashes = undefined;
      this._policy = undefined;
      this._reducedPhysBits = undefined;
      this._vcek = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authorKey = value.authorKey;
      this._cbitPos = value.cbitPos;
      this._guestVisibleWorkarounds = value.guestVisibleWorkarounds;
      this._hostData = value.hostData;
      this._idAuth = value.idAuth;
      this._idBlock = value.idBlock;
      this._kernelHashes = value.kernelHashes;
      this._policy = value.policy;
      this._reducedPhysBits = value.reducedPhysBits;
      this._vcek = value.vcek;
    }
  }

  // author_key - computed: false, optional: true, required: false
  private _authorKey?: string; 
  public get authorKey() {
    return this.getStringAttribute('author_key');
  }
  public set authorKey(value: string) {
    this._authorKey = value;
  }
  public resetAuthorKey() {
    this._authorKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorKeyInput() {
    return this._authorKey;
  }

  // cbit_pos - computed: false, optional: true, required: false
  private _cbitPos?: number; 
  public get cbitPos() {
    return this.getNumberAttribute('cbit_pos');
  }
  public set cbitPos(value: number) {
    this._cbitPos = value;
  }
  public resetCbitPos() {
    this._cbitPos = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cbitPosInput() {
    return this._cbitPos;
  }

  // guest_visible_workarounds - computed: false, optional: true, required: false
  private _guestVisibleWorkarounds?: string; 
  public get guestVisibleWorkarounds() {
    return this.getStringAttribute('guest_visible_workarounds');
  }
  public set guestVisibleWorkarounds(value: string) {
    this._guestVisibleWorkarounds = value;
  }
  public resetGuestVisibleWorkarounds() {
    this._guestVisibleWorkarounds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get guestVisibleWorkaroundsInput() {
    return this._guestVisibleWorkarounds;
  }

  // host_data - computed: false, optional: true, required: false
  private _hostData?: string; 
  public get hostData() {
    return this.getStringAttribute('host_data');
  }
  public set hostData(value: string) {
    this._hostData = value;
  }
  public resetHostData() {
    this._hostData = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostDataInput() {
    return this._hostData;
  }

  // id_auth - computed: false, optional: true, required: false
  private _idAuth?: string; 
  public get idAuth() {
    return this.getStringAttribute('id_auth');
  }
  public set idAuth(value: string) {
    this._idAuth = value;
  }
  public resetIdAuth() {
    this._idAuth = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idAuthInput() {
    return this._idAuth;
  }

  // id_block - computed: false, optional: true, required: false
  private _idBlock?: string; 
  public get idBlock() {
    return this.getStringAttribute('id_block');
  }
  public set idBlock(value: string) {
    this._idBlock = value;
  }
  public resetIdBlock() {
    this._idBlock = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idBlockInput() {
    return this._idBlock;
  }

  // kernel_hashes - computed: false, optional: true, required: false
  private _kernelHashes?: string; 
  public get kernelHashes() {
    return this.getStringAttribute('kernel_hashes');
  }
  public set kernelHashes(value: string) {
    this._kernelHashes = value;
  }
  public resetKernelHashes() {
    this._kernelHashes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kernelHashesInput() {
    return this._kernelHashes;
  }

  // policy - computed: false, optional: true, required: false
  private _policy?: number; 
  public get policy() {
    return this.getNumberAttribute('policy');
  }
  public set policy(value: number) {
    this._policy = value;
  }
  public resetPolicy() {
    this._policy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get policyInput() {
    return this._policy;
  }

  // reduced_phys_bits - computed: false, optional: true, required: false
  private _reducedPhysBits?: number; 
  public get reducedPhysBits() {
    return this.getNumberAttribute('reduced_phys_bits');
  }
  public set reducedPhysBits(value: number) {
    this._reducedPhysBits = value;
  }
  public resetReducedPhysBits() {
    this._reducedPhysBits = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reducedPhysBitsInput() {
    return this._reducedPhysBits;
  }

  // vcek - computed: false, optional: true, required: false
  private _vcek?: string; 
  public get vcek() {
    return this.getStringAttribute('vcek');
  }
  public set vcek(value: string) {
    this._vcek = value;
  }
  public resetVcek() {
    this._vcek = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vcekInput() {
    return this._vcek;
  }
}
export interface DomainLaunchSecurityTdxQuoteGenerationService {
  /**
  * Sets the path used by the TDX quote generation service (for example, a socket or device path) for obtaining attestation quotes; value is a user-provided string.
  * 
  * See: <https://libvirt.org/formatdomain.html#launch-security>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path?: string;
}

export function domainLaunchSecurityTdxQuoteGenerationServiceToTerraform(struct?: DomainLaunchSecurityTdxQuoteGenerationService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function domainLaunchSecurityTdxQuoteGenerationServiceToHclTerraform(struct?: DomainLaunchSecurityTdxQuoteGenerationService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainLaunchSecurityTdxQuoteGenerationServiceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainLaunchSecurityTdxQuoteGenerationService | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainLaunchSecurityTdxQuoteGenerationService | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
    }
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface DomainLaunchSecurityTdx {
  /**
  * Sets the TDX mrConfigId measurement value representing the guest configuration identity; value is user-provided binary/hex data from the TDX tooling.
  * 
  * See: <https://libvirt.org/formatdomain.html#launch-security>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mr_config_id Domain#mr_config_id}
  */
  readonly mrConfigId?: string;
  /**
  * Sets the TDX mrOwner measurement value representing the owner of the guest; value is user-provided binary/hex data from the TDX tooling.
  * 
  * See: <https://libvirt.org/formatdomain.html#launch-security>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mr_owner Domain#mr_owner}
  */
  readonly mrOwner?: string;
  /**
  * Sets the TDX mrOwnerConfig measurement value describing the owner-specific configuration; value is user-provided binary/hex data from the TDX tooling.
  * 
  * See: <https://libvirt.org/formatdomain.html#launch-security>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mr_owner_config Domain#mr_owner_config}
  */
  readonly mrOwnerConfig?: string;
  /**
  * Sets the TDX guest policy bitfield controlling allowed operations (such as debug or migration); value is user-provided, typically as an integer or hex string.
  * 
  * See: <https://libvirt.org/formatdomain.html#launch-security>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#policy Domain#policy}
  */
  readonly policy?: number;
  /**
  * Configures an optional TDX quoteGenerationService, which specifies how attestation quotes are generated for the guest; child attributes further describe the service endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#quote_generation_service Domain#quote_generation_service}
  */
  readonly quoteGenerationService?: DomainLaunchSecurityTdxQuoteGenerationService;
}

export function domainLaunchSecurityTdxToTerraform(struct?: DomainLaunchSecurityTdx | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mr_config_id: cdktf.stringToTerraform(struct!.mrConfigId),
    mr_owner: cdktf.stringToTerraform(struct!.mrOwner),
    mr_owner_config: cdktf.stringToTerraform(struct!.mrOwnerConfig),
    policy: cdktf.numberToTerraform(struct!.policy),
    quote_generation_service: domainLaunchSecurityTdxQuoteGenerationServiceToTerraform(struct!.quoteGenerationService),
  }
}


export function domainLaunchSecurityTdxToHclTerraform(struct?: DomainLaunchSecurityTdx | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mr_config_id: {
      value: cdktf.stringToHclTerraform(struct!.mrConfigId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mr_owner: {
      value: cdktf.stringToHclTerraform(struct!.mrOwner),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mr_owner_config: {
      value: cdktf.stringToHclTerraform(struct!.mrOwnerConfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    policy: {
      value: cdktf.numberToHclTerraform(struct!.policy),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    quote_generation_service: {
      value: domainLaunchSecurityTdxQuoteGenerationServiceToHclTerraform(struct!.quoteGenerationService),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainLaunchSecurityTdxQuoteGenerationService",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainLaunchSecurityTdxOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainLaunchSecurityTdx | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mrConfigId !== undefined) {
      hasAnyValues = true;
      internalValueResult.mrConfigId = this._mrConfigId;
    }
    if (this._mrOwner !== undefined) {
      hasAnyValues = true;
      internalValueResult.mrOwner = this._mrOwner;
    }
    if (this._mrOwnerConfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.mrOwnerConfig = this._mrOwnerConfig;
    }
    if (this._policy !== undefined) {
      hasAnyValues = true;
      internalValueResult.policy = this._policy;
    }
    if (this._quoteGenerationService?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.quoteGenerationService = this._quoteGenerationService?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainLaunchSecurityTdx | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mrConfigId = undefined;
      this._mrOwner = undefined;
      this._mrOwnerConfig = undefined;
      this._policy = undefined;
      this._quoteGenerationService.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mrConfigId = value.mrConfigId;
      this._mrOwner = value.mrOwner;
      this._mrOwnerConfig = value.mrOwnerConfig;
      this._policy = value.policy;
      this._quoteGenerationService.internalValue = value.quoteGenerationService;
    }
  }

  // mr_config_id - computed: false, optional: true, required: false
  private _mrConfigId?: string; 
  public get mrConfigId() {
    return this.getStringAttribute('mr_config_id');
  }
  public set mrConfigId(value: string) {
    this._mrConfigId = value;
  }
  public resetMrConfigId() {
    this._mrConfigId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mrConfigIdInput() {
    return this._mrConfigId;
  }

  // mr_owner - computed: false, optional: true, required: false
  private _mrOwner?: string; 
  public get mrOwner() {
    return this.getStringAttribute('mr_owner');
  }
  public set mrOwner(value: string) {
    this._mrOwner = value;
  }
  public resetMrOwner() {
    this._mrOwner = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mrOwnerInput() {
    return this._mrOwner;
  }

  // mr_owner_config - computed: false, optional: true, required: false
  private _mrOwnerConfig?: string; 
  public get mrOwnerConfig() {
    return this.getStringAttribute('mr_owner_config');
  }
  public set mrOwnerConfig(value: string) {
    this._mrOwnerConfig = value;
  }
  public resetMrOwnerConfig() {
    this._mrOwnerConfig = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mrOwnerConfigInput() {
    return this._mrOwnerConfig;
  }

  // policy - computed: false, optional: true, required: false
  private _policy?: number; 
  public get policy() {
    return this.getNumberAttribute('policy');
  }
  public set policy(value: number) {
    this._policy = value;
  }
  public resetPolicy() {
    this._policy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get policyInput() {
    return this._policy;
  }

  // quote_generation_service - computed: false, optional: true, required: false
  private _quoteGenerationService = new DomainLaunchSecurityTdxQuoteGenerationServiceOutputReference(this, "quote_generation_service");
  public get quoteGenerationService() {
    return this._quoteGenerationService;
  }
  public putQuoteGenerationService(value: DomainLaunchSecurityTdxQuoteGenerationService) {
    this._quoteGenerationService.internalValue = value;
  }
  public resetQuoteGenerationService() {
    this._quoteGenerationService.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get quoteGenerationServiceInput() {
    return this._quoteGenerationService.internalValue;
  }
}
export interface DomainLaunchSecurity {
  /**
  * Enables s390 protected virtualization (IBM Secure Execution) for the domain when set to true; if absent/false, s390pv launch security is not configured.
  * 
  * See: <https://libvirt.org/formatdomain.html#launch-security>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#s390pv Domain#s390pv}
  */
  readonly s390Pv?: boolean | cdktf.IResolvable;
  /**
  * Configures AMD SEV launch security parameters for the domain, such as policy, certificates, and reduced physical address bits.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sev Domain#sev}
  */
  readonly sev?: DomainLaunchSecuritySev;
  /**
  * Configures AMD SEV-SNP launch security parameters for the domain, extending SEV with additional integrity and security features; the subfields (if any) are userprovided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sevsnp Domain#sevsnp}
  */
  readonly sevsnp?: DomainLaunchSecuritySevsnp;
  /**
  * Enables Intel TDX launch security configuration for the domain and groups all TDX-specific measurement and policy options; presence configures the domain to run as a TDX guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tdx Domain#tdx}
  */
  readonly tdx?: DomainLaunchSecurityTdx;
}

export function domainLaunchSecurityToTerraform(struct?: DomainLaunchSecurity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    s390pv: cdktf.booleanToTerraform(struct!.s390Pv),
    sev: domainLaunchSecuritySevToTerraform(struct!.sev),
    sevsnp: domainLaunchSecuritySevsnpToTerraform(struct!.sevsnp),
    tdx: domainLaunchSecurityTdxToTerraform(struct!.tdx),
  }
}


export function domainLaunchSecurityToHclTerraform(struct?: DomainLaunchSecurity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    s390pv: {
      value: cdktf.booleanToHclTerraform(struct!.s390Pv),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    sev: {
      value: domainLaunchSecuritySevToHclTerraform(struct!.sev),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainLaunchSecuritySev",
    },
    sevsnp: {
      value: domainLaunchSecuritySevsnpToHclTerraform(struct!.sevsnp),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainLaunchSecuritySevsnp",
    },
    tdx: {
      value: domainLaunchSecurityTdxToHclTerraform(struct!.tdx),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainLaunchSecurityTdx",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainLaunchSecurityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainLaunchSecurity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._s390Pv !== undefined) {
      hasAnyValues = true;
      internalValueResult.s390Pv = this._s390Pv;
    }
    if (this._sev?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sev = this._sev?.internalValue;
    }
    if (this._sevsnp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sevsnp = this._sevsnp?.internalValue;
    }
    if (this._tdx?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tdx = this._tdx?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainLaunchSecurity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._s390Pv = undefined;
      this._sev.internalValue = undefined;
      this._sevsnp.internalValue = undefined;
      this._tdx.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._s390Pv = value.s390Pv;
      this._sev.internalValue = value.sev;
      this._sevsnp.internalValue = value.sevsnp;
      this._tdx.internalValue = value.tdx;
    }
  }

  // s390pv - computed: false, optional: true, required: false
  private _s390Pv?: boolean | cdktf.IResolvable; 
  public get s390Pv() {
    return this.getBooleanAttribute('s390pv');
  }
  public set s390Pv(value: boolean | cdktf.IResolvable) {
    this._s390Pv = value;
  }
  public resetS390Pv() {
    this._s390Pv = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get s390PvInput() {
    return this._s390Pv;
  }

  // sev - computed: false, optional: true, required: false
  private _sev = new DomainLaunchSecuritySevOutputReference(this, "sev");
  public get sev() {
    return this._sev;
  }
  public putSev(value: DomainLaunchSecuritySev) {
    this._sev.internalValue = value;
  }
  public resetSev() {
    this._sev.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sevInput() {
    return this._sev.internalValue;
  }

  // sevsnp - computed: false, optional: true, required: false
  private _sevsnp = new DomainLaunchSecuritySevsnpOutputReference(this, "sevsnp");
  public get sevsnp() {
    return this._sevsnp;
  }
  public putSevsnp(value: DomainLaunchSecuritySevsnp) {
    this._sevsnp.internalValue = value;
  }
  public resetSevsnp() {
    this._sevsnp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sevsnpInput() {
    return this._sevsnp.internalValue;
  }

  // tdx - computed: false, optional: true, required: false
  private _tdx = new DomainLaunchSecurityTdxOutputReference(this, "tdx");
  public get tdx() {
    return this._tdx;
  }
  public putTdx(value: DomainLaunchSecurityTdx) {
    this._tdx.internalValue = value;
  }
  public resetTdx() {
    this._tdx.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tdxInput() {
    return this._tdx.internalValue;
  }
}
export interface DomainMemoryBackingMemoryAccess {
  /**
  * Sets the memory access mode; the value is user-provided and must be one of the modes supported by libvirt for memoryBacking access (for example, platformspecific NUMA access modes).
  * 
  * See: <https://libvirt.org/formatdomain.html#memory-backing>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode?: string;
}

export function domainMemoryBackingMemoryAccessToTerraform(struct?: DomainMemoryBackingMemoryAccess | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
  }
}


export function domainMemoryBackingMemoryAccessToHclTerraform(struct?: DomainMemoryBackingMemoryAccess | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainMemoryBackingMemoryAccessOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainMemoryBackingMemoryAccess | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainMemoryBackingMemoryAccess | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
    }
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }
}
export interface DomainMemoryBackingMemoryAllocation {
  /**
  * Sets the allocation mode for backing memory; the value is user-provided and must be one of the modes supported by libvirt (for example, immediate vs. ondemand allocation depending on hypervisor support).
  * 
  * See: <https://libvirt.org/formatdomain.html#memory-backing>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode?: string;
  /**
  * Specifies the number of threads to use when performing the chosen memory allocation mode; the value is a user-provided positive integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#memory-backing>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#threads Domain#threads}
  */
  readonly threads?: number;
}

export function domainMemoryBackingMemoryAllocationToTerraform(struct?: DomainMemoryBackingMemoryAllocation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
    threads: cdktf.numberToTerraform(struct!.threads),
  }
}


export function domainMemoryBackingMemoryAllocationToHclTerraform(struct?: DomainMemoryBackingMemoryAllocation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    threads: {
      value: cdktf.numberToHclTerraform(struct!.threads),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainMemoryBackingMemoryAllocationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainMemoryBackingMemoryAllocation | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._threads !== undefined) {
      hasAnyValues = true;
      internalValueResult.threads = this._threads;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainMemoryBackingMemoryAllocation | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
      this._threads = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
      this._threads = value.threads;
    }
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // threads - computed: false, optional: true, required: false
  private _threads?: number; 
  public get threads() {
    return this.getNumberAttribute('threads');
  }
  public set threads(value: number) {
    this._threads = value;
  }
  public resetThreads() {
    this._threads = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get threadsInput() {
    return this._threads;
  }
}
export interface DomainMemoryBackingMemoryHugePagesHugepages {
  /**
  * Restricts use of this huge page size to a specific NUMA node set; the value is user-provided and follows libvirt nodeset syntax (e.g. "0-1,3").
  * 
  * See: <https://libvirt.org/formatdomain.html#memory-backing>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#nodeset Domain#nodeset}
  */
  readonly nodeset?: string;
  /**
  * Sets the huge page size for this entry as a required positive integer, interpreted together with the unit field (for example, 2048 with unit "KiB" for 2 MiB pages).
  * 
  * See: <https://libvirt.org/formatdomain.html#memory-backing>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#size Domain#size}
  */
  readonly size: number;
  /**
  * Sets the unit for the huge page size; the value is user-provided and must be one of the libvirt-supported size units (such as "B", "KiB", "MiB", "GiB").
  * 
  * See: <https://libvirt.org/formatdomain.html#memory-backing>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#unit Domain#unit}
  */
  readonly unit?: string;
}

export function domainMemoryBackingMemoryHugePagesHugepagesToTerraform(struct?: DomainMemoryBackingMemoryHugePagesHugepages | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    nodeset: cdktf.stringToTerraform(struct!.nodeset),
    size: cdktf.numberToTerraform(struct!.size),
    unit: cdktf.stringToTerraform(struct!.unit),
  }
}


export function domainMemoryBackingMemoryHugePagesHugepagesToHclTerraform(struct?: DomainMemoryBackingMemoryHugePagesHugepages | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    nodeset: {
      value: cdktf.stringToHclTerraform(struct!.nodeset),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    size: {
      value: cdktf.numberToHclTerraform(struct!.size),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    unit: {
      value: cdktf.stringToHclTerraform(struct!.unit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainMemoryBackingMemoryHugePagesHugepagesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainMemoryBackingMemoryHugePagesHugepages | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._nodeset !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeset = this._nodeset;
    }
    if (this._size !== undefined) {
      hasAnyValues = true;
      internalValueResult.size = this._size;
    }
    if (this._unit !== undefined) {
      hasAnyValues = true;
      internalValueResult.unit = this._unit;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainMemoryBackingMemoryHugePagesHugepages | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._nodeset = undefined;
      this._size = undefined;
      this._unit = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._nodeset = value.nodeset;
      this._size = value.size;
      this._unit = value.unit;
    }
  }

  // nodeset - computed: false, optional: true, required: false
  private _nodeset?: string; 
  public get nodeset() {
    return this.getStringAttribute('nodeset');
  }
  public set nodeset(value: string) {
    this._nodeset = value;
  }
  public resetNodeset() {
    this._nodeset = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodesetInput() {
    return this._nodeset;
  }

  // size - computed: false, optional: false, required: true
  private _size?: number; 
  public get size() {
    return this.getNumberAttribute('size');
  }
  public set size(value: number) {
    this._size = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sizeInput() {
    return this._size;
  }

  // unit - computed: false, optional: true, required: false
  private _unit?: string; 
  public get unit() {
    return this.getStringAttribute('unit');
  }
  public set unit(value: string) {
    this._unit = value;
  }
  public resetUnit() {
    this._unit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unitInput() {
    return this._unit;
  }
}

export class DomainMemoryBackingMemoryHugePagesHugepagesList extends cdktf.ComplexList {
  public internalValue? : DomainMemoryBackingMemoryHugePagesHugepages[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainMemoryBackingMemoryHugePagesHugepagesOutputReference {
    return new DomainMemoryBackingMemoryHugePagesHugepagesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainMemoryBackingMemoryHugePages {
  /**
  * Defines a single huge page configuration, including page size, optional unit, and optional NUMA node set.
  * 
  * See: <https://libvirt.org/formatdomain.html#memory-backing>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#hugepages Domain#hugepages}
  */
  readonly hugepages?: DomainMemoryBackingMemoryHugePagesHugepages[] | cdktf.IResolvable;
}

export function domainMemoryBackingMemoryHugePagesToTerraform(struct?: DomainMemoryBackingMemoryHugePages | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hugepages: cdktf.listMapper(domainMemoryBackingMemoryHugePagesHugepagesToTerraform, false)(struct!.hugepages),
  }
}


export function domainMemoryBackingMemoryHugePagesToHclTerraform(struct?: DomainMemoryBackingMemoryHugePages | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hugepages: {
      value: cdktf.listMapperHcl(domainMemoryBackingMemoryHugePagesHugepagesToHclTerraform, false)(struct!.hugepages),
      isBlock: true,
      type: "list",
      storageClassType: "DomainMemoryBackingMemoryHugePagesHugepagesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainMemoryBackingMemoryHugePagesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainMemoryBackingMemoryHugePages | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hugepages?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hugepages = this._hugepages?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainMemoryBackingMemoryHugePages | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hugepages.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hugepages.internalValue = value.hugepages;
    }
  }

  // hugepages - computed: false, optional: true, required: false
  private _hugepages = new DomainMemoryBackingMemoryHugePagesHugepagesList(this, "hugepages", false);
  public get hugepages() {
    return this._hugepages;
  }
  public putHugepages(value: DomainMemoryBackingMemoryHugePagesHugepages[] | cdktf.IResolvable) {
    this._hugepages.internalValue = value;
  }
  public resetHugepages() {
    this._hugepages.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hugepagesInput() {
    return this._hugepages.internalValue;
  }
}
export interface DomainMemoryBackingMemorySource {
  /**
  * Specifies the memory source type; the value is user-provided and must be one of the libvirt-supported types for memoryBacking source (e.g. platform-specific values like "anonymous" or "file").
  * 
  * See: <https://libvirt.org/formatdomain.html#memory-backing>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type?: string;
}

export function domainMemoryBackingMemorySourceToTerraform(struct?: DomainMemoryBackingMemorySource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function domainMemoryBackingMemorySourceToHclTerraform(struct?: DomainMemoryBackingMemorySource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainMemoryBackingMemorySourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainMemoryBackingMemorySource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainMemoryBackingMemorySource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._type = value.type;
    }
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DomainMemoryBacking {
  /**
  * Controls the memory access policy for the guests backed memory (for example, NUMA-related access behavior) via a mode attribute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#memory_access Domain#memory_access}
  */
  readonly memoryAccess?: DomainMemoryBackingMemoryAccess;
  /**
  * Controls the allocation behavior of the backing memory, such as whether memory is preallocated and on how many threads.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#memory_allocation Domain#memory_allocation}
  */
  readonly memoryAllocation?: DomainMemoryBackingMemoryAllocation;
  /**
  * Enables backing memory discard behavior when present; as a presence-only flag, setting this to true emits the element, while false or null omits it.
  * 
  * See: <https://libvirt.org/formatdomain.html#memory-backing>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#memory_discard Domain#memory_discard}
  */
  readonly memoryDiscard?: boolean | cdktf.IResolvable;
  /**
  * Enables and configures the use of huge pages for guest memory, allowing one or more huge page size definitions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#memory_huge_pages Domain#memory_huge_pages}
  */
  readonly memoryHugePages?: DomainMemoryBackingMemoryHugePages;
  /**
  * Requests that the guests memory be locked in host RAM (mlock) when present; as a presence-only flag, true emits the element and false/null omits it.
  * 
  * See: <https://libvirt.org/formatdomain.html#memory-backing>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#memory_locked Domain#memory_locked}
  */
  readonly memoryLocked?: boolean | cdktf.IResolvable;
  /**
  * Disables page sharing for the guests memory when present, preventing features like KSM from deduplicating pages; as a presence-only flag, true emits the element and false/null omits it.
  * 
  * See: <https://libvirt.org/formatdomain.html#memory-backing>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#memory_nosharepages Domain#memory_nosharepages}
  */
  readonly memoryNosharepages?: boolean | cdktf.IResolvable;
  /**
  * Selects the backing source type for guest memory (for example, anonymous, file-backed, or other hypervisor-supported sources).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#memory_source Domain#memory_source}
  */
  readonly memorySource?: DomainMemoryBackingMemorySource;
}

export function domainMemoryBackingToTerraform(struct?: DomainMemoryBacking | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    memory_access: domainMemoryBackingMemoryAccessToTerraform(struct!.memoryAccess),
    memory_allocation: domainMemoryBackingMemoryAllocationToTerraform(struct!.memoryAllocation),
    memory_discard: cdktf.booleanToTerraform(struct!.memoryDiscard),
    memory_huge_pages: domainMemoryBackingMemoryHugePagesToTerraform(struct!.memoryHugePages),
    memory_locked: cdktf.booleanToTerraform(struct!.memoryLocked),
    memory_nosharepages: cdktf.booleanToTerraform(struct!.memoryNosharepages),
    memory_source: domainMemoryBackingMemorySourceToTerraform(struct!.memorySource),
  }
}


export function domainMemoryBackingToHclTerraform(struct?: DomainMemoryBacking | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    memory_access: {
      value: domainMemoryBackingMemoryAccessToHclTerraform(struct!.memoryAccess),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainMemoryBackingMemoryAccess",
    },
    memory_allocation: {
      value: domainMemoryBackingMemoryAllocationToHclTerraform(struct!.memoryAllocation),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainMemoryBackingMemoryAllocation",
    },
    memory_discard: {
      value: cdktf.booleanToHclTerraform(struct!.memoryDiscard),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    memory_huge_pages: {
      value: domainMemoryBackingMemoryHugePagesToHclTerraform(struct!.memoryHugePages),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainMemoryBackingMemoryHugePages",
    },
    memory_locked: {
      value: cdktf.booleanToHclTerraform(struct!.memoryLocked),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    memory_nosharepages: {
      value: cdktf.booleanToHclTerraform(struct!.memoryNosharepages),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    memory_source: {
      value: domainMemoryBackingMemorySourceToHclTerraform(struct!.memorySource),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainMemoryBackingMemorySource",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainMemoryBackingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainMemoryBacking | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._memoryAccess?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.memoryAccess = this._memoryAccess?.internalValue;
    }
    if (this._memoryAllocation?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.memoryAllocation = this._memoryAllocation?.internalValue;
    }
    if (this._memoryDiscard !== undefined) {
      hasAnyValues = true;
      internalValueResult.memoryDiscard = this._memoryDiscard;
    }
    if (this._memoryHugePages?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.memoryHugePages = this._memoryHugePages?.internalValue;
    }
    if (this._memoryLocked !== undefined) {
      hasAnyValues = true;
      internalValueResult.memoryLocked = this._memoryLocked;
    }
    if (this._memoryNosharepages !== undefined) {
      hasAnyValues = true;
      internalValueResult.memoryNosharepages = this._memoryNosharepages;
    }
    if (this._memorySource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.memorySource = this._memorySource?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainMemoryBacking | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._memoryAccess.internalValue = undefined;
      this._memoryAllocation.internalValue = undefined;
      this._memoryDiscard = undefined;
      this._memoryHugePages.internalValue = undefined;
      this._memoryLocked = undefined;
      this._memoryNosharepages = undefined;
      this._memorySource.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._memoryAccess.internalValue = value.memoryAccess;
      this._memoryAllocation.internalValue = value.memoryAllocation;
      this._memoryDiscard = value.memoryDiscard;
      this._memoryHugePages.internalValue = value.memoryHugePages;
      this._memoryLocked = value.memoryLocked;
      this._memoryNosharepages = value.memoryNosharepages;
      this._memorySource.internalValue = value.memorySource;
    }
  }

  // memory_access - computed: false, optional: true, required: false
  private _memoryAccess = new DomainMemoryBackingMemoryAccessOutputReference(this, "memory_access");
  public get memoryAccess() {
    return this._memoryAccess;
  }
  public putMemoryAccess(value: DomainMemoryBackingMemoryAccess) {
    this._memoryAccess.internalValue = value;
  }
  public resetMemoryAccess() {
    this._memoryAccess.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryAccessInput() {
    return this._memoryAccess.internalValue;
  }

  // memory_allocation - computed: false, optional: true, required: false
  private _memoryAllocation = new DomainMemoryBackingMemoryAllocationOutputReference(this, "memory_allocation");
  public get memoryAllocation() {
    return this._memoryAllocation;
  }
  public putMemoryAllocation(value: DomainMemoryBackingMemoryAllocation) {
    this._memoryAllocation.internalValue = value;
  }
  public resetMemoryAllocation() {
    this._memoryAllocation.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryAllocationInput() {
    return this._memoryAllocation.internalValue;
  }

  // memory_discard - computed: false, optional: true, required: false
  private _memoryDiscard?: boolean | cdktf.IResolvable; 
  public get memoryDiscard() {
    return this.getBooleanAttribute('memory_discard');
  }
  public set memoryDiscard(value: boolean | cdktf.IResolvable) {
    this._memoryDiscard = value;
  }
  public resetMemoryDiscard() {
    this._memoryDiscard = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryDiscardInput() {
    return this._memoryDiscard;
  }

  // memory_huge_pages - computed: false, optional: true, required: false
  private _memoryHugePages = new DomainMemoryBackingMemoryHugePagesOutputReference(this, "memory_huge_pages");
  public get memoryHugePages() {
    return this._memoryHugePages;
  }
  public putMemoryHugePages(value: DomainMemoryBackingMemoryHugePages) {
    this._memoryHugePages.internalValue = value;
  }
  public resetMemoryHugePages() {
    this._memoryHugePages.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryHugePagesInput() {
    return this._memoryHugePages.internalValue;
  }

  // memory_locked - computed: false, optional: true, required: false
  private _memoryLocked?: boolean | cdktf.IResolvable; 
  public get memoryLocked() {
    return this.getBooleanAttribute('memory_locked');
  }
  public set memoryLocked(value: boolean | cdktf.IResolvable) {
    this._memoryLocked = value;
  }
  public resetMemoryLocked() {
    this._memoryLocked = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryLockedInput() {
    return this._memoryLocked;
  }

  // memory_nosharepages - computed: false, optional: true, required: false
  private _memoryNosharepages?: boolean | cdktf.IResolvable; 
  public get memoryNosharepages() {
    return this.getBooleanAttribute('memory_nosharepages');
  }
  public set memoryNosharepages(value: boolean | cdktf.IResolvable) {
    this._memoryNosharepages = value;
  }
  public resetMemoryNosharepages() {
    this._memoryNosharepages = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryNosharepagesInput() {
    return this._memoryNosharepages;
  }

  // memory_source - computed: false, optional: true, required: false
  private _memorySource = new DomainMemoryBackingMemorySourceOutputReference(this, "memory_source");
  public get memorySource() {
    return this._memorySource;
  }
  public putMemorySource(value: DomainMemoryBackingMemorySource) {
    this._memorySource.internalValue = value;
  }
  public resetMemorySource() {
    this._memorySource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memorySourceInput() {
    return this._memorySource.internalValue;
  }
}
export interface DomainMemoryTune {
  /**
  * Sets an upper hard limit on the domains memory usage; the value is a user-provided positive integer in libvirt memory units (typically KiB) and must not be lower than other required limits.
  * 
  * See: <https://libvirt.org/formatdomain.html#memory-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#hard_limit Domain#hard_limit}
  */
  readonly hardLimit?: number;
  /**
  * Sets the unit for the memory_tune hard_limit value, typically as a memory size unit such as KiB, MiB, or GiB; the string is user-provided and must match libvirts accepted memory units.
  * 
  * See: <https://libvirt.org/formatdomain.html#memory-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#hard_limit_unit Domain#hard_limit_unit}
  */
  readonly hardLimitUnit?: string;
  /**
  * Sets the minimum amount of memory that the hypervisor guarantees to keep available for the guest, expressed in the unit given by min_guarantee_unit.
  * 
  * See: <https://libvirt.org/formatdomain.html#memory-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#min_guarantee Domain#min_guarantee}
  */
  readonly minGuarantee?: number;
  /**
  * Sets the unit for the memory_tune min_guarantee value, typically as a memory size unit such as KiB, MiB, or GiB; the string is user-provided and must match libvirts accepted memory units.
  * 
  * See: <https://libvirt.org/formatdomain.html#memory-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#min_guarantee_unit Domain#min_guarantee_unit}
  */
  readonly minGuaranteeUnit?: string;
  /**
  * Sets a soft memory usage limit for the guest, above which its memory may be preferentially reclaimed, expressed in the unit given by soft_limit_unit.
  * 
  * See: <https://libvirt.org/formatdomain.html#memory-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#soft_limit Domain#soft_limit}
  */
  readonly softLimit?: number;
  /**
  * Sets the unit for the memory_tune soft_limit value, typically as a memory size unit such as KiB, MiB, or GiB; the string is user-provided and must match libvirts accepted memory units.
  * 
  * See: <https://libvirt.org/formatdomain.html#memory-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#soft_limit_unit Domain#soft_limit_unit}
  */
  readonly softLimitUnit?: string;
  /**
  * Sets an upper limit on the guests combined RAM+swap usage, expressed in the unit given by swap_hard_limit_unit, beyond which further allocation is refused.
  * 
  * See: <https://libvirt.org/formatdomain.html#memory-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#swap_hard_limit Domain#swap_hard_limit}
  */
  readonly swapHardLimit?: number;
  /**
  * Sets the unit for the memory_tune swap_hard_limit value, typically as a memory size unit such as KiB, MiB, or GiB; the string is user-provided and must match libvirts accepted memory units.
  * 
  * See: <https://libvirt.org/formatdomain.html#memory-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#swap_hard_limit_unit Domain#swap_hard_limit_unit}
  */
  readonly swapHardLimitUnit?: string;
}

export function domainMemoryTuneToTerraform(struct?: DomainMemoryTune | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hard_limit: cdktf.numberToTerraform(struct!.hardLimit),
    hard_limit_unit: cdktf.stringToTerraform(struct!.hardLimitUnit),
    min_guarantee: cdktf.numberToTerraform(struct!.minGuarantee),
    min_guarantee_unit: cdktf.stringToTerraform(struct!.minGuaranteeUnit),
    soft_limit: cdktf.numberToTerraform(struct!.softLimit),
    soft_limit_unit: cdktf.stringToTerraform(struct!.softLimitUnit),
    swap_hard_limit: cdktf.numberToTerraform(struct!.swapHardLimit),
    swap_hard_limit_unit: cdktf.stringToTerraform(struct!.swapHardLimitUnit),
  }
}


export function domainMemoryTuneToHclTerraform(struct?: DomainMemoryTune | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hard_limit: {
      value: cdktf.numberToHclTerraform(struct!.hardLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    hard_limit_unit: {
      value: cdktf.stringToHclTerraform(struct!.hardLimitUnit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_guarantee: {
      value: cdktf.numberToHclTerraform(struct!.minGuarantee),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    min_guarantee_unit: {
      value: cdktf.stringToHclTerraform(struct!.minGuaranteeUnit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    soft_limit: {
      value: cdktf.numberToHclTerraform(struct!.softLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    soft_limit_unit: {
      value: cdktf.stringToHclTerraform(struct!.softLimitUnit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    swap_hard_limit: {
      value: cdktf.numberToHclTerraform(struct!.swapHardLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    swap_hard_limit_unit: {
      value: cdktf.stringToHclTerraform(struct!.swapHardLimitUnit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainMemoryTuneOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainMemoryTune | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hardLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.hardLimit = this._hardLimit;
    }
    if (this._hardLimitUnit !== undefined) {
      hasAnyValues = true;
      internalValueResult.hardLimitUnit = this._hardLimitUnit;
    }
    if (this._minGuarantee !== undefined) {
      hasAnyValues = true;
      internalValueResult.minGuarantee = this._minGuarantee;
    }
    if (this._minGuaranteeUnit !== undefined) {
      hasAnyValues = true;
      internalValueResult.minGuaranteeUnit = this._minGuaranteeUnit;
    }
    if (this._softLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.softLimit = this._softLimit;
    }
    if (this._softLimitUnit !== undefined) {
      hasAnyValues = true;
      internalValueResult.softLimitUnit = this._softLimitUnit;
    }
    if (this._swapHardLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.swapHardLimit = this._swapHardLimit;
    }
    if (this._swapHardLimitUnit !== undefined) {
      hasAnyValues = true;
      internalValueResult.swapHardLimitUnit = this._swapHardLimitUnit;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainMemoryTune | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hardLimit = undefined;
      this._hardLimitUnit = undefined;
      this._minGuarantee = undefined;
      this._minGuaranteeUnit = undefined;
      this._softLimit = undefined;
      this._softLimitUnit = undefined;
      this._swapHardLimit = undefined;
      this._swapHardLimitUnit = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hardLimit = value.hardLimit;
      this._hardLimitUnit = value.hardLimitUnit;
      this._minGuarantee = value.minGuarantee;
      this._minGuaranteeUnit = value.minGuaranteeUnit;
      this._softLimit = value.softLimit;
      this._softLimitUnit = value.softLimitUnit;
      this._swapHardLimit = value.swapHardLimit;
      this._swapHardLimitUnit = value.swapHardLimitUnit;
    }
  }

  // hard_limit - computed: false, optional: true, required: false
  private _hardLimit?: number; 
  public get hardLimit() {
    return this.getNumberAttribute('hard_limit');
  }
  public set hardLimit(value: number) {
    this._hardLimit = value;
  }
  public resetHardLimit() {
    this._hardLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hardLimitInput() {
    return this._hardLimit;
  }

  // hard_limit_unit - computed: false, optional: true, required: false
  private _hardLimitUnit?: string; 
  public get hardLimitUnit() {
    return this.getStringAttribute('hard_limit_unit');
  }
  public set hardLimitUnit(value: string) {
    this._hardLimitUnit = value;
  }
  public resetHardLimitUnit() {
    this._hardLimitUnit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hardLimitUnitInput() {
    return this._hardLimitUnit;
  }

  // min_guarantee - computed: false, optional: true, required: false
  private _minGuarantee?: number; 
  public get minGuarantee() {
    return this.getNumberAttribute('min_guarantee');
  }
  public set minGuarantee(value: number) {
    this._minGuarantee = value;
  }
  public resetMinGuarantee() {
    this._minGuarantee = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minGuaranteeInput() {
    return this._minGuarantee;
  }

  // min_guarantee_unit - computed: false, optional: true, required: false
  private _minGuaranteeUnit?: string; 
  public get minGuaranteeUnit() {
    return this.getStringAttribute('min_guarantee_unit');
  }
  public set minGuaranteeUnit(value: string) {
    this._minGuaranteeUnit = value;
  }
  public resetMinGuaranteeUnit() {
    this._minGuaranteeUnit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minGuaranteeUnitInput() {
    return this._minGuaranteeUnit;
  }

  // soft_limit - computed: false, optional: true, required: false
  private _softLimit?: number; 
  public get softLimit() {
    return this.getNumberAttribute('soft_limit');
  }
  public set softLimit(value: number) {
    this._softLimit = value;
  }
  public resetSoftLimit() {
    this._softLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get softLimitInput() {
    return this._softLimit;
  }

  // soft_limit_unit - computed: false, optional: true, required: false
  private _softLimitUnit?: string; 
  public get softLimitUnit() {
    return this.getStringAttribute('soft_limit_unit');
  }
  public set softLimitUnit(value: string) {
    this._softLimitUnit = value;
  }
  public resetSoftLimitUnit() {
    this._softLimitUnit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get softLimitUnitInput() {
    return this._softLimitUnit;
  }

  // swap_hard_limit - computed: false, optional: true, required: false
  private _swapHardLimit?: number; 
  public get swapHardLimit() {
    return this.getNumberAttribute('swap_hard_limit');
  }
  public set swapHardLimit(value: number) {
    this._swapHardLimit = value;
  }
  public resetSwapHardLimit() {
    this._swapHardLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get swapHardLimitInput() {
    return this._swapHardLimit;
  }

  // swap_hard_limit_unit - computed: false, optional: true, required: false
  private _swapHardLimitUnit?: string; 
  public get swapHardLimitUnit() {
    return this.getStringAttribute('swap_hard_limit_unit');
  }
  public set swapHardLimitUnit(value: string) {
    this._swapHardLimitUnit = value;
  }
  public resetSwapHardLimitUnit() {
    this._swapHardLimitUnit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get swapHardLimitUnitInput() {
    return this._swapHardLimitUnit;
  }
}
export interface DomainMetadata {
  /**
  * Provides the raw XML content to store inside the domains metadata element; this must be well-formed XML and is fully user-defined.
  * 
  * See: <https://libvirt.org/formatdomain.html#general-metadata>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#xml Domain#xml}
  */
  readonly xml: string;
}

export function domainMetadataToTerraform(struct?: DomainMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    xml: cdktf.stringToTerraform(struct!.xml),
  }
}


export function domainMetadataToHclTerraform(struct?: DomainMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    xml: {
      value: cdktf.stringToHclTerraform(struct!.xml),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._xml !== undefined) {
      hasAnyValues = true;
      internalValueResult.xml = this._xml;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._xml = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._xml = value.xml;
    }
  }

  // xml - computed: false, optional: false, required: true
  private _xml?: string; 
  public get xml() {
    return this.getStringAttribute('xml');
  }
  public set xml(value: string) {
    this._xml = value;
  }
  // Temporarily expose input value. Use with caution.
  public get xmlInput() {
    return this._xml;
  }
}
export interface DomainNumaTuneMemNodes {
  /**
  * Sets the guest NUMA cell (node) index for this mem_nodes entry; the value is a non-negative integer matching a defined guest NUMA cell.
  * 
  * See: <https://libvirt.org/formatdomain.html#numa-node-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#cell_id Domain#cell_id}
  */
  readonly cellId: number;
  /**
  * Sets the NUMA memory allocation policy for the specified guest cell, with valid values including preferred, interleave, bind, strict, or other modes accepted by libvirt.
  * 
  * See: <https://libvirt.org/formatdomain.html#numa-node-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode: string;
  /**
  * Specifies the host NUMA node or nodes to which the guest cells memory policy applies, using libvirts nodeset syntax (e.g. "0-2,4").
  * 
  * See: <https://libvirt.org/formatdomain.html#numa-node-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#nodeset Domain#nodeset}
  */
  readonly nodeset: string;
}

export function domainNumaTuneMemNodesToTerraform(struct?: DomainNumaTuneMemNodes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cell_id: cdktf.numberToTerraform(struct!.cellId),
    mode: cdktf.stringToTerraform(struct!.mode),
    nodeset: cdktf.stringToTerraform(struct!.nodeset),
  }
}


export function domainNumaTuneMemNodesToHclTerraform(struct?: DomainNumaTuneMemNodes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cell_id: {
      value: cdktf.numberToHclTerraform(struct!.cellId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    nodeset: {
      value: cdktf.stringToHclTerraform(struct!.nodeset),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainNumaTuneMemNodesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainNumaTuneMemNodes | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cellId !== undefined) {
      hasAnyValues = true;
      internalValueResult.cellId = this._cellId;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._nodeset !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeset = this._nodeset;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainNumaTuneMemNodes | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cellId = undefined;
      this._mode = undefined;
      this._nodeset = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cellId = value.cellId;
      this._mode = value.mode;
      this._nodeset = value.nodeset;
    }
  }

  // cell_id - computed: false, optional: false, required: true
  private _cellId?: number; 
  public get cellId() {
    return this.getNumberAttribute('cell_id');
  }
  public set cellId(value: number) {
    this._cellId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get cellIdInput() {
    return this._cellId;
  }

  // mode - computed: false, optional: false, required: true
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // nodeset - computed: false, optional: false, required: true
  private _nodeset?: string; 
  public get nodeset() {
    return this.getStringAttribute('nodeset');
  }
  public set nodeset(value: string) {
    this._nodeset = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nodesetInput() {
    return this._nodeset;
  }
}

export class DomainNumaTuneMemNodesList extends cdktf.ComplexList {
  public internalValue? : DomainNumaTuneMemNodes[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainNumaTuneMemNodesOutputReference {
    return new DomainNumaTuneMemNodesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainNumaTuneMemory {
  /**
  * Sets the overall NUMA memory allocation policy for the domain, with valid values including preferred, interleave, bind, strict, or other modes accepted by libvirt.
  * 
  * See: <https://libvirt.org/formatdomain.html#numa-node-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode?: string;
  /**
  * Specifies the host NUMA node or nodes used by the global memory policy, using libvirts nodeset syntax (e.g. "0-1" or "0,2,4").
  * 
  * See: <https://libvirt.org/formatdomain.html#numa-node-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#nodeset Domain#nodeset}
  */
  readonly nodeset?: string;
  /**
  * Controls whether libvirt automatically selects NUMA nodes for the domains memory (auto) or uses an explicit nodeset (static), with valid values being auto or static.
  * 
  * See: <https://libvirt.org/formatdomain.html#numa-node-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#placement Domain#placement}
  */
  readonly placement?: string;
}

export function domainNumaTuneMemoryToTerraform(struct?: DomainNumaTuneMemory | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
    nodeset: cdktf.stringToTerraform(struct!.nodeset),
    placement: cdktf.stringToTerraform(struct!.placement),
  }
}


export function domainNumaTuneMemoryToHclTerraform(struct?: DomainNumaTuneMemory | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    nodeset: {
      value: cdktf.stringToHclTerraform(struct!.nodeset),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    placement: {
      value: cdktf.stringToHclTerraform(struct!.placement),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainNumaTuneMemoryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainNumaTuneMemory | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._nodeset !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeset = this._nodeset;
    }
    if (this._placement !== undefined) {
      hasAnyValues = true;
      internalValueResult.placement = this._placement;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainNumaTuneMemory | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
      this._nodeset = undefined;
      this._placement = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
      this._nodeset = value.nodeset;
      this._placement = value.placement;
    }
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // nodeset - computed: false, optional: true, required: false
  private _nodeset?: string; 
  public get nodeset() {
    return this.getStringAttribute('nodeset');
  }
  public set nodeset(value: string) {
    this._nodeset = value;
  }
  public resetNodeset() {
    this._nodeset = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodesetInput() {
    return this._nodeset;
  }

  // placement - computed: false, optional: true, required: false
  private _placement?: string; 
  public get placement() {
    return this.getStringAttribute('placement');
  }
  public set placement(value: string) {
    this._placement = value;
  }
  public resetPlacement() {
    this._placement = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get placementInput() {
    return this._placement;
  }
}
export interface DomainNumaTune {
  /**
  * Defines per-guest-NUMA-node memory policies, each entry specifying how a given guest cell maps to host NUMA nodes.
  * 
  * See: <https://libvirt.org/formatdomain.html#numa-node-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mem_nodes Domain#mem_nodes}
  */
  readonly memNodes?: DomainNumaTuneMemNodes[] | cdktf.IResolvable;
  /**
  * Configures a global NUMA memory policy for the domain process, independent of per-cell mem_nodes settings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#memory Domain#memory}
  */
  readonly memory?: DomainNumaTuneMemory;
}

export function domainNumaTuneToTerraform(struct?: DomainNumaTune | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mem_nodes: cdktf.listMapper(domainNumaTuneMemNodesToTerraform, false)(struct!.memNodes),
    memory: domainNumaTuneMemoryToTerraform(struct!.memory),
  }
}


export function domainNumaTuneToHclTerraform(struct?: DomainNumaTune | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mem_nodes: {
      value: cdktf.listMapperHcl(domainNumaTuneMemNodesToHclTerraform, false)(struct!.memNodes),
      isBlock: true,
      type: "list",
      storageClassType: "DomainNumaTuneMemNodesList",
    },
    memory: {
      value: domainNumaTuneMemoryToHclTerraform(struct!.memory),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainNumaTuneMemory",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainNumaTuneOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainNumaTune | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._memNodes?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.memNodes = this._memNodes?.internalValue;
    }
    if (this._memory?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.memory = this._memory?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainNumaTune | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._memNodes.internalValue = undefined;
      this._memory.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._memNodes.internalValue = value.memNodes;
      this._memory.internalValue = value.memory;
    }
  }

  // mem_nodes - computed: false, optional: true, required: false
  private _memNodes = new DomainNumaTuneMemNodesList(this, "mem_nodes", false);
  public get memNodes() {
    return this._memNodes;
  }
  public putMemNodes(value: DomainNumaTuneMemNodes[] | cdktf.IResolvable) {
    this._memNodes.internalValue = value;
  }
  public resetMemNodes() {
    this._memNodes.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memNodesInput() {
    return this._memNodes.internalValue;
  }

  // memory - computed: false, optional: true, required: false
  private _memory = new DomainNumaTuneMemoryOutputReference(this, "memory");
  public get memory() {
    return this._memory;
  }
  public putMemory(value: DomainNumaTuneMemory) {
    this._memory.internalValue = value;
  }
  public resetMemory() {
    this._memory.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryInput() {
    return this._memory.internalValue;
  }
}
export interface DomainOsAcpiTables {
  /**
  * Sets the fully-qualified path on the host to the ACPI table file that will be injected into the guest; the value is user-provided and must reference an accessible file. Example: "/usr/share/acpi/my_dsdt.bin".
  * 
  * See: <https://libvirt.org/formatdomain.html#common-os-element-configuration>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Sets the ACPI table type corresponding to the content of the referenced file (for example "dsdt" or another ACPI table identifier); the value is required and user-provided. Libvirt expects it to match the table contents.
  * 
  * See: <https://libvirt.org/formatdomain.html#common-os-element-configuration>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type: string;
}

export function domainOsAcpiTablesToTerraform(struct?: DomainOsAcpiTables | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function domainOsAcpiTablesToHclTerraform(struct?: DomainOsAcpiTables | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsAcpiTablesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainOsAcpiTables | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsAcpiTables | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._type = value.type;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}

export class DomainOsAcpiTablesList extends cdktf.ComplexList {
  public internalValue? : DomainOsAcpiTables[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainOsAcpiTablesOutputReference {
    return new DomainOsAcpiTablesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainOsAcpi {
  /**
  * Declares one or more custom ACPI tables to load into the guest, each with a required type and path specifying the table file. Multiple entries are allowed.
  * 
  * See: <https://libvirt.org/formatdomain.html#common-os-element-configuration>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tables Domain#tables}
  */
  readonly tables?: DomainOsAcpiTables[] | cdktf.IResolvable;
}

export function domainOsAcpiToTerraform(struct?: DomainOsAcpi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    tables: cdktf.listMapper(domainOsAcpiTablesToTerraform, false)(struct!.tables),
  }
}


export function domainOsAcpiToHclTerraform(struct?: DomainOsAcpi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    tables: {
      value: cdktf.listMapperHcl(domainOsAcpiTablesToHclTerraform, false)(struct!.tables),
      isBlock: true,
      type: "list",
      storageClassType: "DomainOsAcpiTablesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsAcpiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsAcpi | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._tables?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tables = this._tables?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsAcpi | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._tables.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._tables.internalValue = value.tables;
    }
  }

  // tables - computed: false, optional: true, required: false
  private _tables = new DomainOsAcpiTablesList(this, "tables", false);
  public get tables() {
    return this._tables;
  }
  public putTables(value: DomainOsAcpiTables[] | cdktf.IResolvable) {
    this._tables.internalValue = value;
  }
  public resetTables() {
    this._tables.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tablesInput() {
    return this._tables.internalValue;
  }
}
export interface DomainOsBios {
  /**
  * Sets the time in seconds that firmware waits in the boot menu before automatically rebooting or continuing boot; the value is a non-negative integer. Example: 5000.
  * 
  * See: <https://libvirt.org/formatdomain.html#bios-bootloader>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reboot_timeout Domain#reboot_timeout}
  */
  readonly rebootTimeout?: number;
  /**
  * Controls whether the BIOS uses the serial console for input/output; the value is a "yes"/"no" string flag. If unset, the hypervisor default is used.
  * 
  * See: <https://libvirt.org/formatdomain.html#bios-bootloader>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#use_serial Domain#use_serial}
  */
  readonly useSerial?: string;
}

export function domainOsBiosToTerraform(struct?: DomainOsBios | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    reboot_timeout: cdktf.numberToTerraform(struct!.rebootTimeout),
    use_serial: cdktf.stringToTerraform(struct!.useSerial),
  }
}


export function domainOsBiosToHclTerraform(struct?: DomainOsBios | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    reboot_timeout: {
      value: cdktf.numberToHclTerraform(struct!.rebootTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    use_serial: {
      value: cdktf.stringToHclTerraform(struct!.useSerial),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsBiosOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsBios | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._rebootTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.rebootTimeout = this._rebootTimeout;
    }
    if (this._useSerial !== undefined) {
      hasAnyValues = true;
      internalValueResult.useSerial = this._useSerial;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsBios | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._rebootTimeout = undefined;
      this._useSerial = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._rebootTimeout = value.rebootTimeout;
      this._useSerial = value.useSerial;
    }
  }

  // reboot_timeout - computed: false, optional: true, required: false
  private _rebootTimeout?: number; 
  public get rebootTimeout() {
    return this.getNumberAttribute('reboot_timeout');
  }
  public set rebootTimeout(value: number) {
    this._rebootTimeout = value;
  }
  public resetRebootTimeout() {
    this._rebootTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rebootTimeoutInput() {
    return this._rebootTimeout;
  }

  // use_serial - computed: false, optional: true, required: false
  private _useSerial?: string; 
  public get useSerial() {
    return this.getStringAttribute('use_serial');
  }
  public set useSerial(value: string) {
    this._useSerial = value;
  }
  public resetUseSerial() {
    this._useSerial = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useSerialInput() {
    return this._useSerial;
  }
}
export interface DomainOsBootDevices {
  /**
  * Defines a single boot target device type in the boot order; valid values include "hd", "cdrom", "fd", and "network" (and any additional values supported by the hypervisor). Example: "hd".
  * 
  * See: <https://libvirt.org/formatdomain.html#bios-bootloader>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dev Domain#dev}
  */
  readonly dev: string;
}

export function domainOsBootDevicesToTerraform(struct?: DomainOsBootDevices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dev: cdktf.stringToTerraform(struct!.dev),
  }
}


export function domainOsBootDevicesToHclTerraform(struct?: DomainOsBootDevices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dev: {
      value: cdktf.stringToHclTerraform(struct!.dev),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsBootDevicesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainOsBootDevices | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dev !== undefined) {
      hasAnyValues = true;
      internalValueResult.dev = this._dev;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsBootDevices | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dev = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dev = value.dev;
    }
  }

  // dev - computed: false, optional: false, required: true
  private _dev?: string; 
  public get dev() {
    return this.getStringAttribute('dev');
  }
  public set dev(value: string) {
    this._dev = value;
  }
  // Temporarily expose input value. Use with caution.
  public get devInput() {
    return this._dev;
  }
}

export class DomainOsBootDevicesList extends cdktf.ComplexList {
  public internalValue? : DomainOsBootDevices[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainOsBootDevicesOutputReference {
    return new DomainOsBootDevicesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainOsBootMenu {
  /**
  * Controls whether the firmware boot menu is enabled; the value is a "yes"/"no" string flag. Example: "yes" to show the boot menu at startup.
  * 
  * See: <https://libvirt.org/formatdomain.html#bios-bootloader>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enable Domain#enable}
  */
  readonly enable?: string;
  /**
  * Sets the boot menu timeout in milliseconds before the firmware automatically continues boot; the value is a non-negative integer. Example: 3000.
  * 
  * See: <https://libvirt.org/formatdomain.html#bios-bootloader>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#timeout Domain#timeout}
  */
  readonly timeout?: string;
}

export function domainOsBootMenuToTerraform(struct?: DomainOsBootMenu | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.stringToTerraform(struct!.enable),
    timeout: cdktf.stringToTerraform(struct!.timeout),
  }
}


export function domainOsBootMenuToHclTerraform(struct?: DomainOsBootMenu | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.stringToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsBootMenuOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsBootMenu | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsBootMenu | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
      this._timeout = value.timeout;
    }
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: string; 
  public get enable() {
    return this.getStringAttribute('enable');
  }
  public set enable(value: string) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DomainOsFirmwareInfoFeatures {
  /**
  * Sets whether the given firmware feature entry is enabled, typically as a boolean-like flag (for example "yes"/"no" or "on"/"off") as required by the firmware.
  * 
  * See: <https://libvirt.org/formatdomain.html#operating-system-booting>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enabled Domain#enabled}
  */
  readonly enabled?: string;
  /**
  * Specifies the name/identifier of the firmware feature to control (value is user-provided and must match a feature understood by the chosen firmware).
  * 
  * See: <https://libvirt.org/formatdomain.html#operating-system-booting>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name?: string;
}

export function domainOsFirmwareInfoFeaturesToTerraform(struct?: DomainOsFirmwareInfoFeatures | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.stringToTerraform(struct!.enabled),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function domainOsFirmwareInfoFeaturesToHclTerraform(struct?: DomainOsFirmwareInfoFeatures | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.stringToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsFirmwareInfoFeaturesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainOsFirmwareInfoFeatures | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsFirmwareInfoFeatures | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._name = value.name;
    }
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: string; 
  public get enabled() {
    return this.getStringAttribute('enabled');
  }
  public set enabled(value: string) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class DomainOsFirmwareInfoFeaturesList extends cdktf.ComplexList {
  public internalValue? : DomainOsFirmwareInfoFeatures[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainOsFirmwareInfoFeaturesOutputReference {
    return new DomainOsFirmwareInfoFeaturesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainOsFirmwareInfo {
  /**
  * Configures one or more firmware features to be exposed to the guest firmware/boot environment; each entry corresponds to a single feature toggle, with semantics defined by the underlying firmware implementation.
  * 
  * See: <https://libvirt.org/formatdomain.html#operating-system-booting>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#features Domain#features}
  */
  readonly features?: DomainOsFirmwareInfoFeatures[] | cdktf.IResolvable;
}

export function domainOsFirmwareInfoToTerraform(struct?: DomainOsFirmwareInfo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    features: cdktf.listMapper(domainOsFirmwareInfoFeaturesToTerraform, false)(struct!.features),
  }
}


export function domainOsFirmwareInfoToHclTerraform(struct?: DomainOsFirmwareInfo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    features: {
      value: cdktf.listMapperHcl(domainOsFirmwareInfoFeaturesToHclTerraform, false)(struct!.features),
      isBlock: true,
      type: "list",
      storageClassType: "DomainOsFirmwareInfoFeaturesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsFirmwareInfoOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsFirmwareInfo | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._features?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.features = this._features?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsFirmwareInfo | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._features.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._features.internalValue = value.features;
    }
  }

  // features - computed: false, optional: true, required: false
  private _features = new DomainOsFirmwareInfoFeaturesList(this, "features", false);
  public get features() {
    return this._features;
  }
  public putFeatures(value: DomainOsFirmwareInfoFeatures[] | cdktf.IResolvable) {
    this._features.internalValue = value;
  }
  public resetFeatures() {
    this._features.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get featuresInput() {
    return this._features.internalValue;
  }
}
export interface DomainOsInitEnv {
  /**
  * Sets the environment variable name for a container init environment entry (for example "PATH" or "HTTP_PROXY").
  * 
  * See: <https://libvirt.org/formatdomain.html#container-boot>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
  /**
  * Sets the environment variable value for a container init environment entry (for example "/usr/bin:/bin" or "http://proxy:8080").
  * 
  * See: <https://libvirt.org/formatdomain.html#container-boot>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#value Domain#value}
  */
  readonly value: string;
}

export function domainOsInitEnvToTerraform(struct?: DomainOsInitEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function domainOsInitEnvToHclTerraform(struct?: DomainOsInitEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsInitEnvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainOsInitEnv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsInitEnv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DomainOsInitEnvList extends cdktf.ComplexList {
  public internalValue? : DomainOsInitEnv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainOsInitEnvOutputReference {
    return new DomainOsInitEnvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainOsNvRamSourceBlockSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainOsNvRamSourceBlockSecLabelToTerraform(struct?: DomainOsNvRamSourceBlockSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainOsNvRamSourceBlockSecLabelToHclTerraform(struct?: DomainOsNvRamSourceBlockSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceBlockSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainOsNvRamSourceBlockSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceBlockSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainOsNvRamSourceBlockSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainOsNvRamSourceBlockSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainOsNvRamSourceBlockSecLabelOutputReference {
    return new DomainOsNvRamSourceBlockSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainOsNvRamSourceBlock {
  /**
  * Sets the host block device path used as the mirror backing store source (for example "/dev/sdb1"); the value is user-provided and must reference an existing block device.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dev Domain#dev}
  */
  readonly dev?: string;
  /**
  * Configures an optional security label for the block-device backing store of the mirror, controlling how security drivers label this source.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainOsNvRamSourceBlockSecLabel[] | cdktf.IResolvable;
}

export function domainOsNvRamSourceBlockToTerraform(struct?: DomainOsNvRamSourceBlock | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dev: cdktf.stringToTerraform(struct!.dev),
    sec_label: cdktf.listMapper(domainOsNvRamSourceBlockSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainOsNvRamSourceBlockToHclTerraform(struct?: DomainOsNvRamSourceBlock | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dev: {
      value: cdktf.stringToHclTerraform(struct!.dev),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainOsNvRamSourceBlockSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainOsNvRamSourceBlockSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceBlockOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceBlock | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dev !== undefined) {
      hasAnyValues = true;
      internalValueResult.dev = this._dev;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceBlock | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dev = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dev = value.dev;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // dev - computed: false, optional: true, required: false
  private _dev?: string; 
  public get dev() {
    return this.getStringAttribute('dev');
  }
  public set dev(value: string) {
    this._dev = value;
  }
  public resetDev() {
    this._dev = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devInput() {
    return this._dev;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainOsNvRamSourceBlockSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainOsNvRamSourceBlockSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainOsNvRamSourceCookiesCookies {
  /**
  * Sets the cookie name for this backing store HTTP cookie; the value is user-provided and must be non-empty (for example, "sessionid").
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
  /**
  * Sets the cookie value for this backing store HTTP cookie; the value is user-provided and must be non-empty (for example, "abc123").
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#value Domain#value}
  */
  readonly value: string;
}

export function domainOsNvRamSourceCookiesCookiesToTerraform(struct?: DomainOsNvRamSourceCookiesCookies | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function domainOsNvRamSourceCookiesCookiesToHclTerraform(struct?: DomainOsNvRamSourceCookiesCookies | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceCookiesCookiesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainOsNvRamSourceCookiesCookies | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceCookiesCookies | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DomainOsNvRamSourceCookiesCookiesList extends cdktf.ComplexList {
  public internalValue? : DomainOsNvRamSourceCookiesCookies[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainOsNvRamSourceCookiesCookiesOutputReference {
    return new DomainOsNvRamSourceCookiesCookiesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainOsNvRamSourceCookies {
  /**
  * Configures one or more HTTP cookies to be sent when accessing the mirrored backing store over a network protocol that supports cookies (for example, HTTPS or HTTP-based storage).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#cookies Domain#cookies}
  */
  readonly cookies?: DomainOsNvRamSourceCookiesCookies[] | cdktf.IResolvable;
}

export function domainOsNvRamSourceCookiesToTerraform(struct?: DomainOsNvRamSourceCookies | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cookies: cdktf.listMapper(domainOsNvRamSourceCookiesCookiesToTerraform, false)(struct!.cookies),
  }
}


export function domainOsNvRamSourceCookiesToHclTerraform(struct?: DomainOsNvRamSourceCookies | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cookies: {
      value: cdktf.listMapperHcl(domainOsNvRamSourceCookiesCookiesToHclTerraform, false)(struct!.cookies),
      isBlock: true,
      type: "list",
      storageClassType: "DomainOsNvRamSourceCookiesCookiesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceCookiesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceCookies | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cookies?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cookies = this._cookies?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceCookies | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cookies.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cookies.internalValue = value.cookies;
    }
  }

  // cookies - computed: false, optional: true, required: false
  private _cookies = new DomainOsNvRamSourceCookiesCookiesList(this, "cookies", false);
  public get cookies() {
    return this._cookies;
  }
  public putCookies(value: DomainOsNvRamSourceCookiesCookies[] | cdktf.IResolvable) {
    this._cookies.internalValue = value;
  }
  public resetCookies() {
    this._cookies.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cookiesInput() {
    return this._cookies.internalValue;
  }
}
export interface DomainOsNvRamSourceDataStoreFormatMetadataCacheMaxSize {
  /**
  * Sets the unit used for the metadata cache maximum size; valid units follow libvirt size units such as "B", "KiB", "MiB", "GiB" and are user-chosen.
  * 
  * See: <https://libvirt.org/formatdomain.html#memory-allocation>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#unit Domain#unit}
  */
  readonly unit?: string;
  /**
  * Sets the numeric value for the metadata cache maximum size in the specified unit; this must be a positive integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#value Domain#value}
  */
  readonly value: number;
}

export function domainOsNvRamSourceDataStoreFormatMetadataCacheMaxSizeToTerraform(struct?: DomainOsNvRamSourceDataStoreFormatMetadataCacheMaxSize | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    unit: cdktf.stringToTerraform(struct!.unit),
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function domainOsNvRamSourceDataStoreFormatMetadataCacheMaxSizeToHclTerraform(struct?: DomainOsNvRamSourceDataStoreFormatMetadataCacheMaxSize | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    unit: {
      value: cdktf.stringToHclTerraform(struct!.unit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceDataStoreFormatMetadataCacheMaxSizeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceDataStoreFormatMetadataCacheMaxSize | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._unit !== undefined) {
      hasAnyValues = true;
      internalValueResult.unit = this._unit;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceDataStoreFormatMetadataCacheMaxSize | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._unit = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._unit = value.unit;
      this._value = value.value;
    }
  }

  // unit - computed: false, optional: true, required: false
  private _unit?: string; 
  public get unit() {
    return this.getStringAttribute('unit');
  }
  public set unit(value: string) {
    this._unit = value;
  }
  public resetUnit() {
    this._unit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unitInput() {
    return this._unit;
  }

  // value - computed: false, optional: false, required: true
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DomainOsNvRamSourceDataStoreFormatMetadataCache {
  /**
  * Sets the maximum size of the metadata cache used by the data store format; value and unit together define the limit (for example, 64 MiB).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#max_size Domain#max_size}
  */
  readonly maxSize?: DomainOsNvRamSourceDataStoreFormatMetadataCacheMaxSize;
}

export function domainOsNvRamSourceDataStoreFormatMetadataCacheToTerraform(struct?: DomainOsNvRamSourceDataStoreFormatMetadataCache | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_size: domainOsNvRamSourceDataStoreFormatMetadataCacheMaxSizeToTerraform(struct!.maxSize),
  }
}


export function domainOsNvRamSourceDataStoreFormatMetadataCacheToHclTerraform(struct?: DomainOsNvRamSourceDataStoreFormatMetadataCache | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_size: {
      value: domainOsNvRamSourceDataStoreFormatMetadataCacheMaxSizeToHclTerraform(struct!.maxSize),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceDataStoreFormatMetadataCacheMaxSize",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceDataStoreFormatMetadataCacheOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceDataStoreFormatMetadataCache | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxSize?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceDataStoreFormatMetadataCache | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxSize.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxSize.internalValue = value.maxSize;
    }
  }

  // max_size - computed: false, optional: true, required: false
  private _maxSize = new DomainOsNvRamSourceDataStoreFormatMetadataCacheMaxSizeOutputReference(this, "max_size");
  public get maxSize() {
    return this._maxSize;
  }
  public putMaxSize(value: DomainOsNvRamSourceDataStoreFormatMetadataCacheMaxSize) {
    this._maxSize.internalValue = value;
  }
  public resetMaxSize() {
    this._maxSize.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize.internalValue;
  }
}
export interface DomainOsNvRamSourceDataStoreFormat {
  /**
  * Configures metadata cache behavior for the mirrored backing stores data store format (for example, limiting the size of cached metadata).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#metadata_cache Domain#metadata_cache}
  */
  readonly metadataCache?: DomainOsNvRamSourceDataStoreFormatMetadataCache;
  /**
  * Sets the data store format type for the mirrored backing store (for example, "qcow2" or "raw"); the value is user-provided and must be a valid libvirt disk format name.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type: string;
}

export function domainOsNvRamSourceDataStoreFormatToTerraform(struct?: DomainOsNvRamSourceDataStoreFormat | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metadata_cache: domainOsNvRamSourceDataStoreFormatMetadataCacheToTerraform(struct!.metadataCache),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function domainOsNvRamSourceDataStoreFormatToHclTerraform(struct?: DomainOsNvRamSourceDataStoreFormat | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metadata_cache: {
      value: domainOsNvRamSourceDataStoreFormatMetadataCacheToHclTerraform(struct!.metadataCache),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceDataStoreFormatMetadataCache",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceDataStoreFormatOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceDataStoreFormat | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metadataCache?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadataCache = this._metadataCache?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceDataStoreFormat | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metadataCache.internalValue = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metadataCache.internalValue = value.metadataCache;
      this._type = value.type;
    }
  }

  // metadata_cache - computed: false, optional: true, required: false
  private _metadataCache = new DomainOsNvRamSourceDataStoreFormatMetadataCacheOutputReference(this, "metadata_cache");
  public get metadataCache() {
    return this._metadataCache;
  }
  public putMetadataCache(value: DomainOsNvRamSourceDataStoreFormatMetadataCache) {
    this._metadataCache.internalValue = value;
  }
  public resetMetadataCache() {
    this._metadataCache.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataCacheInput() {
    return this._metadataCache.internalValue;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DomainOsNvRamSourceDataStore {
  /**
  * Configures the on-disk format settings for the mirrored backing stores data store, including format type and optional metadata cache tuning.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#format Domain#format}
  */
  readonly format?: DomainOsNvRamSourceDataStoreFormat;
}

export function domainOsNvRamSourceDataStoreToTerraform(struct?: DomainOsNvRamSourceDataStore | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    format: domainOsNvRamSourceDataStoreFormatToTerraform(struct!.format),
  }
}


export function domainOsNvRamSourceDataStoreToHclTerraform(struct?: DomainOsNvRamSourceDataStore | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    format: {
      value: domainOsNvRamSourceDataStoreFormatToHclTerraform(struct!.format),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceDataStoreFormat",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceDataStoreOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceDataStore | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._format?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceDataStore | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._format.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._format.internalValue = value.format;
    }
  }

  // format - computed: false, optional: true, required: false
  private _format = new DomainOsNvRamSourceDataStoreFormatOutputReference(this, "format");
  public get format() {
    return this._format;
  }
  public putFormat(value: DomainOsNvRamSourceDataStoreFormat) {
    this._format.internalValue = value;
  }
  public resetFormat() {
    this._format.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format.internalValue;
  }
}
export interface DomainOsNvRamSourceDir {
  /**
  * Sets the host directory path used as the mirrored backing store source; this must be an absolute path on the host (for example, "/var/lib/libvirt/images").
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dir Domain#dir}
  */
  readonly dir?: string;
}

export function domainOsNvRamSourceDirToTerraform(struct?: DomainOsNvRamSourceDir | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dir: cdktf.stringToTerraform(struct!.dir),
  }
}


export function domainOsNvRamSourceDirToHclTerraform(struct?: DomainOsNvRamSourceDir | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dir: {
      value: cdktf.stringToHclTerraform(struct!.dir),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceDirOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceDir | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dir !== undefined) {
      hasAnyValues = true;
      internalValueResult.dir = this._dir;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceDir | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dir = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dir = value.dir;
    }
  }

  // dir - computed: false, optional: true, required: false
  private _dir?: string; 
  public get dir() {
    return this.getStringAttribute('dir');
  }
  public set dir(value: string) {
    this._dir = value;
  }
  public resetDir() {
    this._dir = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dirInput() {
    return this._dir;
  }
}
export interface DomainOsNvRamSourceEncryptionSecrets {
  /**
  * Sets how the referenced secret is identified; typical values are user-provided strings such as "uuid" or "usage" depending on how the secret is looked up.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type?: string;
  /**
  * Sets the libvirt secret usage name when referencing the iSCSI auth secret by usage; the value is a user-provided identifier such as an iSCSI target name.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#usage Domain#usage}
  */
  readonly usage?: string;
}

export function domainOsNvRamSourceEncryptionSecretsToTerraform(struct?: DomainOsNvRamSourceEncryptionSecrets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    type: cdktf.stringToTerraform(struct!.type),
    usage: cdktf.stringToTerraform(struct!.usage),
  }
}


export function domainOsNvRamSourceEncryptionSecretsToHclTerraform(struct?: DomainOsNvRamSourceEncryptionSecrets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    usage: {
      value: cdktf.stringToHclTerraform(struct!.usage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceEncryptionSecretsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainOsNvRamSourceEncryptionSecrets | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._usage !== undefined) {
      hasAnyValues = true;
      internalValueResult.usage = this._usage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceEncryptionSecrets | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._type = undefined;
      this._usage = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._type = value.type;
      this._usage = value.usage;
    }
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // usage - computed: false, optional: true, required: false
  private _usage?: string; 
  public get usage() {
    return this.getStringAttribute('usage');
  }
  public set usage(value: string) {
    this._usage = value;
  }
  public resetUsage() {
    this._usage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usageInput() {
    return this._usage;
  }

  // uuid - computed: true, optional: false, required: false
  public get uuid() {
    return this.getStringAttribute('uuid');
  }
}

export class DomainOsNvRamSourceEncryptionSecretsList extends cdktf.ComplexList {
  public internalValue? : DomainOsNvRamSourceEncryptionSecrets[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainOsNvRamSourceEncryptionSecretsOutputReference {
    return new DomainOsNvRamSourceEncryptionSecretsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainOsNvRamSourceEncryption {
  /**
  * Sets the encryption engine/provider to use for the disk (user-provided string, e.g. implementation-specific engine name).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#engine Domain#engine}
  */
  readonly engine?: string;
  /**
  * Sets the disk encryption format, such as "luks" or another user-provided scheme supported by libvirt/qemu.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#format Domain#format}
  */
  readonly format?: string;
  /**
  * Defines one or more secret references used to access the encrypted disk, each describing how libvirt locates the secret material.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#secrets Domain#secrets}
  */
  readonly secrets?: DomainOsNvRamSourceEncryptionSecrets[] | cdktf.IResolvable;
}

export function domainOsNvRamSourceEncryptionToTerraform(struct?: DomainOsNvRamSourceEncryption | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    engine: cdktf.stringToTerraform(struct!.engine),
    format: cdktf.stringToTerraform(struct!.format),
    secrets: cdktf.listMapper(domainOsNvRamSourceEncryptionSecretsToTerraform, false)(struct!.secrets),
  }
}


export function domainOsNvRamSourceEncryptionToHclTerraform(struct?: DomainOsNvRamSourceEncryption | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    engine: {
      value: cdktf.stringToHclTerraform(struct!.engine),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secrets: {
      value: cdktf.listMapperHcl(domainOsNvRamSourceEncryptionSecretsToHclTerraform, false)(struct!.secrets),
      isBlock: true,
      type: "list",
      storageClassType: "DomainOsNvRamSourceEncryptionSecretsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceEncryptionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceEncryption | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._engine !== undefined) {
      hasAnyValues = true;
      internalValueResult.engine = this._engine;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._secrets?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secrets = this._secrets?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceEncryption | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._engine = undefined;
      this._format = undefined;
      this._secrets.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._engine = value.engine;
      this._format = value.format;
      this._secrets.internalValue = value.secrets;
    }
  }

  // engine - computed: false, optional: true, required: false
  private _engine?: string; 
  public get engine() {
    return this.getStringAttribute('engine');
  }
  public set engine(value: string) {
    this._engine = value;
  }
  public resetEngine() {
    this._engine = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get engineInput() {
    return this._engine;
  }

  // format - computed: false, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // secrets - computed: false, optional: true, required: false
  private _secrets = new DomainOsNvRamSourceEncryptionSecretsList(this, "secrets", false);
  public get secrets() {
    return this._secrets;
  }
  public putSecrets(value: DomainOsNvRamSourceEncryptionSecrets[] | cdktf.IResolvable) {
    this._secrets.internalValue = value;
  }
  public resetSecrets() {
    this._secrets.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretsInput() {
    return this._secrets.internalValue;
  }
}
export interface DomainOsNvRamSourceFileSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainOsNvRamSourceFileSecLabelToTerraform(struct?: DomainOsNvRamSourceFileSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainOsNvRamSourceFileSecLabelToHclTerraform(struct?: DomainOsNvRamSourceFileSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceFileSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainOsNvRamSourceFileSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceFileSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainOsNvRamSourceFileSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainOsNvRamSourceFileSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainOsNvRamSourceFileSecLabelOutputReference {
    return new DomainOsNvRamSourceFileSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainOsNvRamSourceFile {
  /**
  * Sets the name of an fdgroup whose pre-opened file descriptor is used for this backing store instead of opening the file path directly; value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#fd_group Domain#fd_group}
  */
  readonly fdGroup?: string;
  /**
  * Sets the absolute path on the host to the backing file used as the source for this mirrored disk (for example, /var/lib/libvirt/images/base.qcow2).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file?: string;
  /**
  * Configures an explicit security label for the file backing store, overriding default security driver labeling for this file.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainOsNvRamSourceFileSecLabel[] | cdktf.IResolvable;
}

export function domainOsNvRamSourceFileToTerraform(struct?: DomainOsNvRamSourceFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fd_group: cdktf.stringToTerraform(struct!.fdGroup),
    file: cdktf.stringToTerraform(struct!.file),
    sec_label: cdktf.listMapper(domainOsNvRamSourceFileSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainOsNvRamSourceFileToHclTerraform(struct?: DomainOsNvRamSourceFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fd_group: {
      value: cdktf.stringToHclTerraform(struct!.fdGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    file: {
      value: cdktf.stringToHclTerraform(struct!.file),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainOsNvRamSourceFileSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainOsNvRamSourceFileSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceFileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceFile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fdGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.fdGroup = this._fdGroup;
    }
    if (this._file !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceFile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fdGroup = undefined;
      this._file = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fdGroup = value.fdGroup;
      this._file = value.file;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // fd_group - computed: false, optional: true, required: false
  private _fdGroup?: string; 
  public get fdGroup() {
    return this.getStringAttribute('fd_group');
  }
  public set fdGroup(value: string) {
    this._fdGroup = value;
  }
  public resetFdGroup() {
    this._fdGroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fdGroupInput() {
    return this._fdGroup;
  }

  // file - computed: false, optional: true, required: false
  private _file?: string; 
  public get file() {
    return this.getStringAttribute('file');
  }
  public set file(value: string) {
    this._file = value;
  }
  public resetFile() {
    this._file = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainOsNvRamSourceFileSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainOsNvRamSourceFileSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainOsNvRamSourceNetworkAuthSecret {
  /**
  * Sets how the referenced secret is identified; typical values are user-provided strings such as "uuid" or "usage" depending on how the secret is looked up.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type?: string;
  /**
  * Sets the libvirt secret usage name when referencing the iSCSI auth secret by usage; the value is a user-provided identifier such as an iSCSI target name.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#usage Domain#usage}
  */
  readonly usage?: string;
}

export function domainOsNvRamSourceNetworkAuthSecretToTerraform(struct?: DomainOsNvRamSourceNetworkAuthSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    type: cdktf.stringToTerraform(struct!.type),
    usage: cdktf.stringToTerraform(struct!.usage),
  }
}


export function domainOsNvRamSourceNetworkAuthSecretToHclTerraform(struct?: DomainOsNvRamSourceNetworkAuthSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    usage: {
      value: cdktf.stringToHclTerraform(struct!.usage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceNetworkAuthSecretOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceNetworkAuthSecret | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._usage !== undefined) {
      hasAnyValues = true;
      internalValueResult.usage = this._usage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceNetworkAuthSecret | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._type = undefined;
      this._usage = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._type = value.type;
      this._usage = value.usage;
    }
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // usage - computed: false, optional: true, required: false
  private _usage?: string; 
  public get usage() {
    return this.getStringAttribute('usage');
  }
  public set usage(value: string) {
    this._usage = value;
  }
  public resetUsage() {
    this._usage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usageInput() {
    return this._usage;
  }

  // uuid - computed: true, optional: false, required: false
  public get uuid() {
    return this.getStringAttribute('uuid');
  }
}
export interface DomainOsNvRamSourceNetworkAuth {
  /**
  * Configures the libvirt secret object used to hold the iSCSI authentication password for this hostdev; this references an existing libvirt secret, not the clear-text secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#secret Domain#secret}
  */
  readonly secret?: DomainOsNvRamSourceNetworkAuthSecret;
  /**
  * Sets the CHAP username used when authenticating to the iSCSI target for this SCSI hostdev; the value is user-provided (for example, "chapuser1").
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#username Domain#username}
  */
  readonly username?: string;
}

export function domainOsNvRamSourceNetworkAuthToTerraform(struct?: DomainOsNvRamSourceNetworkAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret: domainOsNvRamSourceNetworkAuthSecretToTerraform(struct!.secret),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function domainOsNvRamSourceNetworkAuthToHclTerraform(struct?: DomainOsNvRamSourceNetworkAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret: {
      value: domainOsNvRamSourceNetworkAuthSecretToHclTerraform(struct!.secret),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceNetworkAuthSecret",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceNetworkAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceNetworkAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secret?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret?.internalValue;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceNetworkAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secret.internalValue = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secret.internalValue = value.secret;
      this._username = value.username;
    }
  }

  // secret - computed: false, optional: true, required: false
  private _secret = new DomainOsNvRamSourceNetworkAuthSecretOutputReference(this, "secret");
  public get secret() {
    return this._secret;
  }
  public putSecret(value: DomainOsNvRamSourceNetworkAuthSecret) {
    this._secret.internalValue = value;
  }
  public resetSecret() {
    this._secret.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret.internalValue;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface DomainOsNvRamSourceNetworkConfig {
  /**
  * Sets the path to the configuration file used for the network backing store connection, such as a Ceph configuration file (/etc/ceph/ceph.conf).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file: string;
}

export function domainOsNvRamSourceNetworkConfigToTerraform(struct?: DomainOsNvRamSourceNetworkConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    file: cdktf.stringToTerraform(struct!.file),
  }
}


export function domainOsNvRamSourceNetworkConfigToHclTerraform(struct?: DomainOsNvRamSourceNetworkConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    file: {
      value: cdktf.stringToHclTerraform(struct!.file),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceNetworkConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceNetworkConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._file !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceNetworkConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._file = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._file = value.file;
    }
  }

  // file - computed: false, optional: false, required: true
  private _file?: string; 
  public get file() {
    return this.getStringAttribute('file');
  }
  public set file(value: string) {
    this._file = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file;
  }
}
export interface DomainOsNvRamSourceNetworkHosts {
  /**
  * Sets the hostname or IP address of the iSCSI target portal (for example, "10.0.0.10" or "iscsi.example.com").
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name?: string;
  /**
  * Sets the TCP port of the iSCSI target portal; if omitted, libvirt/driver defaults (commonly 3260) are used.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#port Domain#port}
  */
  readonly port?: string;
  /**
  * Sets a UNIX domain socket path to connect to an iSCSI target via a local socket instead of TCP; value is a user-provided filesystem path.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#socket Domain#socket}
  */
  readonly socket?: string;
  /**
  * Sets the transport type used to reach the iSCSI target portal; valid values are user-provided strings as supported by the environment (for example, "tcp" or "iser").
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#transport Domain#transport}
  */
  readonly transport?: string;
}

export function domainOsNvRamSourceNetworkHostsToTerraform(struct?: DomainOsNvRamSourceNetworkHosts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    port: cdktf.stringToTerraform(struct!.port),
    socket: cdktf.stringToTerraform(struct!.socket),
    transport: cdktf.stringToTerraform(struct!.transport),
  }
}


export function domainOsNvRamSourceNetworkHostsToHclTerraform(struct?: DomainOsNvRamSourceNetworkHosts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.stringToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    socket: {
      value: cdktf.stringToHclTerraform(struct!.socket),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    transport: {
      value: cdktf.stringToHclTerraform(struct!.transport),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceNetworkHostsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainOsNvRamSourceNetworkHosts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._socket !== undefined) {
      hasAnyValues = true;
      internalValueResult.socket = this._socket;
    }
    if (this._transport !== undefined) {
      hasAnyValues = true;
      internalValueResult.transport = this._transport;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceNetworkHosts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._port = undefined;
      this._socket = undefined;
      this._transport = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._port = value.port;
      this._socket = value.socket;
      this._transport = value.transport;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port - computed: false, optional: true, required: false
  private _port?: string; 
  public get port() {
    return this.getStringAttribute('port');
  }
  public set port(value: string) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // socket - computed: false, optional: true, required: false
  private _socket?: string; 
  public get socket() {
    return this.getStringAttribute('socket');
  }
  public set socket(value: string) {
    this._socket = value;
  }
  public resetSocket() {
    this._socket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketInput() {
    return this._socket;
  }

  // transport - computed: false, optional: true, required: false
  private _transport?: string; 
  public get transport() {
    return this.getStringAttribute('transport');
  }
  public set transport(value: string) {
    this._transport = value;
  }
  public resetTransport() {
    this._transport = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get transportInput() {
    return this._transport;
  }
}

export class DomainOsNvRamSourceNetworkHostsList extends cdktf.ComplexList {
  public internalValue? : DomainOsNvRamSourceNetworkHosts[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainOsNvRamSourceNetworkHostsOutputReference {
    return new DomainOsNvRamSourceNetworkHostsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainOsNvRamSourceNetworkIdentity {
  /**
  * Sets the path to a local agent socket used for external authentication (for example, SASL or SSH agent) when connecting to the network backing store; value is a user-provided Unix socket path.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#agent_sock Domain#agent_sock}
  */
  readonly agentSock?: string;
  /**
  * Sets the group name to use for authentication or access control when connecting to the network backing store; value is user-provided and protocol-specific.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#group Domain#group}
  */
  readonly group?: string;
  /**
  * Sets the path to a private key file used for authenticating to the network backing store (for example, an SSH or TLS key); value is a user-provided filesystem path.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#keyfile Domain#keyfile}
  */
  readonly keyfile?: string;
  /**
  * Sets the user identifier used for authentication to the network backing store; value is user-provided and typically matches a remote account name.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#user Domain#user}
  */
  readonly user?: string;
  /**
  * Sets an explicit username string used for authentication to the network backing store, separate from any other user identity settings; value is user-provided (for example, "backupuser").
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#user_name Domain#user_name}
  */
  readonly userName?: string;
}

export function domainOsNvRamSourceNetworkIdentityToTerraform(struct?: DomainOsNvRamSourceNetworkIdentity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    agent_sock: cdktf.stringToTerraform(struct!.agentSock),
    group: cdktf.stringToTerraform(struct!.group),
    keyfile: cdktf.stringToTerraform(struct!.keyfile),
    user: cdktf.stringToTerraform(struct!.user),
    user_name: cdktf.stringToTerraform(struct!.userName),
  }
}


export function domainOsNvRamSourceNetworkIdentityToHclTerraform(struct?: DomainOsNvRamSourceNetworkIdentity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    agent_sock: {
      value: cdktf.stringToHclTerraform(struct!.agentSock),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    group: {
      value: cdktf.stringToHclTerraform(struct!.group),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keyfile: {
      value: cdktf.stringToHclTerraform(struct!.keyfile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user: {
      value: cdktf.stringToHclTerraform(struct!.user),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user_name: {
      value: cdktf.stringToHclTerraform(struct!.userName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceNetworkIdentityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceNetworkIdentity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._agentSock !== undefined) {
      hasAnyValues = true;
      internalValueResult.agentSock = this._agentSock;
    }
    if (this._group !== undefined) {
      hasAnyValues = true;
      internalValueResult.group = this._group;
    }
    if (this._keyfile !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyfile = this._keyfile;
    }
    if (this._user !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user;
    }
    if (this._userName !== undefined) {
      hasAnyValues = true;
      internalValueResult.userName = this._userName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceNetworkIdentity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._agentSock = undefined;
      this._group = undefined;
      this._keyfile = undefined;
      this._user = undefined;
      this._userName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._agentSock = value.agentSock;
      this._group = value.group;
      this._keyfile = value.keyfile;
      this._user = value.user;
      this._userName = value.userName;
    }
  }

  // agent_sock - computed: false, optional: true, required: false
  private _agentSock?: string; 
  public get agentSock() {
    return this.getStringAttribute('agent_sock');
  }
  public set agentSock(value: string) {
    this._agentSock = value;
  }
  public resetAgentSock() {
    this._agentSock = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get agentSockInput() {
    return this._agentSock;
  }

  // group - computed: false, optional: true, required: false
  private _group?: string; 
  public get group() {
    return this.getStringAttribute('group');
  }
  public set group(value: string) {
    this._group = value;
  }
  public resetGroup() {
    this._group = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupInput() {
    return this._group;
  }

  // keyfile - computed: false, optional: true, required: false
  private _keyfile?: string; 
  public get keyfile() {
    return this.getStringAttribute('keyfile');
  }
  public set keyfile(value: string) {
    this._keyfile = value;
  }
  public resetKeyfile() {
    this._keyfile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyfileInput() {
    return this._keyfile;
  }

  // user - computed: false, optional: true, required: false
  private _user?: string; 
  public get user() {
    return this.getStringAttribute('user');
  }
  public set user(value: string) {
    this._user = value;
  }
  public resetUser() {
    this._user = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user;
  }

  // user_name - computed: false, optional: true, required: false
  private _userName?: string; 
  public get userName() {
    return this.getStringAttribute('user_name');
  }
  public set userName(value: string) {
    this._userName = value;
  }
  public resetUserName() {
    this._userName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userNameInput() {
    return this._userName;
  }
}
export interface DomainOsNvRamSourceNetworkInitiatorIqn {
  /**
  * Sets the initiator IQN string used when logging into an iSCSI target backing the mirrored disk; value must be a valid IQN (for example, iqn.2020-01.com.example:host1).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name?: string;
}

export function domainOsNvRamSourceNetworkInitiatorIqnToTerraform(struct?: DomainOsNvRamSourceNetworkInitiatorIqn | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function domainOsNvRamSourceNetworkInitiatorIqnToHclTerraform(struct?: DomainOsNvRamSourceNetworkInitiatorIqn | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceNetworkInitiatorIqnOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceNetworkInitiatorIqn | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceNetworkInitiatorIqn | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DomainOsNvRamSourceNetworkInitiator {
  /**
  * Configures the iSCSI initiator IQN block for the mirrored network backing store, defining the initiator name presented to the target.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#iqn Domain#iqn}
  */
  readonly iqn?: DomainOsNvRamSourceNetworkInitiatorIqn;
}

export function domainOsNvRamSourceNetworkInitiatorToTerraform(struct?: DomainOsNvRamSourceNetworkInitiator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    iqn: domainOsNvRamSourceNetworkInitiatorIqnToTerraform(struct!.iqn),
  }
}


export function domainOsNvRamSourceNetworkInitiatorToHclTerraform(struct?: DomainOsNvRamSourceNetworkInitiator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    iqn: {
      value: domainOsNvRamSourceNetworkInitiatorIqnToHclTerraform(struct!.iqn),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceNetworkInitiatorIqn",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceNetworkInitiatorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceNetworkInitiator | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._iqn?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.iqn = this._iqn?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceNetworkInitiator | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._iqn.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._iqn.internalValue = value.iqn;
    }
  }

  // iqn - computed: false, optional: true, required: false
  private _iqn = new DomainOsNvRamSourceNetworkInitiatorIqnOutputReference(this, "iqn");
  public get iqn() {
    return this._iqn;
  }
  public putIqn(value: DomainOsNvRamSourceNetworkInitiatorIqn) {
    this._iqn.internalValue = value;
  }
  public resetIqn() {
    this._iqn.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get iqnInput() {
    return this._iqn.internalValue;
  }
}
export interface DomainOsNvRamSourceNetworkKnownHosts {
  /**
  * Sets the path to the known-hosts file used to verify the identity of the remote storage host; value is a required user-provided filesystem path (for example, /etc/libvirt/known_hosts).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
}

export function domainOsNvRamSourceNetworkKnownHostsToTerraform(struct?: DomainOsNvRamSourceNetworkKnownHosts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function domainOsNvRamSourceNetworkKnownHostsToHclTerraform(struct?: DomainOsNvRamSourceNetworkKnownHosts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceNetworkKnownHostsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceNetworkKnownHosts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceNetworkKnownHosts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface DomainOsNvRamSourceNetworkReconnect {
  /**
  * Sets the reconnection delay (in seconds) before retrying a failed connection to the mirrored network backing store; value is a required user-provided non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#delay Domain#delay}
  */
  readonly delay: string;
}

export function domainOsNvRamSourceNetworkReconnectToTerraform(struct?: DomainOsNvRamSourceNetworkReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    delay: cdktf.stringToTerraform(struct!.delay),
  }
}


export function domainOsNvRamSourceNetworkReconnectToHclTerraform(struct?: DomainOsNvRamSourceNetworkReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    delay: {
      value: cdktf.stringToHclTerraform(struct!.delay),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceNetworkReconnectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceNetworkReconnect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._delay !== undefined) {
      hasAnyValues = true;
      internalValueResult.delay = this._delay;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceNetworkReconnect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._delay = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._delay = value.delay;
    }
  }

  // delay - computed: false, optional: false, required: true
  private _delay?: string; 
  public get delay() {
    return this.getStringAttribute('delay');
  }
  public set delay(value: string) {
    this._delay = value;
  }
  // Temporarily expose input value. Use with caution.
  public get delayInput() {
    return this._delay;
  }
}
export interface DomainOsNvRamSourceNetworkSnapshot {
  /**
  * Sets the name of the network snapshot to use as the backing store for the mirrored disks network source; value is user-provided and must match an existing snapshot identifier on the storage backend.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
}

export function domainOsNvRamSourceNetworkSnapshotToTerraform(struct?: DomainOsNvRamSourceNetworkSnapshot | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function domainOsNvRamSourceNetworkSnapshotToHclTerraform(struct?: DomainOsNvRamSourceNetworkSnapshot | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceNetworkSnapshotOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceNetworkSnapshot | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceNetworkSnapshot | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DomainOsNvRamSourceNetwork {
  /**
  * Configures CHAP authentication parameters for the iSCSI source backing an assigned SCSI host device; include this block only when the target requires authentication.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#auth Domain#auth}
  */
  readonly auth?: DomainOsNvRamSourceNetworkAuth;
  /**
  * Points to an external configuration source for the network backing store (for example, an RBD or Ceph config file) that libvirt passes to the backend.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#config Domain#config}
  */
  readonly config?: DomainOsNvRamSourceNetworkConfig;
  /**
  * Declares one or more network endpoints (hosts) for the backing store server, each with its own name/address and possibly additional attributes.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#hosts Domain#hosts}
  */
  readonly hosts?: DomainOsNvRamSourceNetworkHosts[] | cdktf.IResolvable;
  /**
  * Configures authentication/identity parameters used when accessing the mirrored backing store over a network, such as user, group, keyfile, or agent socket, depending on the protocol.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#identity Domain#identity}
  */
  readonly identity?: DomainOsNvRamSourceNetworkIdentity;
  /**
  * Configures initiator identity information (typically for iSCSI-like protocols) used when accessing the mirrored network backing store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#initiator Domain#initiator}
  */
  readonly initiator?: DomainOsNvRamSourceNetworkInitiator;
  /**
  * Enables use of a known-hosts file to validate the remote hosts identity when connecting to the mirrored network backing store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#known_hosts Domain#known_hosts}
  */
  readonly knownHosts?: DomainOsNvRamSourceNetworkKnownHosts;
  /**
  * Sets a name for the network source of the mirrored backing store, typically used by certain protocols (such as RBD pool or NBD export names); value is user-provided and protocol-specific.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name?: string;
  /**
  * Sets the network storage protocol used for the mirrored backing store; value is user-provided but must be a protocol supported by libvirt for network disks (for example, rbd, sheepdog, gluster, nbd).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#protocol Domain#protocol}
  */
  readonly protocol?: string;
  /**
  * Sets an optional query string or subresource specifier for the network storage URL of the mirrored backing store; value is user-provided and protocol-specific.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#query Domain#query}
  */
  readonly query?: string;
  /**
  * Configures automatic reconnection behavior for the mirrored network backing store after a connection loss.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reconnect Domain#reconnect}
  */
  readonly reconnect?: DomainOsNvRamSourceNetworkReconnect;
  /**
  * Configures snapshot-related behavior for the network-based mirrored backing store, with semantics depending on the underlying protocol and storage implementation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#snapshot Domain#snapshot}
  */
  readonly snapshot?: DomainOsNvRamSourceNetworkSnapshot;
  /**
  * Controls whether TLS is used for the mirrored disks network backing-store connection; value is user-provided and typically enabled only when the chosen protocol and backend support TLS.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tls Domain#tls}
  */
  readonly tls?: string;
  /**
  * Sets the expected TLS hostname for the mirrored disks network backing-store connection, used for certificate verification; value is user-provided and should match the server certificates hostname (for example, "storage.example.com").
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tls_hostname Domain#tls_hostname}
  */
  readonly tlsHostname?: string;
}

export function domainOsNvRamSourceNetworkToTerraform(struct?: DomainOsNvRamSourceNetwork | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: domainOsNvRamSourceNetworkAuthToTerraform(struct!.auth),
    config: domainOsNvRamSourceNetworkConfigToTerraform(struct!.config),
    hosts: cdktf.listMapper(domainOsNvRamSourceNetworkHostsToTerraform, false)(struct!.hosts),
    identity: domainOsNvRamSourceNetworkIdentityToTerraform(struct!.identity),
    initiator: domainOsNvRamSourceNetworkInitiatorToTerraform(struct!.initiator),
    known_hosts: domainOsNvRamSourceNetworkKnownHostsToTerraform(struct!.knownHosts),
    name: cdktf.stringToTerraform(struct!.name),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    query: cdktf.stringToTerraform(struct!.query),
    reconnect: domainOsNvRamSourceNetworkReconnectToTerraform(struct!.reconnect),
    snapshot: domainOsNvRamSourceNetworkSnapshotToTerraform(struct!.snapshot),
    tls: cdktf.stringToTerraform(struct!.tls),
    tls_hostname: cdktf.stringToTerraform(struct!.tlsHostname),
  }
}


export function domainOsNvRamSourceNetworkToHclTerraform(struct?: DomainOsNvRamSourceNetwork | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: domainOsNvRamSourceNetworkAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceNetworkAuth",
    },
    config: {
      value: domainOsNvRamSourceNetworkConfigToHclTerraform(struct!.config),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceNetworkConfig",
    },
    hosts: {
      value: cdktf.listMapperHcl(domainOsNvRamSourceNetworkHostsToHclTerraform, false)(struct!.hosts),
      isBlock: true,
      type: "list",
      storageClassType: "DomainOsNvRamSourceNetworkHostsList",
    },
    identity: {
      value: domainOsNvRamSourceNetworkIdentityToHclTerraform(struct!.identity),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceNetworkIdentity",
    },
    initiator: {
      value: domainOsNvRamSourceNetworkInitiatorToHclTerraform(struct!.initiator),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceNetworkInitiator",
    },
    known_hosts: {
      value: domainOsNvRamSourceNetworkKnownHostsToHclTerraform(struct!.knownHosts),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceNetworkKnownHosts",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    query: {
      value: cdktf.stringToHclTerraform(struct!.query),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reconnect: {
      value: domainOsNvRamSourceNetworkReconnectToHclTerraform(struct!.reconnect),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceNetworkReconnect",
    },
    snapshot: {
      value: domainOsNvRamSourceNetworkSnapshotToHclTerraform(struct!.snapshot),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceNetworkSnapshot",
    },
    tls: {
      value: cdktf.stringToHclTerraform(struct!.tls),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_hostname: {
      value: cdktf.stringToHclTerraform(struct!.tlsHostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceNetworkOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceNetwork | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._config?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.config = this._config?.internalValue;
    }
    if (this._hosts?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hosts = this._hosts?.internalValue;
    }
    if (this._identity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.identity = this._identity?.internalValue;
    }
    if (this._initiator?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.initiator = this._initiator?.internalValue;
    }
    if (this._knownHosts?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.knownHosts = this._knownHosts?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._query !== undefined) {
      hasAnyValues = true;
      internalValueResult.query = this._query;
    }
    if (this._reconnect?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.reconnect = this._reconnect?.internalValue;
    }
    if (this._snapshot?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.snapshot = this._snapshot?.internalValue;
    }
    if (this._tls !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls;
    }
    if (this._tlsHostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsHostname = this._tlsHostname;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceNetwork | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._config.internalValue = undefined;
      this._hosts.internalValue = undefined;
      this._identity.internalValue = undefined;
      this._initiator.internalValue = undefined;
      this._knownHosts.internalValue = undefined;
      this._name = undefined;
      this._protocol = undefined;
      this._query = undefined;
      this._reconnect.internalValue = undefined;
      this._snapshot.internalValue = undefined;
      this._tls = undefined;
      this._tlsHostname = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._config.internalValue = value.config;
      this._hosts.internalValue = value.hosts;
      this._identity.internalValue = value.identity;
      this._initiator.internalValue = value.initiator;
      this._knownHosts.internalValue = value.knownHosts;
      this._name = value.name;
      this._protocol = value.protocol;
      this._query = value.query;
      this._reconnect.internalValue = value.reconnect;
      this._snapshot.internalValue = value.snapshot;
      this._tls = value.tls;
      this._tlsHostname = value.tlsHostname;
    }
  }

  // auth - computed: false, optional: true, required: false
  private _auth = new DomainOsNvRamSourceNetworkAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DomainOsNvRamSourceNetworkAuth) {
    this._auth.internalValue = value;
  }
  public resetAuth() {
    this._auth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // config - computed: false, optional: true, required: false
  private _config = new DomainOsNvRamSourceNetworkConfigOutputReference(this, "config");
  public get config() {
    return this._config;
  }
  public putConfig(value: DomainOsNvRamSourceNetworkConfig) {
    this._config.internalValue = value;
  }
  public resetConfig() {
    this._config.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configInput() {
    return this._config.internalValue;
  }

  // hosts - computed: false, optional: true, required: false
  private _hosts = new DomainOsNvRamSourceNetworkHostsList(this, "hosts", false);
  public get hosts() {
    return this._hosts;
  }
  public putHosts(value: DomainOsNvRamSourceNetworkHosts[] | cdktf.IResolvable) {
    this._hosts.internalValue = value;
  }
  public resetHosts() {
    this._hosts.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostsInput() {
    return this._hosts.internalValue;
  }

  // identity - computed: false, optional: true, required: false
  private _identity = new DomainOsNvRamSourceNetworkIdentityOutputReference(this, "identity");
  public get identity() {
    return this._identity;
  }
  public putIdentity(value: DomainOsNvRamSourceNetworkIdentity) {
    this._identity.internalValue = value;
  }
  public resetIdentity() {
    this._identity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identityInput() {
    return this._identity.internalValue;
  }

  // initiator - computed: false, optional: true, required: false
  private _initiator = new DomainOsNvRamSourceNetworkInitiatorOutputReference(this, "initiator");
  public get initiator() {
    return this._initiator;
  }
  public putInitiator(value: DomainOsNvRamSourceNetworkInitiator) {
    this._initiator.internalValue = value;
  }
  public resetInitiator() {
    this._initiator.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initiatorInput() {
    return this._initiator.internalValue;
  }

  // known_hosts - computed: false, optional: true, required: false
  private _knownHosts = new DomainOsNvRamSourceNetworkKnownHostsOutputReference(this, "known_hosts");
  public get knownHosts() {
    return this._knownHosts;
  }
  public putKnownHosts(value: DomainOsNvRamSourceNetworkKnownHosts) {
    this._knownHosts.internalValue = value;
  }
  public resetKnownHosts() {
    this._knownHosts.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get knownHostsInput() {
    return this._knownHosts.internalValue;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // protocol - computed: false, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // query - computed: false, optional: true, required: false
  private _query?: string; 
  public get query() {
    return this.getStringAttribute('query');
  }
  public set query(value: string) {
    this._query = value;
  }
  public resetQuery() {
    this._query = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queryInput() {
    return this._query;
  }

  // reconnect - computed: false, optional: true, required: false
  private _reconnect = new DomainOsNvRamSourceNetworkReconnectOutputReference(this, "reconnect");
  public get reconnect() {
    return this._reconnect;
  }
  public putReconnect(value: DomainOsNvRamSourceNetworkReconnect) {
    this._reconnect.internalValue = value;
  }
  public resetReconnect() {
    this._reconnect.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reconnectInput() {
    return this._reconnect.internalValue;
  }

  // snapshot - computed: false, optional: true, required: false
  private _snapshot = new DomainOsNvRamSourceNetworkSnapshotOutputReference(this, "snapshot");
  public get snapshot() {
    return this._snapshot;
  }
  public putSnapshot(value: DomainOsNvRamSourceNetworkSnapshot) {
    this._snapshot.internalValue = value;
  }
  public resetSnapshot() {
    this._snapshot.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get snapshotInput() {
    return this._snapshot.internalValue;
  }

  // tls - computed: false, optional: true, required: false
  private _tls?: string; 
  public get tls() {
    return this.getStringAttribute('tls');
  }
  public set tls(value: string) {
    this._tls = value;
  }
  public resetTls() {
    this._tls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls;
  }

  // tls_hostname - computed: false, optional: true, required: false
  private _tlsHostname?: string; 
  public get tlsHostname() {
    return this.getStringAttribute('tls_hostname');
  }
  public set tlsHostname(value: string) {
    this._tlsHostname = value;
  }
  public resetTlsHostname() {
    this._tlsHostname = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsHostnameInput() {
    return this._tlsHostname;
  }
}
export interface DomainOsNvRamSourceNvme {
}

export function domainOsNvRamSourceNvmeToTerraform(struct?: DomainOsNvRamSourceNvme | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function domainOsNvRamSourceNvmeToHclTerraform(struct?: DomainOsNvRamSourceNvme | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DomainOsNvRamSourceNvmeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceNvme | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceNvme | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DomainOsNvRamSourceReadahead {
  /**
  * Sets the read-ahead size for the mirrored disks backing store; value is a user-provided positive integer in bytes (for example, 65536 for 64 KiB).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#size Domain#size}
  */
  readonly size: string;
}

export function domainOsNvRamSourceReadaheadToTerraform(struct?: DomainOsNvRamSourceReadahead | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    size: cdktf.stringToTerraform(struct!.size),
  }
}


export function domainOsNvRamSourceReadaheadToHclTerraform(struct?: DomainOsNvRamSourceReadahead | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    size: {
      value: cdktf.stringToHclTerraform(struct!.size),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceReadaheadOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceReadahead | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._size !== undefined) {
      hasAnyValues = true;
      internalValueResult.size = this._size;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceReadahead | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._size = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._size = value.size;
    }
  }

  // size - computed: false, optional: false, required: true
  private _size?: string; 
  public get size() {
    return this.getStringAttribute('size');
  }
  public set size(value: string) {
    this._size = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sizeInput() {
    return this._size;
  }
}
export interface DomainOsNvRamSourceReservationsSourceDbus {
  /**
  * Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#channel Domain#channel}
  */
  readonly channel?: string;
}

export function domainOsNvRamSourceReservationsSourceDbusToTerraform(struct?: DomainOsNvRamSourceReservationsSourceDbus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    channel: cdktf.stringToTerraform(struct!.channel),
  }
}


export function domainOsNvRamSourceReservationsSourceDbusToHclTerraform(struct?: DomainOsNvRamSourceReservationsSourceDbus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    channel: {
      value: cdktf.stringToHclTerraform(struct!.channel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceReservationsSourceDbusOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceReservationsSourceDbus | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._channel !== undefined) {
      hasAnyValues = true;
      internalValueResult.channel = this._channel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceReservationsSourceDbus | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._channel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._channel = value.channel;
    }
  }

  // channel - computed: false, optional: true, required: false
  private _channel?: string; 
  public get channel() {
    return this.getStringAttribute('channel');
  }
  public set channel(value: string) {
    this._channel = value;
  }
  public resetChannel() {
    this._channel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get channelInput() {
    return this._channel;
  }
}
export interface DomainOsNvRamSourceReservationsSourceDevSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainOsNvRamSourceReservationsSourceDevSecLabelToTerraform(struct?: DomainOsNvRamSourceReservationsSourceDevSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainOsNvRamSourceReservationsSourceDevSecLabelToHclTerraform(struct?: DomainOsNvRamSourceReservationsSourceDevSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceReservationsSourceDevSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainOsNvRamSourceReservationsSourceDevSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceReservationsSourceDevSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainOsNvRamSourceReservationsSourceDevSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainOsNvRamSourceReservationsSourceDevSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainOsNvRamSourceReservationsSourceDevSecLabelOutputReference {
    return new DomainOsNvRamSourceReservationsSourceDevSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainOsNvRamSourceReservationsSourceDev {
  /**
  * Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainOsNvRamSourceReservationsSourceDevSecLabel[] | cdktf.IResolvable;
}

export function domainOsNvRamSourceReservationsSourceDevToTerraform(struct?: DomainOsNvRamSourceReservationsSourceDev | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainOsNvRamSourceReservationsSourceDevSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainOsNvRamSourceReservationsSourceDevToHclTerraform(struct?: DomainOsNvRamSourceReservationsSourceDev | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainOsNvRamSourceReservationsSourceDevSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainOsNvRamSourceReservationsSourceDevSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceReservationsSourceDevOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceReservationsSourceDev | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceReservationsSourceDev | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainOsNvRamSourceReservationsSourceDevSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainOsNvRamSourceReservationsSourceDevSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainOsNvRamSourceReservationsSourceFileSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainOsNvRamSourceReservationsSourceFileSecLabelToTerraform(struct?: DomainOsNvRamSourceReservationsSourceFileSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainOsNvRamSourceReservationsSourceFileSecLabelToHclTerraform(struct?: DomainOsNvRamSourceReservationsSourceFileSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceReservationsSourceFileSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainOsNvRamSourceReservationsSourceFileSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceReservationsSourceFileSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainOsNvRamSourceReservationsSourceFileSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainOsNvRamSourceReservationsSourceFileSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainOsNvRamSourceReservationsSourceFileSecLabelOutputReference {
    return new DomainOsNvRamSourceReservationsSourceFileSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainOsNvRamSourceReservationsSourceFile {
  /**
  * Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.
  * 
  * See: <https://libvirt.org/formatdomain.html#device-logfile>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#append Domain#append}
  */
  readonly append?: string;
  /**
  * Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainOsNvRamSourceReservationsSourceFileSecLabel[] | cdktf.IResolvable;
}

export function domainOsNvRamSourceReservationsSourceFileToTerraform(struct?: DomainOsNvRamSourceReservationsSourceFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.stringToTerraform(struct!.append),
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainOsNvRamSourceReservationsSourceFileSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainOsNvRamSourceReservationsSourceFileToHclTerraform(struct?: DomainOsNvRamSourceReservationsSourceFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.stringToHclTerraform(struct!.append),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainOsNvRamSourceReservationsSourceFileSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainOsNvRamSourceReservationsSourceFileSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceReservationsSourceFileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceReservationsSourceFile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceReservationsSourceFile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append = value.append;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append?: string; 
  public get append() {
    return this.getStringAttribute('append');
  }
  public set append(value: string) {
    this._append = value;
  }
  public resetAppend() {
    this._append = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append;
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainOsNvRamSourceReservationsSourceFileSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainOsNvRamSourceReservationsSourceFileSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainOsNvRamSourceReservationsSourceNmdm {
  /**
  * Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.
  * 
  * See: <https://libvirt.org/formatdomain.html#nmdm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#master Domain#master}
  */
  readonly master: string;
  /**
  * Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.
  * 
  * See: <https://libvirt.org/formatdomain.html#nmdm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#slave Domain#slave}
  */
  readonly slave: string;
}

export function domainOsNvRamSourceReservationsSourceNmdmToTerraform(struct?: DomainOsNvRamSourceReservationsSourceNmdm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    master: cdktf.stringToTerraform(struct!.master),
    slave: cdktf.stringToTerraform(struct!.slave),
  }
}


export function domainOsNvRamSourceReservationsSourceNmdmToHclTerraform(struct?: DomainOsNvRamSourceReservationsSourceNmdm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    master: {
      value: cdktf.stringToHclTerraform(struct!.master),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    slave: {
      value: cdktf.stringToHclTerraform(struct!.slave),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceReservationsSourceNmdmOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceReservationsSourceNmdm | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._master !== undefined) {
      hasAnyValues = true;
      internalValueResult.master = this._master;
    }
    if (this._slave !== undefined) {
      hasAnyValues = true;
      internalValueResult.slave = this._slave;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceReservationsSourceNmdm | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._master = undefined;
      this._slave = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._master = value.master;
      this._slave = value.slave;
    }
  }

  // master - computed: false, optional: false, required: true
  private _master?: string; 
  public get master() {
    return this.getStringAttribute('master');
  }
  public set master(value: string) {
    this._master = value;
  }
  // Temporarily expose input value. Use with caution.
  public get masterInput() {
    return this._master;
  }

  // slave - computed: false, optional: false, required: true
  private _slave?: string; 
  public get slave() {
    return this.getStringAttribute('slave');
  }
  public set slave(value: string) {
    this._slave = value;
  }
  // Temporarily expose input value. Use with caution.
  public get slaveInput() {
    return this._slave;
  }
}
export interface DomainOsNvRamSourceReservationsSourcePipeSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainOsNvRamSourceReservationsSourcePipeSecLabelToTerraform(struct?: DomainOsNvRamSourceReservationsSourcePipeSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainOsNvRamSourceReservationsSourcePipeSecLabelToHclTerraform(struct?: DomainOsNvRamSourceReservationsSourcePipeSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceReservationsSourcePipeSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainOsNvRamSourceReservationsSourcePipeSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceReservationsSourcePipeSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainOsNvRamSourceReservationsSourcePipeSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainOsNvRamSourceReservationsSourcePipeSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainOsNvRamSourceReservationsSourcePipeSecLabelOutputReference {
    return new DomainOsNvRamSourceReservationsSourcePipeSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainOsNvRamSourceReservationsSourcePipe {
  /**
  * Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainOsNvRamSourceReservationsSourcePipeSecLabel[] | cdktf.IResolvable;
}

export function domainOsNvRamSourceReservationsSourcePipeToTerraform(struct?: DomainOsNvRamSourceReservationsSourcePipe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainOsNvRamSourceReservationsSourcePipeSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainOsNvRamSourceReservationsSourcePipeToHclTerraform(struct?: DomainOsNvRamSourceReservationsSourcePipe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainOsNvRamSourceReservationsSourcePipeSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainOsNvRamSourceReservationsSourcePipeSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceReservationsSourcePipeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceReservationsSourcePipe | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceReservationsSourcePipe | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainOsNvRamSourceReservationsSourcePipeSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainOsNvRamSourceReservationsSourcePipeSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainOsNvRamSourceReservationsSourcePtySecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainOsNvRamSourceReservationsSourcePtySecLabelToTerraform(struct?: DomainOsNvRamSourceReservationsSourcePtySecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainOsNvRamSourceReservationsSourcePtySecLabelToHclTerraform(struct?: DomainOsNvRamSourceReservationsSourcePtySecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceReservationsSourcePtySecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainOsNvRamSourceReservationsSourcePtySecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceReservationsSourcePtySecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainOsNvRamSourceReservationsSourcePtySecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainOsNvRamSourceReservationsSourcePtySecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainOsNvRamSourceReservationsSourcePtySecLabelOutputReference {
    return new DomainOsNvRamSourceReservationsSourcePtySecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainOsNvRamSourceReservationsSourcePty {
  /**
  * Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainOsNvRamSourceReservationsSourcePtySecLabel[] | cdktf.IResolvable;
}

export function domainOsNvRamSourceReservationsSourcePtyToTerraform(struct?: DomainOsNvRamSourceReservationsSourcePty | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainOsNvRamSourceReservationsSourcePtySecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainOsNvRamSourceReservationsSourcePtyToHclTerraform(struct?: DomainOsNvRamSourceReservationsSourcePty | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainOsNvRamSourceReservationsSourcePtySecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainOsNvRamSourceReservationsSourcePtySecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceReservationsSourcePtyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceReservationsSourcePty | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceReservationsSourcePty | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainOsNvRamSourceReservationsSourcePtySecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainOsNvRamSourceReservationsSourcePtySecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainOsNvRamSourceReservationsSourceQemuvdAgentClipBoard {
  /**
  * Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#copy_paste Domain#copy_paste}
  */
  readonly copyPaste: string;
}

export function domainOsNvRamSourceReservationsSourceQemuvdAgentClipBoardToTerraform(struct?: DomainOsNvRamSourceReservationsSourceQemuvdAgentClipBoard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    copy_paste: cdktf.stringToTerraform(struct!.copyPaste),
  }
}


export function domainOsNvRamSourceReservationsSourceQemuvdAgentClipBoardToHclTerraform(struct?: DomainOsNvRamSourceReservationsSourceQemuvdAgentClipBoard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    copy_paste: {
      value: cdktf.stringToHclTerraform(struct!.copyPaste),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceReservationsSourceQemuvdAgentClipBoardOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceReservationsSourceQemuvdAgentClipBoard | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._copyPaste !== undefined) {
      hasAnyValues = true;
      internalValueResult.copyPaste = this._copyPaste;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceReservationsSourceQemuvdAgentClipBoard | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._copyPaste = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._copyPaste = value.copyPaste;
    }
  }

  // copy_paste - computed: false, optional: false, required: true
  private _copyPaste?: string; 
  public get copyPaste() {
    return this.getStringAttribute('copy_paste');
  }
  public set copyPaste(value: string) {
    this._copyPaste = value;
  }
  // Temporarily expose input value. Use with caution.
  public get copyPasteInput() {
    return this._copyPaste;
  }
}
export interface DomainOsNvRamSourceReservationsSourceQemuvdAgentMouse {
  /**
  * Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).
  * 
  * See: <https://libvirt.org/formatdomain.html#channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode: string;
}

export function domainOsNvRamSourceReservationsSourceQemuvdAgentMouseToTerraform(struct?: DomainOsNvRamSourceReservationsSourceQemuvdAgentMouse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
  }
}


export function domainOsNvRamSourceReservationsSourceQemuvdAgentMouseToHclTerraform(struct?: DomainOsNvRamSourceReservationsSourceQemuvdAgentMouse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceReservationsSourceQemuvdAgentMouseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceReservationsSourceQemuvdAgentMouse | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceReservationsSourceQemuvdAgentMouse | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
    }
  }

  // mode - computed: false, optional: false, required: true
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }
}
export interface DomainOsNvRamSourceReservationsSourceQemuvdAgent {
  /**
  * Configures clipboard-related behavior for the QEMU vdagentbased EGD source, controlling whether clipboard data exchange is allowed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#clip_board Domain#clip_board}
  */
  readonly clipBoard?: DomainOsNvRamSourceReservationsSourceQemuvdAgentClipBoard;
  /**
  * Configures mouse integration options for the QEMU vdagentbased EGD source, such as how mouse events are handled.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mouse Domain#mouse}
  */
  readonly mouse?: DomainOsNvRamSourceReservationsSourceQemuvdAgentMouse;
}

export function domainOsNvRamSourceReservationsSourceQemuvdAgentToTerraform(struct?: DomainOsNvRamSourceReservationsSourceQemuvdAgent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    clip_board: domainOsNvRamSourceReservationsSourceQemuvdAgentClipBoardToTerraform(struct!.clipBoard),
    mouse: domainOsNvRamSourceReservationsSourceQemuvdAgentMouseToTerraform(struct!.mouse),
  }
}


export function domainOsNvRamSourceReservationsSourceQemuvdAgentToHclTerraform(struct?: DomainOsNvRamSourceReservationsSourceQemuvdAgent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    clip_board: {
      value: domainOsNvRamSourceReservationsSourceQemuvdAgentClipBoardToHclTerraform(struct!.clipBoard),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceReservationsSourceQemuvdAgentClipBoard",
    },
    mouse: {
      value: domainOsNvRamSourceReservationsSourceQemuvdAgentMouseToHclTerraform(struct!.mouse),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceReservationsSourceQemuvdAgentMouse",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceReservationsSourceQemuvdAgentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceReservationsSourceQemuvdAgent | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clipBoard?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clipBoard = this._clipBoard?.internalValue;
    }
    if (this._mouse?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.mouse = this._mouse?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceReservationsSourceQemuvdAgent | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clipBoard.internalValue = undefined;
      this._mouse.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clipBoard.internalValue = value.clipBoard;
      this._mouse.internalValue = value.mouse;
    }
  }

  // clip_board - computed: false, optional: true, required: false
  private _clipBoard = new DomainOsNvRamSourceReservationsSourceQemuvdAgentClipBoardOutputReference(this, "clip_board");
  public get clipBoard() {
    return this._clipBoard;
  }
  public putClipBoard(value: DomainOsNvRamSourceReservationsSourceQemuvdAgentClipBoard) {
    this._clipBoard.internalValue = value;
  }
  public resetClipBoard() {
    this._clipBoard.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clipBoardInput() {
    return this._clipBoard.internalValue;
  }

  // mouse - computed: false, optional: true, required: false
  private _mouse = new DomainOsNvRamSourceReservationsSourceQemuvdAgentMouseOutputReference(this, "mouse");
  public get mouse() {
    return this._mouse;
  }
  public putMouse(value: DomainOsNvRamSourceReservationsSourceQemuvdAgentMouse) {
    this._mouse.internalValue = value;
  }
  public resetMouse() {
    this._mouse.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mouseInput() {
    return this._mouse.internalValue;
  }
}
export interface DomainOsNvRamSourceReservationsSourceSpicePort {
  /**
  * Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#channel Domain#channel}
  */
  readonly channel: string;
}

export function domainOsNvRamSourceReservationsSourceSpicePortToTerraform(struct?: DomainOsNvRamSourceReservationsSourceSpicePort | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    channel: cdktf.stringToTerraform(struct!.channel),
  }
}


export function domainOsNvRamSourceReservationsSourceSpicePortToHclTerraform(struct?: DomainOsNvRamSourceReservationsSourceSpicePort | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    channel: {
      value: cdktf.stringToHclTerraform(struct!.channel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceReservationsSourceSpicePortOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceReservationsSourceSpicePort | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._channel !== undefined) {
      hasAnyValues = true;
      internalValueResult.channel = this._channel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceReservationsSourceSpicePort | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._channel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._channel = value.channel;
    }
  }

  // channel - computed: false, optional: false, required: true
  private _channel?: string; 
  public get channel() {
    return this.getStringAttribute('channel');
  }
  public set channel(value: string) {
    this._channel = value;
  }
  // Temporarily expose input value. Use with caution.
  public get channelInput() {
    return this._channel;
  }
}
export interface DomainOsNvRamSourceReservationsSourceTcpReconnect {
  /**
  * Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enabled Domain#enabled}
  */
  readonly enabled: string;
  /**
  * Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#timeout Domain#timeout}
  */
  readonly timeout?: number;
}

export function domainOsNvRamSourceReservationsSourceTcpReconnectToTerraform(struct?: DomainOsNvRamSourceReservationsSourceTcpReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.stringToTerraform(struct!.enabled),
    timeout: cdktf.numberToTerraform(struct!.timeout),
  }
}


export function domainOsNvRamSourceReservationsSourceTcpReconnectToHclTerraform(struct?: DomainOsNvRamSourceReservationsSourceTcpReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.stringToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.numberToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceReservationsSourceTcpReconnectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceReservationsSourceTcpReconnect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceReservationsSourceTcpReconnect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._timeout = value.timeout;
    }
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: string; 
  public get enabled() {
    return this.getStringAttribute('enabled');
  }
  public set enabled(value: string) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: number; 
  public get timeout() {
    return this.getNumberAttribute('timeout');
  }
  public set timeout(value: number) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DomainOsNvRamSourceReservationsSourceTcp {
  /**
  * Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#host Domain#host}
  */
  readonly host?: string;
  /**
  * Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode?: string;
  /**
  * Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reconnect Domain#reconnect}
  */
  readonly reconnect?: DomainOsNvRamSourceReservationsSourceTcpReconnect;
  /**
  * Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#service Domain#service}
  */
  readonly service?: string;
  /**
  * Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tls Domain#tls}
  */
  readonly tls?: string;
}

export function domainOsNvRamSourceReservationsSourceTcpToTerraform(struct?: DomainOsNvRamSourceReservationsSourceTcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    mode: cdktf.stringToTerraform(struct!.mode),
    reconnect: domainOsNvRamSourceReservationsSourceTcpReconnectToTerraform(struct!.reconnect),
    service: cdktf.stringToTerraform(struct!.service),
    tls: cdktf.stringToTerraform(struct!.tls),
  }
}


export function domainOsNvRamSourceReservationsSourceTcpToHclTerraform(struct?: DomainOsNvRamSourceReservationsSourceTcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reconnect: {
      value: domainOsNvRamSourceReservationsSourceTcpReconnectToHclTerraform(struct!.reconnect),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceReservationsSourceTcpReconnect",
    },
    service: {
      value: cdktf.stringToHclTerraform(struct!.service),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: cdktf.stringToHclTerraform(struct!.tls),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceReservationsSourceTcpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceReservationsSourceTcp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._reconnect?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.reconnect = this._reconnect?.internalValue;
    }
    if (this._service !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service;
    }
    if (this._tls !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceReservationsSourceTcp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host = undefined;
      this._mode = undefined;
      this._reconnect.internalValue = undefined;
      this._service = undefined;
      this._tls = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host = value.host;
      this._mode = value.mode;
      this._reconnect.internalValue = value.reconnect;
      this._service = value.service;
      this._tls = value.tls;
    }
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // reconnect - computed: false, optional: true, required: false
  private _reconnect = new DomainOsNvRamSourceReservationsSourceTcpReconnectOutputReference(this, "reconnect");
  public get reconnect() {
    return this._reconnect;
  }
  public putReconnect(value: DomainOsNvRamSourceReservationsSourceTcpReconnect) {
    this._reconnect.internalValue = value;
  }
  public resetReconnect() {
    this._reconnect.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reconnectInput() {
    return this._reconnect.internalValue;
  }

  // service - computed: false, optional: true, required: false
  private _service?: string; 
  public get service() {
    return this.getStringAttribute('service');
  }
  public set service(value: string) {
    this._service = value;
  }
  public resetService() {
    this._service = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service;
  }

  // tls - computed: false, optional: true, required: false
  private _tls?: string; 
  public get tls() {
    return this.getStringAttribute('tls');
  }
  public set tls(value: string) {
    this._tls = value;
  }
  public resetTls() {
    this._tls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls;
  }
}
export interface DomainOsNvRamSourceReservationsSourceUdp {
  /**
  * Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bind_host Domain#bind_host}
  */
  readonly bindHost: string;
  /**
  * Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bind_service Domain#bind_service}
  */
  readonly bindService: string;
  /**
  * Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#connect_host Domain#connect_host}
  */
  readonly connectHost: string;
  /**
  * Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#connect_service Domain#connect_service}
  */
  readonly connectService: string;
}

export function domainOsNvRamSourceReservationsSourceUdpToTerraform(struct?: DomainOsNvRamSourceReservationsSourceUdp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_host: cdktf.stringToTerraform(struct!.bindHost),
    bind_service: cdktf.stringToTerraform(struct!.bindService),
    connect_host: cdktf.stringToTerraform(struct!.connectHost),
    connect_service: cdktf.stringToTerraform(struct!.connectService),
  }
}


export function domainOsNvRamSourceReservationsSourceUdpToHclTerraform(struct?: DomainOsNvRamSourceReservationsSourceUdp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_host: {
      value: cdktf.stringToHclTerraform(struct!.bindHost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bind_service: {
      value: cdktf.stringToHclTerraform(struct!.bindService),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connect_host: {
      value: cdktf.stringToHclTerraform(struct!.connectHost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connect_service: {
      value: cdktf.stringToHclTerraform(struct!.connectService),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceReservationsSourceUdpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceReservationsSourceUdp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindHost !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindHost = this._bindHost;
    }
    if (this._bindService !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindService = this._bindService;
    }
    if (this._connectHost !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectHost = this._connectHost;
    }
    if (this._connectService !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectService = this._connectService;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceReservationsSourceUdp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bindHost = undefined;
      this._bindService = undefined;
      this._connectHost = undefined;
      this._connectService = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bindHost = value.bindHost;
      this._bindService = value.bindService;
      this._connectHost = value.connectHost;
      this._connectService = value.connectService;
    }
  }

  // bind_host - computed: false, optional: false, required: true
  private _bindHost?: string; 
  public get bindHost() {
    return this.getStringAttribute('bind_host');
  }
  public set bindHost(value: string) {
    this._bindHost = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bindHostInput() {
    return this._bindHost;
  }

  // bind_service - computed: false, optional: false, required: true
  private _bindService?: string; 
  public get bindService() {
    return this.getStringAttribute('bind_service');
  }
  public set bindService(value: string) {
    this._bindService = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bindServiceInput() {
    return this._bindService;
  }

  // connect_host - computed: false, optional: false, required: true
  private _connectHost?: string; 
  public get connectHost() {
    return this.getStringAttribute('connect_host');
  }
  public set connectHost(value: string) {
    this._connectHost = value;
  }
  // Temporarily expose input value. Use with caution.
  public get connectHostInput() {
    return this._connectHost;
  }

  // connect_service - computed: false, optional: false, required: true
  private _connectService?: string; 
  public get connectService() {
    return this.getStringAttribute('connect_service');
  }
  public set connectService(value: string) {
    this._connectService = value;
  }
  // Temporarily expose input value. Use with caution.
  public get connectServiceInput() {
    return this._connectService;
  }
}
export interface DomainOsNvRamSourceReservationsSourceUnixReconnect {
  /**
  * Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enabled Domain#enabled}
  */
  readonly enabled: string;
  /**
  * Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#timeout Domain#timeout}
  */
  readonly timeout?: number;
}

export function domainOsNvRamSourceReservationsSourceUnixReconnectToTerraform(struct?: DomainOsNvRamSourceReservationsSourceUnixReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.stringToTerraform(struct!.enabled),
    timeout: cdktf.numberToTerraform(struct!.timeout),
  }
}


export function domainOsNvRamSourceReservationsSourceUnixReconnectToHclTerraform(struct?: DomainOsNvRamSourceReservationsSourceUnixReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.stringToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.numberToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceReservationsSourceUnixReconnectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceReservationsSourceUnixReconnect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceReservationsSourceUnixReconnect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._timeout = value.timeout;
    }
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: string; 
  public get enabled() {
    return this.getStringAttribute('enabled');
  }
  public set enabled(value: string) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: number; 
  public get timeout() {
    return this.getNumberAttribute('timeout');
  }
  public set timeout(value: number) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DomainOsNvRamSourceReservationsSourceUnixSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainOsNvRamSourceReservationsSourceUnixSecLabelToTerraform(struct?: DomainOsNvRamSourceReservationsSourceUnixSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainOsNvRamSourceReservationsSourceUnixSecLabelToHclTerraform(struct?: DomainOsNvRamSourceReservationsSourceUnixSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceReservationsSourceUnixSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainOsNvRamSourceReservationsSourceUnixSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceReservationsSourceUnixSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainOsNvRamSourceReservationsSourceUnixSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainOsNvRamSourceReservationsSourceUnixSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainOsNvRamSourceReservationsSourceUnixSecLabelOutputReference {
    return new DomainOsNvRamSourceReservationsSourceUnixSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainOsNvRamSourceReservationsSourceUnix {
  /**
  * Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode?: string;
  /**
  * Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path?: string;
  /**
  * Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reconnect Domain#reconnect}
  */
  readonly reconnect?: DomainOsNvRamSourceReservationsSourceUnixReconnect;
  /**
  * Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainOsNvRamSourceReservationsSourceUnixSecLabel[] | cdktf.IResolvable;
}

export function domainOsNvRamSourceReservationsSourceUnixToTerraform(struct?: DomainOsNvRamSourceReservationsSourceUnix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
    reconnect: domainOsNvRamSourceReservationsSourceUnixReconnectToTerraform(struct!.reconnect),
    sec_label: cdktf.listMapper(domainOsNvRamSourceReservationsSourceUnixSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainOsNvRamSourceReservationsSourceUnixToHclTerraform(struct?: DomainOsNvRamSourceReservationsSourceUnix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reconnect: {
      value: domainOsNvRamSourceReservationsSourceUnixReconnectToHclTerraform(struct!.reconnect),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceReservationsSourceUnixReconnect",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainOsNvRamSourceReservationsSourceUnixSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainOsNvRamSourceReservationsSourceUnixSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceReservationsSourceUnixOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceReservationsSourceUnix | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._reconnect?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.reconnect = this._reconnect?.internalValue;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceReservationsSourceUnix | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
      this._path = undefined;
      this._reconnect.internalValue = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
      this._path = value.path;
      this._reconnect.internalValue = value.reconnect;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // reconnect - computed: false, optional: true, required: false
  private _reconnect = new DomainOsNvRamSourceReservationsSourceUnixReconnectOutputReference(this, "reconnect");
  public get reconnect() {
    return this._reconnect;
  }
  public putReconnect(value: DomainOsNvRamSourceReservationsSourceUnixReconnect) {
    this._reconnect.internalValue = value;
  }
  public resetReconnect() {
    this._reconnect.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reconnectInput() {
    return this._reconnect.internalValue;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainOsNvRamSourceReservationsSourceUnixSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainOsNvRamSourceReservationsSourceUnixSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainOsNvRamSourceReservationsSource {
  /**
  * Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dbus Domain#dbus}
  */
  readonly dbus?: DomainOsNvRamSourceReservationsSourceDbus;
  /**
  * Configures an EGD RNG backend that reads entropy from a host character device node.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dev Domain#dev}
  */
  readonly dev?: DomainOsNvRamSourceReservationsSourceDev;
  /**
  * Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file?: DomainOsNvRamSourceReservationsSourceFile;
  /**
  * Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#nmdm Domain#nmdm}
  */
  readonly nmdm?: DomainOsNvRamSourceReservationsSourceNmdm;
  /**
  * Enables use of a null character device as the reservation backing source; when this boolean is true, a Null source is emitted and all written data is discarded.
  * 
  * See: <https://libvirt.org/formatdomain.html#null-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#null Domain#null}
  */
  readonly null?: boolean | cdktf.IResolvable;
  /**
  * Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pipe Domain#pipe}
  */
  readonly pipe?: DomainOsNvRamSourceReservationsSourcePipe;
  /**
  * Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pty Domain#pty}
  */
  readonly pty?: DomainOsNvRamSourceReservationsSourcePty;
  /**
  * Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#qemuvd_agent Domain#qemuvd_agent}
  */
  readonly qemuvdAgent?: DomainOsNvRamSourceReservationsSourceQemuvdAgent;
  /**
  * Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#spice_port Domain#spice_port}
  */
  readonly spicePort?: DomainOsNvRamSourceReservationsSourceSpicePort;
  /**
  * Enables a SPICE VMC (SPICE management channel) backend for this backing-store source; when set true the element is emitted, when false or null it is omitted.
  * 
  * See: <https://libvirt.org/formatdomain.html#spice-channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#spice_vmc Domain#spice_vmc}
  */
  readonly spiceVmc?: boolean | cdktf.IResolvable;
  /**
  * Connects the backing-store sources character channel to the domains standard I/O (stdin/stdout/stderr); when true the element is emitted, when false or null it is omitted.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-interface>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#std_io Domain#std_io}
  */
  readonly stdIo?: boolean | cdktf.IResolvable;
  /**
  * Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tcp Domain#tcp}
  */
  readonly tcp?: DomainOsNvRamSourceReservationsSourceTcp;
  /**
  * Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#udp Domain#udp}
  */
  readonly udp?: DomainOsNvRamSourceReservationsSourceUdp;
  /**
  * Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#unix Domain#unix}
  */
  readonly unix?: DomainOsNvRamSourceReservationsSourceUnix;
  /**
  * Enables use of a VC (virtual cluster or vendor-specific) reservation source when set; since this is presence-based, setting it to true emits the element and false/null omits it.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vc Domain#vc}
  */
  readonly vc?: boolean | cdktf.IResolvable;
}

export function domainOsNvRamSourceReservationsSourceToTerraform(struct?: DomainOsNvRamSourceReservationsSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dbus: domainOsNvRamSourceReservationsSourceDbusToTerraform(struct!.dbus),
    dev: domainOsNvRamSourceReservationsSourceDevToTerraform(struct!.dev),
    file: domainOsNvRamSourceReservationsSourceFileToTerraform(struct!.file),
    nmdm: domainOsNvRamSourceReservationsSourceNmdmToTerraform(struct!.nmdm),
    null: cdktf.booleanToTerraform(struct!.null),
    pipe: domainOsNvRamSourceReservationsSourcePipeToTerraform(struct!.pipe),
    pty: domainOsNvRamSourceReservationsSourcePtyToTerraform(struct!.pty),
    qemuvd_agent: domainOsNvRamSourceReservationsSourceQemuvdAgentToTerraform(struct!.qemuvdAgent),
    spice_port: domainOsNvRamSourceReservationsSourceSpicePortToTerraform(struct!.spicePort),
    spice_vmc: cdktf.booleanToTerraform(struct!.spiceVmc),
    std_io: cdktf.booleanToTerraform(struct!.stdIo),
    tcp: domainOsNvRamSourceReservationsSourceTcpToTerraform(struct!.tcp),
    udp: domainOsNvRamSourceReservationsSourceUdpToTerraform(struct!.udp),
    unix: domainOsNvRamSourceReservationsSourceUnixToTerraform(struct!.unix),
    vc: cdktf.booleanToTerraform(struct!.vc),
  }
}


export function domainOsNvRamSourceReservationsSourceToHclTerraform(struct?: DomainOsNvRamSourceReservationsSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dbus: {
      value: domainOsNvRamSourceReservationsSourceDbusToHclTerraform(struct!.dbus),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceReservationsSourceDbus",
    },
    dev: {
      value: domainOsNvRamSourceReservationsSourceDevToHclTerraform(struct!.dev),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceReservationsSourceDev",
    },
    file: {
      value: domainOsNvRamSourceReservationsSourceFileToHclTerraform(struct!.file),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceReservationsSourceFile",
    },
    nmdm: {
      value: domainOsNvRamSourceReservationsSourceNmdmToHclTerraform(struct!.nmdm),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceReservationsSourceNmdm",
    },
    null: {
      value: cdktf.booleanToHclTerraform(struct!.null),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    pipe: {
      value: domainOsNvRamSourceReservationsSourcePipeToHclTerraform(struct!.pipe),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceReservationsSourcePipe",
    },
    pty: {
      value: domainOsNvRamSourceReservationsSourcePtyToHclTerraform(struct!.pty),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceReservationsSourcePty",
    },
    qemuvd_agent: {
      value: domainOsNvRamSourceReservationsSourceQemuvdAgentToHclTerraform(struct!.qemuvdAgent),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceReservationsSourceQemuvdAgent",
    },
    spice_port: {
      value: domainOsNvRamSourceReservationsSourceSpicePortToHclTerraform(struct!.spicePort),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceReservationsSourceSpicePort",
    },
    spice_vmc: {
      value: cdktf.booleanToHclTerraform(struct!.spiceVmc),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    std_io: {
      value: cdktf.booleanToHclTerraform(struct!.stdIo),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tcp: {
      value: domainOsNvRamSourceReservationsSourceTcpToHclTerraform(struct!.tcp),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceReservationsSourceTcp",
    },
    udp: {
      value: domainOsNvRamSourceReservationsSourceUdpToHclTerraform(struct!.udp),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceReservationsSourceUdp",
    },
    unix: {
      value: domainOsNvRamSourceReservationsSourceUnixToHclTerraform(struct!.unix),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceReservationsSourceUnix",
    },
    vc: {
      value: cdktf.booleanToHclTerraform(struct!.vc),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceReservationsSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceReservationsSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dbus?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dbus = this._dbus?.internalValue;
    }
    if (this._dev?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dev = this._dev?.internalValue;
    }
    if (this._file?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file?.internalValue;
    }
    if (this._nmdm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nmdm = this._nmdm?.internalValue;
    }
    if (this._null !== undefined) {
      hasAnyValues = true;
      internalValueResult.null = this._null;
    }
    if (this._pipe?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipe = this._pipe?.internalValue;
    }
    if (this._pty?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pty = this._pty?.internalValue;
    }
    if (this._qemuvdAgent?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.qemuvdAgent = this._qemuvdAgent?.internalValue;
    }
    if (this._spicePort?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spicePort = this._spicePort?.internalValue;
    }
    if (this._spiceVmc !== undefined) {
      hasAnyValues = true;
      internalValueResult.spiceVmc = this._spiceVmc;
    }
    if (this._stdIo !== undefined) {
      hasAnyValues = true;
      internalValueResult.stdIo = this._stdIo;
    }
    if (this._tcp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tcp = this._tcp?.internalValue;
    }
    if (this._udp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.udp = this._udp?.internalValue;
    }
    if (this._unix?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.unix = this._unix?.internalValue;
    }
    if (this._vc !== undefined) {
      hasAnyValues = true;
      internalValueResult.vc = this._vc;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceReservationsSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dbus.internalValue = undefined;
      this._dev.internalValue = undefined;
      this._file.internalValue = undefined;
      this._nmdm.internalValue = undefined;
      this._null = undefined;
      this._pipe.internalValue = undefined;
      this._pty.internalValue = undefined;
      this._qemuvdAgent.internalValue = undefined;
      this._spicePort.internalValue = undefined;
      this._spiceVmc = undefined;
      this._stdIo = undefined;
      this._tcp.internalValue = undefined;
      this._udp.internalValue = undefined;
      this._unix.internalValue = undefined;
      this._vc = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dbus.internalValue = value.dbus;
      this._dev.internalValue = value.dev;
      this._file.internalValue = value.file;
      this._nmdm.internalValue = value.nmdm;
      this._null = value.null;
      this._pipe.internalValue = value.pipe;
      this._pty.internalValue = value.pty;
      this._qemuvdAgent.internalValue = value.qemuvdAgent;
      this._spicePort.internalValue = value.spicePort;
      this._spiceVmc = value.spiceVmc;
      this._stdIo = value.stdIo;
      this._tcp.internalValue = value.tcp;
      this._udp.internalValue = value.udp;
      this._unix.internalValue = value.unix;
      this._vc = value.vc;
    }
  }

  // dbus - computed: false, optional: true, required: false
  private _dbus = new DomainOsNvRamSourceReservationsSourceDbusOutputReference(this, "dbus");
  public get dbus() {
    return this._dbus;
  }
  public putDbus(value: DomainOsNvRamSourceReservationsSourceDbus) {
    this._dbus.internalValue = value;
  }
  public resetDbus() {
    this._dbus.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dbusInput() {
    return this._dbus.internalValue;
  }

  // dev - computed: false, optional: true, required: false
  private _dev = new DomainOsNvRamSourceReservationsSourceDevOutputReference(this, "dev");
  public get dev() {
    return this._dev;
  }
  public putDev(value: DomainOsNvRamSourceReservationsSourceDev) {
    this._dev.internalValue = value;
  }
  public resetDev() {
    this._dev.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devInput() {
    return this._dev.internalValue;
  }

  // file - computed: false, optional: true, required: false
  private _file = new DomainOsNvRamSourceReservationsSourceFileOutputReference(this, "file");
  public get file() {
    return this._file;
  }
  public putFile(value: DomainOsNvRamSourceReservationsSourceFile) {
    this._file.internalValue = value;
  }
  public resetFile() {
    this._file.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file.internalValue;
  }

  // nmdm - computed: false, optional: true, required: false
  private _nmdm = new DomainOsNvRamSourceReservationsSourceNmdmOutputReference(this, "nmdm");
  public get nmdm() {
    return this._nmdm;
  }
  public putNmdm(value: DomainOsNvRamSourceReservationsSourceNmdm) {
    this._nmdm.internalValue = value;
  }
  public resetNmdm() {
    this._nmdm.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nmdmInput() {
    return this._nmdm.internalValue;
  }

  // null - computed: false, optional: true, required: false
  private _null?: boolean | cdktf.IResolvable; 
  public get null() {
    return this.getBooleanAttribute('null');
  }
  public set null(value: boolean | cdktf.IResolvable) {
    this._null = value;
  }
  public resetNull() {
    this._null = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nullInput() {
    return this._null;
  }

  // pipe - computed: false, optional: true, required: false
  private _pipe = new DomainOsNvRamSourceReservationsSourcePipeOutputReference(this, "pipe");
  public get pipe() {
    return this._pipe;
  }
  public putPipe(value: DomainOsNvRamSourceReservationsSourcePipe) {
    this._pipe.internalValue = value;
  }
  public resetPipe() {
    this._pipe.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipeInput() {
    return this._pipe.internalValue;
  }

  // pty - computed: false, optional: true, required: false
  private _pty = new DomainOsNvRamSourceReservationsSourcePtyOutputReference(this, "pty");
  public get pty() {
    return this._pty;
  }
  public putPty(value: DomainOsNvRamSourceReservationsSourcePty) {
    this._pty.internalValue = value;
  }
  public resetPty() {
    this._pty.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ptyInput() {
    return this._pty.internalValue;
  }

  // qemuvd_agent - computed: false, optional: true, required: false
  private _qemuvdAgent = new DomainOsNvRamSourceReservationsSourceQemuvdAgentOutputReference(this, "qemuvd_agent");
  public get qemuvdAgent() {
    return this._qemuvdAgent;
  }
  public putQemuvdAgent(value: DomainOsNvRamSourceReservationsSourceQemuvdAgent) {
    this._qemuvdAgent.internalValue = value;
  }
  public resetQemuvdAgent() {
    this._qemuvdAgent.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get qemuvdAgentInput() {
    return this._qemuvdAgent.internalValue;
  }

  // spice_port - computed: false, optional: true, required: false
  private _spicePort = new DomainOsNvRamSourceReservationsSourceSpicePortOutputReference(this, "spice_port");
  public get spicePort() {
    return this._spicePort;
  }
  public putSpicePort(value: DomainOsNvRamSourceReservationsSourceSpicePort) {
    this._spicePort.internalValue = value;
  }
  public resetSpicePort() {
    this._spicePort.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spicePortInput() {
    return this._spicePort.internalValue;
  }

  // spice_vmc - computed: false, optional: true, required: false
  private _spiceVmc?: boolean | cdktf.IResolvable; 
  public get spiceVmc() {
    return this.getBooleanAttribute('spice_vmc');
  }
  public set spiceVmc(value: boolean | cdktf.IResolvable) {
    this._spiceVmc = value;
  }
  public resetSpiceVmc() {
    this._spiceVmc = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spiceVmcInput() {
    return this._spiceVmc;
  }

  // std_io - computed: false, optional: true, required: false
  private _stdIo?: boolean | cdktf.IResolvable; 
  public get stdIo() {
    return this.getBooleanAttribute('std_io');
  }
  public set stdIo(value: boolean | cdktf.IResolvable) {
    this._stdIo = value;
  }
  public resetStdIo() {
    this._stdIo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stdIoInput() {
    return this._stdIo;
  }

  // tcp - computed: false, optional: true, required: false
  private _tcp = new DomainOsNvRamSourceReservationsSourceTcpOutputReference(this, "tcp");
  public get tcp() {
    return this._tcp;
  }
  public putTcp(value: DomainOsNvRamSourceReservationsSourceTcp) {
    this._tcp.internalValue = value;
  }
  public resetTcp() {
    this._tcp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tcpInput() {
    return this._tcp.internalValue;
  }

  // udp - computed: false, optional: true, required: false
  private _udp = new DomainOsNvRamSourceReservationsSourceUdpOutputReference(this, "udp");
  public get udp() {
    return this._udp;
  }
  public putUdp(value: DomainOsNvRamSourceReservationsSourceUdp) {
    this._udp.internalValue = value;
  }
  public resetUdp() {
    this._udp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get udpInput() {
    return this._udp.internalValue;
  }

  // unix - computed: false, optional: true, required: false
  private _unix = new DomainOsNvRamSourceReservationsSourceUnixOutputReference(this, "unix");
  public get unix() {
    return this._unix;
  }
  public putUnix(value: DomainOsNvRamSourceReservationsSourceUnix) {
    this._unix.internalValue = value;
  }
  public resetUnix() {
    this._unix.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unixInput() {
    return this._unix.internalValue;
  }

  // vc - computed: false, optional: true, required: false
  private _vc?: boolean | cdktf.IResolvable; 
  public get vc() {
    return this.getBooleanAttribute('vc');
  }
  public set vc(value: boolean | cdktf.IResolvable) {
    this._vc = value;
  }
  public resetVc() {
    this._vc = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vcInput() {
    return this._vc;
  }
}
export interface DomainOsNvRamSourceReservations {
  /**
  * Controls whether persistent reservations are enabled for the mirrored disks backing-store source; value is user-provided and typically expects "yes" or "no" semantics per libvirt.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enabled Domain#enabled}
  */
  readonly enabled?: string;
  /**
  * Indicates whether reservations are managed by libvirt ("yes") or externally ("no"); value is provided as a string and translated to a boolean, with "yes" meaning true and "no" meaning false.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#managed Domain#managed}
  */
  readonly managed?: boolean | cdktf.IResolvable;
  /**
  * Selects the mechanism used to provide reservation control for the mirrored backing-store source, such as a D-Bus service or a device/file endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#source Domain#source}
  */
  readonly source?: DomainOsNvRamSourceReservationsSource;
}

export function domainOsNvRamSourceReservationsToTerraform(struct?: DomainOsNvRamSourceReservations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.stringToTerraform(struct!.enabled),
    managed: cdktf.booleanToTerraform(struct!.managed),
    source: domainOsNvRamSourceReservationsSourceToTerraform(struct!.source),
  }
}


export function domainOsNvRamSourceReservationsToHclTerraform(struct?: DomainOsNvRamSourceReservations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.stringToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    managed: {
      value: cdktf.booleanToHclTerraform(struct!.managed),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    source: {
      value: domainOsNvRamSourceReservationsSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceReservationsSource",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceReservationsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceReservations | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._managed !== undefined) {
      hasAnyValues = true;
      internalValueResult.managed = this._managed;
    }
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceReservations | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._managed = undefined;
      this._source.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._managed = value.managed;
      this._source.internalValue = value.source;
    }
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: string; 
  public get enabled() {
    return this.getStringAttribute('enabled');
  }
  public set enabled(value: string) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // managed - computed: false, optional: true, required: false
  private _managed?: boolean | cdktf.IResolvable; 
  public get managed() {
    return this.getBooleanAttribute('managed');
  }
  public set managed(value: boolean | cdktf.IResolvable) {
    this._managed = value;
  }
  public resetManaged() {
    this._managed = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get managedInput() {
    return this._managed;
  }

  // source - computed: false, optional: true, required: false
  private _source = new DomainOsNvRamSourceReservationsSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: DomainOsNvRamSourceReservationsSource) {
    this._source.internalValue = value;
  }
  public resetSource() {
    this._source.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }
}
export interface DomainOsNvRamSourceSlicesSlices {
  /**
  * Sets the starting offset (in bytes) of this slice within the underlying backing-store source; must be a nonnegative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#offset Domain#offset}
  */
  readonly offset: number;
  /**
  * Sets the size (in bytes) of this slice within the underlying backing-store source; must be a positive integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#size Domain#size}
  */
  readonly size: number;
  /**
  * Specifies the type of slice mapping to use for this range; the value is userprovided and must match a type supported by the hypervisor (for example, a particular mapping or layout scheme).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type: string;
}

export function domainOsNvRamSourceSlicesSlicesToTerraform(struct?: DomainOsNvRamSourceSlicesSlices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    offset: cdktf.numberToTerraform(struct!.offset),
    size: cdktf.numberToTerraform(struct!.size),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function domainOsNvRamSourceSlicesSlicesToHclTerraform(struct?: DomainOsNvRamSourceSlicesSlices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    offset: {
      value: cdktf.numberToHclTerraform(struct!.offset),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    size: {
      value: cdktf.numberToHclTerraform(struct!.size),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceSlicesSlicesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainOsNvRamSourceSlicesSlices | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._offset !== undefined) {
      hasAnyValues = true;
      internalValueResult.offset = this._offset;
    }
    if (this._size !== undefined) {
      hasAnyValues = true;
      internalValueResult.size = this._size;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceSlicesSlices | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._offset = undefined;
      this._size = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._offset = value.offset;
      this._size = value.size;
      this._type = value.type;
    }
  }

  // offset - computed: false, optional: false, required: true
  private _offset?: number; 
  public get offset() {
    return this.getNumberAttribute('offset');
  }
  public set offset(value: number) {
    this._offset = value;
  }
  // Temporarily expose input value. Use with caution.
  public get offsetInput() {
    return this._offset;
  }

  // size - computed: false, optional: false, required: true
  private _size?: number; 
  public get size() {
    return this.getNumberAttribute('size');
  }
  public set size(value: number) {
    this._size = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sizeInput() {
    return this._size;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}

export class DomainOsNvRamSourceSlicesSlicesList extends cdktf.ComplexList {
  public internalValue? : DomainOsNvRamSourceSlicesSlices[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainOsNvRamSourceSlicesSlicesOutputReference {
    return new DomainOsNvRamSourceSlicesSlicesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainOsNvRamSourceSlices {
  /**
  * Configures one or more slices of the backing-store source, each describing a contiguous portion of the underlying device or file that is exposed through this mirror backing store.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#slices Domain#slices}
  */
  readonly slices?: DomainOsNvRamSourceSlicesSlices[] | cdktf.IResolvable;
}

export function domainOsNvRamSourceSlicesToTerraform(struct?: DomainOsNvRamSourceSlices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    slices: cdktf.listMapper(domainOsNvRamSourceSlicesSlicesToTerraform, false)(struct!.slices),
  }
}


export function domainOsNvRamSourceSlicesToHclTerraform(struct?: DomainOsNvRamSourceSlices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    slices: {
      value: cdktf.listMapperHcl(domainOsNvRamSourceSlicesSlicesToHclTerraform, false)(struct!.slices),
      isBlock: true,
      type: "list",
      storageClassType: "DomainOsNvRamSourceSlicesSlicesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceSlicesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceSlices | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._slices?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.slices = this._slices?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceSlices | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._slices.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._slices.internalValue = value.slices;
    }
  }

  // slices - computed: false, optional: true, required: false
  private _slices = new DomainOsNvRamSourceSlicesSlicesList(this, "slices", false);
  public get slices() {
    return this._slices;
  }
  public putSlices(value: DomainOsNvRamSourceSlicesSlices[] | cdktf.IResolvable) {
    this._slices.internalValue = value;
  }
  public resetSlices() {
    this._slices.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get slicesInput() {
    return this._slices.internalValue;
  }
}
export interface DomainOsNvRamSourceSsl {
  /**
  * Controls certificate verification for SSL/TLS access to the mirrored backing-store source; typical values are "yes" or "no" to enable or disable verification.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#verify Domain#verify}
  */
  readonly verify: string;
}

export function domainOsNvRamSourceSslToTerraform(struct?: DomainOsNvRamSourceSsl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    verify: cdktf.stringToTerraform(struct!.verify),
  }
}


export function domainOsNvRamSourceSslToHclTerraform(struct?: DomainOsNvRamSourceSsl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    verify: {
      value: cdktf.stringToHclTerraform(struct!.verify),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceSslOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceSsl | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._verify !== undefined) {
      hasAnyValues = true;
      internalValueResult.verify = this._verify;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceSsl | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._verify = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._verify = value.verify;
    }
  }

  // verify - computed: false, optional: false, required: true
  private _verify?: string; 
  public get verify() {
    return this.getStringAttribute('verify');
  }
  public set verify(value: string) {
    this._verify = value;
  }
  // Temporarily expose input value. Use with caution.
  public get verifyInput() {
    return this._verify;
  }
}
export interface DomainOsNvRamSourceTimeout {
  /**
  * Sets the timeout duration in seconds for accessing the mirrored backing-store source; must be a nonnegative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#seconds Domain#seconds}
  */
  readonly seconds: string;
}

export function domainOsNvRamSourceTimeoutToTerraform(struct?: DomainOsNvRamSourceTimeout | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    seconds: cdktf.stringToTerraform(struct!.seconds),
  }
}


export function domainOsNvRamSourceTimeoutToHclTerraform(struct?: DomainOsNvRamSourceTimeout | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    seconds: {
      value: cdktf.stringToHclTerraform(struct!.seconds),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceTimeoutOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceTimeout | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._seconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.seconds = this._seconds;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceTimeout | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._seconds = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._seconds = value.seconds;
    }
  }

  // seconds - computed: false, optional: false, required: true
  private _seconds?: string; 
  public get seconds() {
    return this.getStringAttribute('seconds');
  }
  public set seconds(value: string) {
    this._seconds = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secondsInput() {
    return this._seconds;
  }
}
export interface DomainOsNvRamSourceVhostUserDbus {
  /**
  * Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#channel Domain#channel}
  */
  readonly channel?: string;
}

export function domainOsNvRamSourceVhostUserDbusToTerraform(struct?: DomainOsNvRamSourceVhostUserDbus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    channel: cdktf.stringToTerraform(struct!.channel),
  }
}


export function domainOsNvRamSourceVhostUserDbusToHclTerraform(struct?: DomainOsNvRamSourceVhostUserDbus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    channel: {
      value: cdktf.stringToHclTerraform(struct!.channel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceVhostUserDbusOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceVhostUserDbus | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._channel !== undefined) {
      hasAnyValues = true;
      internalValueResult.channel = this._channel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceVhostUserDbus | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._channel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._channel = value.channel;
    }
  }

  // channel - computed: false, optional: true, required: false
  private _channel?: string; 
  public get channel() {
    return this.getStringAttribute('channel');
  }
  public set channel(value: string) {
    this._channel = value;
  }
  public resetChannel() {
    this._channel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get channelInput() {
    return this._channel;
  }
}
export interface DomainOsNvRamSourceVhostUserDevSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainOsNvRamSourceVhostUserDevSecLabelToTerraform(struct?: DomainOsNvRamSourceVhostUserDevSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainOsNvRamSourceVhostUserDevSecLabelToHclTerraform(struct?: DomainOsNvRamSourceVhostUserDevSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceVhostUserDevSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainOsNvRamSourceVhostUserDevSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceVhostUserDevSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainOsNvRamSourceVhostUserDevSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainOsNvRamSourceVhostUserDevSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainOsNvRamSourceVhostUserDevSecLabelOutputReference {
    return new DomainOsNvRamSourceVhostUserDevSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainOsNvRamSourceVhostUserDev {
  /**
  * Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainOsNvRamSourceVhostUserDevSecLabel[] | cdktf.IResolvable;
}

export function domainOsNvRamSourceVhostUserDevToTerraform(struct?: DomainOsNvRamSourceVhostUserDev | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainOsNvRamSourceVhostUserDevSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainOsNvRamSourceVhostUserDevToHclTerraform(struct?: DomainOsNvRamSourceVhostUserDev | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainOsNvRamSourceVhostUserDevSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainOsNvRamSourceVhostUserDevSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceVhostUserDevOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceVhostUserDev | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceVhostUserDev | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainOsNvRamSourceVhostUserDevSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainOsNvRamSourceVhostUserDevSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainOsNvRamSourceVhostUserFileSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainOsNvRamSourceVhostUserFileSecLabelToTerraform(struct?: DomainOsNvRamSourceVhostUserFileSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainOsNvRamSourceVhostUserFileSecLabelToHclTerraform(struct?: DomainOsNvRamSourceVhostUserFileSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceVhostUserFileSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainOsNvRamSourceVhostUserFileSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceVhostUserFileSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainOsNvRamSourceVhostUserFileSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainOsNvRamSourceVhostUserFileSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainOsNvRamSourceVhostUserFileSecLabelOutputReference {
    return new DomainOsNvRamSourceVhostUserFileSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainOsNvRamSourceVhostUserFile {
  /**
  * Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.
  * 
  * See: <https://libvirt.org/formatdomain.html#device-logfile>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#append Domain#append}
  */
  readonly append?: string;
  /**
  * Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainOsNvRamSourceVhostUserFileSecLabel[] | cdktf.IResolvable;
}

export function domainOsNvRamSourceVhostUserFileToTerraform(struct?: DomainOsNvRamSourceVhostUserFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.stringToTerraform(struct!.append),
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainOsNvRamSourceVhostUserFileSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainOsNvRamSourceVhostUserFileToHclTerraform(struct?: DomainOsNvRamSourceVhostUserFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.stringToHclTerraform(struct!.append),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainOsNvRamSourceVhostUserFileSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainOsNvRamSourceVhostUserFileSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceVhostUserFileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceVhostUserFile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceVhostUserFile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append = value.append;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append?: string; 
  public get append() {
    return this.getStringAttribute('append');
  }
  public set append(value: string) {
    this._append = value;
  }
  public resetAppend() {
    this._append = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append;
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainOsNvRamSourceVhostUserFileSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainOsNvRamSourceVhostUserFileSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainOsNvRamSourceVhostUserNmdm {
  /**
  * Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.
  * 
  * See: <https://libvirt.org/formatdomain.html#nmdm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#master Domain#master}
  */
  readonly master: string;
  /**
  * Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.
  * 
  * See: <https://libvirt.org/formatdomain.html#nmdm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#slave Domain#slave}
  */
  readonly slave: string;
}

export function domainOsNvRamSourceVhostUserNmdmToTerraform(struct?: DomainOsNvRamSourceVhostUserNmdm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    master: cdktf.stringToTerraform(struct!.master),
    slave: cdktf.stringToTerraform(struct!.slave),
  }
}


export function domainOsNvRamSourceVhostUserNmdmToHclTerraform(struct?: DomainOsNvRamSourceVhostUserNmdm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    master: {
      value: cdktf.stringToHclTerraform(struct!.master),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    slave: {
      value: cdktf.stringToHclTerraform(struct!.slave),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceVhostUserNmdmOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceVhostUserNmdm | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._master !== undefined) {
      hasAnyValues = true;
      internalValueResult.master = this._master;
    }
    if (this._slave !== undefined) {
      hasAnyValues = true;
      internalValueResult.slave = this._slave;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceVhostUserNmdm | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._master = undefined;
      this._slave = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._master = value.master;
      this._slave = value.slave;
    }
  }

  // master - computed: false, optional: false, required: true
  private _master?: string; 
  public get master() {
    return this.getStringAttribute('master');
  }
  public set master(value: string) {
    this._master = value;
  }
  // Temporarily expose input value. Use with caution.
  public get masterInput() {
    return this._master;
  }

  // slave - computed: false, optional: false, required: true
  private _slave?: string; 
  public get slave() {
    return this.getStringAttribute('slave');
  }
  public set slave(value: string) {
    this._slave = value;
  }
  // Temporarily expose input value. Use with caution.
  public get slaveInput() {
    return this._slave;
  }
}
export interface DomainOsNvRamSourceVhostUserPipeSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainOsNvRamSourceVhostUserPipeSecLabelToTerraform(struct?: DomainOsNvRamSourceVhostUserPipeSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainOsNvRamSourceVhostUserPipeSecLabelToHclTerraform(struct?: DomainOsNvRamSourceVhostUserPipeSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceVhostUserPipeSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainOsNvRamSourceVhostUserPipeSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceVhostUserPipeSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainOsNvRamSourceVhostUserPipeSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainOsNvRamSourceVhostUserPipeSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainOsNvRamSourceVhostUserPipeSecLabelOutputReference {
    return new DomainOsNvRamSourceVhostUserPipeSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainOsNvRamSourceVhostUserPipe {
  /**
  * Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainOsNvRamSourceVhostUserPipeSecLabel[] | cdktf.IResolvable;
}

export function domainOsNvRamSourceVhostUserPipeToTerraform(struct?: DomainOsNvRamSourceVhostUserPipe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainOsNvRamSourceVhostUserPipeSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainOsNvRamSourceVhostUserPipeToHclTerraform(struct?: DomainOsNvRamSourceVhostUserPipe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainOsNvRamSourceVhostUserPipeSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainOsNvRamSourceVhostUserPipeSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceVhostUserPipeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceVhostUserPipe | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceVhostUserPipe | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainOsNvRamSourceVhostUserPipeSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainOsNvRamSourceVhostUserPipeSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainOsNvRamSourceVhostUserPtySecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainOsNvRamSourceVhostUserPtySecLabelToTerraform(struct?: DomainOsNvRamSourceVhostUserPtySecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainOsNvRamSourceVhostUserPtySecLabelToHclTerraform(struct?: DomainOsNvRamSourceVhostUserPtySecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceVhostUserPtySecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainOsNvRamSourceVhostUserPtySecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceVhostUserPtySecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainOsNvRamSourceVhostUserPtySecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainOsNvRamSourceVhostUserPtySecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainOsNvRamSourceVhostUserPtySecLabelOutputReference {
    return new DomainOsNvRamSourceVhostUserPtySecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainOsNvRamSourceVhostUserPty {
  /**
  * Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainOsNvRamSourceVhostUserPtySecLabel[] | cdktf.IResolvable;
}

export function domainOsNvRamSourceVhostUserPtyToTerraform(struct?: DomainOsNvRamSourceVhostUserPty | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainOsNvRamSourceVhostUserPtySecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainOsNvRamSourceVhostUserPtyToHclTerraform(struct?: DomainOsNvRamSourceVhostUserPty | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainOsNvRamSourceVhostUserPtySecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainOsNvRamSourceVhostUserPtySecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceVhostUserPtyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceVhostUserPty | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceVhostUserPty | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainOsNvRamSourceVhostUserPtySecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainOsNvRamSourceVhostUserPtySecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainOsNvRamSourceVhostUserQemuvdAgentClipBoard {
  /**
  * Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#copy_paste Domain#copy_paste}
  */
  readonly copyPaste: string;
}

export function domainOsNvRamSourceVhostUserQemuvdAgentClipBoardToTerraform(struct?: DomainOsNvRamSourceVhostUserQemuvdAgentClipBoard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    copy_paste: cdktf.stringToTerraform(struct!.copyPaste),
  }
}


export function domainOsNvRamSourceVhostUserQemuvdAgentClipBoardToHclTerraform(struct?: DomainOsNvRamSourceVhostUserQemuvdAgentClipBoard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    copy_paste: {
      value: cdktf.stringToHclTerraform(struct!.copyPaste),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceVhostUserQemuvdAgentClipBoardOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceVhostUserQemuvdAgentClipBoard | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._copyPaste !== undefined) {
      hasAnyValues = true;
      internalValueResult.copyPaste = this._copyPaste;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceVhostUserQemuvdAgentClipBoard | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._copyPaste = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._copyPaste = value.copyPaste;
    }
  }

  // copy_paste - computed: false, optional: false, required: true
  private _copyPaste?: string; 
  public get copyPaste() {
    return this.getStringAttribute('copy_paste');
  }
  public set copyPaste(value: string) {
    this._copyPaste = value;
  }
  // Temporarily expose input value. Use with caution.
  public get copyPasteInput() {
    return this._copyPaste;
  }
}
export interface DomainOsNvRamSourceVhostUserQemuvdAgentMouse {
  /**
  * Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).
  * 
  * See: <https://libvirt.org/formatdomain.html#channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode: string;
}

export function domainOsNvRamSourceVhostUserQemuvdAgentMouseToTerraform(struct?: DomainOsNvRamSourceVhostUserQemuvdAgentMouse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
  }
}


export function domainOsNvRamSourceVhostUserQemuvdAgentMouseToHclTerraform(struct?: DomainOsNvRamSourceVhostUserQemuvdAgentMouse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceVhostUserQemuvdAgentMouseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceVhostUserQemuvdAgentMouse | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceVhostUserQemuvdAgentMouse | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
    }
  }

  // mode - computed: false, optional: false, required: true
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }
}
export interface DomainOsNvRamSourceVhostUserQemuvdAgent {
  /**
  * Configures clipboard-related behavior for the QEMU vdagentbased EGD source, controlling whether clipboard data exchange is allowed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#clip_board Domain#clip_board}
  */
  readonly clipBoard?: DomainOsNvRamSourceVhostUserQemuvdAgentClipBoard;
  /**
  * Configures mouse integration options for the QEMU vdagentbased EGD source, such as how mouse events are handled.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mouse Domain#mouse}
  */
  readonly mouse?: DomainOsNvRamSourceVhostUserQemuvdAgentMouse;
}

export function domainOsNvRamSourceVhostUserQemuvdAgentToTerraform(struct?: DomainOsNvRamSourceVhostUserQemuvdAgent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    clip_board: domainOsNvRamSourceVhostUserQemuvdAgentClipBoardToTerraform(struct!.clipBoard),
    mouse: domainOsNvRamSourceVhostUserQemuvdAgentMouseToTerraform(struct!.mouse),
  }
}


export function domainOsNvRamSourceVhostUserQemuvdAgentToHclTerraform(struct?: DomainOsNvRamSourceVhostUserQemuvdAgent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    clip_board: {
      value: domainOsNvRamSourceVhostUserQemuvdAgentClipBoardToHclTerraform(struct!.clipBoard),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceVhostUserQemuvdAgentClipBoard",
    },
    mouse: {
      value: domainOsNvRamSourceVhostUserQemuvdAgentMouseToHclTerraform(struct!.mouse),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceVhostUserQemuvdAgentMouse",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceVhostUserQemuvdAgentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceVhostUserQemuvdAgent | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clipBoard?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clipBoard = this._clipBoard?.internalValue;
    }
    if (this._mouse?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.mouse = this._mouse?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceVhostUserQemuvdAgent | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clipBoard.internalValue = undefined;
      this._mouse.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clipBoard.internalValue = value.clipBoard;
      this._mouse.internalValue = value.mouse;
    }
  }

  // clip_board - computed: false, optional: true, required: false
  private _clipBoard = new DomainOsNvRamSourceVhostUserQemuvdAgentClipBoardOutputReference(this, "clip_board");
  public get clipBoard() {
    return this._clipBoard;
  }
  public putClipBoard(value: DomainOsNvRamSourceVhostUserQemuvdAgentClipBoard) {
    this._clipBoard.internalValue = value;
  }
  public resetClipBoard() {
    this._clipBoard.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clipBoardInput() {
    return this._clipBoard.internalValue;
  }

  // mouse - computed: false, optional: true, required: false
  private _mouse = new DomainOsNvRamSourceVhostUserQemuvdAgentMouseOutputReference(this, "mouse");
  public get mouse() {
    return this._mouse;
  }
  public putMouse(value: DomainOsNvRamSourceVhostUserQemuvdAgentMouse) {
    this._mouse.internalValue = value;
  }
  public resetMouse() {
    this._mouse.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mouseInput() {
    return this._mouse.internalValue;
  }
}
export interface DomainOsNvRamSourceVhostUserSpicePort {
  /**
  * Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#channel Domain#channel}
  */
  readonly channel: string;
}

export function domainOsNvRamSourceVhostUserSpicePortToTerraform(struct?: DomainOsNvRamSourceVhostUserSpicePort | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    channel: cdktf.stringToTerraform(struct!.channel),
  }
}


export function domainOsNvRamSourceVhostUserSpicePortToHclTerraform(struct?: DomainOsNvRamSourceVhostUserSpicePort | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    channel: {
      value: cdktf.stringToHclTerraform(struct!.channel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceVhostUserSpicePortOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceVhostUserSpicePort | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._channel !== undefined) {
      hasAnyValues = true;
      internalValueResult.channel = this._channel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceVhostUserSpicePort | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._channel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._channel = value.channel;
    }
  }

  // channel - computed: false, optional: false, required: true
  private _channel?: string; 
  public get channel() {
    return this.getStringAttribute('channel');
  }
  public set channel(value: string) {
    this._channel = value;
  }
  // Temporarily expose input value. Use with caution.
  public get channelInput() {
    return this._channel;
  }
}
export interface DomainOsNvRamSourceVhostUserTcpReconnect {
  /**
  * Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enabled Domain#enabled}
  */
  readonly enabled: string;
  /**
  * Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#timeout Domain#timeout}
  */
  readonly timeout?: number;
}

export function domainOsNvRamSourceVhostUserTcpReconnectToTerraform(struct?: DomainOsNvRamSourceVhostUserTcpReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.stringToTerraform(struct!.enabled),
    timeout: cdktf.numberToTerraform(struct!.timeout),
  }
}


export function domainOsNvRamSourceVhostUserTcpReconnectToHclTerraform(struct?: DomainOsNvRamSourceVhostUserTcpReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.stringToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.numberToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceVhostUserTcpReconnectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceVhostUserTcpReconnect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceVhostUserTcpReconnect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._timeout = value.timeout;
    }
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: string; 
  public get enabled() {
    return this.getStringAttribute('enabled');
  }
  public set enabled(value: string) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: number; 
  public get timeout() {
    return this.getNumberAttribute('timeout');
  }
  public set timeout(value: number) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DomainOsNvRamSourceVhostUserTcp {
  /**
  * Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#host Domain#host}
  */
  readonly host?: string;
  /**
  * Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode?: string;
  /**
  * Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reconnect Domain#reconnect}
  */
  readonly reconnect?: DomainOsNvRamSourceVhostUserTcpReconnect;
  /**
  * Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#service Domain#service}
  */
  readonly service?: string;
  /**
  * Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tls Domain#tls}
  */
  readonly tls?: string;
}

export function domainOsNvRamSourceVhostUserTcpToTerraform(struct?: DomainOsNvRamSourceVhostUserTcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    mode: cdktf.stringToTerraform(struct!.mode),
    reconnect: domainOsNvRamSourceVhostUserTcpReconnectToTerraform(struct!.reconnect),
    service: cdktf.stringToTerraform(struct!.service),
    tls: cdktf.stringToTerraform(struct!.tls),
  }
}


export function domainOsNvRamSourceVhostUserTcpToHclTerraform(struct?: DomainOsNvRamSourceVhostUserTcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reconnect: {
      value: domainOsNvRamSourceVhostUserTcpReconnectToHclTerraform(struct!.reconnect),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceVhostUserTcpReconnect",
    },
    service: {
      value: cdktf.stringToHclTerraform(struct!.service),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: cdktf.stringToHclTerraform(struct!.tls),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceVhostUserTcpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceVhostUserTcp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._reconnect?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.reconnect = this._reconnect?.internalValue;
    }
    if (this._service !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service;
    }
    if (this._tls !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceVhostUserTcp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host = undefined;
      this._mode = undefined;
      this._reconnect.internalValue = undefined;
      this._service = undefined;
      this._tls = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host = value.host;
      this._mode = value.mode;
      this._reconnect.internalValue = value.reconnect;
      this._service = value.service;
      this._tls = value.tls;
    }
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // reconnect - computed: false, optional: true, required: false
  private _reconnect = new DomainOsNvRamSourceVhostUserTcpReconnectOutputReference(this, "reconnect");
  public get reconnect() {
    return this._reconnect;
  }
  public putReconnect(value: DomainOsNvRamSourceVhostUserTcpReconnect) {
    this._reconnect.internalValue = value;
  }
  public resetReconnect() {
    this._reconnect.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reconnectInput() {
    return this._reconnect.internalValue;
  }

  // service - computed: false, optional: true, required: false
  private _service?: string; 
  public get service() {
    return this.getStringAttribute('service');
  }
  public set service(value: string) {
    this._service = value;
  }
  public resetService() {
    this._service = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service;
  }

  // tls - computed: false, optional: true, required: false
  private _tls?: string; 
  public get tls() {
    return this.getStringAttribute('tls');
  }
  public set tls(value: string) {
    this._tls = value;
  }
  public resetTls() {
    this._tls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls;
  }
}
export interface DomainOsNvRamSourceVhostUserUdp {
  /**
  * Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bind_host Domain#bind_host}
  */
  readonly bindHost: string;
  /**
  * Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bind_service Domain#bind_service}
  */
  readonly bindService: string;
  /**
  * Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#connect_host Domain#connect_host}
  */
  readonly connectHost: string;
  /**
  * Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#connect_service Domain#connect_service}
  */
  readonly connectService: string;
}

export function domainOsNvRamSourceVhostUserUdpToTerraform(struct?: DomainOsNvRamSourceVhostUserUdp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_host: cdktf.stringToTerraform(struct!.bindHost),
    bind_service: cdktf.stringToTerraform(struct!.bindService),
    connect_host: cdktf.stringToTerraform(struct!.connectHost),
    connect_service: cdktf.stringToTerraform(struct!.connectService),
  }
}


export function domainOsNvRamSourceVhostUserUdpToHclTerraform(struct?: DomainOsNvRamSourceVhostUserUdp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_host: {
      value: cdktf.stringToHclTerraform(struct!.bindHost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bind_service: {
      value: cdktf.stringToHclTerraform(struct!.bindService),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connect_host: {
      value: cdktf.stringToHclTerraform(struct!.connectHost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connect_service: {
      value: cdktf.stringToHclTerraform(struct!.connectService),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceVhostUserUdpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceVhostUserUdp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindHost !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindHost = this._bindHost;
    }
    if (this._bindService !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindService = this._bindService;
    }
    if (this._connectHost !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectHost = this._connectHost;
    }
    if (this._connectService !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectService = this._connectService;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceVhostUserUdp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bindHost = undefined;
      this._bindService = undefined;
      this._connectHost = undefined;
      this._connectService = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bindHost = value.bindHost;
      this._bindService = value.bindService;
      this._connectHost = value.connectHost;
      this._connectService = value.connectService;
    }
  }

  // bind_host - computed: false, optional: false, required: true
  private _bindHost?: string; 
  public get bindHost() {
    return this.getStringAttribute('bind_host');
  }
  public set bindHost(value: string) {
    this._bindHost = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bindHostInput() {
    return this._bindHost;
  }

  // bind_service - computed: false, optional: false, required: true
  private _bindService?: string; 
  public get bindService() {
    return this.getStringAttribute('bind_service');
  }
  public set bindService(value: string) {
    this._bindService = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bindServiceInput() {
    return this._bindService;
  }

  // connect_host - computed: false, optional: false, required: true
  private _connectHost?: string; 
  public get connectHost() {
    return this.getStringAttribute('connect_host');
  }
  public set connectHost(value: string) {
    this._connectHost = value;
  }
  // Temporarily expose input value. Use with caution.
  public get connectHostInput() {
    return this._connectHost;
  }

  // connect_service - computed: false, optional: false, required: true
  private _connectService?: string; 
  public get connectService() {
    return this.getStringAttribute('connect_service');
  }
  public set connectService(value: string) {
    this._connectService = value;
  }
  // Temporarily expose input value. Use with caution.
  public get connectServiceInput() {
    return this._connectService;
  }
}
export interface DomainOsNvRamSourceVhostUserUnixReconnect {
  /**
  * Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enabled Domain#enabled}
  */
  readonly enabled: string;
  /**
  * Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#timeout Domain#timeout}
  */
  readonly timeout?: number;
}

export function domainOsNvRamSourceVhostUserUnixReconnectToTerraform(struct?: DomainOsNvRamSourceVhostUserUnixReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.stringToTerraform(struct!.enabled),
    timeout: cdktf.numberToTerraform(struct!.timeout),
  }
}


export function domainOsNvRamSourceVhostUserUnixReconnectToHclTerraform(struct?: DomainOsNvRamSourceVhostUserUnixReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.stringToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.numberToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceVhostUserUnixReconnectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceVhostUserUnixReconnect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceVhostUserUnixReconnect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._timeout = value.timeout;
    }
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: string; 
  public get enabled() {
    return this.getStringAttribute('enabled');
  }
  public set enabled(value: string) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: number; 
  public get timeout() {
    return this.getNumberAttribute('timeout');
  }
  public set timeout(value: number) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DomainOsNvRamSourceVhostUserUnixSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainOsNvRamSourceVhostUserUnixSecLabelToTerraform(struct?: DomainOsNvRamSourceVhostUserUnixSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainOsNvRamSourceVhostUserUnixSecLabelToHclTerraform(struct?: DomainOsNvRamSourceVhostUserUnixSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceVhostUserUnixSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainOsNvRamSourceVhostUserUnixSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceVhostUserUnixSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainOsNvRamSourceVhostUserUnixSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainOsNvRamSourceVhostUserUnixSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainOsNvRamSourceVhostUserUnixSecLabelOutputReference {
    return new DomainOsNvRamSourceVhostUserUnixSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainOsNvRamSourceVhostUserUnix {
  /**
  * Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode?: string;
  /**
  * Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path?: string;
  /**
  * Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reconnect Domain#reconnect}
  */
  readonly reconnect?: DomainOsNvRamSourceVhostUserUnixReconnect;
  /**
  * Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainOsNvRamSourceVhostUserUnixSecLabel[] | cdktf.IResolvable;
}

export function domainOsNvRamSourceVhostUserUnixToTerraform(struct?: DomainOsNvRamSourceVhostUserUnix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
    reconnect: domainOsNvRamSourceVhostUserUnixReconnectToTerraform(struct!.reconnect),
    sec_label: cdktf.listMapper(domainOsNvRamSourceVhostUserUnixSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainOsNvRamSourceVhostUserUnixToHclTerraform(struct?: DomainOsNvRamSourceVhostUserUnix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reconnect: {
      value: domainOsNvRamSourceVhostUserUnixReconnectToHclTerraform(struct!.reconnect),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceVhostUserUnixReconnect",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainOsNvRamSourceVhostUserUnixSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainOsNvRamSourceVhostUserUnixSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceVhostUserUnixOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceVhostUserUnix | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._reconnect?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.reconnect = this._reconnect?.internalValue;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceVhostUserUnix | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
      this._path = undefined;
      this._reconnect.internalValue = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
      this._path = value.path;
      this._reconnect.internalValue = value.reconnect;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // reconnect - computed: false, optional: true, required: false
  private _reconnect = new DomainOsNvRamSourceVhostUserUnixReconnectOutputReference(this, "reconnect");
  public get reconnect() {
    return this._reconnect;
  }
  public putReconnect(value: DomainOsNvRamSourceVhostUserUnixReconnect) {
    this._reconnect.internalValue = value;
  }
  public resetReconnect() {
    this._reconnect.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reconnectInput() {
    return this._reconnect.internalValue;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainOsNvRamSourceVhostUserUnixSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainOsNvRamSourceVhostUserUnixSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainOsNvRamSourceVhostUser {
  /**
  * Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dbus Domain#dbus}
  */
  readonly dbus?: DomainOsNvRamSourceVhostUserDbus;
  /**
  * Configures an EGD RNG backend that reads entropy from a host character device node.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dev Domain#dev}
  */
  readonly dev?: DomainOsNvRamSourceVhostUserDev;
  /**
  * Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file?: DomainOsNvRamSourceVhostUserFile;
  /**
  * Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#nmdm Domain#nmdm}
  */
  readonly nmdm?: DomainOsNvRamSourceVhostUserNmdm;
  /**
  * When set to true, uses a null character device as the vhost-user backing-store source, discarding all output and providing no input; when false or unset, the null device is not used.
  * 
  * See: <https://libvirt.org/formatdomain.html#null-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#null Domain#null}
  */
  readonly null?: boolean | cdktf.IResolvable;
  /**
  * Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pipe Domain#pipe}
  */
  readonly pipe?: DomainOsNvRamSourceVhostUserPipe;
  /**
  * Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pty Domain#pty}
  */
  readonly pty?: DomainOsNvRamSourceVhostUserPty;
  /**
  * Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#qemuvd_agent Domain#qemuvd_agent}
  */
  readonly qemuvdAgent?: DomainOsNvRamSourceVhostUserQemuvdAgent;
  /**
  * Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#spice_port Domain#spice_port}
  */
  readonly spicePort?: DomainOsNvRamSourceVhostUserSpicePort;
  /**
  * When set to true, exposes the vhost-user backing through a SPICE virtio-serial management channel (SpiceVMC); when false or unset, the element is omitted.
  * 
  * See: <https://libvirt.org/formatdomain.html#spice-channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#spice_vmc Domain#spice_vmc}
  */
  readonly spiceVmc?: boolean | cdktf.IResolvable;
  /**
  * When set to true, connects the vhost-user backing to the domains standard I/O character device; when false or unset, the StdIO element is omitted.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-interface>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#std_io Domain#std_io}
  */
  readonly stdIo?: boolean | cdktf.IResolvable;
  /**
  * Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tcp Domain#tcp}
  */
  readonly tcp?: DomainOsNvRamSourceVhostUserTcp;
  /**
  * Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#udp Domain#udp}
  */
  readonly udp?: DomainOsNvRamSourceVhostUserUdp;
  /**
  * Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#unix Domain#unix}
  */
  readonly unix?: DomainOsNvRamSourceVhostUserUnix;
  /**
  * Enables use of a vhost-user communication mechanism compatible with a VC-style (versioned capability) endpoint for the disk mirror backing store; when set true the VC element is emitted, when false or null it is omitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vc Domain#vc}
  */
  readonly vc?: boolean | cdktf.IResolvable;
}

export function domainOsNvRamSourceVhostUserToTerraform(struct?: DomainOsNvRamSourceVhostUser | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dbus: domainOsNvRamSourceVhostUserDbusToTerraform(struct!.dbus),
    dev: domainOsNvRamSourceVhostUserDevToTerraform(struct!.dev),
    file: domainOsNvRamSourceVhostUserFileToTerraform(struct!.file),
    nmdm: domainOsNvRamSourceVhostUserNmdmToTerraform(struct!.nmdm),
    null: cdktf.booleanToTerraform(struct!.null),
    pipe: domainOsNvRamSourceVhostUserPipeToTerraform(struct!.pipe),
    pty: domainOsNvRamSourceVhostUserPtyToTerraform(struct!.pty),
    qemuvd_agent: domainOsNvRamSourceVhostUserQemuvdAgentToTerraform(struct!.qemuvdAgent),
    spice_port: domainOsNvRamSourceVhostUserSpicePortToTerraform(struct!.spicePort),
    spice_vmc: cdktf.booleanToTerraform(struct!.spiceVmc),
    std_io: cdktf.booleanToTerraform(struct!.stdIo),
    tcp: domainOsNvRamSourceVhostUserTcpToTerraform(struct!.tcp),
    udp: domainOsNvRamSourceVhostUserUdpToTerraform(struct!.udp),
    unix: domainOsNvRamSourceVhostUserUnixToTerraform(struct!.unix),
    vc: cdktf.booleanToTerraform(struct!.vc),
  }
}


export function domainOsNvRamSourceVhostUserToHclTerraform(struct?: DomainOsNvRamSourceVhostUser | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dbus: {
      value: domainOsNvRamSourceVhostUserDbusToHclTerraform(struct!.dbus),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceVhostUserDbus",
    },
    dev: {
      value: domainOsNvRamSourceVhostUserDevToHclTerraform(struct!.dev),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceVhostUserDev",
    },
    file: {
      value: domainOsNvRamSourceVhostUserFileToHclTerraform(struct!.file),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceVhostUserFile",
    },
    nmdm: {
      value: domainOsNvRamSourceVhostUserNmdmToHclTerraform(struct!.nmdm),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceVhostUserNmdm",
    },
    null: {
      value: cdktf.booleanToHclTerraform(struct!.null),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    pipe: {
      value: domainOsNvRamSourceVhostUserPipeToHclTerraform(struct!.pipe),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceVhostUserPipe",
    },
    pty: {
      value: domainOsNvRamSourceVhostUserPtyToHclTerraform(struct!.pty),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceVhostUserPty",
    },
    qemuvd_agent: {
      value: domainOsNvRamSourceVhostUserQemuvdAgentToHclTerraform(struct!.qemuvdAgent),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceVhostUserQemuvdAgent",
    },
    spice_port: {
      value: domainOsNvRamSourceVhostUserSpicePortToHclTerraform(struct!.spicePort),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceVhostUserSpicePort",
    },
    spice_vmc: {
      value: cdktf.booleanToHclTerraform(struct!.spiceVmc),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    std_io: {
      value: cdktf.booleanToHclTerraform(struct!.stdIo),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tcp: {
      value: domainOsNvRamSourceVhostUserTcpToHclTerraform(struct!.tcp),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceVhostUserTcp",
    },
    udp: {
      value: domainOsNvRamSourceVhostUserUdpToHclTerraform(struct!.udp),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceVhostUserUdp",
    },
    unix: {
      value: domainOsNvRamSourceVhostUserUnixToHclTerraform(struct!.unix),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceVhostUserUnix",
    },
    vc: {
      value: cdktf.booleanToHclTerraform(struct!.vc),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceVhostUserOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceVhostUser | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dbus?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dbus = this._dbus?.internalValue;
    }
    if (this._dev?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dev = this._dev?.internalValue;
    }
    if (this._file?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file?.internalValue;
    }
    if (this._nmdm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nmdm = this._nmdm?.internalValue;
    }
    if (this._null !== undefined) {
      hasAnyValues = true;
      internalValueResult.null = this._null;
    }
    if (this._pipe?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipe = this._pipe?.internalValue;
    }
    if (this._pty?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pty = this._pty?.internalValue;
    }
    if (this._qemuvdAgent?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.qemuvdAgent = this._qemuvdAgent?.internalValue;
    }
    if (this._spicePort?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spicePort = this._spicePort?.internalValue;
    }
    if (this._spiceVmc !== undefined) {
      hasAnyValues = true;
      internalValueResult.spiceVmc = this._spiceVmc;
    }
    if (this._stdIo !== undefined) {
      hasAnyValues = true;
      internalValueResult.stdIo = this._stdIo;
    }
    if (this._tcp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tcp = this._tcp?.internalValue;
    }
    if (this._udp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.udp = this._udp?.internalValue;
    }
    if (this._unix?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.unix = this._unix?.internalValue;
    }
    if (this._vc !== undefined) {
      hasAnyValues = true;
      internalValueResult.vc = this._vc;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceVhostUser | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dbus.internalValue = undefined;
      this._dev.internalValue = undefined;
      this._file.internalValue = undefined;
      this._nmdm.internalValue = undefined;
      this._null = undefined;
      this._pipe.internalValue = undefined;
      this._pty.internalValue = undefined;
      this._qemuvdAgent.internalValue = undefined;
      this._spicePort.internalValue = undefined;
      this._spiceVmc = undefined;
      this._stdIo = undefined;
      this._tcp.internalValue = undefined;
      this._udp.internalValue = undefined;
      this._unix.internalValue = undefined;
      this._vc = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dbus.internalValue = value.dbus;
      this._dev.internalValue = value.dev;
      this._file.internalValue = value.file;
      this._nmdm.internalValue = value.nmdm;
      this._null = value.null;
      this._pipe.internalValue = value.pipe;
      this._pty.internalValue = value.pty;
      this._qemuvdAgent.internalValue = value.qemuvdAgent;
      this._spicePort.internalValue = value.spicePort;
      this._spiceVmc = value.spiceVmc;
      this._stdIo = value.stdIo;
      this._tcp.internalValue = value.tcp;
      this._udp.internalValue = value.udp;
      this._unix.internalValue = value.unix;
      this._vc = value.vc;
    }
  }

  // dbus - computed: false, optional: true, required: false
  private _dbus = new DomainOsNvRamSourceVhostUserDbusOutputReference(this, "dbus");
  public get dbus() {
    return this._dbus;
  }
  public putDbus(value: DomainOsNvRamSourceVhostUserDbus) {
    this._dbus.internalValue = value;
  }
  public resetDbus() {
    this._dbus.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dbusInput() {
    return this._dbus.internalValue;
  }

  // dev - computed: false, optional: true, required: false
  private _dev = new DomainOsNvRamSourceVhostUserDevOutputReference(this, "dev");
  public get dev() {
    return this._dev;
  }
  public putDev(value: DomainOsNvRamSourceVhostUserDev) {
    this._dev.internalValue = value;
  }
  public resetDev() {
    this._dev.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devInput() {
    return this._dev.internalValue;
  }

  // file - computed: false, optional: true, required: false
  private _file = new DomainOsNvRamSourceVhostUserFileOutputReference(this, "file");
  public get file() {
    return this._file;
  }
  public putFile(value: DomainOsNvRamSourceVhostUserFile) {
    this._file.internalValue = value;
  }
  public resetFile() {
    this._file.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file.internalValue;
  }

  // nmdm - computed: false, optional: true, required: false
  private _nmdm = new DomainOsNvRamSourceVhostUserNmdmOutputReference(this, "nmdm");
  public get nmdm() {
    return this._nmdm;
  }
  public putNmdm(value: DomainOsNvRamSourceVhostUserNmdm) {
    this._nmdm.internalValue = value;
  }
  public resetNmdm() {
    this._nmdm.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nmdmInput() {
    return this._nmdm.internalValue;
  }

  // null - computed: false, optional: true, required: false
  private _null?: boolean | cdktf.IResolvable; 
  public get null() {
    return this.getBooleanAttribute('null');
  }
  public set null(value: boolean | cdktf.IResolvable) {
    this._null = value;
  }
  public resetNull() {
    this._null = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nullInput() {
    return this._null;
  }

  // pipe - computed: false, optional: true, required: false
  private _pipe = new DomainOsNvRamSourceVhostUserPipeOutputReference(this, "pipe");
  public get pipe() {
    return this._pipe;
  }
  public putPipe(value: DomainOsNvRamSourceVhostUserPipe) {
    this._pipe.internalValue = value;
  }
  public resetPipe() {
    this._pipe.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipeInput() {
    return this._pipe.internalValue;
  }

  // pty - computed: false, optional: true, required: false
  private _pty = new DomainOsNvRamSourceVhostUserPtyOutputReference(this, "pty");
  public get pty() {
    return this._pty;
  }
  public putPty(value: DomainOsNvRamSourceVhostUserPty) {
    this._pty.internalValue = value;
  }
  public resetPty() {
    this._pty.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ptyInput() {
    return this._pty.internalValue;
  }

  // qemuvd_agent - computed: false, optional: true, required: false
  private _qemuvdAgent = new DomainOsNvRamSourceVhostUserQemuvdAgentOutputReference(this, "qemuvd_agent");
  public get qemuvdAgent() {
    return this._qemuvdAgent;
  }
  public putQemuvdAgent(value: DomainOsNvRamSourceVhostUserQemuvdAgent) {
    this._qemuvdAgent.internalValue = value;
  }
  public resetQemuvdAgent() {
    this._qemuvdAgent.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get qemuvdAgentInput() {
    return this._qemuvdAgent.internalValue;
  }

  // spice_port - computed: false, optional: true, required: false
  private _spicePort = new DomainOsNvRamSourceVhostUserSpicePortOutputReference(this, "spice_port");
  public get spicePort() {
    return this._spicePort;
  }
  public putSpicePort(value: DomainOsNvRamSourceVhostUserSpicePort) {
    this._spicePort.internalValue = value;
  }
  public resetSpicePort() {
    this._spicePort.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spicePortInput() {
    return this._spicePort.internalValue;
  }

  // spice_vmc - computed: false, optional: true, required: false
  private _spiceVmc?: boolean | cdktf.IResolvable; 
  public get spiceVmc() {
    return this.getBooleanAttribute('spice_vmc');
  }
  public set spiceVmc(value: boolean | cdktf.IResolvable) {
    this._spiceVmc = value;
  }
  public resetSpiceVmc() {
    this._spiceVmc = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spiceVmcInput() {
    return this._spiceVmc;
  }

  // std_io - computed: false, optional: true, required: false
  private _stdIo?: boolean | cdktf.IResolvable; 
  public get stdIo() {
    return this.getBooleanAttribute('std_io');
  }
  public set stdIo(value: boolean | cdktf.IResolvable) {
    this._stdIo = value;
  }
  public resetStdIo() {
    this._stdIo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stdIoInput() {
    return this._stdIo;
  }

  // tcp - computed: false, optional: true, required: false
  private _tcp = new DomainOsNvRamSourceVhostUserTcpOutputReference(this, "tcp");
  public get tcp() {
    return this._tcp;
  }
  public putTcp(value: DomainOsNvRamSourceVhostUserTcp) {
    this._tcp.internalValue = value;
  }
  public resetTcp() {
    this._tcp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tcpInput() {
    return this._tcp.internalValue;
  }

  // udp - computed: false, optional: true, required: false
  private _udp = new DomainOsNvRamSourceVhostUserUdpOutputReference(this, "udp");
  public get udp() {
    return this._udp;
  }
  public putUdp(value: DomainOsNvRamSourceVhostUserUdp) {
    this._udp.internalValue = value;
  }
  public resetUdp() {
    this._udp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get udpInput() {
    return this._udp.internalValue;
  }

  // unix - computed: false, optional: true, required: false
  private _unix = new DomainOsNvRamSourceVhostUserUnixOutputReference(this, "unix");
  public get unix() {
    return this._unix;
  }
  public putUnix(value: DomainOsNvRamSourceVhostUserUnix) {
    this._unix.internalValue = value;
  }
  public resetUnix() {
    this._unix.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unixInput() {
    return this._unix.internalValue;
  }

  // vc - computed: false, optional: true, required: false
  private _vc?: boolean | cdktf.IResolvable; 
  public get vc() {
    return this.getBooleanAttribute('vc');
  }
  public set vc(value: boolean | cdktf.IResolvable) {
    this._vc = value;
  }
  public resetVc() {
    this._vc = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vcInput() {
    return this._vc;
  }
}
export interface DomainOsNvRamSourceVhostVdpa {
  /**
  * Sets the host vDPA character device path used as the backingStore source for the mirrored disk when using a vhost-vdpa backend; the value is user-provided and must reference an existing device node (for example, /dev/vhost-vdpa0).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dev Domain#dev}
  */
  readonly dev: string;
}

export function domainOsNvRamSourceVhostVdpaToTerraform(struct?: DomainOsNvRamSourceVhostVdpa | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dev: cdktf.stringToTerraform(struct!.dev),
  }
}


export function domainOsNvRamSourceVhostVdpaToHclTerraform(struct?: DomainOsNvRamSourceVhostVdpa | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dev: {
      value: cdktf.stringToHclTerraform(struct!.dev),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceVhostVdpaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceVhostVdpa | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dev !== undefined) {
      hasAnyValues = true;
      internalValueResult.dev = this._dev;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceVhostVdpa | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dev = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dev = value.dev;
    }
  }

  // dev - computed: false, optional: false, required: true
  private _dev?: string; 
  public get dev() {
    return this.getStringAttribute('dev');
  }
  public set dev(value: string) {
    this._dev = value;
  }
  // Temporarily expose input value. Use with caution.
  public get devInput() {
    return this._dev;
  }
}
export interface DomainOsNvRamSourceVolumeSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainOsNvRamSourceVolumeSecLabelToTerraform(struct?: DomainOsNvRamSourceVolumeSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainOsNvRamSourceVolumeSecLabelToHclTerraform(struct?: DomainOsNvRamSourceVolumeSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceVolumeSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainOsNvRamSourceVolumeSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceVolumeSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainOsNvRamSourceVolumeSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainOsNvRamSourceVolumeSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainOsNvRamSourceVolumeSecLabelOutputReference {
    return new DomainOsNvRamSourceVolumeSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainOsNvRamSourceVolume {
  /**
  * Sets the access mode with which the storage volume is used as the backingStore source (for example, "readOnly" or "readWrite" depending on driver support); the value is user-provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode?: string;
  /**
  * Names the storage pool that contains the backing storage volume used as the mirror backingStore source; must match an existing libvirt storage pool name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pool Domain#pool}
  */
  readonly pool?: string;
  /**
  * Configures an optional security label override applied to the backing storage volume used as the mirror backingStore source.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainOsNvRamSourceVolumeSecLabel[] | cdktf.IResolvable;
  /**
  * Sets the name of the storage volume within the specified pool that is used as the backingStore source for the mirrored disk.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#volume Domain#volume}
  */
  readonly volume?: string;
}

export function domainOsNvRamSourceVolumeToTerraform(struct?: DomainOsNvRamSourceVolume | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
    pool: cdktf.stringToTerraform(struct!.pool),
    sec_label: cdktf.listMapper(domainOsNvRamSourceVolumeSecLabelToTerraform, false)(struct!.secLabel),
    volume: cdktf.stringToTerraform(struct!.volume),
  }
}


export function domainOsNvRamSourceVolumeToHclTerraform(struct?: DomainOsNvRamSourceVolume | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pool: {
      value: cdktf.stringToHclTerraform(struct!.pool),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainOsNvRamSourceVolumeSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainOsNvRamSourceVolumeSecLabelList",
    },
    volume: {
      value: cdktf.stringToHclTerraform(struct!.volume),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceVolumeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSourceVolume | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._pool !== undefined) {
      hasAnyValues = true;
      internalValueResult.pool = this._pool;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    if (this._volume !== undefined) {
      hasAnyValues = true;
      internalValueResult.volume = this._volume;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSourceVolume | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
      this._pool = undefined;
      this._secLabel.internalValue = undefined;
      this._volume = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
      this._pool = value.pool;
      this._secLabel.internalValue = value.secLabel;
      this._volume = value.volume;
    }
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // pool - computed: false, optional: true, required: false
  private _pool?: string; 
  public get pool() {
    return this.getStringAttribute('pool');
  }
  public set pool(value: string) {
    this._pool = value;
  }
  public resetPool() {
    this._pool = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get poolInput() {
    return this._pool;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainOsNvRamSourceVolumeSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainOsNvRamSourceVolumeSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }

  // volume - computed: false, optional: true, required: false
  private _volume?: string; 
  public get volume() {
    return this.getStringAttribute('volume');
  }
  public set volume(value: string) {
    this._volume = value;
  }
  public resetVolume() {
    this._volume = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get volumeInput() {
    return this._volume;
  }
}
export interface DomainOsNvRamSource {
  /**
  * Describes a block device used as the source for the mirror backing store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#block Domain#block}
  */
  readonly block?: DomainOsNvRamSourceBlock;
  /**
  * Provides optional cookie data associated with the mirror backing store source (for example, auth or session data), with content treated as user-provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#cookies Domain#cookies}
  */
  readonly cookies?: DomainOsNvRamSourceCookies;
  /**
  * Configures a data store descriptor for the mirrored backing store, typically used with networked or advanced storage backends that expose format-specific options.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#data_store Domain#data_store}
  */
  readonly dataStore?: DomainOsNvRamSourceDataStore;
  /**
  * Configures a directory-based source for the mirrored backing store, pointing to a host directory used by the backing image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dir Domain#dir}
  */
  readonly dir?: DomainOsNvRamSourceDir;
  /**
  * Enables disk image encryption configuration for this disk and groups attributes defining the encryption engine, format, and secrets.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#encryption Domain#encryption}
  */
  readonly encryption?: DomainOsNvRamSourceEncryption;
  /**
  * Configures a file-based backing store source for the disk mirror, defining how the backing image is accessed from the host filesystem.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file?: DomainOsNvRamSourceFile;
  /**
  * Sets the index of this backing store within a backing chain, used when multiple backing layers are present; value is a user-provided non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#index Domain#index}
  */
  readonly index?: number;
  /**
  * Configures a network-based backing store source (such as NBD, iSCSI, or RBD) for the disk mirror, including authentication and host endpoints.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#network Domain#network}
  */
  readonly network?: DomainOsNvRamSourceNetwork;
  /**
  * Enables using an NVMe-backed source for the mirrored disks backing store; when present, it selects an NVMe device or namespace as the source, with details defined by libvirt/QEMU for NVMe disks.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#nvme Domain#nvme}
  */
  readonly nvme?: DomainOsNvRamSourceNvme;
  /**
  * Configures read-ahead behavior for the mirrored disks backing-store source, allowing tuning of how much data is pre-fetched from the backend.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#readahead Domain#readahead}
  */
  readonly readahead?: DomainOsNvRamSourceReadahead;
  /**
  * Configures SCSI-style reservations or similar persistent reservation management for the mirrored disks backing-store source, controlling how access is coordinated across nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reservations Domain#reservations}
  */
  readonly reservations?: DomainOsNvRamSourceReservations;
  /**
  * Configures optional slice or segment information for the backing store source (for example, to describe which logical slices of a device are used); content is user-provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#slices Domain#slices}
  */
  readonly slices?: DomainOsNvRamSourceSlices;
  /**
  * Enables SSL/TLS parameters for accessing the mirrored backing-store source when it is provided over a secure transport.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#ssl Domain#ssl}
  */
  readonly ssl?: DomainOsNvRamSourceSsl;
  /**
  * Specifies how strictly the mirrored backing-store source must be available during domain startup; valid values include "mandatory", "requisite", "optional" (userprovided string matched by libvirt).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#startup_policy Domain#startup_policy}
  */
  readonly startupPolicy?: string;
  /**
  * Configures a timeout for connecting to or initializing the mirrored backing-store source.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#timeout Domain#timeout}
  */
  readonly timeout?: DomainOsNvRamSourceTimeout;
  /**
  * Selects a vhost-user backend as the transport for the mirrored backing-store source, allowing it to be provided via a userspace process.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vhost_user Domain#vhost_user}
  */
  readonly vhostUser?: DomainOsNvRamSourceVhostUser;
  /**
  * Selects a vhost-vDPA backend for the disk mirror backing store, allowing acceleration via a vDPA device; additional details are determined by libvirt and device configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vhost_vdpa Domain#vhost_vdpa}
  */
  readonly vhostVdpa?: DomainOsNvRamSourceVhostVdpa;
  /**
  * Configures the backingStore source as a libvirt storage volume reference instead of a raw file/block path for the mirrored disk.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#volume Domain#volume}
  */
  readonly volume?: DomainOsNvRamSourceVolume;
}

export function domainOsNvRamSourceToTerraform(struct?: DomainOsNvRamSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    block: domainOsNvRamSourceBlockToTerraform(struct!.block),
    cookies: domainOsNvRamSourceCookiesToTerraform(struct!.cookies),
    data_store: domainOsNvRamSourceDataStoreToTerraform(struct!.dataStore),
    dir: domainOsNvRamSourceDirToTerraform(struct!.dir),
    encryption: domainOsNvRamSourceEncryptionToTerraform(struct!.encryption),
    file: domainOsNvRamSourceFileToTerraform(struct!.file),
    index: cdktf.numberToTerraform(struct!.index),
    network: domainOsNvRamSourceNetworkToTerraform(struct!.network),
    nvme: domainOsNvRamSourceNvmeToTerraform(struct!.nvme),
    readahead: domainOsNvRamSourceReadaheadToTerraform(struct!.readahead),
    reservations: domainOsNvRamSourceReservationsToTerraform(struct!.reservations),
    slices: domainOsNvRamSourceSlicesToTerraform(struct!.slices),
    ssl: domainOsNvRamSourceSslToTerraform(struct!.ssl),
    startup_policy: cdktf.stringToTerraform(struct!.startupPolicy),
    timeout: domainOsNvRamSourceTimeoutToTerraform(struct!.timeout),
    vhost_user: domainOsNvRamSourceVhostUserToTerraform(struct!.vhostUser),
    vhost_vdpa: domainOsNvRamSourceVhostVdpaToTerraform(struct!.vhostVdpa),
    volume: domainOsNvRamSourceVolumeToTerraform(struct!.volume),
  }
}


export function domainOsNvRamSourceToHclTerraform(struct?: DomainOsNvRamSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    block: {
      value: domainOsNvRamSourceBlockToHclTerraform(struct!.block),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceBlock",
    },
    cookies: {
      value: domainOsNvRamSourceCookiesToHclTerraform(struct!.cookies),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceCookies",
    },
    data_store: {
      value: domainOsNvRamSourceDataStoreToHclTerraform(struct!.dataStore),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceDataStore",
    },
    dir: {
      value: domainOsNvRamSourceDirToHclTerraform(struct!.dir),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceDir",
    },
    encryption: {
      value: domainOsNvRamSourceEncryptionToHclTerraform(struct!.encryption),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceEncryption",
    },
    file: {
      value: domainOsNvRamSourceFileToHclTerraform(struct!.file),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceFile",
    },
    index: {
      value: cdktf.numberToHclTerraform(struct!.index),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    network: {
      value: domainOsNvRamSourceNetworkToHclTerraform(struct!.network),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceNetwork",
    },
    nvme: {
      value: domainOsNvRamSourceNvmeToHclTerraform(struct!.nvme),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceNvme",
    },
    readahead: {
      value: domainOsNvRamSourceReadaheadToHclTerraform(struct!.readahead),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceReadahead",
    },
    reservations: {
      value: domainOsNvRamSourceReservationsToHclTerraform(struct!.reservations),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceReservations",
    },
    slices: {
      value: domainOsNvRamSourceSlicesToHclTerraform(struct!.slices),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceSlices",
    },
    ssl: {
      value: domainOsNvRamSourceSslToHclTerraform(struct!.ssl),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceSsl",
    },
    startup_policy: {
      value: cdktf.stringToHclTerraform(struct!.startupPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: domainOsNvRamSourceTimeoutToHclTerraform(struct!.timeout),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceTimeout",
    },
    vhost_user: {
      value: domainOsNvRamSourceVhostUserToHclTerraform(struct!.vhostUser),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceVhostUser",
    },
    vhost_vdpa: {
      value: domainOsNvRamSourceVhostVdpaToHclTerraform(struct!.vhostVdpa),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceVhostVdpa",
    },
    volume: {
      value: domainOsNvRamSourceVolumeToHclTerraform(struct!.volume),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSourceVolume",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRamSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._block?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.block = this._block?.internalValue;
    }
    if (this._cookies?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cookies = this._cookies?.internalValue;
    }
    if (this._dataStore?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dataStore = this._dataStore?.internalValue;
    }
    if (this._dir?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dir = this._dir?.internalValue;
    }
    if (this._encryption?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.encryption = this._encryption?.internalValue;
    }
    if (this._file?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file?.internalValue;
    }
    if (this._index !== undefined) {
      hasAnyValues = true;
      internalValueResult.index = this._index;
    }
    if (this._network?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.network = this._network?.internalValue;
    }
    if (this._nvme?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nvme = this._nvme?.internalValue;
    }
    if (this._readahead?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.readahead = this._readahead?.internalValue;
    }
    if (this._reservations?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.reservations = this._reservations?.internalValue;
    }
    if (this._slices?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.slices = this._slices?.internalValue;
    }
    if (this._ssl?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ssl = this._ssl?.internalValue;
    }
    if (this._startupPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.startupPolicy = this._startupPolicy;
    }
    if (this._timeout?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout?.internalValue;
    }
    if (this._vhostUser?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.vhostUser = this._vhostUser?.internalValue;
    }
    if (this._vhostVdpa?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.vhostVdpa = this._vhostVdpa?.internalValue;
    }
    if (this._volume?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.volume = this._volume?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRamSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._block.internalValue = undefined;
      this._cookies.internalValue = undefined;
      this._dataStore.internalValue = undefined;
      this._dir.internalValue = undefined;
      this._encryption.internalValue = undefined;
      this._file.internalValue = undefined;
      this._index = undefined;
      this._network.internalValue = undefined;
      this._nvme.internalValue = undefined;
      this._readahead.internalValue = undefined;
      this._reservations.internalValue = undefined;
      this._slices.internalValue = undefined;
      this._ssl.internalValue = undefined;
      this._startupPolicy = undefined;
      this._timeout.internalValue = undefined;
      this._vhostUser.internalValue = undefined;
      this._vhostVdpa.internalValue = undefined;
      this._volume.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._block.internalValue = value.block;
      this._cookies.internalValue = value.cookies;
      this._dataStore.internalValue = value.dataStore;
      this._dir.internalValue = value.dir;
      this._encryption.internalValue = value.encryption;
      this._file.internalValue = value.file;
      this._index = value.index;
      this._network.internalValue = value.network;
      this._nvme.internalValue = value.nvme;
      this._readahead.internalValue = value.readahead;
      this._reservations.internalValue = value.reservations;
      this._slices.internalValue = value.slices;
      this._ssl.internalValue = value.ssl;
      this._startupPolicy = value.startupPolicy;
      this._timeout.internalValue = value.timeout;
      this._vhostUser.internalValue = value.vhostUser;
      this._vhostVdpa.internalValue = value.vhostVdpa;
      this._volume.internalValue = value.volume;
    }
  }

  // block - computed: false, optional: true, required: false
  private _block = new DomainOsNvRamSourceBlockOutputReference(this, "block");
  public get block() {
    return this._block;
  }
  public putBlock(value: DomainOsNvRamSourceBlock) {
    this._block.internalValue = value;
  }
  public resetBlock() {
    this._block.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get blockInput() {
    return this._block.internalValue;
  }

  // cookies - computed: false, optional: true, required: false
  private _cookies = new DomainOsNvRamSourceCookiesOutputReference(this, "cookies");
  public get cookies() {
    return this._cookies;
  }
  public putCookies(value: DomainOsNvRamSourceCookies) {
    this._cookies.internalValue = value;
  }
  public resetCookies() {
    this._cookies.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cookiesInput() {
    return this._cookies.internalValue;
  }

  // data_store - computed: false, optional: true, required: false
  private _dataStore = new DomainOsNvRamSourceDataStoreOutputReference(this, "data_store");
  public get dataStore() {
    return this._dataStore;
  }
  public putDataStore(value: DomainOsNvRamSourceDataStore) {
    this._dataStore.internalValue = value;
  }
  public resetDataStore() {
    this._dataStore.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dataStoreInput() {
    return this._dataStore.internalValue;
  }

  // dir - computed: false, optional: true, required: false
  private _dir = new DomainOsNvRamSourceDirOutputReference(this, "dir");
  public get dir() {
    return this._dir;
  }
  public putDir(value: DomainOsNvRamSourceDir) {
    this._dir.internalValue = value;
  }
  public resetDir() {
    this._dir.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dirInput() {
    return this._dir.internalValue;
  }

  // encryption - computed: false, optional: true, required: false
  private _encryption = new DomainOsNvRamSourceEncryptionOutputReference(this, "encryption");
  public get encryption() {
    return this._encryption;
  }
  public putEncryption(value: DomainOsNvRamSourceEncryption) {
    this._encryption.internalValue = value;
  }
  public resetEncryption() {
    this._encryption.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get encryptionInput() {
    return this._encryption.internalValue;
  }

  // file - computed: false, optional: true, required: false
  private _file = new DomainOsNvRamSourceFileOutputReference(this, "file");
  public get file() {
    return this._file;
  }
  public putFile(value: DomainOsNvRamSourceFile) {
    this._file.internalValue = value;
  }
  public resetFile() {
    this._file.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file.internalValue;
  }

  // index - computed: false, optional: true, required: false
  private _index?: number; 
  public get index() {
    return this.getNumberAttribute('index');
  }
  public set index(value: number) {
    this._index = value;
  }
  public resetIndex() {
    this._index = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get indexInput() {
    return this._index;
  }

  // network - computed: false, optional: true, required: false
  private _network = new DomainOsNvRamSourceNetworkOutputReference(this, "network");
  public get network() {
    return this._network;
  }
  public putNetwork(value: DomainOsNvRamSourceNetwork) {
    this._network.internalValue = value;
  }
  public resetNetwork() {
    this._network.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkInput() {
    return this._network.internalValue;
  }

  // nvme - computed: false, optional: true, required: false
  private _nvme = new DomainOsNvRamSourceNvmeOutputReference(this, "nvme");
  public get nvme() {
    return this._nvme;
  }
  public putNvme(value: DomainOsNvRamSourceNvme) {
    this._nvme.internalValue = value;
  }
  public resetNvme() {
    this._nvme.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nvmeInput() {
    return this._nvme.internalValue;
  }

  // readahead - computed: false, optional: true, required: false
  private _readahead = new DomainOsNvRamSourceReadaheadOutputReference(this, "readahead");
  public get readahead() {
    return this._readahead;
  }
  public putReadahead(value: DomainOsNvRamSourceReadahead) {
    this._readahead.internalValue = value;
  }
  public resetReadahead() {
    this._readahead.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readaheadInput() {
    return this._readahead.internalValue;
  }

  // reservations - computed: false, optional: true, required: false
  private _reservations = new DomainOsNvRamSourceReservationsOutputReference(this, "reservations");
  public get reservations() {
    return this._reservations;
  }
  public putReservations(value: DomainOsNvRamSourceReservations) {
    this._reservations.internalValue = value;
  }
  public resetReservations() {
    this._reservations.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reservationsInput() {
    return this._reservations.internalValue;
  }

  // slices - computed: false, optional: true, required: false
  private _slices = new DomainOsNvRamSourceSlicesOutputReference(this, "slices");
  public get slices() {
    return this._slices;
  }
  public putSlices(value: DomainOsNvRamSourceSlices) {
    this._slices.internalValue = value;
  }
  public resetSlices() {
    this._slices.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get slicesInput() {
    return this._slices.internalValue;
  }

  // ssl - computed: false, optional: true, required: false
  private _ssl = new DomainOsNvRamSourceSslOutputReference(this, "ssl");
  public get ssl() {
    return this._ssl;
  }
  public putSsl(value: DomainOsNvRamSourceSsl) {
    this._ssl.internalValue = value;
  }
  public resetSsl() {
    this._ssl.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sslInput() {
    return this._ssl.internalValue;
  }

  // startup_policy - computed: false, optional: true, required: false
  private _startupPolicy?: string; 
  public get startupPolicy() {
    return this.getStringAttribute('startup_policy');
  }
  public set startupPolicy(value: string) {
    this._startupPolicy = value;
  }
  public resetStartupPolicy() {
    this._startupPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get startupPolicyInput() {
    return this._startupPolicy;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout = new DomainOsNvRamSourceTimeoutOutputReference(this, "timeout");
  public get timeout() {
    return this._timeout;
  }
  public putTimeout(value: DomainOsNvRamSourceTimeout) {
    this._timeout.internalValue = value;
  }
  public resetTimeout() {
    this._timeout.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout.internalValue;
  }

  // vhost_user - computed: false, optional: true, required: false
  private _vhostUser = new DomainOsNvRamSourceVhostUserOutputReference(this, "vhost_user");
  public get vhostUser() {
    return this._vhostUser;
  }
  public putVhostUser(value: DomainOsNvRamSourceVhostUser) {
    this._vhostUser.internalValue = value;
  }
  public resetVhostUser() {
    this._vhostUser.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vhostUserInput() {
    return this._vhostUser.internalValue;
  }

  // vhost_vdpa - computed: false, optional: true, required: false
  private _vhostVdpa = new DomainOsNvRamSourceVhostVdpaOutputReference(this, "vhost_vdpa");
  public get vhostVdpa() {
    return this._vhostVdpa;
  }
  public putVhostVdpa(value: DomainOsNvRamSourceVhostVdpa) {
    this._vhostVdpa.internalValue = value;
  }
  public resetVhostVdpa() {
    this._vhostVdpa.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vhostVdpaInput() {
    return this._vhostVdpa.internalValue;
  }

  // volume - computed: false, optional: true, required: false
  private _volume = new DomainOsNvRamSourceVolumeOutputReference(this, "volume");
  public get volume() {
    return this._volume;
  }
  public putVolume(value: DomainOsNvRamSourceVolume) {
    this._volume.internalValue = value;
  }
  public resetVolume() {
    this._volume.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get volumeInput() {
    return this._volume.internalValue;
  }
}
export interface DomainOsNvRam {
  /**
  * Sets the on-disk format of the NVRAM file backing the guest firmware state; the value is user-provided (for example, matching the firmwares expected format).
  * 
  * See: <https://libvirt.org/formatdomain.html#bios-bootloader>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#format Domain#format}
  */
  readonly format?: string;
  /**
  * Sets the path or identifier of the NVRAM storage used by the guest firmware to persist UEFI/firmware variables.
  * 
  * See: <https://libvirt.org/formatdomain.html#bios-bootloader>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#nv_ram Domain#nv_ram}
  */
  readonly nvRam: string;
  /**
  * Defines the data source for the mirror backing store, such as a block device or file path.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#source Domain#source}
  */
  readonly source?: DomainOsNvRamSource;
  /**
  * Sets the path or volume name of the NVRAM template image from which the guests NVRAM is initially created; the value is user-provided (for example, pointing to an OVMF_VARS template).
  * 
  * See: <https://libvirt.org/formatdomain.html#operating-system-booting>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#template Domain#template}
  */
  readonly template?: string;
  /**
  * Sets the storage format of the NVRAM template (for example, raw or qcow2), controlling how the hypervisor interprets the template backing store.
  * 
  * See: <https://libvirt.org/formatdomain.html#operating-system-booting>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#template_format Domain#template_format}
  */
  readonly templateFormat?: string;
}

export function domainOsNvRamToTerraform(struct?: DomainOsNvRam | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    format: cdktf.stringToTerraform(struct!.format),
    nv_ram: cdktf.stringToTerraform(struct!.nvRam),
    source: domainOsNvRamSourceToTerraform(struct!.source),
    template: cdktf.stringToTerraform(struct!.template),
    template_format: cdktf.stringToTerraform(struct!.templateFormat),
  }
}


export function domainOsNvRamToHclTerraform(struct?: DomainOsNvRam | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    nv_ram: {
      value: cdktf.stringToHclTerraform(struct!.nvRam),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    source: {
      value: domainOsNvRamSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRamSource",
    },
    template: {
      value: cdktf.stringToHclTerraform(struct!.template),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    template_format: {
      value: cdktf.stringToHclTerraform(struct!.templateFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsNvRamOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsNvRam | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._nvRam !== undefined) {
      hasAnyValues = true;
      internalValueResult.nvRam = this._nvRam;
    }
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    if (this._template !== undefined) {
      hasAnyValues = true;
      internalValueResult.template = this._template;
    }
    if (this._templateFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.templateFormat = this._templateFormat;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsNvRam | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._format = undefined;
      this._nvRam = undefined;
      this._source.internalValue = undefined;
      this._template = undefined;
      this._templateFormat = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._format = value.format;
      this._nvRam = value.nvRam;
      this._source.internalValue = value.source;
      this._template = value.template;
      this._templateFormat = value.templateFormat;
    }
  }

  // format - computed: false, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // nv_ram - computed: false, optional: false, required: true
  private _nvRam?: string; 
  public get nvRam() {
    return this.getStringAttribute('nv_ram');
  }
  public set nvRam(value: string) {
    this._nvRam = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nvRamInput() {
    return this._nvRam;
  }

  // source - computed: false, optional: true, required: false
  private _source = new DomainOsNvRamSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: DomainOsNvRamSource) {
    this._source.internalValue = value;
  }
  public resetSource() {
    this._source.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }

  // template - computed: false, optional: true, required: false
  private _template?: string; 
  public get template() {
    return this.getStringAttribute('template');
  }
  public set template(value: string) {
    this._template = value;
  }
  public resetTemplate() {
    this._template = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get templateInput() {
    return this._template;
  }

  // template_format - computed: false, optional: true, required: false
  private _templateFormat?: string; 
  public get templateFormat() {
    return this.getStringAttribute('template_format');
  }
  public set templateFormat(value: string) {
    this._templateFormat = value;
  }
  public resetTemplateFormat() {
    this._templateFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get templateFormatInput() {
    return this._templateFormat;
  }
}
export interface DomainOsSmBios {
  /**
  * Sets the SMBIOS mode, controlling the source of SMBIOS information presented to the guest; valid values are driver-specific (commonly host, sysinfo, emulate, or none) and must follow libvirts smbios mode semantics.
  * 
  * See: <https://libvirt.org/formatdomain.html#operating-system-booting>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode: string;
}

export function domainOsSmBiosToTerraform(struct?: DomainOsSmBios | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
  }
}


export function domainOsSmBiosToHclTerraform(struct?: DomainOsSmBios | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsSmBiosOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOsSmBios | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOsSmBios | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
    }
  }

  // mode - computed: false, optional: false, required: true
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }
}
export interface DomainOs {
  /**
  * Enables configuration of additional ACPI tables presented to the guest firmware/OS via nested table definitions. The element itself has no attributes; behavior is controlled by its child tables.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#acpi Domain#acpi}
  */
  readonly acpi?: DomainOsAcpi;
  /**
  * Configures BIOS-related boot behavior for fully virtualized guests, such as reboot timeout and use of serial console for BIOS messages. All child attributes are optional.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bios Domain#bios}
  */
  readonly bios?: DomainOsBios;
  /**
  * Specifies an ordered list of devices the firmware should try when booting the guest OS. Multiple entries are allowed to define a boot priority list.
  * 
  * See: <https://libvirt.org/formatdomain.html#bios-bootloader>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#boot_devices Domain#boot_devices}
  */
  readonly bootDevices?: DomainOsBootDevices[] | cdktf.IResolvable;
  /**
  * Enables or configures the firmware boot menu shown before booting the OS, including optional timeout. Presence alone does not enable it; see enable/timeout attributes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#boot_menu Domain#boot_menu}
  */
  readonly bootMenu?: DomainOsBootMenu;
  /**
  * Provides the kernel command line arguments passed to the guest when using direct kernel boot; the value is a free-form string. Example: "console=ttyS0 root=/dev/vda1".
  * 
  * See: <https://libvirt.org/formatdomain.html#direct-kernel-boot>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#cmdline Domain#cmdline}
  */
  readonly cmdline?: string;
  /**
  * Sets the host path to a Device Tree Blob passed to the guest kernel during direct kernel boot on architectures that use DTBs; the value is user-provided. Example: "/var/lib/libvirt/images/guest.dtb".
  * 
  * See: <https://libvirt.org/formatdomain.html#direct-kernel-boot>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dtb Domain#dtb}
  */
  readonly dtb?: string;
  /**
  * Selects the guest firmware type or boot mode via a string value (for example "efi", "bios", or other driver-dependent identifiers); the value is user-provided and must be supported by the hypervisor/host. If unset, the default firmware is used.
  * 
  * See: <https://libvirt.org/formatdomain.html#operating-system-booting>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#firmware Domain#firmware}
  */
  readonly firmware?: string;
  /**
  * Provides structured configuration for the firmware image when using pflash/NVRAM or other non-default firmware setups, such as specifying a particular firmware file and NVRAM store; contents and attributes are user-provided and driver-specific. Use this when finer-grained firmware selection is needed beyond the simple firmware attribute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#firmware_info Domain#firmware_info}
  */
  readonly firmwareInfo?: DomainOsFirmwareInfo;
  /**
  * Sets the path to the init binary inside a container-based guest, used instead of a kernel or boot image when booting container domains.
  * 
  * See: <https://libvirt.org/formatdomain.html#container-boot>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#init Domain#init}
  */
  readonly init?: string;
  /**
  * Provides additional command-line arguments to pass to the init binary configured by domain.os.init; multiple values map to multiple arguments in order (for example ["--foreground","--config=/cfg"]).
  * 
  * See: <https://libvirt.org/formatdomain.html#container-boot>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#init_args Domain#init_args}
  */
  readonly initArgs?: string[];
  /**
  * Sets the working directory from which the container init binary is started.
  * 
  * See: <https://libvirt.org/formatdomain.html#container-boot>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#init_dir Domain#init_dir}
  */
  readonly initDir?: string;
  /**
  * Defines one environment variable to export for the container init process; multiple blocks can be used to define multiple variables.
  * 
  * See: <https://libvirt.org/formatdomain.html#container-boot>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#init_env Domain#init_env}
  */
  readonly initEnv?: DomainOsInitEnv[] | cdktf.IResolvable;
  /**
  * Sets the numeric group ID or group name that the container init process runs as.
  * 
  * See: <https://libvirt.org/formatdomain.html#container-boot>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#init_group Domain#init_group}
  */
  readonly initGroup?: string;
  /**
  * Sets the numeric user ID or user name that the container init process runs as.
  * 
  * See: <https://libvirt.org/formatdomain.html#container-boot>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#init_user Domain#init_user}
  */
  readonly initUser?: string;
  /**
  * Specifies the path on the host to an initrd image used when directly booting a kernel for the guest.
  * 
  * See: <https://libvirt.org/formatdomain.html#direct-kernel-boot>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#initrd Domain#initrd}
  */
  readonly initrd?: string;
  /**
  * Specifies the path on the host to a kernel image used for direct kernel boot of the guest.
  * 
  * See: <https://libvirt.org/formatdomain.html#direct-kernel-boot>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#kernel Domain#kernel}
  */
  readonly kernel?: string;
  /**
  * Sets the path or identifier of the firmware/BIOS/EFI loader image used to boot the guest (for example an OVMF or BIOS binary).
  * 
  * See: <https://libvirt.org/formatdomain.html#bios-bootloader>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#loader Domain#loader}
  */
  readonly loader?: string;
  /**
  * Sets the loader image format (for example "raw" or "qcow2") corresponding to the loader; value is user-provided but must be supported by the hypervisor/firmware.
  * 
  * See: <https://libvirt.org/formatdomain.html#bios-bootloader>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#loader_format Domain#loader_format}
  */
  readonly loaderFormat?: string;
  /**
  * Controls whether the firmware loader image is opened read-only, typically using a "yes"/"no" style flag as expected by libvirt/QEMU.
  * 
  * See: <https://libvirt.org/formatdomain.html#bios-bootloader>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#loader_readonly Domain#loader_readonly}
  */
  readonly loaderReadonly?: string;
  /**
  * Enables or disables secure boot support for the configured firmware loader, usually via a "yes"/"no" style flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#bios-bootloader>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#loader_secure Domain#loader_secure}
  */
  readonly loaderSecure?: string;
  /**
  * Controls whether the firmware loader operates in stateless mode (firmware state not persisted), typically configured as a "yes"/"no" style flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#bios-bootloader>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#loader_stateless Domain#loader_stateless}
  */
  readonly loaderStateless?: string;
  /**
  * Specifies the loader type, such as "pflash" for UEFI flash-based firmware or "rom" for traditional BIOS, with supported values depending on the hypervisor/architecture.
  * 
  * See: <https://libvirt.org/formatdomain.html#bios-bootloader>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#loader_type Domain#loader_type}
  */
  readonly loaderType?: string;
  /**
  * Sets the path for the guest NVRAM/UEFI variable store file associated with the firmware loader, allowing persistence of firmware settings across reboots.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#nv_ram Domain#nv_ram}
  */
  readonly nvRam?: DomainOsNvRam;
  /**
  * Provides the path to a UEFI shim binary used in secure-boot chains, typically sitting between firmware and the OS loader; the value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#direct-kernel-boot>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#shim Domain#shim}
  */
  readonly shim?: string;
  /**
  * Enables configuration of SMBIOS-related behavior for the guest firmware, such as whether to use host, guest-defined, or sysinfo-based SMBIOS data.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sm_bios Domain#sm_bios}
  */
  readonly smBios?: DomainOsSmBios;
  /**
  * Sets the guest OS type string (for example, hvm or exe), indicating the virtualization style or booting method expected by the hypervisor.
  * 
  * See: <https://libvirt.org/formatdomain.html#operating-system-booting>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type?: string;
  /**
  * Sets the architecture for the guest OS type (for example, x86_64 or i686) via the arch attribute, influencing the machine type, CPU model, and firmware choice.
  * 
  * See: <https://libvirt.org/formatdomain.html#operating-system-booting>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type_arch Domain#type_arch}
  */
  readonly typeArch?: string;
  /**
  * Sets the machine type for the guest OS type (for example, pc-q35-2.10 or pc-i440fx-7.2), selecting the chipset and board model used by the hypervisor.
  * 
  * See: <https://libvirt.org/formatdomain.html#operating-system-booting>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type_machine Domain#type_machine}
  */
  readonly typeMachine?: string;
}

export function domainOsToTerraform(struct?: DomainOs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    acpi: domainOsAcpiToTerraform(struct!.acpi),
    bios: domainOsBiosToTerraform(struct!.bios),
    boot_devices: cdktf.listMapper(domainOsBootDevicesToTerraform, false)(struct!.bootDevices),
    boot_menu: domainOsBootMenuToTerraform(struct!.bootMenu),
    cmdline: cdktf.stringToTerraform(struct!.cmdline),
    dtb: cdktf.stringToTerraform(struct!.dtb),
    firmware: cdktf.stringToTerraform(struct!.firmware),
    firmware_info: domainOsFirmwareInfoToTerraform(struct!.firmwareInfo),
    init: cdktf.stringToTerraform(struct!.init),
    init_args: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.initArgs),
    init_dir: cdktf.stringToTerraform(struct!.initDir),
    init_env: cdktf.listMapper(domainOsInitEnvToTerraform, false)(struct!.initEnv),
    init_group: cdktf.stringToTerraform(struct!.initGroup),
    init_user: cdktf.stringToTerraform(struct!.initUser),
    initrd: cdktf.stringToTerraform(struct!.initrd),
    kernel: cdktf.stringToTerraform(struct!.kernel),
    loader: cdktf.stringToTerraform(struct!.loader),
    loader_format: cdktf.stringToTerraform(struct!.loaderFormat),
    loader_readonly: cdktf.stringToTerraform(struct!.loaderReadonly),
    loader_secure: cdktf.stringToTerraform(struct!.loaderSecure),
    loader_stateless: cdktf.stringToTerraform(struct!.loaderStateless),
    loader_type: cdktf.stringToTerraform(struct!.loaderType),
    nv_ram: domainOsNvRamToTerraform(struct!.nvRam),
    shim: cdktf.stringToTerraform(struct!.shim),
    sm_bios: domainOsSmBiosToTerraform(struct!.smBios),
    type: cdktf.stringToTerraform(struct!.type),
    type_arch: cdktf.stringToTerraform(struct!.typeArch),
    type_machine: cdktf.stringToTerraform(struct!.typeMachine),
  }
}


export function domainOsToHclTerraform(struct?: DomainOs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    acpi: {
      value: domainOsAcpiToHclTerraform(struct!.acpi),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsAcpi",
    },
    bios: {
      value: domainOsBiosToHclTerraform(struct!.bios),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsBios",
    },
    boot_devices: {
      value: cdktf.listMapperHcl(domainOsBootDevicesToHclTerraform, false)(struct!.bootDevices),
      isBlock: true,
      type: "list",
      storageClassType: "DomainOsBootDevicesList",
    },
    boot_menu: {
      value: domainOsBootMenuToHclTerraform(struct!.bootMenu),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsBootMenu",
    },
    cmdline: {
      value: cdktf.stringToHclTerraform(struct!.cmdline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dtb: {
      value: cdktf.stringToHclTerraform(struct!.dtb),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    firmware: {
      value: cdktf.stringToHclTerraform(struct!.firmware),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    firmware_info: {
      value: domainOsFirmwareInfoToHclTerraform(struct!.firmwareInfo),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsFirmwareInfo",
    },
    init: {
      value: cdktf.stringToHclTerraform(struct!.init),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    init_args: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.initArgs),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    init_dir: {
      value: cdktf.stringToHclTerraform(struct!.initDir),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    init_env: {
      value: cdktf.listMapperHcl(domainOsInitEnvToHclTerraform, false)(struct!.initEnv),
      isBlock: true,
      type: "list",
      storageClassType: "DomainOsInitEnvList",
    },
    init_group: {
      value: cdktf.stringToHclTerraform(struct!.initGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    init_user: {
      value: cdktf.stringToHclTerraform(struct!.initUser),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    initrd: {
      value: cdktf.stringToHclTerraform(struct!.initrd),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kernel: {
      value: cdktf.stringToHclTerraform(struct!.kernel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    loader: {
      value: cdktf.stringToHclTerraform(struct!.loader),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    loader_format: {
      value: cdktf.stringToHclTerraform(struct!.loaderFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    loader_readonly: {
      value: cdktf.stringToHclTerraform(struct!.loaderReadonly),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    loader_secure: {
      value: cdktf.stringToHclTerraform(struct!.loaderSecure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    loader_stateless: {
      value: cdktf.stringToHclTerraform(struct!.loaderStateless),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    loader_type: {
      value: cdktf.stringToHclTerraform(struct!.loaderType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    nv_ram: {
      value: domainOsNvRamToHclTerraform(struct!.nvRam),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsNvRam",
    },
    shim: {
      value: cdktf.stringToHclTerraform(struct!.shim),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sm_bios: {
      value: domainOsSmBiosToHclTerraform(struct!.smBios),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainOsSmBios",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type_arch: {
      value: cdktf.stringToHclTerraform(struct!.typeArch),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type_machine: {
      value: cdktf.stringToHclTerraform(struct!.typeMachine),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainOsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainOs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._acpi?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.acpi = this._acpi?.internalValue;
    }
    if (this._bios?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bios = this._bios?.internalValue;
    }
    if (this._bootDevices?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bootDevices = this._bootDevices?.internalValue;
    }
    if (this._bootMenu?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bootMenu = this._bootMenu?.internalValue;
    }
    if (this._cmdline !== undefined) {
      hasAnyValues = true;
      internalValueResult.cmdline = this._cmdline;
    }
    if (this._dtb !== undefined) {
      hasAnyValues = true;
      internalValueResult.dtb = this._dtb;
    }
    if (this._firmware !== undefined) {
      hasAnyValues = true;
      internalValueResult.firmware = this._firmware;
    }
    if (this._firmwareInfo?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.firmwareInfo = this._firmwareInfo?.internalValue;
    }
    if (this._init !== undefined) {
      hasAnyValues = true;
      internalValueResult.init = this._init;
    }
    if (this._initArgs !== undefined) {
      hasAnyValues = true;
      internalValueResult.initArgs = this._initArgs;
    }
    if (this._initDir !== undefined) {
      hasAnyValues = true;
      internalValueResult.initDir = this._initDir;
    }
    if (this._initEnv?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.initEnv = this._initEnv?.internalValue;
    }
    if (this._initGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.initGroup = this._initGroup;
    }
    if (this._initUser !== undefined) {
      hasAnyValues = true;
      internalValueResult.initUser = this._initUser;
    }
    if (this._initrd !== undefined) {
      hasAnyValues = true;
      internalValueResult.initrd = this._initrd;
    }
    if (this._kernel !== undefined) {
      hasAnyValues = true;
      internalValueResult.kernel = this._kernel;
    }
    if (this._loader !== undefined) {
      hasAnyValues = true;
      internalValueResult.loader = this._loader;
    }
    if (this._loaderFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.loaderFormat = this._loaderFormat;
    }
    if (this._loaderReadonly !== undefined) {
      hasAnyValues = true;
      internalValueResult.loaderReadonly = this._loaderReadonly;
    }
    if (this._loaderSecure !== undefined) {
      hasAnyValues = true;
      internalValueResult.loaderSecure = this._loaderSecure;
    }
    if (this._loaderStateless !== undefined) {
      hasAnyValues = true;
      internalValueResult.loaderStateless = this._loaderStateless;
    }
    if (this._loaderType !== undefined) {
      hasAnyValues = true;
      internalValueResult.loaderType = this._loaderType;
    }
    if (this._nvRam?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nvRam = this._nvRam?.internalValue;
    }
    if (this._shim !== undefined) {
      hasAnyValues = true;
      internalValueResult.shim = this._shim;
    }
    if (this._smBios?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.smBios = this._smBios?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._typeArch !== undefined) {
      hasAnyValues = true;
      internalValueResult.typeArch = this._typeArch;
    }
    if (this._typeMachine !== undefined) {
      hasAnyValues = true;
      internalValueResult.typeMachine = this._typeMachine;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainOs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._acpi.internalValue = undefined;
      this._bios.internalValue = undefined;
      this._bootDevices.internalValue = undefined;
      this._bootMenu.internalValue = undefined;
      this._cmdline = undefined;
      this._dtb = undefined;
      this._firmware = undefined;
      this._firmwareInfo.internalValue = undefined;
      this._init = undefined;
      this._initArgs = undefined;
      this._initDir = undefined;
      this._initEnv.internalValue = undefined;
      this._initGroup = undefined;
      this._initUser = undefined;
      this._initrd = undefined;
      this._kernel = undefined;
      this._loader = undefined;
      this._loaderFormat = undefined;
      this._loaderReadonly = undefined;
      this._loaderSecure = undefined;
      this._loaderStateless = undefined;
      this._loaderType = undefined;
      this._nvRam.internalValue = undefined;
      this._shim = undefined;
      this._smBios.internalValue = undefined;
      this._type = undefined;
      this._typeArch = undefined;
      this._typeMachine = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._acpi.internalValue = value.acpi;
      this._bios.internalValue = value.bios;
      this._bootDevices.internalValue = value.bootDevices;
      this._bootMenu.internalValue = value.bootMenu;
      this._cmdline = value.cmdline;
      this._dtb = value.dtb;
      this._firmware = value.firmware;
      this._firmwareInfo.internalValue = value.firmwareInfo;
      this._init = value.init;
      this._initArgs = value.initArgs;
      this._initDir = value.initDir;
      this._initEnv.internalValue = value.initEnv;
      this._initGroup = value.initGroup;
      this._initUser = value.initUser;
      this._initrd = value.initrd;
      this._kernel = value.kernel;
      this._loader = value.loader;
      this._loaderFormat = value.loaderFormat;
      this._loaderReadonly = value.loaderReadonly;
      this._loaderSecure = value.loaderSecure;
      this._loaderStateless = value.loaderStateless;
      this._loaderType = value.loaderType;
      this._nvRam.internalValue = value.nvRam;
      this._shim = value.shim;
      this._smBios.internalValue = value.smBios;
      this._type = value.type;
      this._typeArch = value.typeArch;
      this._typeMachine = value.typeMachine;
    }
  }

  // acpi - computed: false, optional: true, required: false
  private _acpi = new DomainOsAcpiOutputReference(this, "acpi");
  public get acpi() {
    return this._acpi;
  }
  public putAcpi(value: DomainOsAcpi) {
    this._acpi.internalValue = value;
  }
  public resetAcpi() {
    this._acpi.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get acpiInput() {
    return this._acpi.internalValue;
  }

  // bios - computed: false, optional: true, required: false
  private _bios = new DomainOsBiosOutputReference(this, "bios");
  public get bios() {
    return this._bios;
  }
  public putBios(value: DomainOsBios) {
    this._bios.internalValue = value;
  }
  public resetBios() {
    this._bios.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get biosInput() {
    return this._bios.internalValue;
  }

  // boot_devices - computed: false, optional: true, required: false
  private _bootDevices = new DomainOsBootDevicesList(this, "boot_devices", false);
  public get bootDevices() {
    return this._bootDevices;
  }
  public putBootDevices(value: DomainOsBootDevices[] | cdktf.IResolvable) {
    this._bootDevices.internalValue = value;
  }
  public resetBootDevices() {
    this._bootDevices.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bootDevicesInput() {
    return this._bootDevices.internalValue;
  }

  // boot_menu - computed: false, optional: true, required: false
  private _bootMenu = new DomainOsBootMenuOutputReference(this, "boot_menu");
  public get bootMenu() {
    return this._bootMenu;
  }
  public putBootMenu(value: DomainOsBootMenu) {
    this._bootMenu.internalValue = value;
  }
  public resetBootMenu() {
    this._bootMenu.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bootMenuInput() {
    return this._bootMenu.internalValue;
  }

  // cmdline - computed: false, optional: true, required: false
  private _cmdline?: string; 
  public get cmdline() {
    return this.getStringAttribute('cmdline');
  }
  public set cmdline(value: string) {
    this._cmdline = value;
  }
  public resetCmdline() {
    this._cmdline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cmdlineInput() {
    return this._cmdline;
  }

  // dtb - computed: false, optional: true, required: false
  private _dtb?: string; 
  public get dtb() {
    return this.getStringAttribute('dtb');
  }
  public set dtb(value: string) {
    this._dtb = value;
  }
  public resetDtb() {
    this._dtb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dtbInput() {
    return this._dtb;
  }

  // firmware - computed: false, optional: true, required: false
  private _firmware?: string; 
  public get firmware() {
    return this.getStringAttribute('firmware');
  }
  public set firmware(value: string) {
    this._firmware = value;
  }
  public resetFirmware() {
    this._firmware = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get firmwareInput() {
    return this._firmware;
  }

  // firmware_info - computed: false, optional: true, required: false
  private _firmwareInfo = new DomainOsFirmwareInfoOutputReference(this, "firmware_info");
  public get firmwareInfo() {
    return this._firmwareInfo;
  }
  public putFirmwareInfo(value: DomainOsFirmwareInfo) {
    this._firmwareInfo.internalValue = value;
  }
  public resetFirmwareInfo() {
    this._firmwareInfo.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get firmwareInfoInput() {
    return this._firmwareInfo.internalValue;
  }

  // init - computed: false, optional: true, required: false
  private _init?: string; 
  public get init() {
    return this.getStringAttribute('init');
  }
  public set init(value: string) {
    this._init = value;
  }
  public resetInit() {
    this._init = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initInput() {
    return this._init;
  }

  // init_args - computed: false, optional: true, required: false
  private _initArgs?: string[]; 
  public get initArgs() {
    return this.getListAttribute('init_args');
  }
  public set initArgs(value: string[]) {
    this._initArgs = value;
  }
  public resetInitArgs() {
    this._initArgs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initArgsInput() {
    return this._initArgs;
  }

  // init_dir - computed: false, optional: true, required: false
  private _initDir?: string; 
  public get initDir() {
    return this.getStringAttribute('init_dir');
  }
  public set initDir(value: string) {
    this._initDir = value;
  }
  public resetInitDir() {
    this._initDir = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initDirInput() {
    return this._initDir;
  }

  // init_env - computed: false, optional: true, required: false
  private _initEnv = new DomainOsInitEnvList(this, "init_env", false);
  public get initEnv() {
    return this._initEnv;
  }
  public putInitEnv(value: DomainOsInitEnv[] | cdktf.IResolvable) {
    this._initEnv.internalValue = value;
  }
  public resetInitEnv() {
    this._initEnv.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initEnvInput() {
    return this._initEnv.internalValue;
  }

  // init_group - computed: false, optional: true, required: false
  private _initGroup?: string; 
  public get initGroup() {
    return this.getStringAttribute('init_group');
  }
  public set initGroup(value: string) {
    this._initGroup = value;
  }
  public resetInitGroup() {
    this._initGroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initGroupInput() {
    return this._initGroup;
  }

  // init_user - computed: false, optional: true, required: false
  private _initUser?: string; 
  public get initUser() {
    return this.getStringAttribute('init_user');
  }
  public set initUser(value: string) {
    this._initUser = value;
  }
  public resetInitUser() {
    this._initUser = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initUserInput() {
    return this._initUser;
  }

  // initrd - computed: false, optional: true, required: false
  private _initrd?: string; 
  public get initrd() {
    return this.getStringAttribute('initrd');
  }
  public set initrd(value: string) {
    this._initrd = value;
  }
  public resetInitrd() {
    this._initrd = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initrdInput() {
    return this._initrd;
  }

  // kernel - computed: false, optional: true, required: false
  private _kernel?: string; 
  public get kernel() {
    return this.getStringAttribute('kernel');
  }
  public set kernel(value: string) {
    this._kernel = value;
  }
  public resetKernel() {
    this._kernel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kernelInput() {
    return this._kernel;
  }

  // loader - computed: false, optional: true, required: false
  private _loader?: string; 
  public get loader() {
    return this.getStringAttribute('loader');
  }
  public set loader(value: string) {
    this._loader = value;
  }
  public resetLoader() {
    this._loader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loaderInput() {
    return this._loader;
  }

  // loader_format - computed: false, optional: true, required: false
  private _loaderFormat?: string; 
  public get loaderFormat() {
    return this.getStringAttribute('loader_format');
  }
  public set loaderFormat(value: string) {
    this._loaderFormat = value;
  }
  public resetLoaderFormat() {
    this._loaderFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loaderFormatInput() {
    return this._loaderFormat;
  }

  // loader_readonly - computed: false, optional: true, required: false
  private _loaderReadonly?: string; 
  public get loaderReadonly() {
    return this.getStringAttribute('loader_readonly');
  }
  public set loaderReadonly(value: string) {
    this._loaderReadonly = value;
  }
  public resetLoaderReadonly() {
    this._loaderReadonly = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loaderReadonlyInput() {
    return this._loaderReadonly;
  }

  // loader_secure - computed: false, optional: true, required: false
  private _loaderSecure?: string; 
  public get loaderSecure() {
    return this.getStringAttribute('loader_secure');
  }
  public set loaderSecure(value: string) {
    this._loaderSecure = value;
  }
  public resetLoaderSecure() {
    this._loaderSecure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loaderSecureInput() {
    return this._loaderSecure;
  }

  // loader_stateless - computed: false, optional: true, required: false
  private _loaderStateless?: string; 
  public get loaderStateless() {
    return this.getStringAttribute('loader_stateless');
  }
  public set loaderStateless(value: string) {
    this._loaderStateless = value;
  }
  public resetLoaderStateless() {
    this._loaderStateless = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loaderStatelessInput() {
    return this._loaderStateless;
  }

  // loader_type - computed: false, optional: true, required: false
  private _loaderType?: string; 
  public get loaderType() {
    return this.getStringAttribute('loader_type');
  }
  public set loaderType(value: string) {
    this._loaderType = value;
  }
  public resetLoaderType() {
    this._loaderType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loaderTypeInput() {
    return this._loaderType;
  }

  // nv_ram - computed: false, optional: true, required: false
  private _nvRam = new DomainOsNvRamOutputReference(this, "nv_ram");
  public get nvRam() {
    return this._nvRam;
  }
  public putNvRam(value: DomainOsNvRam) {
    this._nvRam.internalValue = value;
  }
  public resetNvRam() {
    this._nvRam.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nvRamInput() {
    return this._nvRam.internalValue;
  }

  // shim - computed: false, optional: true, required: false
  private _shim?: string; 
  public get shim() {
    return this.getStringAttribute('shim');
  }
  public set shim(value: string) {
    this._shim = value;
  }
  public resetShim() {
    this._shim = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shimInput() {
    return this._shim;
  }

  // sm_bios - computed: false, optional: true, required: false
  private _smBios = new DomainOsSmBiosOutputReference(this, "sm_bios");
  public get smBios() {
    return this._smBios;
  }
  public putSmBios(value: DomainOsSmBios) {
    this._smBios.internalValue = value;
  }
  public resetSmBios() {
    this._smBios.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get smBiosInput() {
    return this._smBios.internalValue;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // type_arch - computed: false, optional: true, required: false
  private _typeArch?: string; 
  public get typeArch() {
    return this.getStringAttribute('type_arch');
  }
  public set typeArch(value: string) {
    this._typeArch = value;
  }
  public resetTypeArch() {
    this._typeArch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeArchInput() {
    return this._typeArch;
  }

  // type_machine - computed: false, optional: true, required: false
  private _typeMachine?: string; 
  public get typeMachine() {
    return this.getStringAttribute('type_machine');
  }
  public set typeMachine(value: string) {
    this._typeMachine = value;
  }
  public resetTypeMachine() {
    this._typeMachine = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeMachineInput() {
    return this._typeMachine;
  }
}
export interface DomainPerfEvents {
  /**
  * Controls whether the given perf event is active; valid values are yes or no, enabling or disabling collection of that event.
  * 
  * See: <https://libvirt.org/formatdomain.html#performance-monitoring-events>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enabled Domain#enabled}
  */
  readonly enabled: string;
  /**
  * Sets the name of the performance event to monitor, which must be one of the libvirt-supported perf event identifiers (for example, perf.cpu_cycles, perf.instructions).
  * 
  * See: <https://libvirt.org/formatdomain.html#performance-monitoring-events>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
}

export function domainPerfEventsToTerraform(struct?: DomainPerfEvents | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.stringToTerraform(struct!.enabled),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function domainPerfEventsToHclTerraform(struct?: DomainPerfEvents | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.stringToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainPerfEventsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainPerfEvents | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainPerfEvents | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._name = value.name;
    }
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: string; 
  public get enabled() {
    return this.getStringAttribute('enabled');
  }
  public set enabled(value: string) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class DomainPerfEventsList extends cdktf.ComplexList {
  public internalValue? : DomainPerfEvents[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainPerfEventsOutputReference {
    return new DomainPerfEventsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainPerf {
  /**
  * Defines one or more performance monitoring events to track for the guest, each identified by a name and an enabled flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#performance-monitoring-events>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#events Domain#events}
  */
  readonly events?: DomainPerfEvents[] | cdktf.IResolvable;
}

export function domainPerfToTerraform(struct?: DomainPerf | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    events: cdktf.listMapper(domainPerfEventsToTerraform, false)(struct!.events),
  }
}


export function domainPerfToHclTerraform(struct?: DomainPerf | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    events: {
      value: cdktf.listMapperHcl(domainPerfEventsToHclTerraform, false)(struct!.events),
      isBlock: true,
      type: "list",
      storageClassType: "DomainPerfEventsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainPerfOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainPerf | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._events?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.events = this._events?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainPerf | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._events.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._events.internalValue = value.events;
    }
  }

  // events - computed: false, optional: true, required: false
  private _events = new DomainPerfEventsList(this, "events", false);
  public get events() {
    return this._events;
  }
  public putEvents(value: DomainPerfEvents[] | cdktf.IResolvable) {
    this._events.internalValue = value;
  }
  public resetEvents() {
    this._events.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get eventsInput() {
    return this._events.internalValue;
  }
}
export interface DomainPmSuspendToDisk {
  /**
  * Controls whether suspend-to-disk (S4) is exposed to the guest; valid values are yes or no.
  * 
  * See: <https://libvirt.org/formatdomain.html#power-management>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enabled Domain#enabled}
  */
  readonly enabled: string;
}

export function domainPmSuspendToDiskToTerraform(struct?: DomainPmSuspendToDisk | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.stringToTerraform(struct!.enabled),
  }
}


export function domainPmSuspendToDiskToHclTerraform(struct?: DomainPmSuspendToDisk | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.stringToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainPmSuspendToDiskOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainPmSuspendToDisk | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainPmSuspendToDisk | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
    }
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: string; 
  public get enabled() {
    return this.getStringAttribute('enabled');
  }
  public set enabled(value: string) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }
}
export interface DomainPmSuspendToMem {
  /**
  * Controls whether suspend-to-disk (S4) is exposed to the guest; valid values are yes or no.
  * 
  * See: <https://libvirt.org/formatdomain.html#power-management>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enabled Domain#enabled}
  */
  readonly enabled: string;
}

export function domainPmSuspendToMemToTerraform(struct?: DomainPmSuspendToMem | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.stringToTerraform(struct!.enabled),
  }
}


export function domainPmSuspendToMemToHclTerraform(struct?: DomainPmSuspendToMem | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.stringToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainPmSuspendToMemOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainPmSuspendToMem | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainPmSuspendToMem | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
    }
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: string; 
  public get enabled() {
    return this.getStringAttribute('enabled');
  }
  public set enabled(value: string) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }
}
export interface DomainPm {
  /**
  * Configures whether the guest firmware advertises S4 (suspend-to-disk / hibernate) capability to the guest OS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#suspend_to_disk Domain#suspend_to_disk}
  */
  readonly suspendToDisk?: DomainPmSuspendToDisk;
  /**
  * Configures whether the guest firmware advertises S4 (suspend-to-disk / hibernate) capability to the guest OS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#suspend_to_mem Domain#suspend_to_mem}
  */
  readonly suspendToMem?: DomainPmSuspendToMem;
}

export function domainPmToTerraform(struct?: DomainPm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    suspend_to_disk: domainPmSuspendToDiskToTerraform(struct!.suspendToDisk),
    suspend_to_mem: domainPmSuspendToMemToTerraform(struct!.suspendToMem),
  }
}


export function domainPmToHclTerraform(struct?: DomainPm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    suspend_to_disk: {
      value: domainPmSuspendToDiskToHclTerraform(struct!.suspendToDisk),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainPmSuspendToDisk",
    },
    suspend_to_mem: {
      value: domainPmSuspendToMemToHclTerraform(struct!.suspendToMem),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainPmSuspendToMem",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainPmOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainPm | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._suspendToDisk?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.suspendToDisk = this._suspendToDisk?.internalValue;
    }
    if (this._suspendToMem?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.suspendToMem = this._suspendToMem?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainPm | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._suspendToDisk.internalValue = undefined;
      this._suspendToMem.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._suspendToDisk.internalValue = value.suspendToDisk;
      this._suspendToMem.internalValue = value.suspendToMem;
    }
  }

  // suspend_to_disk - computed: false, optional: true, required: false
  private _suspendToDisk = new DomainPmSuspendToDiskOutputReference(this, "suspend_to_disk");
  public get suspendToDisk() {
    return this._suspendToDisk;
  }
  public putSuspendToDisk(value: DomainPmSuspendToDisk) {
    this._suspendToDisk.internalValue = value;
  }
  public resetSuspendToDisk() {
    this._suspendToDisk.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get suspendToDiskInput() {
    return this._suspendToDisk.internalValue;
  }

  // suspend_to_mem - computed: false, optional: true, required: false
  private _suspendToMem = new DomainPmSuspendToMemOutputReference(this, "suspend_to_mem");
  public get suspendToMem() {
    return this._suspendToMem;
  }
  public putSuspendToMem(value: DomainPmSuspendToMem) {
    this._suspendToMem.internalValue = value;
  }
  public resetSuspendToMem() {
    this._suspendToMem.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get suspendToMemInput() {
    return this._suspendToMem.internalValue;
  }
}
export interface DomainResourceFibreChannel {
  /**
  * Sets the Fibre Channel VMID (appid) used by SAN/NVMe-FC infrastructure for per-VM QoS, access control, and telemetry; the value is user-provided and must match the storage fabrics expected VMID format.
  * 
  * See: <https://libvirt.org/formatdomain.html#fibre-channel-vmid>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#app_id Domain#app_id}
  */
  readonly appId: string;
}

export function domainResourceFibreChannelToTerraform(struct?: DomainResourceFibreChannel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    app_id: cdktf.stringToTerraform(struct!.appId),
  }
}


export function domainResourceFibreChannelToHclTerraform(struct?: DomainResourceFibreChannel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    app_id: {
      value: cdktf.stringToHclTerraform(struct!.appId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainResourceFibreChannelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainResourceFibreChannel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._appId !== undefined) {
      hasAnyValues = true;
      internalValueResult.appId = this._appId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainResourceFibreChannel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._appId = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._appId = value.appId;
    }
  }

  // app_id - computed: false, optional: false, required: true
  private _appId?: string; 
  public get appId() {
    return this.getStringAttribute('app_id');
  }
  public set appId(value: string) {
    this._appId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get appIdInput() {
    return this._appId;
  }
}
export interface DomainResource {
  /**
  * Configures the Fibre Channel VMID (appid) used by FC/NVMe-FC storage fabrics for QoS and telemetry associated with this domain.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#fibre_channel Domain#fibre_channel}
  */
  readonly fibreChannel?: DomainResourceFibreChannel;
  /**
  * Sets the resource partition name/path that the hypervisor should place this domain into for host-level resource accounting or control; the value is user-provided and may be a hierarchical partition identifier (for example, "/machine/qemu/production").
  * 
  * See: <https://libvirt.org/formatdomain.html#resource-partitioning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#partition Domain#partition}
  */
  readonly partition?: string;
}

export function domainResourceToTerraform(struct?: DomainResource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fibre_channel: domainResourceFibreChannelToTerraform(struct!.fibreChannel),
    partition: cdktf.stringToTerraform(struct!.partition),
  }
}


export function domainResourceToHclTerraform(struct?: DomainResource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fibre_channel: {
      value: domainResourceFibreChannelToHclTerraform(struct!.fibreChannel),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainResourceFibreChannel",
    },
    partition: {
      value: cdktf.stringToHclTerraform(struct!.partition),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainResourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainResource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fibreChannel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fibreChannel = this._fibreChannel?.internalValue;
    }
    if (this._partition !== undefined) {
      hasAnyValues = true;
      internalValueResult.partition = this._partition;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainResource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fibreChannel.internalValue = undefined;
      this._partition = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fibreChannel.internalValue = value.fibreChannel;
      this._partition = value.partition;
    }
  }

  // fibre_channel - computed: false, optional: true, required: false
  private _fibreChannel = new DomainResourceFibreChannelOutputReference(this, "fibre_channel");
  public get fibreChannel() {
    return this._fibreChannel;
  }
  public putFibreChannel(value: DomainResourceFibreChannel) {
    this._fibreChannel.internalValue = value;
  }
  public resetFibreChannel() {
    this._fibreChannel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fibreChannelInput() {
    return this._fibreChannel.internalValue;
  }

  // partition - computed: false, optional: true, required: false
  private _partition?: string; 
  public get partition() {
    return this.getStringAttribute('partition');
  }
  public set partition(value: string) {
    this._partition = value;
  }
  public resetPartition() {
    this._partition = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get partitionInput() {
    return this._partition;
  }
}
export interface DomainSecLabel {
  /**
  * Sets the base label template that libvirt may use as a starting point when generating dynamic security labels for the domain; the value is user-provided (for example, "system_u:system_r:svirt_t:s0").
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#base_label Domain#base_label}
  */
  readonly baseLabel?: string;
  /**
  * Sets the security label that should be applied to guest image files associated with this domain; the value is user-provided and must be compatible with the selected security model.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#image_label Domain#image_label}
  */
  readonly imageLabel?: string;
  /**
  * Sets the domains own security label (for example SELinux or DAC label) when using static or explicit labeling; the value is user-provided and must be valid for the chosen security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Selects which security driver/model to use for labeling this domain, typically "selinux" or "dac"; other values are driver-specific and must match a security driver enabled on the host.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether libvirt is allowed to change labels on associated resources at start time, using yes/no string values ("yes" to relabel resources automatically, "no" to leave existing labels unchanged).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
  /**
  * Sets the seclabel mode, typically "dynamic", "static", or "none", which determines whether libvirt auto-generates labels, uses explicitly provided labels, or disables security labeling for this domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type?: string;
}

export function domainSecLabelToTerraform(struct?: DomainSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    base_label: cdktf.stringToTerraform(struct!.baseLabel),
    image_label: cdktf.stringToTerraform(struct!.imageLabel),
    label: cdktf.stringToTerraform(struct!.label),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function domainSecLabelToHclTerraform(struct?: DomainSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    base_label: {
      value: cdktf.stringToHclTerraform(struct!.baseLabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    image_label: {
      value: cdktf.stringToHclTerraform(struct!.imageLabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._baseLabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.baseLabel = this._baseLabel;
    }
    if (this._imageLabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.imageLabel = this._imageLabel;
    }
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._baseLabel = undefined;
      this._imageLabel = undefined;
      this._label = undefined;
      this._model = undefined;
      this._relabel = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._baseLabel = value.baseLabel;
      this._imageLabel = value.imageLabel;
      this._label = value.label;
      this._model = value.model;
      this._relabel = value.relabel;
      this._type = value.type;
    }
  }

  // base_label - computed: false, optional: true, required: false
  private _baseLabel?: string; 
  public get baseLabel() {
    return this.getStringAttribute('base_label');
  }
  public set baseLabel(value: string) {
    this._baseLabel = value;
  }
  public resetBaseLabel() {
    this._baseLabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get baseLabelInput() {
    return this._baseLabel;
  }

  // image_label - computed: false, optional: true, required: false
  private _imageLabel?: string; 
  public get imageLabel() {
    return this.getStringAttribute('image_label');
  }
  public set imageLabel(value: string) {
    this._imageLabel = value;
  }
  public resetImageLabel() {
    this._imageLabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageLabelInput() {
    return this._imageLabel;
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}

export class DomainSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainSecLabelOutputReference {
    return new DomainSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainSysInfoFwCfgEntry {
  /**
  * Sets the host file path whose contents should be provided to the guest via this fw_cfg entry instead of an inline value; the path is user-provided and must be readable by the hypervisor.
  * 
  * See: <https://libvirt.org/formatdomain.html#smbios-system-information>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file?: string;
  /**
  * Sets the fw_cfg key name used to identify this entry to the guest/firmware; the string is user-provided and typically follows firmware-expected naming (for example, "opt/org.example/config").
  * 
  * See: <https://libvirt.org/formatdomain.html#smbios-system-information>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
  /**
  * Sets the literal string value for this fw_cfg entry when no file is specified, providing small configuration blobs directly to the guest.
  * 
  * See: <https://libvirt.org/formatdomain.html#smbios-system-information>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#value Domain#value}
  */
  readonly value: string;
}

export function domainSysInfoFwCfgEntryToTerraform(struct?: DomainSysInfoFwCfgEntry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    file: cdktf.stringToTerraform(struct!.file),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function domainSysInfoFwCfgEntryToHclTerraform(struct?: DomainSysInfoFwCfgEntry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    file: {
      value: cdktf.stringToHclTerraform(struct!.file),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainSysInfoFwCfgEntryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainSysInfoFwCfgEntry | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._file !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainSysInfoFwCfgEntry | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._file = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._file = value.file;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // file - computed: false, optional: true, required: false
  private _file?: string; 
  public get file() {
    return this.getStringAttribute('file');
  }
  public set file(value: string) {
    this._file = value;
  }
  public resetFile() {
    this._file = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DomainSysInfoFwCfgEntryList extends cdktf.ComplexList {
  public internalValue? : DomainSysInfoFwCfgEntry[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainSysInfoFwCfgEntryOutputReference {
    return new DomainSysInfoFwCfgEntryOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainSysInfoFwCfg {
  /**
  * Defines a single fw_cfg item to expose to the guest firmware, either as an inlined value or as data loaded from a file.
  * 
  * See: <https://libvirt.org/formatdomain.html#smbios-system-information>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#entry Domain#entry}
  */
  readonly entry?: DomainSysInfoFwCfgEntry[] | cdktf.IResolvable;
}

export function domainSysInfoFwCfgToTerraform(struct?: DomainSysInfoFwCfg | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    entry: cdktf.listMapper(domainSysInfoFwCfgEntryToTerraform, false)(struct!.entry),
  }
}


export function domainSysInfoFwCfgToHclTerraform(struct?: DomainSysInfoFwCfg | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    entry: {
      value: cdktf.listMapperHcl(domainSysInfoFwCfgEntryToHclTerraform, false)(struct!.entry),
      isBlock: true,
      type: "list",
      storageClassType: "DomainSysInfoFwCfgEntryList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainSysInfoFwCfgOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainSysInfoFwCfg | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._entry?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.entry = this._entry?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainSysInfoFwCfg | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._entry.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._entry.internalValue = value.entry;
    }
  }

  // entry - computed: false, optional: true, required: false
  private _entry = new DomainSysInfoFwCfgEntryList(this, "entry", false);
  public get entry() {
    return this._entry;
  }
  public putEntry(value: DomainSysInfoFwCfgEntry[] | cdktf.IResolvable) {
    this._entry.internalValue = value;
  }
  public resetEntry() {
    this._entry.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get entryInput() {
    return this._entry.internalValue;
  }
}
export interface DomainSysInfoSmbiosBaseBoardEntry {
  /**
  * Sets the host file path whose contents should be provided to the guest via this fw_cfg entry instead of an inline value; the path is user-provided and must be readable by the hypervisor.
  * 
  * See: <https://libvirt.org/formatdomain.html#smbios-system-information>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file?: string;
  /**
  * Sets the fw_cfg key name used to identify this entry to the guest/firmware; the string is user-provided and typically follows firmware-expected naming (for example, "opt/org.example/config").
  * 
  * See: <https://libvirt.org/formatdomain.html#smbios-system-information>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
  /**
  * Sets the literal string value for this fw_cfg entry when no file is specified, providing small configuration blobs directly to the guest.
  * 
  * See: <https://libvirt.org/formatdomain.html#smbios-system-information>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#value Domain#value}
  */
  readonly value: string;
}

export function domainSysInfoSmbiosBaseBoardEntryToTerraform(struct?: DomainSysInfoSmbiosBaseBoardEntry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    file: cdktf.stringToTerraform(struct!.file),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function domainSysInfoSmbiosBaseBoardEntryToHclTerraform(struct?: DomainSysInfoSmbiosBaseBoardEntry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    file: {
      value: cdktf.stringToHclTerraform(struct!.file),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainSysInfoSmbiosBaseBoardEntryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainSysInfoSmbiosBaseBoardEntry | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._file !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainSysInfoSmbiosBaseBoardEntry | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._file = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._file = value.file;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // file - computed: false, optional: true, required: false
  private _file?: string; 
  public get file() {
    return this.getStringAttribute('file');
  }
  public set file(value: string) {
    this._file = value;
  }
  public resetFile() {
    this._file = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DomainSysInfoSmbiosBaseBoardEntryList extends cdktf.ComplexList {
  public internalValue? : DomainSysInfoSmbiosBaseBoardEntry[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainSysInfoSmbiosBaseBoardEntryOutputReference {
    return new DomainSysInfoSmbiosBaseBoardEntryOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainSysInfoSmbiosBaseBoard {
  /**
  * Defines one SMBIOS base board field/value pair (for example, product name or serial) that will be visible to the guest via tools like dmidecode.
  * 
  * See: <https://libvirt.org/formatdomain.html#smbios-system-information>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#entry Domain#entry}
  */
  readonly entry?: DomainSysInfoSmbiosBaseBoardEntry[] | cdktf.IResolvable;
}

export function domainSysInfoSmbiosBaseBoardToTerraform(struct?: DomainSysInfoSmbiosBaseBoard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    entry: cdktf.listMapper(domainSysInfoSmbiosBaseBoardEntryToTerraform, false)(struct!.entry),
  }
}


export function domainSysInfoSmbiosBaseBoardToHclTerraform(struct?: DomainSysInfoSmbiosBaseBoard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    entry: {
      value: cdktf.listMapperHcl(domainSysInfoSmbiosBaseBoardEntryToHclTerraform, false)(struct!.entry),
      isBlock: true,
      type: "list",
      storageClassType: "DomainSysInfoSmbiosBaseBoardEntryList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainSysInfoSmbiosBaseBoardOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainSysInfoSmbiosBaseBoard | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._entry?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.entry = this._entry?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainSysInfoSmbiosBaseBoard | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._entry.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._entry.internalValue = value.entry;
    }
  }

  // entry - computed: false, optional: true, required: false
  private _entry = new DomainSysInfoSmbiosBaseBoardEntryList(this, "entry", false);
  public get entry() {
    return this._entry;
  }
  public putEntry(value: DomainSysInfoSmbiosBaseBoardEntry[] | cdktf.IResolvable) {
    this._entry.internalValue = value;
  }
  public resetEntry() {
    this._entry.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get entryInput() {
    return this._entry.internalValue;
  }
}

export class DomainSysInfoSmbiosBaseBoardList extends cdktf.ComplexList {
  public internalValue? : DomainSysInfoSmbiosBaseBoard[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainSysInfoSmbiosBaseBoardOutputReference {
    return new DomainSysInfoSmbiosBaseBoardOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainSysInfoSmbiosBiosEntry {
  /**
  * Sets the host file path whose contents should be provided to the guest via this fw_cfg entry instead of an inline value; the path is user-provided and must be readable by the hypervisor.
  * 
  * See: <https://libvirt.org/formatdomain.html#smbios-system-information>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file?: string;
  /**
  * Sets the fw_cfg key name used to identify this entry to the guest/firmware; the string is user-provided and typically follows firmware-expected naming (for example, "opt/org.example/config").
  * 
  * See: <https://libvirt.org/formatdomain.html#smbios-system-information>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
  /**
  * Sets the literal string value for this fw_cfg entry when no file is specified, providing small configuration blobs directly to the guest.
  * 
  * See: <https://libvirt.org/formatdomain.html#smbios-system-information>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#value Domain#value}
  */
  readonly value: string;
}

export function domainSysInfoSmbiosBiosEntryToTerraform(struct?: DomainSysInfoSmbiosBiosEntry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    file: cdktf.stringToTerraform(struct!.file),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function domainSysInfoSmbiosBiosEntryToHclTerraform(struct?: DomainSysInfoSmbiosBiosEntry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    file: {
      value: cdktf.stringToHclTerraform(struct!.file),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainSysInfoSmbiosBiosEntryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainSysInfoSmbiosBiosEntry | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._file !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainSysInfoSmbiosBiosEntry | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._file = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._file = value.file;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // file - computed: false, optional: true, required: false
  private _file?: string; 
  public get file() {
    return this.getStringAttribute('file');
  }
  public set file(value: string) {
    this._file = value;
  }
  public resetFile() {
    this._file = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DomainSysInfoSmbiosBiosEntryList extends cdktf.ComplexList {
  public internalValue? : DomainSysInfoSmbiosBiosEntry[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainSysInfoSmbiosBiosEntryOutputReference {
    return new DomainSysInfoSmbiosBiosEntryOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainSysInfoSmbiosBios {
  /**
  * Defines a single SMBIOS BIOS field override, identified by its required name and either an inline value or a file containing the value.
  * 
  * See: <https://libvirt.org/formatdomain.html#smbios-system-information>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#entry Domain#entry}
  */
  readonly entry?: DomainSysInfoSmbiosBiosEntry[] | cdktf.IResolvable;
}

export function domainSysInfoSmbiosBiosToTerraform(struct?: DomainSysInfoSmbiosBios | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    entry: cdktf.listMapper(domainSysInfoSmbiosBiosEntryToTerraform, false)(struct!.entry),
  }
}


export function domainSysInfoSmbiosBiosToHclTerraform(struct?: DomainSysInfoSmbiosBios | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    entry: {
      value: cdktf.listMapperHcl(domainSysInfoSmbiosBiosEntryToHclTerraform, false)(struct!.entry),
      isBlock: true,
      type: "list",
      storageClassType: "DomainSysInfoSmbiosBiosEntryList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainSysInfoSmbiosBiosOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainSysInfoSmbiosBios | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._entry?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.entry = this._entry?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainSysInfoSmbiosBios | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._entry.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._entry.internalValue = value.entry;
    }
  }

  // entry - computed: false, optional: true, required: false
  private _entry = new DomainSysInfoSmbiosBiosEntryList(this, "entry", false);
  public get entry() {
    return this._entry;
  }
  public putEntry(value: DomainSysInfoSmbiosBiosEntry[] | cdktf.IResolvable) {
    this._entry.internalValue = value;
  }
  public resetEntry() {
    this._entry.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get entryInput() {
    return this._entry.internalValue;
  }
}
export interface DomainSysInfoSmbiosChassisEntry {
  /**
  * Sets the host file path whose contents should be provided to the guest via this fw_cfg entry instead of an inline value; the path is user-provided and must be readable by the hypervisor.
  * 
  * See: <https://libvirt.org/formatdomain.html#smbios-system-information>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file?: string;
  /**
  * Sets the fw_cfg key name used to identify this entry to the guest/firmware; the string is user-provided and typically follows firmware-expected naming (for example, "opt/org.example/config").
  * 
  * See: <https://libvirt.org/formatdomain.html#smbios-system-information>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
  /**
  * Sets the literal string value for this fw_cfg entry when no file is specified, providing small configuration blobs directly to the guest.
  * 
  * See: <https://libvirt.org/formatdomain.html#smbios-system-information>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#value Domain#value}
  */
  readonly value: string;
}

export function domainSysInfoSmbiosChassisEntryToTerraform(struct?: DomainSysInfoSmbiosChassisEntry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    file: cdktf.stringToTerraform(struct!.file),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function domainSysInfoSmbiosChassisEntryToHclTerraform(struct?: DomainSysInfoSmbiosChassisEntry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    file: {
      value: cdktf.stringToHclTerraform(struct!.file),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainSysInfoSmbiosChassisEntryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainSysInfoSmbiosChassisEntry | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._file !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainSysInfoSmbiosChassisEntry | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._file = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._file = value.file;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // file - computed: false, optional: true, required: false
  private _file?: string; 
  public get file() {
    return this.getStringAttribute('file');
  }
  public set file(value: string) {
    this._file = value;
  }
  public resetFile() {
    this._file = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DomainSysInfoSmbiosChassisEntryList extends cdktf.ComplexList {
  public internalValue? : DomainSysInfoSmbiosChassisEntry[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainSysInfoSmbiosChassisEntryOutputReference {
    return new DomainSysInfoSmbiosChassisEntryOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainSysInfoSmbiosChassis {
  /**
  * Defines a single SMBIOS chassis field override, identified by its required name and supplied via an inline value or a file.
  * 
  * See: <https://libvirt.org/formatdomain.html#smbios-system-information>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#entry Domain#entry}
  */
  readonly entry?: DomainSysInfoSmbiosChassisEntry[] | cdktf.IResolvable;
}

export function domainSysInfoSmbiosChassisToTerraform(struct?: DomainSysInfoSmbiosChassis | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    entry: cdktf.listMapper(domainSysInfoSmbiosChassisEntryToTerraform, false)(struct!.entry),
  }
}


export function domainSysInfoSmbiosChassisToHclTerraform(struct?: DomainSysInfoSmbiosChassis | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    entry: {
      value: cdktf.listMapperHcl(domainSysInfoSmbiosChassisEntryToHclTerraform, false)(struct!.entry),
      isBlock: true,
      type: "list",
      storageClassType: "DomainSysInfoSmbiosChassisEntryList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainSysInfoSmbiosChassisOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainSysInfoSmbiosChassis | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._entry?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.entry = this._entry?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainSysInfoSmbiosChassis | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._entry.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._entry.internalValue = value.entry;
    }
  }

  // entry - computed: false, optional: true, required: false
  private _entry = new DomainSysInfoSmbiosChassisEntryList(this, "entry", false);
  public get entry() {
    return this._entry;
  }
  public putEntry(value: DomainSysInfoSmbiosChassisEntry[] | cdktf.IResolvable) {
    this._entry.internalValue = value;
  }
  public resetEntry() {
    this._entry.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get entryInput() {
    return this._entry.internalValue;
  }
}
export interface DomainSysInfoSmbiosMemoryEntry {
  /**
  * Sets the host file path whose contents should be provided to the guest via this fw_cfg entry instead of an inline value; the path is user-provided and must be readable by the hypervisor.
  * 
  * See: <https://libvirt.org/formatdomain.html#smbios-system-information>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file?: string;
  /**
  * Sets the fw_cfg key name used to identify this entry to the guest/firmware; the string is user-provided and typically follows firmware-expected naming (for example, "opt/org.example/config").
  * 
  * See: <https://libvirt.org/formatdomain.html#smbios-system-information>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
  /**
  * Sets the literal string value for this fw_cfg entry when no file is specified, providing small configuration blobs directly to the guest.
  * 
  * See: <https://libvirt.org/formatdomain.html#smbios-system-information>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#value Domain#value}
  */
  readonly value: string;
}

export function domainSysInfoSmbiosMemoryEntryToTerraform(struct?: DomainSysInfoSmbiosMemoryEntry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    file: cdktf.stringToTerraform(struct!.file),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function domainSysInfoSmbiosMemoryEntryToHclTerraform(struct?: DomainSysInfoSmbiosMemoryEntry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    file: {
      value: cdktf.stringToHclTerraform(struct!.file),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainSysInfoSmbiosMemoryEntryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainSysInfoSmbiosMemoryEntry | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._file !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainSysInfoSmbiosMemoryEntry | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._file = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._file = value.file;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // file - computed: false, optional: true, required: false
  private _file?: string; 
  public get file() {
    return this.getStringAttribute('file');
  }
  public set file(value: string) {
    this._file = value;
  }
  public resetFile() {
    this._file = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DomainSysInfoSmbiosMemoryEntryList extends cdktf.ComplexList {
  public internalValue? : DomainSysInfoSmbiosMemoryEntry[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainSysInfoSmbiosMemoryEntryOutputReference {
    return new DomainSysInfoSmbiosMemoryEntryOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainSysInfoSmbiosMemory {
  /**
  * Defines a single SMBIOS memory information field override, identified by its required name and provided via value or file.
  * 
  * See: <https://libvirt.org/formatdomain.html#smbios-system-information>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#entry Domain#entry}
  */
  readonly entry?: DomainSysInfoSmbiosMemoryEntry[] | cdktf.IResolvable;
}

export function domainSysInfoSmbiosMemoryToTerraform(struct?: DomainSysInfoSmbiosMemory | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    entry: cdktf.listMapper(domainSysInfoSmbiosMemoryEntryToTerraform, false)(struct!.entry),
  }
}


export function domainSysInfoSmbiosMemoryToHclTerraform(struct?: DomainSysInfoSmbiosMemory | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    entry: {
      value: cdktf.listMapperHcl(domainSysInfoSmbiosMemoryEntryToHclTerraform, false)(struct!.entry),
      isBlock: true,
      type: "list",
      storageClassType: "DomainSysInfoSmbiosMemoryEntryList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainSysInfoSmbiosMemoryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainSysInfoSmbiosMemory | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._entry?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.entry = this._entry?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainSysInfoSmbiosMemory | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._entry.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._entry.internalValue = value.entry;
    }
  }

  // entry - computed: false, optional: true, required: false
  private _entry = new DomainSysInfoSmbiosMemoryEntryList(this, "entry", false);
  public get entry() {
    return this._entry;
  }
  public putEntry(value: DomainSysInfoSmbiosMemoryEntry[] | cdktf.IResolvable) {
    this._entry.internalValue = value;
  }
  public resetEntry() {
    this._entry.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get entryInput() {
    return this._entry.internalValue;
  }
}

export class DomainSysInfoSmbiosMemoryList extends cdktf.ComplexList {
  public internalValue? : DomainSysInfoSmbiosMemory[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainSysInfoSmbiosMemoryOutputReference {
    return new DomainSysInfoSmbiosMemoryOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainSysInfoSmbiosOemStrings {
  /**
  * Defines a single OEM string entry, each being an arbitrary user-provided string (for example, "Cluster=prod" or "Owner=teamX").
  * 
  * See: <https://libvirt.org/formatdomain.html#smbios-system-information>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#entry Domain#entry}
  */
  readonly entry?: string[];
}

export function domainSysInfoSmbiosOemStringsToTerraform(struct?: DomainSysInfoSmbiosOemStrings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    entry: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.entry),
  }
}


export function domainSysInfoSmbiosOemStringsToHclTerraform(struct?: DomainSysInfoSmbiosOemStrings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    entry: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.entry),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainSysInfoSmbiosOemStringsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainSysInfoSmbiosOemStrings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._entry !== undefined) {
      hasAnyValues = true;
      internalValueResult.entry = this._entry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainSysInfoSmbiosOemStrings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._entry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._entry = value.entry;
    }
  }

  // entry - computed: false, optional: true, required: false
  private _entry?: string[]; 
  public get entry() {
    return this.getListAttribute('entry');
  }
  public set entry(value: string[]) {
    this._entry = value;
  }
  public resetEntry() {
    this._entry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get entryInput() {
    return this._entry;
  }
}
export interface DomainSysInfoSmbiosProcessorEntry {
  /**
  * Sets the host file path whose contents should be provided to the guest via this fw_cfg entry instead of an inline value; the path is user-provided and must be readable by the hypervisor.
  * 
  * See: <https://libvirt.org/formatdomain.html#smbios-system-information>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file?: string;
  /**
  * Sets the fw_cfg key name used to identify this entry to the guest/firmware; the string is user-provided and typically follows firmware-expected naming (for example, "opt/org.example/config").
  * 
  * See: <https://libvirt.org/formatdomain.html#smbios-system-information>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
  /**
  * Sets the literal string value for this fw_cfg entry when no file is specified, providing small configuration blobs directly to the guest.
  * 
  * See: <https://libvirt.org/formatdomain.html#smbios-system-information>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#value Domain#value}
  */
  readonly value: string;
}

export function domainSysInfoSmbiosProcessorEntryToTerraform(struct?: DomainSysInfoSmbiosProcessorEntry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    file: cdktf.stringToTerraform(struct!.file),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function domainSysInfoSmbiosProcessorEntryToHclTerraform(struct?: DomainSysInfoSmbiosProcessorEntry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    file: {
      value: cdktf.stringToHclTerraform(struct!.file),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainSysInfoSmbiosProcessorEntryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainSysInfoSmbiosProcessorEntry | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._file !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainSysInfoSmbiosProcessorEntry | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._file = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._file = value.file;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // file - computed: false, optional: true, required: false
  private _file?: string; 
  public get file() {
    return this.getStringAttribute('file');
  }
  public set file(value: string) {
    this._file = value;
  }
  public resetFile() {
    this._file = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DomainSysInfoSmbiosProcessorEntryList extends cdktf.ComplexList {
  public internalValue? : DomainSysInfoSmbiosProcessorEntry[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainSysInfoSmbiosProcessorEntryOutputReference {
    return new DomainSysInfoSmbiosProcessorEntryOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainSysInfoSmbiosProcessor {
  /**
  * Defines a single SMBIOS processor field override, identified by its required name and a user-provided value or file-backed value (for example, customizing processor version or manufacturer).
  * 
  * See: <https://libvirt.org/formatdomain.html#smbios-system-information>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#entry Domain#entry}
  */
  readonly entry?: DomainSysInfoSmbiosProcessorEntry[] | cdktf.IResolvable;
}

export function domainSysInfoSmbiosProcessorToTerraform(struct?: DomainSysInfoSmbiosProcessor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    entry: cdktf.listMapper(domainSysInfoSmbiosProcessorEntryToTerraform, false)(struct!.entry),
  }
}


export function domainSysInfoSmbiosProcessorToHclTerraform(struct?: DomainSysInfoSmbiosProcessor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    entry: {
      value: cdktf.listMapperHcl(domainSysInfoSmbiosProcessorEntryToHclTerraform, false)(struct!.entry),
      isBlock: true,
      type: "list",
      storageClassType: "DomainSysInfoSmbiosProcessorEntryList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainSysInfoSmbiosProcessorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainSysInfoSmbiosProcessor | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._entry?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.entry = this._entry?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainSysInfoSmbiosProcessor | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._entry.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._entry.internalValue = value.entry;
    }
  }

  // entry - computed: false, optional: true, required: false
  private _entry = new DomainSysInfoSmbiosProcessorEntryList(this, "entry", false);
  public get entry() {
    return this._entry;
  }
  public putEntry(value: DomainSysInfoSmbiosProcessorEntry[] | cdktf.IResolvable) {
    this._entry.internalValue = value;
  }
  public resetEntry() {
    this._entry.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get entryInput() {
    return this._entry.internalValue;
  }
}

export class DomainSysInfoSmbiosProcessorList extends cdktf.ComplexList {
  public internalValue? : DomainSysInfoSmbiosProcessor[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainSysInfoSmbiosProcessorOutputReference {
    return new DomainSysInfoSmbiosProcessorOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainSysInfoSmbiosSystemEntry {
  /**
  * Sets the host file path whose contents should be provided to the guest via this fw_cfg entry instead of an inline value; the path is user-provided and must be readable by the hypervisor.
  * 
  * See: <https://libvirt.org/formatdomain.html#smbios-system-information>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file?: string;
  /**
  * Sets the fw_cfg key name used to identify this entry to the guest/firmware; the string is user-provided and typically follows firmware-expected naming (for example, "opt/org.example/config").
  * 
  * See: <https://libvirt.org/formatdomain.html#smbios-system-information>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
  /**
  * Sets the literal string value for this fw_cfg entry when no file is specified, providing small configuration blobs directly to the guest.
  * 
  * See: <https://libvirt.org/formatdomain.html#smbios-system-information>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#value Domain#value}
  */
  readonly value: string;
}

export function domainSysInfoSmbiosSystemEntryToTerraform(struct?: DomainSysInfoSmbiosSystemEntry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    file: cdktf.stringToTerraform(struct!.file),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function domainSysInfoSmbiosSystemEntryToHclTerraform(struct?: DomainSysInfoSmbiosSystemEntry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    file: {
      value: cdktf.stringToHclTerraform(struct!.file),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainSysInfoSmbiosSystemEntryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainSysInfoSmbiosSystemEntry | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._file !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainSysInfoSmbiosSystemEntry | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._file = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._file = value.file;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // file - computed: false, optional: true, required: false
  private _file?: string; 
  public get file() {
    return this.getStringAttribute('file');
  }
  public set file(value: string) {
    this._file = value;
  }
  public resetFile() {
    this._file = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DomainSysInfoSmbiosSystemEntryList extends cdktf.ComplexList {
  public internalValue? : DomainSysInfoSmbiosSystemEntry[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainSysInfoSmbiosSystemEntryOutputReference {
    return new DomainSysInfoSmbiosSystemEntryOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainSysInfoSmbiosSystem {
  /**
  * Defines one custom SMBIOS system field entry; each entry specifies a field `name` and either an inline `value` or a `file` to read the value from.
  * 
  * See: <https://libvirt.org/formatdomain.html#smbios-system-information>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#entry Domain#entry}
  */
  readonly entry?: DomainSysInfoSmbiosSystemEntry[] | cdktf.IResolvable;
}

export function domainSysInfoSmbiosSystemToTerraform(struct?: DomainSysInfoSmbiosSystem | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    entry: cdktf.listMapper(domainSysInfoSmbiosSystemEntryToTerraform, false)(struct!.entry),
  }
}


export function domainSysInfoSmbiosSystemToHclTerraform(struct?: DomainSysInfoSmbiosSystem | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    entry: {
      value: cdktf.listMapperHcl(domainSysInfoSmbiosSystemEntryToHclTerraform, false)(struct!.entry),
      isBlock: true,
      type: "list",
      storageClassType: "DomainSysInfoSmbiosSystemEntryList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainSysInfoSmbiosSystemOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainSysInfoSmbiosSystem | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._entry?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.entry = this._entry?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainSysInfoSmbiosSystem | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._entry.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._entry.internalValue = value.entry;
    }
  }

  // entry - computed: false, optional: true, required: false
  private _entry = new DomainSysInfoSmbiosSystemEntryList(this, "entry", false);
  public get entry() {
    return this._entry;
  }
  public putEntry(value: DomainSysInfoSmbiosSystemEntry[] | cdktf.IResolvable) {
    this._entry.internalValue = value;
  }
  public resetEntry() {
    this._entry.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get entryInput() {
    return this._entry.internalValue;
  }
}
export interface DomainSysInfoSmbios {
  /**
  * Configures the SMBIOS base board (motherboard) section, allowing customization of board-level fields presented to the guest.
  * 
  * See: <https://libvirt.org/formatdomain.html#smbios-system-information>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#base_board Domain#base_board}
  */
  readonly baseBoard?: DomainSysInfoSmbiosBaseBoard[] | cdktf.IResolvable;
  /**
  * Configures the SMBIOS BIOS information block, enabling you to override individual BIOS-related fields exposed to the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bios Domain#bios}
  */
  readonly bios?: DomainSysInfoSmbiosBios;
  /**
  * Configures the SMBIOS chassis information block, allowing overrides for how the guest sees chassis-related system information.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#chassis Domain#chassis}
  */
  readonly chassis?: DomainSysInfoSmbiosChassis;
  /**
  * Configures the SMBIOS memory information block, allowing customized memory-related fields to be exposed to the guest.
  * 
  * See: <https://libvirt.org/formatdomain.html#smbios-system-information>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#memory Domain#memory}
  */
  readonly memory?: DomainSysInfoSmbiosMemory[] | cdktf.IResolvable;
  /**
  * Configures the SMBIOS OEM strings block, allowing arbitrary vendor-specific strings to be presented to the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#oem_strings Domain#oem_strings}
  */
  readonly oemStrings?: DomainSysInfoSmbiosOemStrings;
  /**
  * Configures the SMBIOS processor information block, enabling overrides of CPU-related identification fields.
  * 
  * See: <https://libvirt.org/formatdomain.html#smbios-system-information>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#processor Domain#processor}
  */
  readonly processor?: DomainSysInfoSmbiosProcessor[] | cdktf.IResolvable;
  /**
  * Enables configuration of custom SMBIOS system table fields presented to the guest, such as product name, version, serial, and UUID.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#system Domain#system}
  */
  readonly systemAttribute?: DomainSysInfoSmbiosSystem;
}

export function domainSysInfoSmbiosToTerraform(struct?: DomainSysInfoSmbios | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    base_board: cdktf.listMapper(domainSysInfoSmbiosBaseBoardToTerraform, false)(struct!.baseBoard),
    bios: domainSysInfoSmbiosBiosToTerraform(struct!.bios),
    chassis: domainSysInfoSmbiosChassisToTerraform(struct!.chassis),
    memory: cdktf.listMapper(domainSysInfoSmbiosMemoryToTerraform, false)(struct!.memory),
    oem_strings: domainSysInfoSmbiosOemStringsToTerraform(struct!.oemStrings),
    processor: cdktf.listMapper(domainSysInfoSmbiosProcessorToTerraform, false)(struct!.processor),
    system: domainSysInfoSmbiosSystemToTerraform(struct!.systemAttribute),
  }
}


export function domainSysInfoSmbiosToHclTerraform(struct?: DomainSysInfoSmbios | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    base_board: {
      value: cdktf.listMapperHcl(domainSysInfoSmbiosBaseBoardToHclTerraform, false)(struct!.baseBoard),
      isBlock: true,
      type: "list",
      storageClassType: "DomainSysInfoSmbiosBaseBoardList",
    },
    bios: {
      value: domainSysInfoSmbiosBiosToHclTerraform(struct!.bios),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainSysInfoSmbiosBios",
    },
    chassis: {
      value: domainSysInfoSmbiosChassisToHclTerraform(struct!.chassis),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainSysInfoSmbiosChassis",
    },
    memory: {
      value: cdktf.listMapperHcl(domainSysInfoSmbiosMemoryToHclTerraform, false)(struct!.memory),
      isBlock: true,
      type: "list",
      storageClassType: "DomainSysInfoSmbiosMemoryList",
    },
    oem_strings: {
      value: domainSysInfoSmbiosOemStringsToHclTerraform(struct!.oemStrings),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainSysInfoSmbiosOemStrings",
    },
    processor: {
      value: cdktf.listMapperHcl(domainSysInfoSmbiosProcessorToHclTerraform, false)(struct!.processor),
      isBlock: true,
      type: "list",
      storageClassType: "DomainSysInfoSmbiosProcessorList",
    },
    system: {
      value: domainSysInfoSmbiosSystemToHclTerraform(struct!.systemAttribute),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainSysInfoSmbiosSystem",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainSysInfoSmbiosOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainSysInfoSmbios | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._baseBoard?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.baseBoard = this._baseBoard?.internalValue;
    }
    if (this._bios?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bios = this._bios?.internalValue;
    }
    if (this._chassis?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.chassis = this._chassis?.internalValue;
    }
    if (this._memory?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.memory = this._memory?.internalValue;
    }
    if (this._oemStrings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oemStrings = this._oemStrings?.internalValue;
    }
    if (this._processor?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.processor = this._processor?.internalValue;
    }
    if (this._system?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemAttribute = this._system?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainSysInfoSmbios | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._baseBoard.internalValue = undefined;
      this._bios.internalValue = undefined;
      this._chassis.internalValue = undefined;
      this._memory.internalValue = undefined;
      this._oemStrings.internalValue = undefined;
      this._processor.internalValue = undefined;
      this._system.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._baseBoard.internalValue = value.baseBoard;
      this._bios.internalValue = value.bios;
      this._chassis.internalValue = value.chassis;
      this._memory.internalValue = value.memory;
      this._oemStrings.internalValue = value.oemStrings;
      this._processor.internalValue = value.processor;
      this._system.internalValue = value.systemAttribute;
    }
  }

  // base_board - computed: false, optional: true, required: false
  private _baseBoard = new DomainSysInfoSmbiosBaseBoardList(this, "base_board", false);
  public get baseBoard() {
    return this._baseBoard;
  }
  public putBaseBoard(value: DomainSysInfoSmbiosBaseBoard[] | cdktf.IResolvable) {
    this._baseBoard.internalValue = value;
  }
  public resetBaseBoard() {
    this._baseBoard.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get baseBoardInput() {
    return this._baseBoard.internalValue;
  }

  // bios - computed: false, optional: true, required: false
  private _bios = new DomainSysInfoSmbiosBiosOutputReference(this, "bios");
  public get bios() {
    return this._bios;
  }
  public putBios(value: DomainSysInfoSmbiosBios) {
    this._bios.internalValue = value;
  }
  public resetBios() {
    this._bios.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get biosInput() {
    return this._bios.internalValue;
  }

  // chassis - computed: false, optional: true, required: false
  private _chassis = new DomainSysInfoSmbiosChassisOutputReference(this, "chassis");
  public get chassis() {
    return this._chassis;
  }
  public putChassis(value: DomainSysInfoSmbiosChassis) {
    this._chassis.internalValue = value;
  }
  public resetChassis() {
    this._chassis.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get chassisInput() {
    return this._chassis.internalValue;
  }

  // memory - computed: false, optional: true, required: false
  private _memory = new DomainSysInfoSmbiosMemoryList(this, "memory", false);
  public get memory() {
    return this._memory;
  }
  public putMemory(value: DomainSysInfoSmbiosMemory[] | cdktf.IResolvable) {
    this._memory.internalValue = value;
  }
  public resetMemory() {
    this._memory.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryInput() {
    return this._memory.internalValue;
  }

  // oem_strings - computed: false, optional: true, required: false
  private _oemStrings = new DomainSysInfoSmbiosOemStringsOutputReference(this, "oem_strings");
  public get oemStrings() {
    return this._oemStrings;
  }
  public putOemStrings(value: DomainSysInfoSmbiosOemStrings) {
    this._oemStrings.internalValue = value;
  }
  public resetOemStrings() {
    this._oemStrings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oemStringsInput() {
    return this._oemStrings.internalValue;
  }

  // processor - computed: false, optional: true, required: false
  private _processor = new DomainSysInfoSmbiosProcessorList(this, "processor", false);
  public get processor() {
    return this._processor;
  }
  public putProcessor(value: DomainSysInfoSmbiosProcessor[] | cdktf.IResolvable) {
    this._processor.internalValue = value;
  }
  public resetProcessor() {
    this._processor.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get processorInput() {
    return this._processor.internalValue;
  }

  // system - computed: false, optional: true, required: false
  private _system = new DomainSysInfoSmbiosSystemOutputReference(this, "system");
  public get systemAttribute() {
    return this._system;
  }
  public putSystemAttribute(value: DomainSysInfoSmbiosSystem) {
    this._system.internalValue = value;
  }
  public resetSystemAttribute() {
    this._system.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemAttributeInput() {
    return this._system.internalValue;
  }
}
export interface DomainSysInfo {
  /**
  * Configures a set of fw_cfg entries that firmware or the guest can read, used to inject arbitrary configuration data or files into the guest at boot.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#fw_cfg Domain#fw_cfg}
  */
  readonly fwCfg?: DomainSysInfoFwCfg;
  /**
  * Configures SMBIOS-related system information blocks that the hypervisor exposes to the guest (system, base board, chassis, etc.).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#smbios Domain#smbios}
  */
  readonly smbios?: DomainSysInfoSmbios;
}

export function domainSysInfoToTerraform(struct?: DomainSysInfo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fw_cfg: domainSysInfoFwCfgToTerraform(struct!.fwCfg),
    smbios: domainSysInfoSmbiosToTerraform(struct!.smbios),
  }
}


export function domainSysInfoToHclTerraform(struct?: DomainSysInfo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fw_cfg: {
      value: domainSysInfoFwCfgToHclTerraform(struct!.fwCfg),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainSysInfoFwCfg",
    },
    smbios: {
      value: domainSysInfoSmbiosToHclTerraform(struct!.smbios),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainSysInfoSmbios",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainSysInfoOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainSysInfo | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fwCfg?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fwCfg = this._fwCfg?.internalValue;
    }
    if (this._smbios?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.smbios = this._smbios?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainSysInfo | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fwCfg.internalValue = undefined;
      this._smbios.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fwCfg.internalValue = value.fwCfg;
      this._smbios.internalValue = value.smbios;
    }
  }

  // fw_cfg - computed: false, optional: true, required: false
  private _fwCfg = new DomainSysInfoFwCfgOutputReference(this, "fw_cfg");
  public get fwCfg() {
    return this._fwCfg;
  }
  public putFwCfg(value: DomainSysInfoFwCfg) {
    this._fwCfg.internalValue = value;
  }
  public resetFwCfg() {
    this._fwCfg.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fwCfgInput() {
    return this._fwCfg.internalValue;
  }

  // smbios - computed: false, optional: true, required: false
  private _smbios = new DomainSysInfoSmbiosOutputReference(this, "smbios");
  public get smbios() {
    return this._smbios;
  }
  public putSmbios(value: DomainSysInfoSmbios) {
    this._smbios.internalValue = value;
  }
  public resetSmbios() {
    this._smbios.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get smbiosInput() {
    return this._smbios.internalValue;
  }
}

export class DomainSysInfoList extends cdktf.ComplexList {
  public internalValue? : DomainSysInfo[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainSysInfoOutputReference {
    return new DomainSysInfoOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainThrottleGroupsThrottleGroups {
  /**
  * Sets the unique name of this throttle group, which must match the `group_name` used by disk `throttlefilters` to attach a disk to the group; the name string is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#group_name Domain#group_name}
  */
  readonly groupName?: string;
  /**
  * Sets the sustained read bandwidth limit for the group in bytes per second; value is a non-negative integer, for example `10485760` for 10 MiB/s.
  * 
  * See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#read_bytes_sec Domain#read_bytes_sec}
  */
  readonly readBytesSec?: number;
  /**
  * Sets the maximum burst read bandwidth limit for the group in bytes per second; value is a non-negative integer and is used together with `read_bytes_sec_max_length`.
  * 
  * See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#read_bytes_sec_max Domain#read_bytes_sec_max}
  */
  readonly readBytesSecMax?: number;
  /**
  * Sets the time window in seconds over which the `read_bytes_sec_max` burst limit applies; value is a non-negative integer number of seconds.
  * 
  * See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#read_bytes_sec_max_length Domain#read_bytes_sec_max_length}
  */
  readonly readBytesSecMaxLength?: number;
  /**
  * Sets the sustained read IOPS limit for the group; value is a non-negative integer specifying maximum read operations per second.
  * 
  * See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#read_iops_sec Domain#read_iops_sec}
  */
  readonly readIopsSec?: number;
  /**
  * Sets the maximum burst read IOPS limit for the group; value is a non-negative integer and is used together with `read_iops_sec_max_length`.
  * 
  * See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#read_iops_sec_max Domain#read_iops_sec_max}
  */
  readonly readIopsSecMax?: number;
  /**
  * Sets the time window in seconds over which the `read_iops_sec_max` burst IOPS limit applies; value is a non-negative integer number of seconds.
  * 
  * See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#read_iops_sec_max_length Domain#read_iops_sec_max_length}
  */
  readonly readIopsSecMaxLength?: number;
  /**
  * Sets the I/O size in bytes used when converting between size-based and operation-based limits for this group; value is a positive integer, typically a block size such as `4096`.
  * 
  * See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#size_iops_sec Domain#size_iops_sec}
  */
  readonly sizeIopsSec?: number;
  /**
  * Sets the sustained aggregate bandwidth limit (read + write) for the group in bytes per second; value is a non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#total_bytes_sec Domain#total_bytes_sec}
  */
  readonly totalBytesSec?: number;
  /**
  * Sets the maximum burst aggregate bandwidth limit (read + write) for the group in bytes per second; value is a non-negative integer and is typically paired with a corresponding `*_max_length` window.
  * 
  * See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#total_bytes_sec_max Domain#total_bytes_sec_max}
  */
  readonly totalBytesSecMax?: number;
  /**
  * Sets the I/O burst length, in bytes, over which the total_bytes_sec_max limit is measured for the throttle group; the value is user-provided and must be a nonnegative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#total_bytes_sec_max_length Domain#total_bytes_sec_max_length}
  */
  readonly totalBytesSecMaxLength?: number;
  /**
  * Sets the steadystate limit on the total number of I/O operations per second (reads + writes) allowed for disks in this throttle group; the value is userprovided and must be a nonnegative integer (IOPS).
  * 
  * See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#total_iops_sec Domain#total_iops_sec}
  */
  readonly totalIopsSec?: number;
  /**
  * Sets the maximum burst IOPS limit (reads + writes) for the throttle group, above the steady total_iops_sec value; the value is userprovided and must be a nonnegative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#total_iops_sec_max Domain#total_iops_sec_max}
  */
  readonly totalIopsSecMax?: number;
  /**
  * Sets the I/O burst length, in number of requests, over which the total_iops_sec_max limit is measured for the throttle group; the value is userprovided and must be a nonnegative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#total_iops_sec_max_length Domain#total_iops_sec_max_length}
  */
  readonly totalIopsSecMaxLength?: number;
  /**
  * Sets the steadystate limit on write throughput in bytes per second for disks in this throttle group; the value is userprovided and must be a nonnegative integer (e.g. 104857600 for 100 MiB/s).
  * 
  * See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#write_bytes_sec Domain#write_bytes_sec}
  */
  readonly writeBytesSec?: number;
  /**
  * Sets the maximum burst write throughput in bytes per second for the throttle group, above the steady write_bytes_sec limit; the value is userprovided and must be a nonnegative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#write_bytes_sec_max Domain#write_bytes_sec_max}
  */
  readonly writeBytesSecMax?: number;
  /**
  * Sets the I/O burst length, in bytes, over which the write_bytes_sec_max limit is measured for the throttle group; the value is userprovided and must be a nonnegative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#write_bytes_sec_max_length Domain#write_bytes_sec_max_length}
  */
  readonly writeBytesSecMaxLength?: number;
  /**
  * Sets the steadystate limit on write IOPS for disks in this throttle group; the value is userprovided and must be a nonnegative integer (number of write requests per second).
  * 
  * See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#write_iops_sec Domain#write_iops_sec}
  */
  readonly writeIopsSec?: number;
  /**
  * Sets the maximum burst write IOPS limit for the throttle group, above the steady write_iops_sec value; the value is userprovided and must be a nonnegative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#write_iops_sec_max Domain#write_iops_sec_max}
  */
  readonly writeIopsSecMax?: number;
  /**
  * Sets the I/O burst length, in number of write requests, over which the write_iops_sec_max limit is measured for the throttle group; the value is userprovided and must be a nonnegative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#write_iops_sec_max_length Domain#write_iops_sec_max_length}
  */
  readonly writeIopsSecMaxLength?: number;
}

export function domainThrottleGroupsThrottleGroupsToTerraform(struct?: DomainThrottleGroupsThrottleGroups | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    group_name: cdktf.stringToTerraform(struct!.groupName),
    read_bytes_sec: cdktf.numberToTerraform(struct!.readBytesSec),
    read_bytes_sec_max: cdktf.numberToTerraform(struct!.readBytesSecMax),
    read_bytes_sec_max_length: cdktf.numberToTerraform(struct!.readBytesSecMaxLength),
    read_iops_sec: cdktf.numberToTerraform(struct!.readIopsSec),
    read_iops_sec_max: cdktf.numberToTerraform(struct!.readIopsSecMax),
    read_iops_sec_max_length: cdktf.numberToTerraform(struct!.readIopsSecMaxLength),
    size_iops_sec: cdktf.numberToTerraform(struct!.sizeIopsSec),
    total_bytes_sec: cdktf.numberToTerraform(struct!.totalBytesSec),
    total_bytes_sec_max: cdktf.numberToTerraform(struct!.totalBytesSecMax),
    total_bytes_sec_max_length: cdktf.numberToTerraform(struct!.totalBytesSecMaxLength),
    total_iops_sec: cdktf.numberToTerraform(struct!.totalIopsSec),
    total_iops_sec_max: cdktf.numberToTerraform(struct!.totalIopsSecMax),
    total_iops_sec_max_length: cdktf.numberToTerraform(struct!.totalIopsSecMaxLength),
    write_bytes_sec: cdktf.numberToTerraform(struct!.writeBytesSec),
    write_bytes_sec_max: cdktf.numberToTerraform(struct!.writeBytesSecMax),
    write_bytes_sec_max_length: cdktf.numberToTerraform(struct!.writeBytesSecMaxLength),
    write_iops_sec: cdktf.numberToTerraform(struct!.writeIopsSec),
    write_iops_sec_max: cdktf.numberToTerraform(struct!.writeIopsSecMax),
    write_iops_sec_max_length: cdktf.numberToTerraform(struct!.writeIopsSecMaxLength),
  }
}


export function domainThrottleGroupsThrottleGroupsToHclTerraform(struct?: DomainThrottleGroupsThrottleGroups | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    group_name: {
      value: cdktf.stringToHclTerraform(struct!.groupName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    read_bytes_sec: {
      value: cdktf.numberToHclTerraform(struct!.readBytesSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    read_bytes_sec_max: {
      value: cdktf.numberToHclTerraform(struct!.readBytesSecMax),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    read_bytes_sec_max_length: {
      value: cdktf.numberToHclTerraform(struct!.readBytesSecMaxLength),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    read_iops_sec: {
      value: cdktf.numberToHclTerraform(struct!.readIopsSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    read_iops_sec_max: {
      value: cdktf.numberToHclTerraform(struct!.readIopsSecMax),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    read_iops_sec_max_length: {
      value: cdktf.numberToHclTerraform(struct!.readIopsSecMaxLength),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    size_iops_sec: {
      value: cdktf.numberToHclTerraform(struct!.sizeIopsSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    total_bytes_sec: {
      value: cdktf.numberToHclTerraform(struct!.totalBytesSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    total_bytes_sec_max: {
      value: cdktf.numberToHclTerraform(struct!.totalBytesSecMax),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    total_bytes_sec_max_length: {
      value: cdktf.numberToHclTerraform(struct!.totalBytesSecMaxLength),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    total_iops_sec: {
      value: cdktf.numberToHclTerraform(struct!.totalIopsSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    total_iops_sec_max: {
      value: cdktf.numberToHclTerraform(struct!.totalIopsSecMax),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    total_iops_sec_max_length: {
      value: cdktf.numberToHclTerraform(struct!.totalIopsSecMaxLength),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    write_bytes_sec: {
      value: cdktf.numberToHclTerraform(struct!.writeBytesSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    write_bytes_sec_max: {
      value: cdktf.numberToHclTerraform(struct!.writeBytesSecMax),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    write_bytes_sec_max_length: {
      value: cdktf.numberToHclTerraform(struct!.writeBytesSecMaxLength),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    write_iops_sec: {
      value: cdktf.numberToHclTerraform(struct!.writeIopsSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    write_iops_sec_max: {
      value: cdktf.numberToHclTerraform(struct!.writeIopsSecMax),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    write_iops_sec_max_length: {
      value: cdktf.numberToHclTerraform(struct!.writeIopsSecMaxLength),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainThrottleGroupsThrottleGroupsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainThrottleGroupsThrottleGroups | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._groupName !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupName = this._groupName;
    }
    if (this._readBytesSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.readBytesSec = this._readBytesSec;
    }
    if (this._readBytesSecMax !== undefined) {
      hasAnyValues = true;
      internalValueResult.readBytesSecMax = this._readBytesSecMax;
    }
    if (this._readBytesSecMaxLength !== undefined) {
      hasAnyValues = true;
      internalValueResult.readBytesSecMaxLength = this._readBytesSecMaxLength;
    }
    if (this._readIopsSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.readIopsSec = this._readIopsSec;
    }
    if (this._readIopsSecMax !== undefined) {
      hasAnyValues = true;
      internalValueResult.readIopsSecMax = this._readIopsSecMax;
    }
    if (this._readIopsSecMaxLength !== undefined) {
      hasAnyValues = true;
      internalValueResult.readIopsSecMaxLength = this._readIopsSecMaxLength;
    }
    if (this._sizeIopsSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.sizeIopsSec = this._sizeIopsSec;
    }
    if (this._totalBytesSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.totalBytesSec = this._totalBytesSec;
    }
    if (this._totalBytesSecMax !== undefined) {
      hasAnyValues = true;
      internalValueResult.totalBytesSecMax = this._totalBytesSecMax;
    }
    if (this._totalBytesSecMaxLength !== undefined) {
      hasAnyValues = true;
      internalValueResult.totalBytesSecMaxLength = this._totalBytesSecMaxLength;
    }
    if (this._totalIopsSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.totalIopsSec = this._totalIopsSec;
    }
    if (this._totalIopsSecMax !== undefined) {
      hasAnyValues = true;
      internalValueResult.totalIopsSecMax = this._totalIopsSecMax;
    }
    if (this._totalIopsSecMaxLength !== undefined) {
      hasAnyValues = true;
      internalValueResult.totalIopsSecMaxLength = this._totalIopsSecMaxLength;
    }
    if (this._writeBytesSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeBytesSec = this._writeBytesSec;
    }
    if (this._writeBytesSecMax !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeBytesSecMax = this._writeBytesSecMax;
    }
    if (this._writeBytesSecMaxLength !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeBytesSecMaxLength = this._writeBytesSecMaxLength;
    }
    if (this._writeIopsSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeIopsSec = this._writeIopsSec;
    }
    if (this._writeIopsSecMax !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeIopsSecMax = this._writeIopsSecMax;
    }
    if (this._writeIopsSecMaxLength !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeIopsSecMaxLength = this._writeIopsSecMaxLength;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainThrottleGroupsThrottleGroups | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._groupName = undefined;
      this._readBytesSec = undefined;
      this._readBytesSecMax = undefined;
      this._readBytesSecMaxLength = undefined;
      this._readIopsSec = undefined;
      this._readIopsSecMax = undefined;
      this._readIopsSecMaxLength = undefined;
      this._sizeIopsSec = undefined;
      this._totalBytesSec = undefined;
      this._totalBytesSecMax = undefined;
      this._totalBytesSecMaxLength = undefined;
      this._totalIopsSec = undefined;
      this._totalIopsSecMax = undefined;
      this._totalIopsSecMaxLength = undefined;
      this._writeBytesSec = undefined;
      this._writeBytesSecMax = undefined;
      this._writeBytesSecMaxLength = undefined;
      this._writeIopsSec = undefined;
      this._writeIopsSecMax = undefined;
      this._writeIopsSecMaxLength = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._groupName = value.groupName;
      this._readBytesSec = value.readBytesSec;
      this._readBytesSecMax = value.readBytesSecMax;
      this._readBytesSecMaxLength = value.readBytesSecMaxLength;
      this._readIopsSec = value.readIopsSec;
      this._readIopsSecMax = value.readIopsSecMax;
      this._readIopsSecMaxLength = value.readIopsSecMaxLength;
      this._sizeIopsSec = value.sizeIopsSec;
      this._totalBytesSec = value.totalBytesSec;
      this._totalBytesSecMax = value.totalBytesSecMax;
      this._totalBytesSecMaxLength = value.totalBytesSecMaxLength;
      this._totalIopsSec = value.totalIopsSec;
      this._totalIopsSecMax = value.totalIopsSecMax;
      this._totalIopsSecMaxLength = value.totalIopsSecMaxLength;
      this._writeBytesSec = value.writeBytesSec;
      this._writeBytesSecMax = value.writeBytesSecMax;
      this._writeBytesSecMaxLength = value.writeBytesSecMaxLength;
      this._writeIopsSec = value.writeIopsSec;
      this._writeIopsSecMax = value.writeIopsSecMax;
      this._writeIopsSecMaxLength = value.writeIopsSecMaxLength;
    }
  }

  // group_name - computed: false, optional: true, required: false
  private _groupName?: string; 
  public get groupName() {
    return this.getStringAttribute('group_name');
  }
  public set groupName(value: string) {
    this._groupName = value;
  }
  public resetGroupName() {
    this._groupName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupNameInput() {
    return this._groupName;
  }

  // read_bytes_sec - computed: false, optional: true, required: false
  private _readBytesSec?: number; 
  public get readBytesSec() {
    return this.getNumberAttribute('read_bytes_sec');
  }
  public set readBytesSec(value: number) {
    this._readBytesSec = value;
  }
  public resetReadBytesSec() {
    this._readBytesSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readBytesSecInput() {
    return this._readBytesSec;
  }

  // read_bytes_sec_max - computed: false, optional: true, required: false
  private _readBytesSecMax?: number; 
  public get readBytesSecMax() {
    return this.getNumberAttribute('read_bytes_sec_max');
  }
  public set readBytesSecMax(value: number) {
    this._readBytesSecMax = value;
  }
  public resetReadBytesSecMax() {
    this._readBytesSecMax = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readBytesSecMaxInput() {
    return this._readBytesSecMax;
  }

  // read_bytes_sec_max_length - computed: false, optional: true, required: false
  private _readBytesSecMaxLength?: number; 
  public get readBytesSecMaxLength() {
    return this.getNumberAttribute('read_bytes_sec_max_length');
  }
  public set readBytesSecMaxLength(value: number) {
    this._readBytesSecMaxLength = value;
  }
  public resetReadBytesSecMaxLength() {
    this._readBytesSecMaxLength = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readBytesSecMaxLengthInput() {
    return this._readBytesSecMaxLength;
  }

  // read_iops_sec - computed: false, optional: true, required: false
  private _readIopsSec?: number; 
  public get readIopsSec() {
    return this.getNumberAttribute('read_iops_sec');
  }
  public set readIopsSec(value: number) {
    this._readIopsSec = value;
  }
  public resetReadIopsSec() {
    this._readIopsSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readIopsSecInput() {
    return this._readIopsSec;
  }

  // read_iops_sec_max - computed: false, optional: true, required: false
  private _readIopsSecMax?: number; 
  public get readIopsSecMax() {
    return this.getNumberAttribute('read_iops_sec_max');
  }
  public set readIopsSecMax(value: number) {
    this._readIopsSecMax = value;
  }
  public resetReadIopsSecMax() {
    this._readIopsSecMax = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readIopsSecMaxInput() {
    return this._readIopsSecMax;
  }

  // read_iops_sec_max_length - computed: false, optional: true, required: false
  private _readIopsSecMaxLength?: number; 
  public get readIopsSecMaxLength() {
    return this.getNumberAttribute('read_iops_sec_max_length');
  }
  public set readIopsSecMaxLength(value: number) {
    this._readIopsSecMaxLength = value;
  }
  public resetReadIopsSecMaxLength() {
    this._readIopsSecMaxLength = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readIopsSecMaxLengthInput() {
    return this._readIopsSecMaxLength;
  }

  // size_iops_sec - computed: false, optional: true, required: false
  private _sizeIopsSec?: number; 
  public get sizeIopsSec() {
    return this.getNumberAttribute('size_iops_sec');
  }
  public set sizeIopsSec(value: number) {
    this._sizeIopsSec = value;
  }
  public resetSizeIopsSec() {
    this._sizeIopsSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sizeIopsSecInput() {
    return this._sizeIopsSec;
  }

  // total_bytes_sec - computed: false, optional: true, required: false
  private _totalBytesSec?: number; 
  public get totalBytesSec() {
    return this.getNumberAttribute('total_bytes_sec');
  }
  public set totalBytesSec(value: number) {
    this._totalBytesSec = value;
  }
  public resetTotalBytesSec() {
    this._totalBytesSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get totalBytesSecInput() {
    return this._totalBytesSec;
  }

  // total_bytes_sec_max - computed: false, optional: true, required: false
  private _totalBytesSecMax?: number; 
  public get totalBytesSecMax() {
    return this.getNumberAttribute('total_bytes_sec_max');
  }
  public set totalBytesSecMax(value: number) {
    this._totalBytesSecMax = value;
  }
  public resetTotalBytesSecMax() {
    this._totalBytesSecMax = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get totalBytesSecMaxInput() {
    return this._totalBytesSecMax;
  }

  // total_bytes_sec_max_length - computed: false, optional: true, required: false
  private _totalBytesSecMaxLength?: number; 
  public get totalBytesSecMaxLength() {
    return this.getNumberAttribute('total_bytes_sec_max_length');
  }
  public set totalBytesSecMaxLength(value: number) {
    this._totalBytesSecMaxLength = value;
  }
  public resetTotalBytesSecMaxLength() {
    this._totalBytesSecMaxLength = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get totalBytesSecMaxLengthInput() {
    return this._totalBytesSecMaxLength;
  }

  // total_iops_sec - computed: false, optional: true, required: false
  private _totalIopsSec?: number; 
  public get totalIopsSec() {
    return this.getNumberAttribute('total_iops_sec');
  }
  public set totalIopsSec(value: number) {
    this._totalIopsSec = value;
  }
  public resetTotalIopsSec() {
    this._totalIopsSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get totalIopsSecInput() {
    return this._totalIopsSec;
  }

  // total_iops_sec_max - computed: false, optional: true, required: false
  private _totalIopsSecMax?: number; 
  public get totalIopsSecMax() {
    return this.getNumberAttribute('total_iops_sec_max');
  }
  public set totalIopsSecMax(value: number) {
    this._totalIopsSecMax = value;
  }
  public resetTotalIopsSecMax() {
    this._totalIopsSecMax = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get totalIopsSecMaxInput() {
    return this._totalIopsSecMax;
  }

  // total_iops_sec_max_length - computed: false, optional: true, required: false
  private _totalIopsSecMaxLength?: number; 
  public get totalIopsSecMaxLength() {
    return this.getNumberAttribute('total_iops_sec_max_length');
  }
  public set totalIopsSecMaxLength(value: number) {
    this._totalIopsSecMaxLength = value;
  }
  public resetTotalIopsSecMaxLength() {
    this._totalIopsSecMaxLength = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get totalIopsSecMaxLengthInput() {
    return this._totalIopsSecMaxLength;
  }

  // write_bytes_sec - computed: false, optional: true, required: false
  private _writeBytesSec?: number; 
  public get writeBytesSec() {
    return this.getNumberAttribute('write_bytes_sec');
  }
  public set writeBytesSec(value: number) {
    this._writeBytesSec = value;
  }
  public resetWriteBytesSec() {
    this._writeBytesSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeBytesSecInput() {
    return this._writeBytesSec;
  }

  // write_bytes_sec_max - computed: false, optional: true, required: false
  private _writeBytesSecMax?: number; 
  public get writeBytesSecMax() {
    return this.getNumberAttribute('write_bytes_sec_max');
  }
  public set writeBytesSecMax(value: number) {
    this._writeBytesSecMax = value;
  }
  public resetWriteBytesSecMax() {
    this._writeBytesSecMax = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeBytesSecMaxInput() {
    return this._writeBytesSecMax;
  }

  // write_bytes_sec_max_length - computed: false, optional: true, required: false
  private _writeBytesSecMaxLength?: number; 
  public get writeBytesSecMaxLength() {
    return this.getNumberAttribute('write_bytes_sec_max_length');
  }
  public set writeBytesSecMaxLength(value: number) {
    this._writeBytesSecMaxLength = value;
  }
  public resetWriteBytesSecMaxLength() {
    this._writeBytesSecMaxLength = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeBytesSecMaxLengthInput() {
    return this._writeBytesSecMaxLength;
  }

  // write_iops_sec - computed: false, optional: true, required: false
  private _writeIopsSec?: number; 
  public get writeIopsSec() {
    return this.getNumberAttribute('write_iops_sec');
  }
  public set writeIopsSec(value: number) {
    this._writeIopsSec = value;
  }
  public resetWriteIopsSec() {
    this._writeIopsSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeIopsSecInput() {
    return this._writeIopsSec;
  }

  // write_iops_sec_max - computed: false, optional: true, required: false
  private _writeIopsSecMax?: number; 
  public get writeIopsSecMax() {
    return this.getNumberAttribute('write_iops_sec_max');
  }
  public set writeIopsSecMax(value: number) {
    this._writeIopsSecMax = value;
  }
  public resetWriteIopsSecMax() {
    this._writeIopsSecMax = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeIopsSecMaxInput() {
    return this._writeIopsSecMax;
  }

  // write_iops_sec_max_length - computed: false, optional: true, required: false
  private _writeIopsSecMaxLength?: number; 
  public get writeIopsSecMaxLength() {
    return this.getNumberAttribute('write_iops_sec_max_length');
  }
  public set writeIopsSecMaxLength(value: number) {
    this._writeIopsSecMaxLength = value;
  }
  public resetWriteIopsSecMaxLength() {
    this._writeIopsSecMaxLength = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeIopsSecMaxLengthInput() {
    return this._writeIopsSecMaxLength;
  }
}

export class DomainThrottleGroupsThrottleGroupsList extends cdktf.ComplexList {
  public internalValue? : DomainThrottleGroupsThrottleGroups[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainThrottleGroupsThrottleGroupsOutputReference {
    return new DomainThrottleGroupsThrottleGroupsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainThrottleGroups {
  /**
  * Defines a single disk throttle group, including its group name and optional aggregate byte and IOPS limits used by disks that join this group.
  * 
  * See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#throttle_groups Domain#throttle_groups}
  */
  readonly throttleGroups?: DomainThrottleGroupsThrottleGroups[] | cdktf.IResolvable;
}

export function domainThrottleGroupsToTerraform(struct?: DomainThrottleGroups | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    throttle_groups: cdktf.listMapper(domainThrottleGroupsThrottleGroupsToTerraform, false)(struct!.throttleGroups),
  }
}


export function domainThrottleGroupsToHclTerraform(struct?: DomainThrottleGroups | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    throttle_groups: {
      value: cdktf.listMapperHcl(domainThrottleGroupsThrottleGroupsToHclTerraform, false)(struct!.throttleGroups),
      isBlock: true,
      type: "list",
      storageClassType: "DomainThrottleGroupsThrottleGroupsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainThrottleGroupsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainThrottleGroups | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._throttleGroups?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.throttleGroups = this._throttleGroups?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainThrottleGroups | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._throttleGroups.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._throttleGroups.internalValue = value.throttleGroups;
    }
  }

  // throttle_groups - computed: false, optional: true, required: false
  private _throttleGroups = new DomainThrottleGroupsThrottleGroupsList(this, "throttle_groups", false);
  public get throttleGroups() {
    return this._throttleGroups;
  }
  public putThrottleGroups(value: DomainThrottleGroupsThrottleGroups[] | cdktf.IResolvable) {
    this._throttleGroups.internalValue = value;
  }
  public resetThrottleGroups() {
    this._throttleGroups.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get throttleGroupsInput() {
    return this._throttleGroups.internalValue;
  }
}
export interface DomainVcpusVcpu {
  /**
  * Controls whether this specific vCPU is online at startup, using a booleanlike string value "yes" or "no" in the vcpu elements enabled attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-allocation>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enabled Domain#enabled}
  */
  readonly enabled?: string;
  /**
  * Sets whether this individual vCPU can be hotplugged on or off while the guest is running; accepts the strings "yes" or "no".
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-allocation>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#hotpluggable Domain#hotpluggable}
  */
  readonly hotpluggable?: string;
  /**
  * Sets the boot-time activation order for this vCPU relative to other vCPUs; the value is a user-provided non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-allocation>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#order Domain#order}
  */
  readonly order?: number;
}

export function domainVcpusVcpuToTerraform(struct?: DomainVcpusVcpu | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.stringToTerraform(struct!.enabled),
    hotpluggable: cdktf.stringToTerraform(struct!.hotpluggable),
    order: cdktf.numberToTerraform(struct!.order),
  }
}


export function domainVcpusVcpuToHclTerraform(struct?: DomainVcpusVcpu | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.stringToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hotpluggable: {
      value: cdktf.stringToHclTerraform(struct!.hotpluggable),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    order: {
      value: cdktf.numberToHclTerraform(struct!.order),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainVcpusVcpuOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainVcpusVcpu | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._hotpluggable !== undefined) {
      hasAnyValues = true;
      internalValueResult.hotpluggable = this._hotpluggable;
    }
    if (this._order !== undefined) {
      hasAnyValues = true;
      internalValueResult.order = this._order;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainVcpusVcpu | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._hotpluggable = undefined;
      this._order = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._hotpluggable = value.hotpluggable;
      this._order = value.order;
    }
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: string; 
  public get enabled() {
    return this.getStringAttribute('enabled');
  }
  public set enabled(value: string) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // hotpluggable - computed: false, optional: true, required: false
  private _hotpluggable?: string; 
  public get hotpluggable() {
    return this.getStringAttribute('hotpluggable');
  }
  public set hotpluggable(value: string) {
    this._hotpluggable = value;
  }
  public resetHotpluggable() {
    this._hotpluggable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hotpluggableInput() {
    return this._hotpluggable;
  }

  // id - computed: true, optional: false, required: false
  public get id() {
    return this.getNumberAttribute('id');
  }

  // order - computed: false, optional: true, required: false
  private _order?: number; 
  public get order() {
    return this.getNumberAttribute('order');
  }
  public set order(value: number) {
    this._order = value;
  }
  public resetOrder() {
    this._order = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get orderInput() {
    return this._order;
  }
}

export class DomainVcpusVcpuList extends cdktf.ComplexList {
  public internalValue? : DomainVcpusVcpu[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainVcpusVcpuOutputReference {
    return new DomainVcpusVcpuOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainVcpus {
  /**
  * Defines a single vCPU entry in the vcpus list, typically identified by an id attribute and optionally configured for pinning or hotplug behavior; the id and other attributes are userprovided.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-allocation>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vcpu Domain#vcpu}
  */
  readonly vcpu?: DomainVcpusVcpu[] | cdktf.IResolvable;
}

export function domainVcpusToTerraform(struct?: DomainVcpus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    vcpu: cdktf.listMapper(domainVcpusVcpuToTerraform, false)(struct!.vcpu),
  }
}


export function domainVcpusToHclTerraform(struct?: DomainVcpus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    vcpu: {
      value: cdktf.listMapperHcl(domainVcpusVcpuToHclTerraform, false)(struct!.vcpu),
      isBlock: true,
      type: "list",
      storageClassType: "DomainVcpusVcpuList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainVcpusOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainVcpus | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._vcpu?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.vcpu = this._vcpu?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainVcpus | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._vcpu.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._vcpu.internalValue = value.vcpu;
    }
  }

  // vcpu - computed: false, optional: true, required: false
  private _vcpu = new DomainVcpusVcpuList(this, "vcpu", false);
  public get vcpu() {
    return this._vcpu;
  }
  public putVcpu(value: DomainVcpusVcpu[] | cdktf.IResolvable) {
    this._vcpu.internalValue = value;
  }
  public resetVcpu() {
    this._vcpu.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vcpuInput() {
    return this._vcpu.internalValue;
  }
}
