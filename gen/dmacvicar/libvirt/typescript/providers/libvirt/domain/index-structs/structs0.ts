import * as cdktf from 'cdktf';
export interface DomainBlockIoTuneDevice {
  /**
  * Sets the absolute path of the host block device whose I/O is being tuned (for example `/dev/vda` or `/dev/sda`); this is required for each device entry.
  * 
  * See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Sets an upper limit, in bytes per second, on read bandwidth for this specific device; the value is a positive integer chosen by the user (e.g. `10485760` for 10 MiB/s).
  * 
  * See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#read_bytes_sec Domain#read_bytes_sec}
  */
  readonly readBytesSec?: number;
  /**
  * Sets an upper limit, in I/O operations per second, on reads for this specific device; the value is a positive integer chosen by the user.
  * 
  * See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#read_iops_sec Domain#read_iops_sec}
  */
  readonly readIopsSec?: number;
  /**
  * Sets the relative I/O weight for this specific device, as an integer in the valid blkio weight range (typically 100–1000), used for proportional scheduling when multiple guests compete.
  * 
  * See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#weight Domain#weight}
  */
  readonly weight?: number;
  /**
  * Sets an upper limit, in bytes per second, on write bandwidth for this specific device; the value is a positive integer chosen by the user.
  * 
  * See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#write_bytes_sec Domain#write_bytes_sec}
  */
  readonly writeBytesSec?: number;
  /**
  * Sets an upper limit, in I/O operations per second, on writes for this specific device; the value is a positive integer chosen by the user.
  * 
  * See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#write_iops_sec Domain#write_iops_sec}
  */
  readonly writeIopsSec?: number;
}

export function domainBlockIoTuneDeviceToTerraform(struct?: DomainBlockIoTuneDevice | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    read_bytes_sec: cdktf.numberToTerraform(struct!.readBytesSec),
    read_iops_sec: cdktf.numberToTerraform(struct!.readIopsSec),
    weight: cdktf.numberToTerraform(struct!.weight),
    write_bytes_sec: cdktf.numberToTerraform(struct!.writeBytesSec),
    write_iops_sec: cdktf.numberToTerraform(struct!.writeIopsSec),
  }
}


export function domainBlockIoTuneDeviceToHclTerraform(struct?: DomainBlockIoTuneDevice | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    read_bytes_sec: {
      value: cdktf.numberToHclTerraform(struct!.readBytesSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    read_iops_sec: {
      value: cdktf.numberToHclTerraform(struct!.readIopsSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    write_bytes_sec: {
      value: cdktf.numberToHclTerraform(struct!.writeBytesSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    write_iops_sec: {
      value: cdktf.numberToHclTerraform(struct!.writeIopsSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainBlockIoTuneDeviceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainBlockIoTuneDevice | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._readBytesSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.readBytesSec = this._readBytesSec;
    }
    if (this._readIopsSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.readIopsSec = this._readIopsSec;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    if (this._writeBytesSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeBytesSec = this._writeBytesSec;
    }
    if (this._writeIopsSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeIopsSec = this._writeIopsSec;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainBlockIoTuneDevice | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._readBytesSec = undefined;
      this._readIopsSec = undefined;
      this._weight = undefined;
      this._writeBytesSec = undefined;
      this._writeIopsSec = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._readBytesSec = value.readBytesSec;
      this._readIopsSec = value.readIopsSec;
      this._weight = value.weight;
      this._writeBytesSec = value.writeBytesSec;
      this._writeIopsSec = value.writeIopsSec;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // read_bytes_sec - computed: false, optional: true, required: false
  private _readBytesSec?: number; 
  public get readBytesSec() {
    return this.getNumberAttribute('read_bytes_sec');
  }
  public set readBytesSec(value: number) {
    this._readBytesSec = value;
  }
  public resetReadBytesSec() {
    this._readBytesSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readBytesSecInput() {
    return this._readBytesSec;
  }

  // read_iops_sec - computed: false, optional: true, required: false
  private _readIopsSec?: number; 
  public get readIopsSec() {
    return this.getNumberAttribute('read_iops_sec');
  }
  public set readIopsSec(value: number) {
    this._readIopsSec = value;
  }
  public resetReadIopsSec() {
    this._readIopsSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readIopsSecInput() {
    return this._readIopsSec;
  }

  // weight - computed: false, optional: true, required: false
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  public resetWeight() {
    this._weight = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }

  // write_bytes_sec - computed: false, optional: true, required: false
  private _writeBytesSec?: number; 
  public get writeBytesSec() {
    return this.getNumberAttribute('write_bytes_sec');
  }
  public set writeBytesSec(value: number) {
    this._writeBytesSec = value;
  }
  public resetWriteBytesSec() {
    this._writeBytesSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeBytesSecInput() {
    return this._writeBytesSec;
  }

  // write_iops_sec - computed: false, optional: true, required: false
  private _writeIopsSec?: number; 
  public get writeIopsSec() {
    return this.getNumberAttribute('write_iops_sec');
  }
  public set writeIopsSec(value: number) {
    this._writeIopsSec = value;
  }
  public resetWriteIopsSec() {
    this._writeIopsSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeIopsSecInput() {
    return this._writeIopsSec;
  }
}

export class DomainBlockIoTuneDeviceList extends cdktf.ComplexList {
  public internalValue? : DomainBlockIoTuneDevice[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainBlockIoTuneDeviceOutputReference {
    return new DomainBlockIoTuneDeviceOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainBlockIoTune {
  /**
  * Defines per-block-device I/O tuning parameters, each entry targeting a specific backing device by path.
  * 
  * See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#device Domain#device}
  */
  readonly device?: DomainBlockIoTuneDevice[] | cdktf.IResolvable;
  /**
  * Sets the global blkio weight for the domain’s I/O, as an integer in the valid blkio weight range (typically 100–1000), affecting its proportional share relative to other domains.
  * 
  * See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#weight Domain#weight}
  */
  readonly weight?: number;
}

export function domainBlockIoTuneToTerraform(struct?: DomainBlockIoTune | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    device: cdktf.listMapper(domainBlockIoTuneDeviceToTerraform, false)(struct!.device),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function domainBlockIoTuneToHclTerraform(struct?: DomainBlockIoTune | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    device: {
      value: cdktf.listMapperHcl(domainBlockIoTuneDeviceToHclTerraform, false)(struct!.device),
      isBlock: true,
      type: "list",
      storageClassType: "DomainBlockIoTuneDeviceList",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainBlockIoTuneOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainBlockIoTune | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._device?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.device = this._device?.internalValue;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainBlockIoTune | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._device.internalValue = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._device.internalValue = value.device;
      this._weight = value.weight;
    }
  }

  // device - computed: false, optional: true, required: false
  private _device = new DomainBlockIoTuneDeviceList(this, "device", false);
  public get device() {
    return this._device;
  }
  public putDevice(value: DomainBlockIoTuneDevice[] | cdktf.IResolvable) {
    this._device.internalValue = value;
  }
  public resetDevice() {
    this._device.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deviceInput() {
    return this._device.internalValue;
  }

  // weight - computed: false, optional: true, required: false
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  public resetWeight() {
    this._weight = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}
export interface DomainClockTimerCatchUp {
  /**
  * Sets the maximum time difference, in seconds, that the catch-up mechanism is allowed to correct before giving up and letting the guest stay behind; the value is a positive integer chosen by the user.
  * 
  * See: <https://libvirt.org/formatdomain.html#time-keeping>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#limit Domain#limit}
  */
  readonly limit?: number;
  /**
  * Sets the maximum speed-up factor (relative to real time) used when the guest clock is catching up after being behind the host clock; value is user-provided and typically a positive integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#time-keeping>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#slew Domain#slew}
  */
  readonly slew?: number;
  /**
  * Sets the time difference (in seconds) beyond which the catch-up mechanism is used instead of stepping the guest clock; value is user-provided and usually a positive integer (e.g. 10 or 300).
  * 
  * See: <https://libvirt.org/formatdomain.html#time-keeping>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#threshold Domain#threshold}
  */
  readonly threshold?: number;
}

export function domainClockTimerCatchUpToTerraform(struct?: DomainClockTimerCatchUp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    limit: cdktf.numberToTerraform(struct!.limit),
    slew: cdktf.numberToTerraform(struct!.slew),
    threshold: cdktf.numberToTerraform(struct!.threshold),
  }
}


export function domainClockTimerCatchUpToHclTerraform(struct?: DomainClockTimerCatchUp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    limit: {
      value: cdktf.numberToHclTerraform(struct!.limit),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    slew: {
      value: cdktf.numberToHclTerraform(struct!.slew),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    threshold: {
      value: cdktf.numberToHclTerraform(struct!.threshold),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainClockTimerCatchUpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainClockTimerCatchUp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._limit !== undefined) {
      hasAnyValues = true;
      internalValueResult.limit = this._limit;
    }
    if (this._slew !== undefined) {
      hasAnyValues = true;
      internalValueResult.slew = this._slew;
    }
    if (this._threshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.threshold = this._threshold;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainClockTimerCatchUp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._limit = undefined;
      this._slew = undefined;
      this._threshold = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._limit = value.limit;
      this._slew = value.slew;
      this._threshold = value.threshold;
    }
  }

  // limit - computed: false, optional: true, required: false
  private _limit?: number; 
  public get limit() {
    return this.getNumberAttribute('limit');
  }
  public set limit(value: number) {
    this._limit = value;
  }
  public resetLimit() {
    this._limit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitInput() {
    return this._limit;
  }

  // slew - computed: false, optional: true, required: false
  private _slew?: number; 
  public get slew() {
    return this.getNumberAttribute('slew');
  }
  public set slew(value: number) {
    this._slew = value;
  }
  public resetSlew() {
    this._slew = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get slewInput() {
    return this._slew;
  }

  // threshold - computed: false, optional: true, required: false
  private _threshold?: number; 
  public get threshold() {
    return this.getNumberAttribute('threshold');
  }
  public set threshold(value: number) {
    this._threshold = value;
  }
  public resetThreshold() {
    this._threshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get thresholdInput() {
    return this._threshold;
  }
}
export interface DomainClockTimer {
  /**
  * Configures how a timer behaves when the guest falls behind real time, enabling or tuning the “catchup” mechanism instead of an immediate jump.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#catch_up Domain#catch_up}
  */
  readonly catchUp?: DomainClockTimerCatchUp;
  /**
  * Sets the frequency of the given timer device in Hertz; value is user-provided and must be a positive integer (for example 100 or 1000) when overriding the default.
  * 
  * See: <https://libvirt.org/formatdomain.html#time-keeping>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#frequency Domain#frequency}
  */
  readonly frequency?: number;
  /**
  * Sets how the timer operates, with typical values including "auto", "native", or "emulate" depending on the timer type; value must be one of the modes supported by the chosen hypervisor/timer.
  * 
  * See: <https://libvirt.org/formatdomain.html#time-keeping>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode?: string;
  /**
  * Selects which hardware or virtual timer this entry configures (for example "rtc", "pit", "hpet", "tsc", "kvmclock"); value must be a timer name supported by the guest architecture and hypervisor.
  * 
  * See: <https://libvirt.org/formatdomain.html#time-keeping>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
  /**
  * Controls whether the specified timer is exposed to the guest, using "yes" to enable or "no" to omit it.
  * 
  * See: <https://libvirt.org/formatdomain.html#time-keeping>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#present Domain#present}
  */
  readonly present?: string;
  /**
  * Sets how missed timer ticks are handled, with valid values including "delay", "catchup", and "merge"; for example "delay" shifts subsequent ticks, while "catchup" speeds the clock up briefly.
  * 
  * See: <https://libvirt.org/formatdomain.html#time-keeping>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tick_policy Domain#tick_policy}
  */
  readonly tickPolicy?: string;
  /**
  * Controls how the guest timer tracks the host, typically using values such as "boot", "guest", or "wall" depending on the specific timer; value must be one of the tracking modes supported by the hypervisor.
  * 
  * See: <https://libvirt.org/formatdomain.html#time-keeping>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#track Domain#track}
  */
  readonly track?: string;
}

export function domainClockTimerToTerraform(struct?: DomainClockTimer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    catch_up: domainClockTimerCatchUpToTerraform(struct!.catchUp),
    frequency: cdktf.numberToTerraform(struct!.frequency),
    mode: cdktf.stringToTerraform(struct!.mode),
    name: cdktf.stringToTerraform(struct!.name),
    present: cdktf.stringToTerraform(struct!.present),
    tick_policy: cdktf.stringToTerraform(struct!.tickPolicy),
    track: cdktf.stringToTerraform(struct!.track),
  }
}


export function domainClockTimerToHclTerraform(struct?: DomainClockTimer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    catch_up: {
      value: domainClockTimerCatchUpToHclTerraform(struct!.catchUp),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainClockTimerCatchUp",
    },
    frequency: {
      value: cdktf.numberToHclTerraform(struct!.frequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    present: {
      value: cdktf.stringToHclTerraform(struct!.present),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tick_policy: {
      value: cdktf.stringToHclTerraform(struct!.tickPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    track: {
      value: cdktf.stringToHclTerraform(struct!.track),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainClockTimerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainClockTimer | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._catchUp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.catchUp = this._catchUp?.internalValue;
    }
    if (this._frequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.frequency = this._frequency;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._present !== undefined) {
      hasAnyValues = true;
      internalValueResult.present = this._present;
    }
    if (this._tickPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.tickPolicy = this._tickPolicy;
    }
    if (this._track !== undefined) {
      hasAnyValues = true;
      internalValueResult.track = this._track;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainClockTimer | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._catchUp.internalValue = undefined;
      this._frequency = undefined;
      this._mode = undefined;
      this._name = undefined;
      this._present = undefined;
      this._tickPolicy = undefined;
      this._track = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._catchUp.internalValue = value.catchUp;
      this._frequency = value.frequency;
      this._mode = value.mode;
      this._name = value.name;
      this._present = value.present;
      this._tickPolicy = value.tickPolicy;
      this._track = value.track;
    }
  }

  // catch_up - computed: false, optional: true, required: false
  private _catchUp = new DomainClockTimerCatchUpOutputReference(this, "catch_up");
  public get catchUp() {
    return this._catchUp;
  }
  public putCatchUp(value: DomainClockTimerCatchUp) {
    this._catchUp.internalValue = value;
  }
  public resetCatchUp() {
    this._catchUp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get catchUpInput() {
    return this._catchUp.internalValue;
  }

  // frequency - computed: false, optional: true, required: false
  private _frequency?: number; 
  public get frequency() {
    return this.getNumberAttribute('frequency');
  }
  public set frequency(value: number) {
    this._frequency = value;
  }
  public resetFrequency() {
    this._frequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get frequencyInput() {
    return this._frequency;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // present - computed: false, optional: true, required: false
  private _present?: string; 
  public get present() {
    return this.getStringAttribute('present');
  }
  public set present(value: string) {
    this._present = value;
  }
  public resetPresent() {
    this._present = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get presentInput() {
    return this._present;
  }

  // tick_policy - computed: false, optional: true, required: false
  private _tickPolicy?: string; 
  public get tickPolicy() {
    return this.getStringAttribute('tick_policy');
  }
  public set tickPolicy(value: string) {
    this._tickPolicy = value;
  }
  public resetTickPolicy() {
    this._tickPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tickPolicyInput() {
    return this._tickPolicy;
  }

  // track - computed: false, optional: true, required: false
  private _track?: string; 
  public get track() {
    return this.getStringAttribute('track');
  }
  public set track(value: string) {
    this._track = value;
  }
  public resetTrack() {
    this._track = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get trackInput() {
    return this._track;
  }
}

export class DomainClockTimerList extends cdktf.ComplexList {
  public internalValue? : DomainClockTimer[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainClockTimerOutputReference {
    return new DomainClockTimerOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainClock {
  /**
  * Sets a numeric time adjustment applied to the guest clock on startup or reset, interpreted in seconds unless a different unit is implied by `basis`; the value is user-provided (e.g. `-3600`).
  * 
  * See: <https://libvirt.org/formatdomain.html#time-keeping>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#adjustment Domain#adjustment}
  */
  readonly adjustment?: string;
  /**
  * Selects how `adjustment` is interpreted relative to the base time, with allowed values `utc` or `localtime`; if omitted, libvirt uses its default behavior.
  * 
  * See: <https://libvirt.org/formatdomain.html#time-keeping>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#basis Domain#basis}
  */
  readonly basis?: string;
  /**
  * Controls what time the guest sees at boot, with common values `utc`, `localtime`, `timezone`, or `variable` to follow or diverge from the host clock.
  * 
  * See: <https://libvirt.org/formatdomain.html#time-keeping>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#offset Domain#offset}
  */
  readonly offset?: string;
  /**
  * Specifies when the clock settings take effect, with valid values such as `utc`, `localtime`, or `absolute` depending on mode; the exact allowed values are driver-specific.
  * 
  * See: <https://libvirt.org/formatdomain.html#time-keeping>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#start Domain#start}
  */
  readonly start?: number;
  /**
  * Sets the IANA time zone name used when `offset` is `timezone`, such as `UTC`, `Europe/Berlin`, or `America/New_York`.
  * 
  * See: <https://libvirt.org/formatdomain.html#time-keeping>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#time_zone Domain#time_zone}
  */
  readonly timeZone?: string;
  /**
  * Defines one or more hardware or paravirtualized timers for the guest clock (e.g. HPET, KVM clock), including their policies and catch-up behavior.
  * 
  * See: <https://libvirt.org/formatdomain.html#time-keeping>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#timer Domain#timer}
  */
  readonly timer?: DomainClockTimer[] | cdktf.IResolvable;
}

export function domainClockToTerraform(struct?: DomainClock | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    adjustment: cdktf.stringToTerraform(struct!.adjustment),
    basis: cdktf.stringToTerraform(struct!.basis),
    offset: cdktf.stringToTerraform(struct!.offset),
    start: cdktf.numberToTerraform(struct!.start),
    time_zone: cdktf.stringToTerraform(struct!.timeZone),
    timer: cdktf.listMapper(domainClockTimerToTerraform, false)(struct!.timer),
  }
}


export function domainClockToHclTerraform(struct?: DomainClock | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    adjustment: {
      value: cdktf.stringToHclTerraform(struct!.adjustment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    basis: {
      value: cdktf.stringToHclTerraform(struct!.basis),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    offset: {
      value: cdktf.stringToHclTerraform(struct!.offset),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    start: {
      value: cdktf.numberToHclTerraform(struct!.start),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    time_zone: {
      value: cdktf.stringToHclTerraform(struct!.timeZone),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timer: {
      value: cdktf.listMapperHcl(domainClockTimerToHclTerraform, false)(struct!.timer),
      isBlock: true,
      type: "list",
      storageClassType: "DomainClockTimerList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainClockOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainClock | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._adjustment !== undefined) {
      hasAnyValues = true;
      internalValueResult.adjustment = this._adjustment;
    }
    if (this._basis !== undefined) {
      hasAnyValues = true;
      internalValueResult.basis = this._basis;
    }
    if (this._offset !== undefined) {
      hasAnyValues = true;
      internalValueResult.offset = this._offset;
    }
    if (this._start !== undefined) {
      hasAnyValues = true;
      internalValueResult.start = this._start;
    }
    if (this._timeZone !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeZone = this._timeZone;
    }
    if (this._timer?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timer = this._timer?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainClock | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._adjustment = undefined;
      this._basis = undefined;
      this._offset = undefined;
      this._start = undefined;
      this._timeZone = undefined;
      this._timer.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._adjustment = value.adjustment;
      this._basis = value.basis;
      this._offset = value.offset;
      this._start = value.start;
      this._timeZone = value.timeZone;
      this._timer.internalValue = value.timer;
    }
  }

  // adjustment - computed: false, optional: true, required: false
  private _adjustment?: string; 
  public get adjustment() {
    return this.getStringAttribute('adjustment');
  }
  public set adjustment(value: string) {
    this._adjustment = value;
  }
  public resetAdjustment() {
    this._adjustment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get adjustmentInput() {
    return this._adjustment;
  }

  // basis - computed: false, optional: true, required: false
  private _basis?: string; 
  public get basis() {
    return this.getStringAttribute('basis');
  }
  public set basis(value: string) {
    this._basis = value;
  }
  public resetBasis() {
    this._basis = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get basisInput() {
    return this._basis;
  }

  // offset - computed: false, optional: true, required: false
  private _offset?: string; 
  public get offset() {
    return this.getStringAttribute('offset');
  }
  public set offset(value: string) {
    this._offset = value;
  }
  public resetOffset() {
    this._offset = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get offsetInput() {
    return this._offset;
  }

  // start - computed: false, optional: true, required: false
  private _start?: number; 
  public get start() {
    return this.getNumberAttribute('start');
  }
  public set start(value: number) {
    this._start = value;
  }
  public resetStart() {
    this._start = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get startInput() {
    return this._start;
  }

  // time_zone - computed: false, optional: true, required: false
  private _timeZone?: string; 
  public get timeZone() {
    return this.getStringAttribute('time_zone');
  }
  public set timeZone(value: string) {
    this._timeZone = value;
  }
  public resetTimeZone() {
    this._timeZone = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeZoneInput() {
    return this._timeZone;
  }

  // timer - computed: false, optional: true, required: false
  private _timer = new DomainClockTimerList(this, "timer", false);
  public get timer() {
    return this._timer;
  }
  public putTimer(value: DomainClockTimer[] | cdktf.IResolvable) {
    this._timer.internalValue = value;
  }
  public resetTimer() {
    this._timer.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timerInput() {
    return this._timer.internalValue;
  }
}
export interface DomainCpuCache {
  /**
  * Sets which cache level (for example 1, 2, or 3) the cache configuration applies to; value is a user-provided positive integer corresponding to a CPU cache level.
  * 
  * See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#level Domain#level}
  */
  readonly level?: number;
  /**
  * Sets the cache configuration mode, with typical values such as "emulate" or "passthrough" depending on hypervisor support; value must be one of the cache modes allowed by libvirt for the selected CPU model.
  * 
  * See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode: string;
}

export function domainCpuCacheToTerraform(struct?: DomainCpuCache | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    level: cdktf.numberToTerraform(struct!.level),
    mode: cdktf.stringToTerraform(struct!.mode),
  }
}


export function domainCpuCacheToHclTerraform(struct?: DomainCpuCache | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    level: {
      value: cdktf.numberToHclTerraform(struct!.level),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainCpuCacheOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainCpuCache | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._level !== undefined) {
      hasAnyValues = true;
      internalValueResult.level = this._level;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainCpuCache | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._level = undefined;
      this._mode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._level = value.level;
      this._mode = value.mode;
    }
  }

  // level - computed: false, optional: true, required: false
  private _level?: number; 
  public get level() {
    return this.getNumberAttribute('level');
  }
  public set level(value: number) {
    this._level = value;
  }
  public resetLevel() {
    this._level = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get levelInput() {
    return this._level;
  }

  // mode - computed: false, optional: false, required: true
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }
}
export interface DomainCpuFeatures {
  /**
  * Names the CPU feature this entry refers to (for example "aes", "vmx", or "sse4.2"); value must be a feature identifier recognized by the underlying CPU model.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name?: string;
  /**
  * Sets the policy for the named CPU feature, commonly "force", "require", "optional", "disable", or "forbid", controlling whether the feature must, may, or must not be exposed to the guest.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#policy Domain#policy}
  */
  readonly policy?: string;
}

export function domainCpuFeaturesToTerraform(struct?: DomainCpuFeatures | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    policy: cdktf.stringToTerraform(struct!.policy),
  }
}


export function domainCpuFeaturesToHclTerraform(struct?: DomainCpuFeatures | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    policy: {
      value: cdktf.stringToHclTerraform(struct!.policy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainCpuFeaturesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainCpuFeatures | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._policy !== undefined) {
      hasAnyValues = true;
      internalValueResult.policy = this._policy;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainCpuFeatures | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._policy = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._policy = value.policy;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // policy - computed: false, optional: true, required: false
  private _policy?: string; 
  public get policy() {
    return this.getStringAttribute('policy');
  }
  public set policy(value: string) {
    this._policy = value;
  }
  public resetPolicy() {
    this._policy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get policyInput() {
    return this._policy;
  }
}

export class DomainCpuFeaturesList extends cdktf.ComplexList {
  public internalValue? : DomainCpuFeatures[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainCpuFeaturesOutputReference {
    return new DomainCpuFeaturesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainCpuMaxPhysAddr {
  /**
  * Sets the maximum number of physical address bits exposed to the guest CPU (for example 36, 40, or 48); value must be a positive integer not exceeding the host capability.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bits Domain#bits}
  */
  readonly bits?: number;
  /**
  * Sets the maximum guest-visible physical address bit width (e.g. 46) when limiting the CPU's physical address space; the value is user-provided and interpreted according to the selected mode.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#limit Domain#limit}
  */
  readonly limit?: number;
  /**
  * Selects how the max physical address limit is applied, with valid values documented by libvirt such as "emulate", "passthrough", or similar driver-specific modes; this attribute is required whenever a max_phys_addr limit is defined.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode: string;
}

export function domainCpuMaxPhysAddrToTerraform(struct?: DomainCpuMaxPhysAddr | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bits: cdktf.numberToTerraform(struct!.bits),
    limit: cdktf.numberToTerraform(struct!.limit),
    mode: cdktf.stringToTerraform(struct!.mode),
  }
}


export function domainCpuMaxPhysAddrToHclTerraform(struct?: DomainCpuMaxPhysAddr | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bits: {
      value: cdktf.numberToHclTerraform(struct!.bits),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    limit: {
      value: cdktf.numberToHclTerraform(struct!.limit),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainCpuMaxPhysAddrOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainCpuMaxPhysAddr | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bits !== undefined) {
      hasAnyValues = true;
      internalValueResult.bits = this._bits;
    }
    if (this._limit !== undefined) {
      hasAnyValues = true;
      internalValueResult.limit = this._limit;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainCpuMaxPhysAddr | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bits = undefined;
      this._limit = undefined;
      this._mode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bits = value.bits;
      this._limit = value.limit;
      this._mode = value.mode;
    }
  }

  // bits - computed: false, optional: true, required: false
  private _bits?: number; 
  public get bits() {
    return this.getNumberAttribute('bits');
  }
  public set bits(value: number) {
    this._bits = value;
  }
  public resetBits() {
    this._bits = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bitsInput() {
    return this._bits;
  }

  // limit - computed: false, optional: true, required: false
  private _limit?: number; 
  public get limit() {
    return this.getNumberAttribute('limit');
  }
  public set limit(value: number) {
    this._limit = value;
  }
  public resetLimit() {
    this._limit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitInput() {
    return this._limit;
  }

  // mode - computed: false, optional: false, required: true
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }
}
export interface DomainCpuNumaCellCachesLine {
  /**
  * Sets the unit for the cache line size, typically "bytes" or another libvirt-supported unit string.
  * 
  * See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#unit Domain#unit}
  */
  readonly unit: string;
  /**
  * Sets the numeric cache line size in the given unit, as a user-provided positive integer (for example 64 or 128).
  * 
  * See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#value Domain#value}
  */
  readonly value: string;
}

export function domainCpuNumaCellCachesLineToTerraform(struct?: DomainCpuNumaCellCachesLine | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    unit: cdktf.stringToTerraform(struct!.unit),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function domainCpuNumaCellCachesLineToHclTerraform(struct?: DomainCpuNumaCellCachesLine | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    unit: {
      value: cdktf.stringToHclTerraform(struct!.unit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainCpuNumaCellCachesLineOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainCpuNumaCellCachesLine | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._unit !== undefined) {
      hasAnyValues = true;
      internalValueResult.unit = this._unit;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainCpuNumaCellCachesLine | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._unit = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._unit = value.unit;
      this._value = value.value;
    }
  }

  // unit - computed: false, optional: false, required: true
  private _unit?: string; 
  public get unit() {
    return this.getStringAttribute('unit');
  }
  public set unit(value: string) {
    this._unit = value;
  }
  // Temporarily expose input value. Use with caution.
  public get unitInput() {
    return this._unit;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DomainCpuNumaCellCachesSize {
  /**
  * Sets the unit for the cache size, such as "KiB", "MiB", or "GiB" as supported by libvirt.
  * 
  * See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#unit Domain#unit}
  */
  readonly unit: string;
  /**
  * Sets the numeric cache size in the given unit, as a user-provided positive integer (for example 256 or 1024).
  * 
  * See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#value Domain#value}
  */
  readonly value: string;
}

export function domainCpuNumaCellCachesSizeToTerraform(struct?: DomainCpuNumaCellCachesSize | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    unit: cdktf.stringToTerraform(struct!.unit),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function domainCpuNumaCellCachesSizeToHclTerraform(struct?: DomainCpuNumaCellCachesSize | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    unit: {
      value: cdktf.stringToHclTerraform(struct!.unit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainCpuNumaCellCachesSizeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainCpuNumaCellCachesSize | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._unit !== undefined) {
      hasAnyValues = true;
      internalValueResult.unit = this._unit;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainCpuNumaCellCachesSize | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._unit = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._unit = value.unit;
      this._value = value.value;
    }
  }

  // unit - computed: false, optional: false, required: true
  private _unit?: string; 
  public get unit() {
    return this.getStringAttribute('unit');
  }
  public set unit(value: string) {
    this._unit = value;
  }
  // Temporarily expose input value. Use with caution.
  public get unitInput() {
    return this._unit;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DomainCpuNumaCellCaches {
  /**
  * Sets the cache associativity policy (for example "direct", "none", or other user-provided policy names) for a memory-side cache in a NUMA cell.
  * 
  * See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#associativity Domain#associativity}
  */
  readonly associativity: string;
  /**
  * Specifies the cache level (e.g. 1, 2, 3) for a memory-side cache in a NUMA cell, as a user-provided integer indicating hierarchy depth.
  * 
  * See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#level Domain#level}
  */
  readonly level: number;
  /**
  * Configures the cache line size for a memory-side cache in a NUMA cell, via a value and unit pair.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#line Domain#line}
  */
  readonly line?: DomainCpuNumaCellCachesLine;
  /**
  * Defines the caching policy for a memory-side cache (for example "writeback" or "writethrough") controlling how memory traffic is cached.
  * 
  * See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#policy Domain#policy}
  */
  readonly policy: string;
  /**
  * Configures the total size of a memory-side cache in a NUMA cell, via a value and unit pair.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#size Domain#size}
  */
  readonly size?: DomainCpuNumaCellCachesSize;
}

export function domainCpuNumaCellCachesToTerraform(struct?: DomainCpuNumaCellCaches | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    associativity: cdktf.stringToTerraform(struct!.associativity),
    level: cdktf.numberToTerraform(struct!.level),
    line: domainCpuNumaCellCachesLineToTerraform(struct!.line),
    policy: cdktf.stringToTerraform(struct!.policy),
    size: domainCpuNumaCellCachesSizeToTerraform(struct!.size),
  }
}


export function domainCpuNumaCellCachesToHclTerraform(struct?: DomainCpuNumaCellCaches | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    associativity: {
      value: cdktf.stringToHclTerraform(struct!.associativity),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    level: {
      value: cdktf.numberToHclTerraform(struct!.level),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    line: {
      value: domainCpuNumaCellCachesLineToHclTerraform(struct!.line),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainCpuNumaCellCachesLine",
    },
    policy: {
      value: cdktf.stringToHclTerraform(struct!.policy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    size: {
      value: domainCpuNumaCellCachesSizeToHclTerraform(struct!.size),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainCpuNumaCellCachesSize",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainCpuNumaCellCachesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainCpuNumaCellCaches | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._associativity !== undefined) {
      hasAnyValues = true;
      internalValueResult.associativity = this._associativity;
    }
    if (this._level !== undefined) {
      hasAnyValues = true;
      internalValueResult.level = this._level;
    }
    if (this._line?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.line = this._line?.internalValue;
    }
    if (this._policy !== undefined) {
      hasAnyValues = true;
      internalValueResult.policy = this._policy;
    }
    if (this._size?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.size = this._size?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainCpuNumaCellCaches | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._associativity = undefined;
      this._level = undefined;
      this._line.internalValue = undefined;
      this._policy = undefined;
      this._size.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._associativity = value.associativity;
      this._level = value.level;
      this._line.internalValue = value.line;
      this._policy = value.policy;
      this._size.internalValue = value.size;
    }
  }

  // associativity - computed: false, optional: false, required: true
  private _associativity?: string; 
  public get associativity() {
    return this.getStringAttribute('associativity');
  }
  public set associativity(value: string) {
    this._associativity = value;
  }
  // Temporarily expose input value. Use with caution.
  public get associativityInput() {
    return this._associativity;
  }

  // level - computed: false, optional: false, required: true
  private _level?: number; 
  public get level() {
    return this.getNumberAttribute('level');
  }
  public set level(value: number) {
    this._level = value;
  }
  // Temporarily expose input value. Use with caution.
  public get levelInput() {
    return this._level;
  }

  // line - computed: false, optional: true, required: false
  private _line = new DomainCpuNumaCellCachesLineOutputReference(this, "line");
  public get line() {
    return this._line;
  }
  public putLine(value: DomainCpuNumaCellCachesLine) {
    this._line.internalValue = value;
  }
  public resetLine() {
    this._line.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lineInput() {
    return this._line.internalValue;
  }

  // policy - computed: false, optional: false, required: true
  private _policy?: string; 
  public get policy() {
    return this.getStringAttribute('policy');
  }
  public set policy(value: string) {
    this._policy = value;
  }
  // Temporarily expose input value. Use with caution.
  public get policyInput() {
    return this._policy;
  }

  // size - computed: false, optional: true, required: false
  private _size = new DomainCpuNumaCellCachesSizeOutputReference(this, "size");
  public get size() {
    return this._size;
  }
  public putSize(value: DomainCpuNumaCellCachesSize) {
    this._size.internalValue = value;
  }
  public resetSize() {
    this._size.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sizeInput() {
    return this._size.internalValue;
  }
}

export class DomainCpuNumaCellCachesList extends cdktf.ComplexList {
  public internalValue? : DomainCpuNumaCellCaches[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainCpuNumaCellCachesOutputReference {
    return new DomainCpuNumaCellCachesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainCpuNumaCellDistancesSiblings {
  /**
  * Sets the relative NUMA distance (an integer cost metric) from this cell to the referenced sibling cell; value is user‑provided, e.g. 10 for local, 20 for remote.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#value Domain#value}
  */
  readonly value: number;
}

export function domainCpuNumaCellDistancesSiblingsToTerraform(struct?: DomainCpuNumaCellDistancesSiblings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function domainCpuNumaCellDistancesSiblingsToHclTerraform(struct?: DomainCpuNumaCellDistancesSiblings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainCpuNumaCellDistancesSiblingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainCpuNumaCellDistancesSiblings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainCpuNumaCellDistancesSiblings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._value = value.value;
    }
  }

  // id - computed: true, optional: false, required: false
  public get id() {
    return this.getNumberAttribute('id');
  }

  // value - computed: false, optional: false, required: true
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DomainCpuNumaCellDistancesSiblingsList extends cdktf.ComplexList {
  public internalValue? : DomainCpuNumaCellDistancesSiblings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainCpuNumaCellDistancesSiblingsOutputReference {
    return new DomainCpuNumaCellDistancesSiblingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainCpuNumaCellDistances {
  /**
  * Lists individual NUMA distance entries from this cell to sibling NUMA cells.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#siblings Domain#siblings}
  */
  readonly siblings?: DomainCpuNumaCellDistancesSiblings[] | cdktf.IResolvable;
}

export function domainCpuNumaCellDistancesToTerraform(struct?: DomainCpuNumaCellDistances | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    siblings: cdktf.listMapper(domainCpuNumaCellDistancesSiblingsToTerraform, false)(struct!.siblings),
  }
}


export function domainCpuNumaCellDistancesToHclTerraform(struct?: DomainCpuNumaCellDistances | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    siblings: {
      value: cdktf.listMapperHcl(domainCpuNumaCellDistancesSiblingsToHclTerraform, false)(struct!.siblings),
      isBlock: true,
      type: "list",
      storageClassType: "DomainCpuNumaCellDistancesSiblingsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainCpuNumaCellDistancesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainCpuNumaCellDistances | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._siblings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.siblings = this._siblings?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainCpuNumaCellDistances | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._siblings.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._siblings.internalValue = value.siblings;
    }
  }

  // siblings - computed: false, optional: true, required: false
  private _siblings = new DomainCpuNumaCellDistancesSiblingsList(this, "siblings", false);
  public get siblings() {
    return this._siblings;
  }
  public putSiblings(value: DomainCpuNumaCellDistancesSiblings[] | cdktf.IResolvable) {
    this._siblings.internalValue = value;
  }
  public resetSiblings() {
    this._siblings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get siblingsInput() {
    return this._siblings.internalValue;
  }
}
export interface DomainCpuNumaCell {
  /**
  * Lists one or more memory-side cache definitions associated with a NUMA cell, describing cache levels and characteristics for heterogeneous memory.
  * 
  * See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#caches Domain#caches}
  */
  readonly caches?: DomainCpuNumaCellCaches[] | cdktf.IResolvable;
  /**
  * Specifies which vCPUs belong to a NUMA cell using a CPU list or range syntax accepted by libvirt (e.g. "0-3,8").
  * 
  * See: <https://libvirt.org/formatdomain.html#numa-node-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#cpus Domain#cpus}
  */
  readonly cpus?: string;
  /**
  * Sets whether pages from this NUMA cell’s memory can be discarded (hinting to the hypervisor that the memory is reclaimable); value is user‑provided, typically a yes/no style flag if supported.
  * 
  * See: <https://libvirt.org/formatdomain.html#numa-node-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#discard Domain#discard}
  */
  readonly discard?: string;
  /**
  * Configures per‑cell NUMA distance information for this virtual NUMA cell, defining relative access costs to other cells.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#distances Domain#distances}
  */
  readonly distances?: DomainCpuNumaCellDistances;
  /**
  * Sets the memory access policy for this NUMA cell (for example, whether memory is preferred, interleaved, or restricted to this node); value is user‑provided according to hypervisor‑supported policies.
  * 
  * See: <https://libvirt.org/formatdomain.html#numa-node-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mem_access Domain#mem_access}
  */
  readonly memAccess?: string;
  /**
  * Sets the amount of memory assigned to this NUMA cell; value is required and given as a numeric quantity interpreted according to the associated unit.
  * 
  * See: <https://libvirt.org/formatdomain.html#numa-node-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#memory Domain#memory}
  */
  readonly memory: number;
  /**
  * Sets the unit for the NUMA cell memory value (for example "KiB", "MiB", or "GiB"); value is user‑provided and must be a libvirt‑supported memory unit.
  * 
  * See: <https://libvirt.org/formatdomain.html#memory-allocation>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#unit Domain#unit}
  */
  readonly unit?: string;
}

export function domainCpuNumaCellToTerraform(struct?: DomainCpuNumaCell | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    caches: cdktf.listMapper(domainCpuNumaCellCachesToTerraform, false)(struct!.caches),
    cpus: cdktf.stringToTerraform(struct!.cpus),
    discard: cdktf.stringToTerraform(struct!.discard),
    distances: domainCpuNumaCellDistancesToTerraform(struct!.distances),
    mem_access: cdktf.stringToTerraform(struct!.memAccess),
    memory: cdktf.numberToTerraform(struct!.memory),
    unit: cdktf.stringToTerraform(struct!.unit),
  }
}


export function domainCpuNumaCellToHclTerraform(struct?: DomainCpuNumaCell | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    caches: {
      value: cdktf.listMapperHcl(domainCpuNumaCellCachesToHclTerraform, false)(struct!.caches),
      isBlock: true,
      type: "list",
      storageClassType: "DomainCpuNumaCellCachesList",
    },
    cpus: {
      value: cdktf.stringToHclTerraform(struct!.cpus),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    discard: {
      value: cdktf.stringToHclTerraform(struct!.discard),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    distances: {
      value: domainCpuNumaCellDistancesToHclTerraform(struct!.distances),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainCpuNumaCellDistances",
    },
    mem_access: {
      value: cdktf.stringToHclTerraform(struct!.memAccess),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory: {
      value: cdktf.numberToHclTerraform(struct!.memory),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    unit: {
      value: cdktf.stringToHclTerraform(struct!.unit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainCpuNumaCellOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainCpuNumaCell | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caches?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.caches = this._caches?.internalValue;
    }
    if (this._cpus !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpus = this._cpus;
    }
    if (this._discard !== undefined) {
      hasAnyValues = true;
      internalValueResult.discard = this._discard;
    }
    if (this._distances?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.distances = this._distances?.internalValue;
    }
    if (this._memAccess !== undefined) {
      hasAnyValues = true;
      internalValueResult.memAccess = this._memAccess;
    }
    if (this._memory !== undefined) {
      hasAnyValues = true;
      internalValueResult.memory = this._memory;
    }
    if (this._unit !== undefined) {
      hasAnyValues = true;
      internalValueResult.unit = this._unit;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainCpuNumaCell | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caches.internalValue = undefined;
      this._cpus = undefined;
      this._discard = undefined;
      this._distances.internalValue = undefined;
      this._memAccess = undefined;
      this._memory = undefined;
      this._unit = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caches.internalValue = value.caches;
      this._cpus = value.cpus;
      this._discard = value.discard;
      this._distances.internalValue = value.distances;
      this._memAccess = value.memAccess;
      this._memory = value.memory;
      this._unit = value.unit;
    }
  }

  // caches - computed: false, optional: true, required: false
  private _caches = new DomainCpuNumaCellCachesList(this, "caches", false);
  public get caches() {
    return this._caches;
  }
  public putCaches(value: DomainCpuNumaCellCaches[] | cdktf.IResolvable) {
    this._caches.internalValue = value;
  }
  public resetCaches() {
    this._caches.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cachesInput() {
    return this._caches.internalValue;
  }

  // cpus - computed: false, optional: true, required: false
  private _cpus?: string; 
  public get cpus() {
    return this.getStringAttribute('cpus');
  }
  public set cpus(value: string) {
    this._cpus = value;
  }
  public resetCpus() {
    this._cpus = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpusInput() {
    return this._cpus;
  }

  // discard - computed: false, optional: true, required: false
  private _discard?: string; 
  public get discard() {
    return this.getStringAttribute('discard');
  }
  public set discard(value: string) {
    this._discard = value;
  }
  public resetDiscard() {
    this._discard = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get discardInput() {
    return this._discard;
  }

  // distances - computed: false, optional: true, required: false
  private _distances = new DomainCpuNumaCellDistancesOutputReference(this, "distances");
  public get distances() {
    return this._distances;
  }
  public putDistances(value: DomainCpuNumaCellDistances) {
    this._distances.internalValue = value;
  }
  public resetDistances() {
    this._distances.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get distancesInput() {
    return this._distances.internalValue;
  }

  // id - computed: true, optional: false, required: false
  public get id() {
    return this.getNumberAttribute('id');
  }

  // mem_access - computed: false, optional: true, required: false
  private _memAccess?: string; 
  public get memAccess() {
    return this.getStringAttribute('mem_access');
  }
  public set memAccess(value: string) {
    this._memAccess = value;
  }
  public resetMemAccess() {
    this._memAccess = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memAccessInput() {
    return this._memAccess;
  }

  // memory - computed: false, optional: false, required: true
  private _memory?: number; 
  public get memory() {
    return this.getNumberAttribute('memory');
  }
  public set memory(value: number) {
    this._memory = value;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryInput() {
    return this._memory;
  }

  // unit - computed: false, optional: true, required: false
  private _unit?: string; 
  public get unit() {
    return this.getStringAttribute('unit');
  }
  public set unit(value: string) {
    this._unit = value;
  }
  public resetUnit() {
    this._unit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unitInput() {
    return this._unit;
  }
}

export class DomainCpuNumaCellList extends cdktf.ComplexList {
  public internalValue? : DomainCpuNumaCell[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainCpuNumaCellOutputReference {
    return new DomainCpuNumaCellOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainCpuNumaInterconnectsBandwidths {
  /**
  * Optionally associates the bandwidth measurement with a specific memory side cache level or instance; value is user‑provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#cache Domain#cache}
  */
  readonly cache?: number;
  /**
  * Sets the ID of the initiator NUMA cell for this bandwidth entry; value is required and must match an existing NUMA cell ID.
  * 
  * See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#initiator Domain#initiator}
  */
  readonly initiator: number;
  /**
  * Sets the ID of the target NUMA cell whose link from the initiator is being described; value is required and must match an existing NUMA cell ID.
  * 
  * See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#target Domain#target}
  */
  readonly target: number;
  /**
  * Sets the bandwidth type being described (for example read, write, or aggregate), as a user‑provided string understood by the hypervisor.
  * 
  * See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type: string;
  /**
  * Sets the unit of the bandwidth value, such as "MB/s"; value is required and must be a libvirt‑supported bandwidth unit.
  * 
  * See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#unit Domain#unit}
  */
  readonly unit: string;
  /**
  * Sets the numeric bandwidth for the interconnect between the initiator and target cells in the given unit; value is required and user‑provided (e.g. 500 for 500 MB/s).
  * 
  * See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#value Domain#value}
  */
  readonly value: number;
}

export function domainCpuNumaInterconnectsBandwidthsToTerraform(struct?: DomainCpuNumaInterconnectsBandwidths | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cache: cdktf.numberToTerraform(struct!.cache),
    initiator: cdktf.numberToTerraform(struct!.initiator),
    target: cdktf.numberToTerraform(struct!.target),
    type: cdktf.stringToTerraform(struct!.type),
    unit: cdktf.stringToTerraform(struct!.unit),
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function domainCpuNumaInterconnectsBandwidthsToHclTerraform(struct?: DomainCpuNumaInterconnectsBandwidths | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cache: {
      value: cdktf.numberToHclTerraform(struct!.cache),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initiator: {
      value: cdktf.numberToHclTerraform(struct!.initiator),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    target: {
      value: cdktf.numberToHclTerraform(struct!.target),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    unit: {
      value: cdktf.stringToHclTerraform(struct!.unit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainCpuNumaInterconnectsBandwidthsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainCpuNumaInterconnectsBandwidths | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cache !== undefined) {
      hasAnyValues = true;
      internalValueResult.cache = this._cache;
    }
    if (this._initiator !== undefined) {
      hasAnyValues = true;
      internalValueResult.initiator = this._initiator;
    }
    if (this._target !== undefined) {
      hasAnyValues = true;
      internalValueResult.target = this._target;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._unit !== undefined) {
      hasAnyValues = true;
      internalValueResult.unit = this._unit;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainCpuNumaInterconnectsBandwidths | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cache = undefined;
      this._initiator = undefined;
      this._target = undefined;
      this._type = undefined;
      this._unit = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cache = value.cache;
      this._initiator = value.initiator;
      this._target = value.target;
      this._type = value.type;
      this._unit = value.unit;
      this._value = value.value;
    }
  }

  // cache - computed: false, optional: true, required: false
  private _cache?: number; 
  public get cache() {
    return this.getNumberAttribute('cache');
  }
  public set cache(value: number) {
    this._cache = value;
  }
  public resetCache() {
    this._cache = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cacheInput() {
    return this._cache;
  }

  // initiator - computed: false, optional: false, required: true
  private _initiator?: number; 
  public get initiator() {
    return this.getNumberAttribute('initiator');
  }
  public set initiator(value: number) {
    this._initiator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get initiatorInput() {
    return this._initiator;
  }

  // target - computed: false, optional: false, required: true
  private _target?: number; 
  public get target() {
    return this.getNumberAttribute('target');
  }
  public set target(value: number) {
    this._target = value;
  }
  // Temporarily expose input value. Use with caution.
  public get targetInput() {
    return this._target;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // unit - computed: false, optional: false, required: true
  private _unit?: string; 
  public get unit() {
    return this.getStringAttribute('unit');
  }
  public set unit(value: string) {
    this._unit = value;
  }
  // Temporarily expose input value. Use with caution.
  public get unitInput() {
    return this._unit;
  }

  // value - computed: false, optional: false, required: true
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DomainCpuNumaInterconnectsBandwidthsList extends cdktf.ComplexList {
  public internalValue? : DomainCpuNumaInterconnectsBandwidths[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainCpuNumaInterconnectsBandwidthsOutputReference {
    return new DomainCpuNumaInterconnectsBandwidthsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainCpuNumaInterconnectsLatencies {
  /**
  * Optionally associates the latency measurement with a specific memory side cache; value is user‑provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#cache Domain#cache}
  */
  readonly cache?: number;
  /**
  * Sets the ID of the initiator NUMA cell for this latency entry; value is required and must correspond to an existing NUMA cell ID.
  * 
  * See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#initiator Domain#initiator}
  */
  readonly initiator: number;
  /**
  * Sets the target NUMA cell ID for this latency entry, identifying which remote node this latency measurement applies to; value is user-provided and must match an existing NUMA cell index.
  * 
  * See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#target Domain#target}
  */
  readonly target: number;
  /**
  * Sets the type of latency being described between NUMA cells (for example, read, write, or generic access latency); value is user-provided, with allowed tokens defined by the hypervisor.
  * 
  * See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type: string;
  /**
  * Sets the numeric latency value for this NUMA interconnect entry, in the unit implied by the chosen type (for example, nanoseconds); value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#value Domain#value}
  */
  readonly value: number;
}

export function domainCpuNumaInterconnectsLatenciesToTerraform(struct?: DomainCpuNumaInterconnectsLatencies | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cache: cdktf.numberToTerraform(struct!.cache),
    initiator: cdktf.numberToTerraform(struct!.initiator),
    target: cdktf.numberToTerraform(struct!.target),
    type: cdktf.stringToTerraform(struct!.type),
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function domainCpuNumaInterconnectsLatenciesToHclTerraform(struct?: DomainCpuNumaInterconnectsLatencies | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cache: {
      value: cdktf.numberToHclTerraform(struct!.cache),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initiator: {
      value: cdktf.numberToHclTerraform(struct!.initiator),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    target: {
      value: cdktf.numberToHclTerraform(struct!.target),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainCpuNumaInterconnectsLatenciesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainCpuNumaInterconnectsLatencies | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cache !== undefined) {
      hasAnyValues = true;
      internalValueResult.cache = this._cache;
    }
    if (this._initiator !== undefined) {
      hasAnyValues = true;
      internalValueResult.initiator = this._initiator;
    }
    if (this._target !== undefined) {
      hasAnyValues = true;
      internalValueResult.target = this._target;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainCpuNumaInterconnectsLatencies | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cache = undefined;
      this._initiator = undefined;
      this._target = undefined;
      this._type = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cache = value.cache;
      this._initiator = value.initiator;
      this._target = value.target;
      this._type = value.type;
      this._value = value.value;
    }
  }

  // cache - computed: false, optional: true, required: false
  private _cache?: number; 
  public get cache() {
    return this.getNumberAttribute('cache');
  }
  public set cache(value: number) {
    this._cache = value;
  }
  public resetCache() {
    this._cache = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cacheInput() {
    return this._cache;
  }

  // initiator - computed: false, optional: false, required: true
  private _initiator?: number; 
  public get initiator() {
    return this.getNumberAttribute('initiator');
  }
  public set initiator(value: number) {
    this._initiator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get initiatorInput() {
    return this._initiator;
  }

  // target - computed: false, optional: false, required: true
  private _target?: number; 
  public get target() {
    return this.getNumberAttribute('target');
  }
  public set target(value: number) {
    this._target = value;
  }
  // Temporarily expose input value. Use with caution.
  public get targetInput() {
    return this._target;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // value - computed: false, optional: false, required: true
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DomainCpuNumaInterconnectsLatenciesList extends cdktf.ComplexList {
  public internalValue? : DomainCpuNumaInterconnectsLatencies[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainCpuNumaInterconnectsLatenciesOutputReference {
    return new DomainCpuNumaInterconnectsLatenciesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainCpuNumaInterconnects {
  /**
  * Defines one or more bandwidth descriptors for interconnect links between initiator and target NUMA cells.
  * 
  * See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bandwidths Domain#bandwidths}
  */
  readonly bandwidths?: DomainCpuNumaInterconnectsBandwidths[] | cdktf.IResolvable;
  /**
  * Defines one or more latency descriptors for interconnect links between initiator and target NUMA cells.
  * 
  * See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#latencies Domain#latencies}
  */
  readonly latencies?: DomainCpuNumaInterconnectsLatencies[] | cdktf.IResolvable;
}

export function domainCpuNumaInterconnectsToTerraform(struct?: DomainCpuNumaInterconnects | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bandwidths: cdktf.listMapper(domainCpuNumaInterconnectsBandwidthsToTerraform, false)(struct!.bandwidths),
    latencies: cdktf.listMapper(domainCpuNumaInterconnectsLatenciesToTerraform, false)(struct!.latencies),
  }
}


export function domainCpuNumaInterconnectsToHclTerraform(struct?: DomainCpuNumaInterconnects | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bandwidths: {
      value: cdktf.listMapperHcl(domainCpuNumaInterconnectsBandwidthsToHclTerraform, false)(struct!.bandwidths),
      isBlock: true,
      type: "list",
      storageClassType: "DomainCpuNumaInterconnectsBandwidthsList",
    },
    latencies: {
      value: cdktf.listMapperHcl(domainCpuNumaInterconnectsLatenciesToHclTerraform, false)(struct!.latencies),
      isBlock: true,
      type: "list",
      storageClassType: "DomainCpuNumaInterconnectsLatenciesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainCpuNumaInterconnectsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainCpuNumaInterconnects | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bandwidths?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bandwidths = this._bandwidths?.internalValue;
    }
    if (this._latencies?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.latencies = this._latencies?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainCpuNumaInterconnects | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bandwidths.internalValue = undefined;
      this._latencies.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bandwidths.internalValue = value.bandwidths;
      this._latencies.internalValue = value.latencies;
    }
  }

  // bandwidths - computed: false, optional: true, required: false
  private _bandwidths = new DomainCpuNumaInterconnectsBandwidthsList(this, "bandwidths", false);
  public get bandwidths() {
    return this._bandwidths;
  }
  public putBandwidths(value: DomainCpuNumaInterconnectsBandwidths[] | cdktf.IResolvable) {
    this._bandwidths.internalValue = value;
  }
  public resetBandwidths() {
    this._bandwidths.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bandwidthsInput() {
    return this._bandwidths.internalValue;
  }

  // latencies - computed: false, optional: true, required: false
  private _latencies = new DomainCpuNumaInterconnectsLatenciesList(this, "latencies", false);
  public get latencies() {
    return this._latencies;
  }
  public putLatencies(value: DomainCpuNumaInterconnectsLatencies[] | cdktf.IResolvable) {
    this._latencies.internalValue = value;
  }
  public resetLatencies() {
    this._latencies.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get latenciesInput() {
    return this._latencies.internalValue;
  }
}
export interface DomainCpuNuma {
  /**
  * Defines a single NUMA cell in the guest, including its CPUs, memory, and optional memory-side cache configuration; multiple cells can be specified for multi-node topologies.
  * 
  * See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#cell Domain#cell}
  */
  readonly cell?: DomainCpuNumaCell[] | cdktf.IResolvable;
  /**
  * Configures additional NUMA interconnect properties such as per‑pair bandwidth and latency between virtual NUMA cells.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#interconnects Domain#interconnects}
  */
  readonly interconnects?: DomainCpuNumaInterconnects;
}

export function domainCpuNumaToTerraform(struct?: DomainCpuNuma | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cell: cdktf.listMapper(domainCpuNumaCellToTerraform, false)(struct!.cell),
    interconnects: domainCpuNumaInterconnectsToTerraform(struct!.interconnects),
  }
}


export function domainCpuNumaToHclTerraform(struct?: DomainCpuNuma | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cell: {
      value: cdktf.listMapperHcl(domainCpuNumaCellToHclTerraform, false)(struct!.cell),
      isBlock: true,
      type: "list",
      storageClassType: "DomainCpuNumaCellList",
    },
    interconnects: {
      value: domainCpuNumaInterconnectsToHclTerraform(struct!.interconnects),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainCpuNumaInterconnects",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainCpuNumaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainCpuNuma | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cell?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cell = this._cell?.internalValue;
    }
    if (this._interconnects?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.interconnects = this._interconnects?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainCpuNuma | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cell.internalValue = undefined;
      this._interconnects.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cell.internalValue = value.cell;
      this._interconnects.internalValue = value.interconnects;
    }
  }

  // cell - computed: false, optional: true, required: false
  private _cell = new DomainCpuNumaCellList(this, "cell", false);
  public get cell() {
    return this._cell;
  }
  public putCell(value: DomainCpuNumaCell[] | cdktf.IResolvable) {
    this._cell.internalValue = value;
  }
  public resetCell() {
    this._cell.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cellInput() {
    return this._cell.internalValue;
  }

  // interconnects - computed: false, optional: true, required: false
  private _interconnects = new DomainCpuNumaInterconnectsOutputReference(this, "interconnects");
  public get interconnects() {
    return this._interconnects;
  }
  public putInterconnects(value: DomainCpuNumaInterconnects) {
    this._interconnects.internalValue = value;
  }
  public resetInterconnects() {
    this._interconnects.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interconnectsInput() {
    return this._interconnects.internalValue;
  }
}
export interface DomainCpuTopology {
  /**
  * Sets the number of CPU clusters per die in the guest CPU topology; value is a positive integer and is optional.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#clusters Domain#clusters}
  */
  readonly clusters?: number;
  /**
  * Sets the number of CPU cores per socket (or per cluster, depending on machine type) in the guest; value is a positive integer and should multiply with sockets, dies, clusters, and threads to match the vCPU count.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#cores Domain#cores}
  */
  readonly cores?: number;
  /**
  * Sets the number of CPU dies per socket in the guest; value is a positive integer and is optional.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dies Domain#dies}
  */
  readonly dies?: number;
  /**
  * Sets the number of CPU sockets in the guest; value is a positive integer and participates in the overall vCPU count calculation.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sockets Domain#sockets}
  */
  readonly sockets?: number;
  /**
  * Sets the number of hardware threads (hyper-threads) per core in the guest; value is a positive integer (commonly 1 or 2).
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#threads Domain#threads}
  */
  readonly threads?: number;
}

export function domainCpuTopologyToTerraform(struct?: DomainCpuTopology | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    clusters: cdktf.numberToTerraform(struct!.clusters),
    cores: cdktf.numberToTerraform(struct!.cores),
    dies: cdktf.numberToTerraform(struct!.dies),
    sockets: cdktf.numberToTerraform(struct!.sockets),
    threads: cdktf.numberToTerraform(struct!.threads),
  }
}


export function domainCpuTopologyToHclTerraform(struct?: DomainCpuTopology | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    clusters: {
      value: cdktf.numberToHclTerraform(struct!.clusters),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    cores: {
      value: cdktf.numberToHclTerraform(struct!.cores),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    dies: {
      value: cdktf.numberToHclTerraform(struct!.dies),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    sockets: {
      value: cdktf.numberToHclTerraform(struct!.sockets),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    threads: {
      value: cdktf.numberToHclTerraform(struct!.threads),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainCpuTopologyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainCpuTopology | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clusters !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusters = this._clusters;
    }
    if (this._cores !== undefined) {
      hasAnyValues = true;
      internalValueResult.cores = this._cores;
    }
    if (this._dies !== undefined) {
      hasAnyValues = true;
      internalValueResult.dies = this._dies;
    }
    if (this._sockets !== undefined) {
      hasAnyValues = true;
      internalValueResult.sockets = this._sockets;
    }
    if (this._threads !== undefined) {
      hasAnyValues = true;
      internalValueResult.threads = this._threads;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainCpuTopology | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clusters = undefined;
      this._cores = undefined;
      this._dies = undefined;
      this._sockets = undefined;
      this._threads = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clusters = value.clusters;
      this._cores = value.cores;
      this._dies = value.dies;
      this._sockets = value.sockets;
      this._threads = value.threads;
    }
  }

  // clusters - computed: false, optional: true, required: false
  private _clusters?: number; 
  public get clusters() {
    return this.getNumberAttribute('clusters');
  }
  public set clusters(value: number) {
    this._clusters = value;
  }
  public resetClusters() {
    this._clusters = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clustersInput() {
    return this._clusters;
  }

  // cores - computed: false, optional: true, required: false
  private _cores?: number; 
  public get cores() {
    return this.getNumberAttribute('cores');
  }
  public set cores(value: number) {
    this._cores = value;
  }
  public resetCores() {
    this._cores = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get coresInput() {
    return this._cores;
  }

  // dies - computed: false, optional: true, required: false
  private _dies?: number; 
  public get dies() {
    return this.getNumberAttribute('dies');
  }
  public set dies(value: number) {
    this._dies = value;
  }
  public resetDies() {
    this._dies = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get diesInput() {
    return this._dies;
  }

  // sockets - computed: false, optional: true, required: false
  private _sockets?: number; 
  public get sockets() {
    return this.getNumberAttribute('sockets');
  }
  public set sockets(value: number) {
    this._sockets = value;
  }
  public resetSockets() {
    this._sockets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketsInput() {
    return this._sockets;
  }

  // threads - computed: false, optional: true, required: false
  private _threads?: number; 
  public get threads() {
    return this.getNumberAttribute('threads');
  }
  public set threads(value: number) {
    this._threads = value;
  }
  public resetThreads() {
    this._threads = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get threadsInput() {
    return this._threads;
  }
}
export interface DomainCpu {
  /**
  * Configures CPU cache behavior for the guest, such as whether to copy or passthrough host cache information at a specific cache level.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#cache Domain#cache}
  */
  readonly cache?: DomainCpuCache;
  /**
  * Controls how strictly the hypervisor verifies that the requested CPU model and features are supported on the host, with values like "none", "partial", or "full".
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#check Domain#check}
  */
  readonly check?: string;
  /**
  * Sets whether deprecated CPU features are allowed, typically using values such as "allow", "forbid", or "require" depending on host and hypervisor support.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#deprecated_features Domain#deprecated_features}
  */
  readonly deprecatedFeatures?: string;
  /**
  * Lists additional per-feature overrides to enable, disable, or require specific CPU instruction set features for the guest.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#features Domain#features}
  */
  readonly features?: DomainCpuFeatures[] | cdktf.IResolvable;
  /**
  * Selects how the requested CPU model is matched against the host, with valid values including "minimum", "exact", and "strict", affecting migration compatibility and feature guarantees.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#match Domain#match}
  */
  readonly match?: string;
  /**
  * Configures a limit on the physical address width visible to the guest, thereby constraining the maximum guest physical address range.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#max_phys_addr Domain#max_phys_addr}
  */
  readonly maxPhysAddr?: DomainCpuMaxPhysAddr;
  /**
  * Controls whether the configured CPU model is considered migratable between hosts, using "yes" or "no" string values.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#migratable Domain#migratable}
  */
  readonly migratable?: boolean | cdktf.IResolvable;
  /**
  * Selects the overall CPU model mode for the guest, such as "host-passthrough", "host-model", or "custom", determining how closely the guest CPU matches the host.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode?: string;
  /**
  * Sets the CPU model name exposed to the guest when using a custom CPU mode, for example "Skylake-Server" or "EPYC".
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls the fallback behavior for applying the requested CPU model (flattened from the cpu.model element), with valid values such as "allow", "forbid", or "legacy" depending on libvirt version.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model_fallback Domain#model_fallback}
  */
  readonly modelFallback?: string;
  /**
  * Sets a custom CPU vendor ID string for the exposed CPU model (flattened from the cpu.model element), allowing a user-provided vendor_id such as "AuthenticAMD" or "GenuineIntel".
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model_vendor_id Domain#model_vendor_id}
  */
  readonly modelVendorId?: string;
  /**
  * Enables detailed NUMA topology specification for the guest CPU, acting as the container for one or more NUMA cells.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#numa Domain#numa}
  */
  readonly numa?: DomainCpuNuma;
  /**
  * Configures the virtual CPU topology presented to the guest, including the number of sockets, cores, threads, dies, and optional clusters; if omitted, libvirt chooses a topology automatically.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#topology Domain#topology}
  */
  readonly topology?: DomainCpuTopology;
  /**
  * Specifies the CPU vendor string advertised to the guest (for example, "GenuineIntel" or "AuthenticAMD"); value is user-provided and must be supported by the underlying hypervisor.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vendor Domain#vendor}
  */
  readonly vendor?: string;
}

export function domainCpuToTerraform(struct?: DomainCpu | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cache: domainCpuCacheToTerraform(struct!.cache),
    check: cdktf.stringToTerraform(struct!.check),
    deprecated_features: cdktf.stringToTerraform(struct!.deprecatedFeatures),
    features: cdktf.listMapper(domainCpuFeaturesToTerraform, false)(struct!.features),
    match: cdktf.stringToTerraform(struct!.match),
    max_phys_addr: domainCpuMaxPhysAddrToTerraform(struct!.maxPhysAddr),
    migratable: cdktf.booleanToTerraform(struct!.migratable),
    mode: cdktf.stringToTerraform(struct!.mode),
    model: cdktf.stringToTerraform(struct!.model),
    model_fallback: cdktf.stringToTerraform(struct!.modelFallback),
    model_vendor_id: cdktf.stringToTerraform(struct!.modelVendorId),
    numa: domainCpuNumaToTerraform(struct!.numa),
    topology: domainCpuTopologyToTerraform(struct!.topology),
    vendor: cdktf.stringToTerraform(struct!.vendor),
  }
}


export function domainCpuToHclTerraform(struct?: DomainCpu | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cache: {
      value: domainCpuCacheToHclTerraform(struct!.cache),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainCpuCache",
    },
    check: {
      value: cdktf.stringToHclTerraform(struct!.check),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    deprecated_features: {
      value: cdktf.stringToHclTerraform(struct!.deprecatedFeatures),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    features: {
      value: cdktf.listMapperHcl(domainCpuFeaturesToHclTerraform, false)(struct!.features),
      isBlock: true,
      type: "list",
      storageClassType: "DomainCpuFeaturesList",
    },
    match: {
      value: cdktf.stringToHclTerraform(struct!.match),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_phys_addr: {
      value: domainCpuMaxPhysAddrToHclTerraform(struct!.maxPhysAddr),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainCpuMaxPhysAddr",
    },
    migratable: {
      value: cdktf.booleanToHclTerraform(struct!.migratable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model_fallback: {
      value: cdktf.stringToHclTerraform(struct!.modelFallback),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model_vendor_id: {
      value: cdktf.stringToHclTerraform(struct!.modelVendorId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    numa: {
      value: domainCpuNumaToHclTerraform(struct!.numa),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainCpuNuma",
    },
    topology: {
      value: domainCpuTopologyToHclTerraform(struct!.topology),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainCpuTopology",
    },
    vendor: {
      value: cdktf.stringToHclTerraform(struct!.vendor),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainCpuOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainCpu | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cache?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cache = this._cache?.internalValue;
    }
    if (this._check !== undefined) {
      hasAnyValues = true;
      internalValueResult.check = this._check;
    }
    if (this._deprecatedFeatures !== undefined) {
      hasAnyValues = true;
      internalValueResult.deprecatedFeatures = this._deprecatedFeatures;
    }
    if (this._features?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.features = this._features?.internalValue;
    }
    if (this._match !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match;
    }
    if (this._maxPhysAddr?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPhysAddr = this._maxPhysAddr?.internalValue;
    }
    if (this._migratable !== undefined) {
      hasAnyValues = true;
      internalValueResult.migratable = this._migratable;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._modelFallback !== undefined) {
      hasAnyValues = true;
      internalValueResult.modelFallback = this._modelFallback;
    }
    if (this._modelVendorId !== undefined) {
      hasAnyValues = true;
      internalValueResult.modelVendorId = this._modelVendorId;
    }
    if (this._numa?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.numa = this._numa?.internalValue;
    }
    if (this._topology?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.topology = this._topology?.internalValue;
    }
    if (this._vendor !== undefined) {
      hasAnyValues = true;
      internalValueResult.vendor = this._vendor;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainCpu | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cache.internalValue = undefined;
      this._check = undefined;
      this._deprecatedFeatures = undefined;
      this._features.internalValue = undefined;
      this._match = undefined;
      this._maxPhysAddr.internalValue = undefined;
      this._migratable = undefined;
      this._mode = undefined;
      this._model = undefined;
      this._modelFallback = undefined;
      this._modelVendorId = undefined;
      this._numa.internalValue = undefined;
      this._topology.internalValue = undefined;
      this._vendor = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cache.internalValue = value.cache;
      this._check = value.check;
      this._deprecatedFeatures = value.deprecatedFeatures;
      this._features.internalValue = value.features;
      this._match = value.match;
      this._maxPhysAddr.internalValue = value.maxPhysAddr;
      this._migratable = value.migratable;
      this._mode = value.mode;
      this._model = value.model;
      this._modelFallback = value.modelFallback;
      this._modelVendorId = value.modelVendorId;
      this._numa.internalValue = value.numa;
      this._topology.internalValue = value.topology;
      this._vendor = value.vendor;
    }
  }

  // cache - computed: false, optional: true, required: false
  private _cache = new DomainCpuCacheOutputReference(this, "cache");
  public get cache() {
    return this._cache;
  }
  public putCache(value: DomainCpuCache) {
    this._cache.internalValue = value;
  }
  public resetCache() {
    this._cache.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cacheInput() {
    return this._cache.internalValue;
  }

  // check - computed: false, optional: true, required: false
  private _check?: string; 
  public get check() {
    return this.getStringAttribute('check');
  }
  public set check(value: string) {
    this._check = value;
  }
  public resetCheck() {
    this._check = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get checkInput() {
    return this._check;
  }

  // deprecated_features - computed: false, optional: true, required: false
  private _deprecatedFeatures?: string; 
  public get deprecatedFeatures() {
    return this.getStringAttribute('deprecated_features');
  }
  public set deprecatedFeatures(value: string) {
    this._deprecatedFeatures = value;
  }
  public resetDeprecatedFeatures() {
    this._deprecatedFeatures = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deprecatedFeaturesInput() {
    return this._deprecatedFeatures;
  }

  // features - computed: false, optional: true, required: false
  private _features = new DomainCpuFeaturesList(this, "features", false);
  public get features() {
    return this._features;
  }
  public putFeatures(value: DomainCpuFeatures[] | cdktf.IResolvable) {
    this._features.internalValue = value;
  }
  public resetFeatures() {
    this._features.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get featuresInput() {
    return this._features.internalValue;
  }

  // match - computed: false, optional: true, required: false
  private _match?: string; 
  public get match() {
    return this.getStringAttribute('match');
  }
  public set match(value: string) {
    this._match = value;
  }
  public resetMatch() {
    this._match = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match;
  }

  // max_phys_addr - computed: false, optional: true, required: false
  private _maxPhysAddr = new DomainCpuMaxPhysAddrOutputReference(this, "max_phys_addr");
  public get maxPhysAddr() {
    return this._maxPhysAddr;
  }
  public putMaxPhysAddr(value: DomainCpuMaxPhysAddr) {
    this._maxPhysAddr.internalValue = value;
  }
  public resetMaxPhysAddr() {
    this._maxPhysAddr.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPhysAddrInput() {
    return this._maxPhysAddr.internalValue;
  }

  // migratable - computed: false, optional: true, required: false
  private _migratable?: boolean | cdktf.IResolvable; 
  public get migratable() {
    return this.getBooleanAttribute('migratable');
  }
  public set migratable(value: boolean | cdktf.IResolvable) {
    this._migratable = value;
  }
  public resetMigratable() {
    this._migratable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get migratableInput() {
    return this._migratable;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // model_fallback - computed: false, optional: true, required: false
  private _modelFallback?: string; 
  public get modelFallback() {
    return this.getStringAttribute('model_fallback');
  }
  public set modelFallback(value: string) {
    this._modelFallback = value;
  }
  public resetModelFallback() {
    this._modelFallback = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelFallbackInput() {
    return this._modelFallback;
  }

  // model_vendor_id - computed: false, optional: true, required: false
  private _modelVendorId?: string; 
  public get modelVendorId() {
    return this.getStringAttribute('model_vendor_id');
  }
  public set modelVendorId(value: string) {
    this._modelVendorId = value;
  }
  public resetModelVendorId() {
    this._modelVendorId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelVendorIdInput() {
    return this._modelVendorId;
  }

  // numa - computed: false, optional: true, required: false
  private _numa = new DomainCpuNumaOutputReference(this, "numa");
  public get numa() {
    return this._numa;
  }
  public putNuma(value: DomainCpuNuma) {
    this._numa.internalValue = value;
  }
  public resetNuma() {
    this._numa.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get numaInput() {
    return this._numa.internalValue;
  }

  // topology - computed: false, optional: true, required: false
  private _topology = new DomainCpuTopologyOutputReference(this, "topology");
  public get topology() {
    return this._topology;
  }
  public putTopology(value: DomainCpuTopology) {
    this._topology.internalValue = value;
  }
  public resetTopology() {
    this._topology.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get topologyInput() {
    return this._topology.internalValue;
  }

  // vendor - computed: false, optional: true, required: false
  private _vendor?: string; 
  public get vendor() {
    return this.getStringAttribute('vendor');
  }
  public set vendor(value: string) {
    this._vendor = value;
  }
  public resetVendor() {
    this._vendor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vendorInput() {
    return this._vendor;
  }
}
export interface DomainCpuTuneCacheTuneCache {
  /**
  * Sets which cache level this allocation refers to (for example, 3 for L3 cache); value is a positive integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#level Domain#level}
  */
  readonly level: number;
  /**
  * Sets the size of cache reserved or described by this entry, combined with unit (for example, "4" with unit "MiB"); value is a positive integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#size Domain#size}
  */
  readonly size: number;
  /**
  * Sets the cache type this entry refers to, such as data, instruction, or unified cache; value is user-provided and must match a type accepted by the hypervisor.
  * 
  * See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type: string;
  /**
  * Sets the unit used for the cache size value, typically bytes or a binary multiple such as KiB or MiB; value is user-provided but must be a unit recognized by libvirt.
  * 
  * See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#unit Domain#unit}
  */
  readonly unit: string;
}

export function domainCpuTuneCacheTuneCacheToTerraform(struct?: DomainCpuTuneCacheTuneCache | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    level: cdktf.numberToTerraform(struct!.level),
    size: cdktf.numberToTerraform(struct!.size),
    type: cdktf.stringToTerraform(struct!.type),
    unit: cdktf.stringToTerraform(struct!.unit),
  }
}


export function domainCpuTuneCacheTuneCacheToHclTerraform(struct?: DomainCpuTuneCacheTuneCache | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    level: {
      value: cdktf.numberToHclTerraform(struct!.level),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    size: {
      value: cdktf.numberToHclTerraform(struct!.size),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    unit: {
      value: cdktf.stringToHclTerraform(struct!.unit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainCpuTuneCacheTuneCacheOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainCpuTuneCacheTuneCache | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._level !== undefined) {
      hasAnyValues = true;
      internalValueResult.level = this._level;
    }
    if (this._size !== undefined) {
      hasAnyValues = true;
      internalValueResult.size = this._size;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._unit !== undefined) {
      hasAnyValues = true;
      internalValueResult.unit = this._unit;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainCpuTuneCacheTuneCache | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._level = undefined;
      this._size = undefined;
      this._type = undefined;
      this._unit = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._level = value.level;
      this._size = value.size;
      this._type = value.type;
      this._unit = value.unit;
    }
  }

  // id - computed: true, optional: false, required: false
  public get id() {
    return this.getNumberAttribute('id');
  }

  // level - computed: false, optional: false, required: true
  private _level?: number; 
  public get level() {
    return this.getNumberAttribute('level');
  }
  public set level(value: number) {
    this._level = value;
  }
  // Temporarily expose input value. Use with caution.
  public get levelInput() {
    return this._level;
  }

  // size - computed: false, optional: false, required: true
  private _size?: number; 
  public get size() {
    return this.getNumberAttribute('size');
  }
  public set size(value: number) {
    this._size = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sizeInput() {
    return this._size;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // unit - computed: false, optional: false, required: true
  private _unit?: string; 
  public get unit() {
    return this.getStringAttribute('unit');
  }
  public set unit(value: string) {
    this._unit = value;
  }
  // Temporarily expose input value. Use with caution.
  public get unitInput() {
    return this._unit;
  }
}

export class DomainCpuTuneCacheTuneCacheList extends cdktf.ComplexList {
  public internalValue? : DomainCpuTuneCacheTuneCache[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainCpuTuneCacheTuneCacheOutputReference {
    return new DomainCpuTuneCacheTuneCacheOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainCpuTuneCacheTuneMonitor {
  /**
  * Sets the cache hierarchy level that the cache monitoring group applies to, as an integer level number (for example, 1 for L1, 2 for L2); the value is user-provided and must match a cache level supported by the host.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#level Domain#level}
  */
  readonly level?: number;
  /**
  * Specifies the set of vCPU indexes that belong to this cache monitoring group, using the same comma-separated and range syntax as other cpuset strings (for example, "0,2-3"); the value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vcpus Domain#vcpus}
  */
  readonly vcpus?: string;
}

export function domainCpuTuneCacheTuneMonitorToTerraform(struct?: DomainCpuTuneCacheTuneMonitor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    level: cdktf.numberToTerraform(struct!.level),
    vcpus: cdktf.stringToTerraform(struct!.vcpus),
  }
}


export function domainCpuTuneCacheTuneMonitorToHclTerraform(struct?: DomainCpuTuneCacheTuneMonitor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    level: {
      value: cdktf.numberToHclTerraform(struct!.level),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    vcpus: {
      value: cdktf.stringToHclTerraform(struct!.vcpus),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainCpuTuneCacheTuneMonitorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainCpuTuneCacheTuneMonitor | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._level !== undefined) {
      hasAnyValues = true;
      internalValueResult.level = this._level;
    }
    if (this._vcpus !== undefined) {
      hasAnyValues = true;
      internalValueResult.vcpus = this._vcpus;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainCpuTuneCacheTuneMonitor | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._level = undefined;
      this._vcpus = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._level = value.level;
      this._vcpus = value.vcpus;
    }
  }

  // level - computed: false, optional: true, required: false
  private _level?: number; 
  public get level() {
    return this.getNumberAttribute('level');
  }
  public set level(value: number) {
    this._level = value;
  }
  public resetLevel() {
    this._level = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get levelInput() {
    return this._level;
  }

  // vcpus - computed: false, optional: true, required: false
  private _vcpus?: string; 
  public get vcpus() {
    return this.getStringAttribute('vcpus');
  }
  public set vcpus(value: string) {
    this._vcpus = value;
  }
  public resetVcpus() {
    this._vcpus = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vcpusInput() {
    return this._vcpus;
  }
}

export class DomainCpuTuneCacheTuneMonitorList extends cdktf.ComplexList {
  public internalValue? : DomainCpuTuneCacheTuneMonitor[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainCpuTuneCacheTuneMonitorOutputReference {
    return new DomainCpuTuneCacheTuneMonitorOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainCpuTuneCacheTune {
  /**
  * Defines a single cache allocation entry associated with this cache tuning group, describing size, level, and type of cache reserved for a given cell or vCPU set.
  * 
  * See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#cache Domain#cache}
  */
  readonly cache?: DomainCpuTuneCacheTuneCache[] | cdktf.IResolvable;
  /**
  * Configures one or more performance monitor associations for this cache tuning group (for example, to track usage of the reserved cache region); values are user-provided and driver-specific.
  * 
  * See: <https://libvirt.org/formatdomain.html#performance-monitoring-events>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#monitor Domain#monitor}
  */
  readonly monitor?: DomainCpuTuneCacheTuneMonitor[] | cdktf.IResolvable;
  /**
  * Specifies the set of vCPUs whose cache allocation is controlled by this cache tuning entry, as a cpuset-style string (for example, "0-3" or "1,3"); the value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vcpus Domain#vcpus}
  */
  readonly vcpus?: string;
}

export function domainCpuTuneCacheTuneToTerraform(struct?: DomainCpuTuneCacheTune | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cache: cdktf.listMapper(domainCpuTuneCacheTuneCacheToTerraform, false)(struct!.cache),
    monitor: cdktf.listMapper(domainCpuTuneCacheTuneMonitorToTerraform, false)(struct!.monitor),
    vcpus: cdktf.stringToTerraform(struct!.vcpus),
  }
}


export function domainCpuTuneCacheTuneToHclTerraform(struct?: DomainCpuTuneCacheTune | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cache: {
      value: cdktf.listMapperHcl(domainCpuTuneCacheTuneCacheToHclTerraform, false)(struct!.cache),
      isBlock: true,
      type: "list",
      storageClassType: "DomainCpuTuneCacheTuneCacheList",
    },
    monitor: {
      value: cdktf.listMapperHcl(domainCpuTuneCacheTuneMonitorToHclTerraform, false)(struct!.monitor),
      isBlock: true,
      type: "list",
      storageClassType: "DomainCpuTuneCacheTuneMonitorList",
    },
    vcpus: {
      value: cdktf.stringToHclTerraform(struct!.vcpus),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainCpuTuneCacheTuneOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainCpuTuneCacheTune | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cache?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cache = this._cache?.internalValue;
    }
    if (this._monitor?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitor = this._monitor?.internalValue;
    }
    if (this._vcpus !== undefined) {
      hasAnyValues = true;
      internalValueResult.vcpus = this._vcpus;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainCpuTuneCacheTune | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cache.internalValue = undefined;
      this._monitor.internalValue = undefined;
      this._vcpus = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cache.internalValue = value.cache;
      this._monitor.internalValue = value.monitor;
      this._vcpus = value.vcpus;
    }
  }

  // cache - computed: false, optional: true, required: false
  private _cache = new DomainCpuTuneCacheTuneCacheList(this, "cache", false);
  public get cache() {
    return this._cache;
  }
  public putCache(value: DomainCpuTuneCacheTuneCache[] | cdktf.IResolvable) {
    this._cache.internalValue = value;
  }
  public resetCache() {
    this._cache.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cacheInput() {
    return this._cache.internalValue;
  }

  // id - computed: true, optional: false, required: false
  public get id() {
    return this.getStringAttribute('id');
  }

  // monitor - computed: false, optional: true, required: false
  private _monitor = new DomainCpuTuneCacheTuneMonitorList(this, "monitor", false);
  public get monitor() {
    return this._monitor;
  }
  public putMonitor(value: DomainCpuTuneCacheTuneMonitor[] | cdktf.IResolvable) {
    this._monitor.internalValue = value;
  }
  public resetMonitor() {
    this._monitor.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitorInput() {
    return this._monitor.internalValue;
  }

  // vcpus - computed: false, optional: true, required: false
  private _vcpus?: string; 
  public get vcpus() {
    return this.getStringAttribute('vcpus');
  }
  public set vcpus(value: string) {
    this._vcpus = value;
  }
  public resetVcpus() {
    this._vcpus = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vcpusInput() {
    return this._vcpus;
  }
}

export class DomainCpuTuneCacheTuneList extends cdktf.ComplexList {
  public internalValue? : DomainCpuTuneCacheTune[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainCpuTuneCacheTuneOutputReference {
    return new DomainCpuTuneCacheTuneOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainCpuTuneEmulatorPin {
  /**
  * Defines the cpuset of host CPUs on which the emulator thread may run, using the standard cpuset syntax such as "0-3" or "1,3,5"; this attribute is required when emulator pinning is configured.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#cpu_set Domain#cpu_set}
  */
  readonly cpuSet: string;
}

export function domainCpuTuneEmulatorPinToTerraform(struct?: DomainCpuTuneEmulatorPin | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cpu_set: cdktf.stringToTerraform(struct!.cpuSet),
  }
}


export function domainCpuTuneEmulatorPinToHclTerraform(struct?: DomainCpuTuneEmulatorPin | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cpu_set: {
      value: cdktf.stringToHclTerraform(struct!.cpuSet),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainCpuTuneEmulatorPinOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainCpuTuneEmulatorPin | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cpuSet !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpuSet = this._cpuSet;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainCpuTuneEmulatorPin | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cpuSet = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cpuSet = value.cpuSet;
    }
  }

  // cpu_set - computed: false, optional: false, required: true
  private _cpuSet?: string; 
  public get cpuSet() {
    return this.getStringAttribute('cpu_set');
  }
  public set cpuSet(value: string) {
    this._cpuSet = value;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuSetInput() {
    return this._cpuSet;
  }
}
export interface DomainCpuTuneEmulatorSched {
  /**
  * Sets the scheduler priority for the emulator thread; the valid numeric range depends on the chosen scheduler policy and host kernel (value is user-provided).
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#priority Domain#priority}
  */
  readonly priority?: number;
  /**
  * Selects the scheduler policy for the emulator thread, typically one of "batch", "fifo", "rr", or "idle" where supported; value is user-provided and must match a kernel scheduling class.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#scheduler Domain#scheduler}
  */
  readonly scheduler?: string;
}

export function domainCpuTuneEmulatorSchedToTerraform(struct?: DomainCpuTuneEmulatorSched | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    priority: cdktf.numberToTerraform(struct!.priority),
    scheduler: cdktf.stringToTerraform(struct!.scheduler),
  }
}


export function domainCpuTuneEmulatorSchedToHclTerraform(struct?: DomainCpuTuneEmulatorSched | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    priority: {
      value: cdktf.numberToHclTerraform(struct!.priority),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    scheduler: {
      value: cdktf.stringToHclTerraform(struct!.scheduler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainCpuTuneEmulatorSchedOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainCpuTuneEmulatorSched | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._priority !== undefined) {
      hasAnyValues = true;
      internalValueResult.priority = this._priority;
    }
    if (this._scheduler !== undefined) {
      hasAnyValues = true;
      internalValueResult.scheduler = this._scheduler;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainCpuTuneEmulatorSched | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._priority = undefined;
      this._scheduler = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._priority = value.priority;
      this._scheduler = value.scheduler;
    }
  }

  // priority - computed: false, optional: true, required: false
  private _priority?: number; 
  public get priority() {
    return this.getNumberAttribute('priority');
  }
  public set priority(value: number) {
    this._priority = value;
  }
  public resetPriority() {
    this._priority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityInput() {
    return this._priority;
  }

  // scheduler - computed: false, optional: true, required: false
  private _scheduler?: string; 
  public get scheduler() {
    return this.getStringAttribute('scheduler');
  }
  public set scheduler(value: string) {
    this._scheduler = value;
  }
  public resetScheduler() {
    this._scheduler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get schedulerInput() {
    return this._scheduler;
  }
}
export interface DomainCpuTuneIoThreadPin {
  /**
  * Defines the cpuset of host CPUs on which the specified IOThread may run, using cpuset syntax like "0,2-3"; this attribute is required for each io_thread_pin entry.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#cpu_set Domain#cpu_set}
  */
  readonly cpuSet: string;
  /**
  * Identifies which IOThread is being pinned by index, using the IOThread ID as defined in the domain (for example, 1 or 2); this attribute is required for each io_thread_pin entry.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#io_thread Domain#io_thread}
  */
  readonly ioThread: number;
}

export function domainCpuTuneIoThreadPinToTerraform(struct?: DomainCpuTuneIoThreadPin | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cpu_set: cdktf.stringToTerraform(struct!.cpuSet),
    io_thread: cdktf.numberToTerraform(struct!.ioThread),
  }
}


export function domainCpuTuneIoThreadPinToHclTerraform(struct?: DomainCpuTuneIoThreadPin | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cpu_set: {
      value: cdktf.stringToHclTerraform(struct!.cpuSet),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    io_thread: {
      value: cdktf.numberToHclTerraform(struct!.ioThread),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainCpuTuneIoThreadPinOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainCpuTuneIoThreadPin | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cpuSet !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpuSet = this._cpuSet;
    }
    if (this._ioThread !== undefined) {
      hasAnyValues = true;
      internalValueResult.ioThread = this._ioThread;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainCpuTuneIoThreadPin | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cpuSet = undefined;
      this._ioThread = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cpuSet = value.cpuSet;
      this._ioThread = value.ioThread;
    }
  }

  // cpu_set - computed: false, optional: false, required: true
  private _cpuSet?: string; 
  public get cpuSet() {
    return this.getStringAttribute('cpu_set');
  }
  public set cpuSet(value: string) {
    this._cpuSet = value;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuSetInput() {
    return this._cpuSet;
  }

  // io_thread - computed: false, optional: false, required: true
  private _ioThread?: number; 
  public get ioThread() {
    return this.getNumberAttribute('io_thread');
  }
  public set ioThread(value: number) {
    this._ioThread = value;
  }
  // Temporarily expose input value. Use with caution.
  public get ioThreadInput() {
    return this._ioThread;
  }
}

export class DomainCpuTuneIoThreadPinList extends cdktf.ComplexList {
  public internalValue? : DomainCpuTuneIoThreadPin[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainCpuTuneIoThreadPinOutputReference {
    return new DomainCpuTuneIoThreadPinOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainCpuTuneIoThreadSched {
  /**
  * Specifies the IOThread or set of IOThreads to which this scheduling configuration applies, usually as a comma-separated list of IOThread IDs (for example, "1" or "1,2"); this attribute is required.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#io_threads Domain#io_threads}
  */
  readonly ioThreads: string;
  /**
  * Sets the scheduler priority for the selected IOThreads; valid numeric range depends on the chosen scheduler policy and host kernel, and is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#priority Domain#priority}
  */
  readonly priority?: number;
  /**
  * Sets the scheduler policy for IOThreads, using one of the supported cgroup scheduler values such as `batch`, `fifo`, `rr`, or `both`; if omitted, the hypervisor’s default scheduling policy is used.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#scheduler Domain#scheduler}
  */
  readonly scheduler?: string;
}

export function domainCpuTuneIoThreadSchedToTerraform(struct?: DomainCpuTuneIoThreadSched | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    io_threads: cdktf.stringToTerraform(struct!.ioThreads),
    priority: cdktf.numberToTerraform(struct!.priority),
    scheduler: cdktf.stringToTerraform(struct!.scheduler),
  }
}


export function domainCpuTuneIoThreadSchedToHclTerraform(struct?: DomainCpuTuneIoThreadSched | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    io_threads: {
      value: cdktf.stringToHclTerraform(struct!.ioThreads),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priority: {
      value: cdktf.numberToHclTerraform(struct!.priority),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    scheduler: {
      value: cdktf.stringToHclTerraform(struct!.scheduler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainCpuTuneIoThreadSchedOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainCpuTuneIoThreadSched | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ioThreads !== undefined) {
      hasAnyValues = true;
      internalValueResult.ioThreads = this._ioThreads;
    }
    if (this._priority !== undefined) {
      hasAnyValues = true;
      internalValueResult.priority = this._priority;
    }
    if (this._scheduler !== undefined) {
      hasAnyValues = true;
      internalValueResult.scheduler = this._scheduler;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainCpuTuneIoThreadSched | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ioThreads = undefined;
      this._priority = undefined;
      this._scheduler = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ioThreads = value.ioThreads;
      this._priority = value.priority;
      this._scheduler = value.scheduler;
    }
  }

  // io_threads - computed: false, optional: false, required: true
  private _ioThreads?: string; 
  public get ioThreads() {
    return this.getStringAttribute('io_threads');
  }
  public set ioThreads(value: string) {
    this._ioThreads = value;
  }
  // Temporarily expose input value. Use with caution.
  public get ioThreadsInput() {
    return this._ioThreads;
  }

  // priority - computed: false, optional: true, required: false
  private _priority?: number; 
  public get priority() {
    return this.getNumberAttribute('priority');
  }
  public set priority(value: number) {
    this._priority = value;
  }
  public resetPriority() {
    this._priority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityInput() {
    return this._priority;
  }

  // scheduler - computed: false, optional: true, required: false
  private _scheduler?: string; 
  public get scheduler() {
    return this.getStringAttribute('scheduler');
  }
  public set scheduler(value: string) {
    this._scheduler = value;
  }
  public resetScheduler() {
    this._scheduler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get schedulerInput() {
    return this._scheduler;
  }
}

export class DomainCpuTuneIoThreadSchedList extends cdktf.ComplexList {
  public internalValue? : DomainCpuTuneIoThreadSched[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainCpuTuneIoThreadSchedOutputReference {
    return new DomainCpuTuneIoThreadSchedOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainCpuTuneMemoryTuneMonitor {
  /**
  * Sets the monitoring level for memory bandwidth (for example, a cache or memory hierarchy level), as a user-provided string understood by the hypervisor.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#level Domain#level}
  */
  readonly level?: number;
  /**
  * Specifies the set of vCPUs to monitor for memory bandwidth, using the libvirt CPU set syntax (e.g. `0-3`, `0,2,4`).
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vcpus Domain#vcpus}
  */
  readonly vcpus?: string;
}

export function domainCpuTuneMemoryTuneMonitorToTerraform(struct?: DomainCpuTuneMemoryTuneMonitor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    level: cdktf.numberToTerraform(struct!.level),
    vcpus: cdktf.stringToTerraform(struct!.vcpus),
  }
}


export function domainCpuTuneMemoryTuneMonitorToHclTerraform(struct?: DomainCpuTuneMemoryTuneMonitor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    level: {
      value: cdktf.numberToHclTerraform(struct!.level),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    vcpus: {
      value: cdktf.stringToHclTerraform(struct!.vcpus),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainCpuTuneMemoryTuneMonitorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainCpuTuneMemoryTuneMonitor | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._level !== undefined) {
      hasAnyValues = true;
      internalValueResult.level = this._level;
    }
    if (this._vcpus !== undefined) {
      hasAnyValues = true;
      internalValueResult.vcpus = this._vcpus;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainCpuTuneMemoryTuneMonitor | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._level = undefined;
      this._vcpus = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._level = value.level;
      this._vcpus = value.vcpus;
    }
  }

  // level - computed: false, optional: true, required: false
  private _level?: number; 
  public get level() {
    return this.getNumberAttribute('level');
  }
  public set level(value: number) {
    this._level = value;
  }
  public resetLevel() {
    this._level = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get levelInput() {
    return this._level;
  }

  // vcpus - computed: false, optional: true, required: false
  private _vcpus?: string; 
  public get vcpus() {
    return this.getStringAttribute('vcpus');
  }
  public set vcpus(value: string) {
    this._vcpus = value;
  }
  public resetVcpus() {
    this._vcpus = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vcpusInput() {
    return this._vcpus;
  }
}

export class DomainCpuTuneMemoryTuneMonitorList extends cdktf.ComplexList {
  public internalValue? : DomainCpuTuneMemoryTuneMonitor[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainCpuTuneMemoryTuneMonitorOutputReference {
    return new DomainCpuTuneMemoryTuneMonitorOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainCpuTuneMemoryTuneNodes {
  /**
  * Sets the memory bandwidth limit for this NUMA node in MB/s; this attribute is required for each node entry.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bandwidth Domain#bandwidth}
  */
  readonly bandwidth: number;
}

export function domainCpuTuneMemoryTuneNodesToTerraform(struct?: DomainCpuTuneMemoryTuneNodes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bandwidth: cdktf.numberToTerraform(struct!.bandwidth),
  }
}


export function domainCpuTuneMemoryTuneNodesToHclTerraform(struct?: DomainCpuTuneMemoryTuneNodes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bandwidth: {
      value: cdktf.numberToHclTerraform(struct!.bandwidth),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainCpuTuneMemoryTuneNodesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainCpuTuneMemoryTuneNodes | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bandwidth !== undefined) {
      hasAnyValues = true;
      internalValueResult.bandwidth = this._bandwidth;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainCpuTuneMemoryTuneNodes | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bandwidth = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bandwidth = value.bandwidth;
    }
  }

  // bandwidth - computed: false, optional: false, required: true
  private _bandwidth?: number; 
  public get bandwidth() {
    return this.getNumberAttribute('bandwidth');
  }
  public set bandwidth(value: number) {
    this._bandwidth = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bandwidthInput() {
    return this._bandwidth;
  }

  // id - computed: true, optional: false, required: false
  public get id() {
    return this.getNumberAttribute('id');
  }
}

export class DomainCpuTuneMemoryTuneNodesList extends cdktf.ComplexList {
  public internalValue? : DomainCpuTuneMemoryTuneNodes[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainCpuTuneMemoryTuneNodesOutputReference {
    return new DomainCpuTuneMemoryTuneNodesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainCpuTuneMemoryTune {
  /**
  * Configures which vCPUs are monitored for memory bandwidth usage and the hierarchy level at which libvirt tracks memory usage statistics.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#monitor Domain#monitor}
  */
  readonly monitor?: DomainCpuTuneMemoryTuneMonitor[] | cdktf.IResolvable;
  /**
  * Defines one or more NUMA memory nodes for which to apply memory bandwidth limits as part of memory tuning.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#nodes Domain#nodes}
  */
  readonly nodes?: DomainCpuTuneMemoryTuneNodes[] | cdktf.IResolvable;
  /**
  * Specifies which vCPUs are subject to the memory tuning configuration, using libvirt CPU set syntax (e.g. `0-1`, `1,3`); this is required when memory tuning is defined.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vcpus Domain#vcpus}
  */
  readonly vcpus: string;
}

export function domainCpuTuneMemoryTuneToTerraform(struct?: DomainCpuTuneMemoryTune | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    monitor: cdktf.listMapper(domainCpuTuneMemoryTuneMonitorToTerraform, false)(struct!.monitor),
    nodes: cdktf.listMapper(domainCpuTuneMemoryTuneNodesToTerraform, false)(struct!.nodes),
    vcpus: cdktf.stringToTerraform(struct!.vcpus),
  }
}


export function domainCpuTuneMemoryTuneToHclTerraform(struct?: DomainCpuTuneMemoryTune | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    monitor: {
      value: cdktf.listMapperHcl(domainCpuTuneMemoryTuneMonitorToHclTerraform, false)(struct!.monitor),
      isBlock: true,
      type: "list",
      storageClassType: "DomainCpuTuneMemoryTuneMonitorList",
    },
    nodes: {
      value: cdktf.listMapperHcl(domainCpuTuneMemoryTuneNodesToHclTerraform, false)(struct!.nodes),
      isBlock: true,
      type: "list",
      storageClassType: "DomainCpuTuneMemoryTuneNodesList",
    },
    vcpus: {
      value: cdktf.stringToHclTerraform(struct!.vcpus),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainCpuTuneMemoryTuneOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainCpuTuneMemoryTune | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._monitor?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitor = this._monitor?.internalValue;
    }
    if (this._nodes?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodes = this._nodes?.internalValue;
    }
    if (this._vcpus !== undefined) {
      hasAnyValues = true;
      internalValueResult.vcpus = this._vcpus;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainCpuTuneMemoryTune | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._monitor.internalValue = undefined;
      this._nodes.internalValue = undefined;
      this._vcpus = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._monitor.internalValue = value.monitor;
      this._nodes.internalValue = value.nodes;
      this._vcpus = value.vcpus;
    }
  }

  // monitor - computed: false, optional: true, required: false
  private _monitor = new DomainCpuTuneMemoryTuneMonitorList(this, "monitor", false);
  public get monitor() {
    return this._monitor;
  }
  public putMonitor(value: DomainCpuTuneMemoryTuneMonitor[] | cdktf.IResolvable) {
    this._monitor.internalValue = value;
  }
  public resetMonitor() {
    this._monitor.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitorInput() {
    return this._monitor.internalValue;
  }

  // nodes - computed: false, optional: true, required: false
  private _nodes = new DomainCpuTuneMemoryTuneNodesList(this, "nodes", false);
  public get nodes() {
    return this._nodes;
  }
  public putNodes(value: DomainCpuTuneMemoryTuneNodes[] | cdktf.IResolvable) {
    this._nodes.internalValue = value;
  }
  public resetNodes() {
    this._nodes.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodesInput() {
    return this._nodes.internalValue;
  }

  // vcpus - computed: false, optional: false, required: true
  private _vcpus?: string; 
  public get vcpus() {
    return this.getStringAttribute('vcpus');
  }
  public set vcpus(value: string) {
    this._vcpus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get vcpusInput() {
    return this._vcpus;
  }
}

export class DomainCpuTuneMemoryTuneList extends cdktf.ComplexList {
  public internalValue? : DomainCpuTuneMemoryTune[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainCpuTuneMemoryTuneOutputReference {
    return new DomainCpuTuneMemoryTuneOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainCpuTuneVcpuPin {
  /**
  * Specifies the host CPU set to which this vCPU is pinned, using libvirt CPU set syntax (e.g. `0-3`, `2,4`); this is required for each pin entry.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#cpu_set Domain#cpu_set}
  */
  readonly cpuSet: string;
  /**
  * Identifies the virtual CPU index (starting at 0) that this pinning rule applies to; this is required for each pin entry.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vcpu Domain#vcpu}
  */
  readonly vcpu: number;
}

export function domainCpuTuneVcpuPinToTerraform(struct?: DomainCpuTuneVcpuPin | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cpu_set: cdktf.stringToTerraform(struct!.cpuSet),
    vcpu: cdktf.numberToTerraform(struct!.vcpu),
  }
}


export function domainCpuTuneVcpuPinToHclTerraform(struct?: DomainCpuTuneVcpuPin | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cpu_set: {
      value: cdktf.stringToHclTerraform(struct!.cpuSet),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    vcpu: {
      value: cdktf.numberToHclTerraform(struct!.vcpu),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainCpuTuneVcpuPinOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainCpuTuneVcpuPin | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cpuSet !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpuSet = this._cpuSet;
    }
    if (this._vcpu !== undefined) {
      hasAnyValues = true;
      internalValueResult.vcpu = this._vcpu;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainCpuTuneVcpuPin | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cpuSet = undefined;
      this._vcpu = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cpuSet = value.cpuSet;
      this._vcpu = value.vcpu;
    }
  }

  // cpu_set - computed: false, optional: false, required: true
  private _cpuSet?: string; 
  public get cpuSet() {
    return this.getStringAttribute('cpu_set');
  }
  public set cpuSet(value: string) {
    this._cpuSet = value;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuSetInput() {
    return this._cpuSet;
  }

  // vcpu - computed: false, optional: false, required: true
  private _vcpu?: number; 
  public get vcpu() {
    return this.getNumberAttribute('vcpu');
  }
  public set vcpu(value: number) {
    this._vcpu = value;
  }
  // Temporarily expose input value. Use with caution.
  public get vcpuInput() {
    return this._vcpu;
  }
}

export class DomainCpuTuneVcpuPinList extends cdktf.ComplexList {
  public internalValue? : DomainCpuTuneVcpuPin[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainCpuTuneVcpuPinOutputReference {
    return new DomainCpuTuneVcpuPinOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainCpuTuneVcpuSched {
  /**
  * Sets the scheduler priority for the selected vCPUs, as an integer whose valid range depends on the chosen scheduler policy and host kernel.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#priority Domain#priority}
  */
  readonly priority?: number;
  /**
  * Sets the scheduler policy for the selected vCPUs, using one of the supported policies such as `batch`, `fifo`, or `rr`; if omitted, the default policy applies.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#scheduler Domain#scheduler}
  */
  readonly scheduler?: string;
  /**
  * Specifies which vCPUs this scheduler configuration applies to, using libvirt CPU set syntax (e.g. `0`, `0-1`, `1,3`); this attribute is required.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vcpus Domain#vcpus}
  */
  readonly vcpus: string;
}

export function domainCpuTuneVcpuSchedToTerraform(struct?: DomainCpuTuneVcpuSched | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    priority: cdktf.numberToTerraform(struct!.priority),
    scheduler: cdktf.stringToTerraform(struct!.scheduler),
    vcpus: cdktf.stringToTerraform(struct!.vcpus),
  }
}


export function domainCpuTuneVcpuSchedToHclTerraform(struct?: DomainCpuTuneVcpuSched | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    priority: {
      value: cdktf.numberToHclTerraform(struct!.priority),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    scheduler: {
      value: cdktf.stringToHclTerraform(struct!.scheduler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    vcpus: {
      value: cdktf.stringToHclTerraform(struct!.vcpus),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainCpuTuneVcpuSchedOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainCpuTuneVcpuSched | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._priority !== undefined) {
      hasAnyValues = true;
      internalValueResult.priority = this._priority;
    }
    if (this._scheduler !== undefined) {
      hasAnyValues = true;
      internalValueResult.scheduler = this._scheduler;
    }
    if (this._vcpus !== undefined) {
      hasAnyValues = true;
      internalValueResult.vcpus = this._vcpus;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainCpuTuneVcpuSched | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._priority = undefined;
      this._scheduler = undefined;
      this._vcpus = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._priority = value.priority;
      this._scheduler = value.scheduler;
      this._vcpus = value.vcpus;
    }
  }

  // priority - computed: false, optional: true, required: false
  private _priority?: number; 
  public get priority() {
    return this.getNumberAttribute('priority');
  }
  public set priority(value: number) {
    this._priority = value;
  }
  public resetPriority() {
    this._priority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityInput() {
    return this._priority;
  }

  // scheduler - computed: false, optional: true, required: false
  private _scheduler?: string; 
  public get scheduler() {
    return this.getStringAttribute('scheduler');
  }
  public set scheduler(value: string) {
    this._scheduler = value;
  }
  public resetScheduler() {
    this._scheduler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get schedulerInput() {
    return this._scheduler;
  }

  // vcpus - computed: false, optional: false, required: true
  private _vcpus?: string; 
  public get vcpus() {
    return this.getStringAttribute('vcpus');
  }
  public set vcpus(value: string) {
    this._vcpus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get vcpusInput() {
    return this._vcpus;
  }
}

export class DomainCpuTuneVcpuSchedList extends cdktf.ComplexList {
  public internalValue? : DomainCpuTuneVcpuSched[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainCpuTuneVcpuSchedOutputReference {
    return new DomainCpuTuneVcpuSchedOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainCpuTune {
  /**
  * Configures cache allocation and partitioning between NUMA cells or vCPUs, allowing you to reserve or limit portions of shared caches.
  * 
  * See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#cache_tune Domain#cache_tune}
  */
  readonly cacheTune?: DomainCpuTuneCacheTune[] | cdktf.IResolvable;
  /**
  * Sets the CPU time period in microseconds used to calculate cgroup quota for the QEMU emulator thread; value is a positive integer and is user-provided (for example, 100000).
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#emulator_period Domain#emulator_period}
  */
  readonly emulatorPeriod?: number;
  /**
  * Configures CPU pinning for the QEMU emulator thread, constraining it to a specific set of host CPUs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#emulator_pin Domain#emulator_pin}
  */
  readonly emulatorPin?: DomainCpuTuneEmulatorPin;
  /**
  * Sets the total CPU time in microseconds that the emulator thread is allowed to consume per scheduling period; value is a user-provided integer, typically positive to enforce a limit or -1 for unlimited where supported.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#emulator_quota Domain#emulator_quota}
  */
  readonly emulatorQuota?: number;
  /**
  * Configures the scheduler policy and priority for the emulator thread within its cgroup.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#emulator_sched Domain#emulator_sched}
  */
  readonly emulatorSched?: DomainCpuTuneEmulatorSched;
  /**
  * Sets the global CPU period in microseconds used as the base for quota calculations for all vCPUs and emulator threads unless overridden; value is a positive integer and user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#global_period Domain#global_period}
  */
  readonly globalPeriod?: number;
  /**
  * Sets the global CPU time quota in microseconds per period for the entire domain, limiting aggregate CPU usage across all vCPUs and emulator threads; value is a user-provided integer, commonly positive or -1 for unlimited where supported.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#global_quota Domain#global_quota}
  */
  readonly globalQuota?: number;
  /**
  * Sets the CPU time period in microseconds used to calculate cgroup quota for IOThreads; value is a positive, user-provided integer (for example, 100000).
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#io_thread_period Domain#io_thread_period}
  */
  readonly ioThreadPeriod?: number;
  /**
  * Configures CPU pinning for a specific IOThread, constraining that IOThread to a set of host CPUs.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#io_thread_pin Domain#io_thread_pin}
  */
  readonly ioThreadPin?: DomainCpuTuneIoThreadPin[] | cdktf.IResolvable;
  /**
  * Sets the total CPU time in microseconds that each IOThread is allowed to consume per scheduling period when per-IOThread quotas are enabled; value is a user-provided integer, typically positive or -1 for unlimited where supported.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#io_thread_quota Domain#io_thread_quota}
  */
  readonly ioThreadQuota?: number;
  /**
  * Configures scheduler policy and priority for one or more IOThreads.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#io_thread_sched Domain#io_thread_sched}
  */
  readonly ioThreadSched?: DomainCpuTuneIoThreadSched[] | cdktf.IResolvable;
  /**
  * Enables per-vCPU memory bandwidth tuning for the domain, grouping configuration for monitored vCPUs and per-NUMA-node memory bandwidth caps.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#memory_tune Domain#memory_tune}
  */
  readonly memoryTune?: DomainCpuTuneMemoryTune[] | cdktf.IResolvable;
  /**
  * Sets the CPU cgroup scheduler period in microseconds for all vCPUs, controlling the time window used with `quota` (for example, `100000`).
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#period Domain#period}
  */
  readonly period?: number;
  /**
  * Sets the total CPU time in microseconds allowed per `period` for all vCPUs, using a positive integer or `-1` for no limit.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#quota Domain#quota}
  */
  readonly quota?: number;
  /**
  * Sets the relative CPU weight (shares) of the domain in the CPU cgroup, typically a positive integer such as `1024` used for proportional scheduling.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#shares Domain#shares}
  */
  readonly shares?: number;
  /**
  * Configures one or more pinning rules mapping each virtual CPU to a specific set of host CPUs for execution.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vcpu_pin Domain#vcpu_pin}
  */
  readonly vcpuPin?: DomainCpuTuneVcpuPin[] | cdktf.IResolvable;
  /**
  * Configures scheduler attributes for one or more groups of vCPUs, such as scheduler class and priority.
  * 
  * See: <https://libvirt.org/formatdomain.html#cpu-tuning>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vcpu_sched Domain#vcpu_sched}
  */
  readonly vcpuSched?: DomainCpuTuneVcpuSched[] | cdktf.IResolvable;
}

export function domainCpuTuneToTerraform(struct?: DomainCpuTune | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cache_tune: cdktf.listMapper(domainCpuTuneCacheTuneToTerraform, false)(struct!.cacheTune),
    emulator_period: cdktf.numberToTerraform(struct!.emulatorPeriod),
    emulator_pin: domainCpuTuneEmulatorPinToTerraform(struct!.emulatorPin),
    emulator_quota: cdktf.numberToTerraform(struct!.emulatorQuota),
    emulator_sched: domainCpuTuneEmulatorSchedToTerraform(struct!.emulatorSched),
    global_period: cdktf.numberToTerraform(struct!.globalPeriod),
    global_quota: cdktf.numberToTerraform(struct!.globalQuota),
    io_thread_period: cdktf.numberToTerraform(struct!.ioThreadPeriod),
    io_thread_pin: cdktf.listMapper(domainCpuTuneIoThreadPinToTerraform, false)(struct!.ioThreadPin),
    io_thread_quota: cdktf.numberToTerraform(struct!.ioThreadQuota),
    io_thread_sched: cdktf.listMapper(domainCpuTuneIoThreadSchedToTerraform, false)(struct!.ioThreadSched),
    memory_tune: cdktf.listMapper(domainCpuTuneMemoryTuneToTerraform, false)(struct!.memoryTune),
    period: cdktf.numberToTerraform(struct!.period),
    quota: cdktf.numberToTerraform(struct!.quota),
    shares: cdktf.numberToTerraform(struct!.shares),
    vcpu_pin: cdktf.listMapper(domainCpuTuneVcpuPinToTerraform, false)(struct!.vcpuPin),
    vcpu_sched: cdktf.listMapper(domainCpuTuneVcpuSchedToTerraform, false)(struct!.vcpuSched),
  }
}


export function domainCpuTuneToHclTerraform(struct?: DomainCpuTune | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cache_tune: {
      value: cdktf.listMapperHcl(domainCpuTuneCacheTuneToHclTerraform, false)(struct!.cacheTune),
      isBlock: true,
      type: "list",
      storageClassType: "DomainCpuTuneCacheTuneList",
    },
    emulator_period: {
      value: cdktf.numberToHclTerraform(struct!.emulatorPeriod),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    emulator_pin: {
      value: domainCpuTuneEmulatorPinToHclTerraform(struct!.emulatorPin),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainCpuTuneEmulatorPin",
    },
    emulator_quota: {
      value: cdktf.numberToHclTerraform(struct!.emulatorQuota),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    emulator_sched: {
      value: domainCpuTuneEmulatorSchedToHclTerraform(struct!.emulatorSched),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainCpuTuneEmulatorSched",
    },
    global_period: {
      value: cdktf.numberToHclTerraform(struct!.globalPeriod),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    global_quota: {
      value: cdktf.numberToHclTerraform(struct!.globalQuota),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    io_thread_period: {
      value: cdktf.numberToHclTerraform(struct!.ioThreadPeriod),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    io_thread_pin: {
      value: cdktf.listMapperHcl(domainCpuTuneIoThreadPinToHclTerraform, false)(struct!.ioThreadPin),
      isBlock: true,
      type: "list",
      storageClassType: "DomainCpuTuneIoThreadPinList",
    },
    io_thread_quota: {
      value: cdktf.numberToHclTerraform(struct!.ioThreadQuota),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    io_thread_sched: {
      value: cdktf.listMapperHcl(domainCpuTuneIoThreadSchedToHclTerraform, false)(struct!.ioThreadSched),
      isBlock: true,
      type: "list",
      storageClassType: "DomainCpuTuneIoThreadSchedList",
    },
    memory_tune: {
      value: cdktf.listMapperHcl(domainCpuTuneMemoryTuneToHclTerraform, false)(struct!.memoryTune),
      isBlock: true,
      type: "list",
      storageClassType: "DomainCpuTuneMemoryTuneList",
    },
    period: {
      value: cdktf.numberToHclTerraform(struct!.period),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    quota: {
      value: cdktf.numberToHclTerraform(struct!.quota),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    shares: {
      value: cdktf.numberToHclTerraform(struct!.shares),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    vcpu_pin: {
      value: cdktf.listMapperHcl(domainCpuTuneVcpuPinToHclTerraform, false)(struct!.vcpuPin),
      isBlock: true,
      type: "list",
      storageClassType: "DomainCpuTuneVcpuPinList",
    },
    vcpu_sched: {
      value: cdktf.listMapperHcl(domainCpuTuneVcpuSchedToHclTerraform, false)(struct!.vcpuSched),
      isBlock: true,
      type: "list",
      storageClassType: "DomainCpuTuneVcpuSchedList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainCpuTuneOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainCpuTune | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cacheTune?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cacheTune = this._cacheTune?.internalValue;
    }
    if (this._emulatorPeriod !== undefined) {
      hasAnyValues = true;
      internalValueResult.emulatorPeriod = this._emulatorPeriod;
    }
    if (this._emulatorPin?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.emulatorPin = this._emulatorPin?.internalValue;
    }
    if (this._emulatorQuota !== undefined) {
      hasAnyValues = true;
      internalValueResult.emulatorQuota = this._emulatorQuota;
    }
    if (this._emulatorSched?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.emulatorSched = this._emulatorSched?.internalValue;
    }
    if (this._globalPeriod !== undefined) {
      hasAnyValues = true;
      internalValueResult.globalPeriod = this._globalPeriod;
    }
    if (this._globalQuota !== undefined) {
      hasAnyValues = true;
      internalValueResult.globalQuota = this._globalQuota;
    }
    if (this._ioThreadPeriod !== undefined) {
      hasAnyValues = true;
      internalValueResult.ioThreadPeriod = this._ioThreadPeriod;
    }
    if (this._ioThreadPin?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ioThreadPin = this._ioThreadPin?.internalValue;
    }
    if (this._ioThreadQuota !== undefined) {
      hasAnyValues = true;
      internalValueResult.ioThreadQuota = this._ioThreadQuota;
    }
    if (this._ioThreadSched?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ioThreadSched = this._ioThreadSched?.internalValue;
    }
    if (this._memoryTune?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.memoryTune = this._memoryTune?.internalValue;
    }
    if (this._period !== undefined) {
      hasAnyValues = true;
      internalValueResult.period = this._period;
    }
    if (this._quota !== undefined) {
      hasAnyValues = true;
      internalValueResult.quota = this._quota;
    }
    if (this._shares !== undefined) {
      hasAnyValues = true;
      internalValueResult.shares = this._shares;
    }
    if (this._vcpuPin?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.vcpuPin = this._vcpuPin?.internalValue;
    }
    if (this._vcpuSched?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.vcpuSched = this._vcpuSched?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainCpuTune | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cacheTune.internalValue = undefined;
      this._emulatorPeriod = undefined;
      this._emulatorPin.internalValue = undefined;
      this._emulatorQuota = undefined;
      this._emulatorSched.internalValue = undefined;
      this._globalPeriod = undefined;
      this._globalQuota = undefined;
      this._ioThreadPeriod = undefined;
      this._ioThreadPin.internalValue = undefined;
      this._ioThreadQuota = undefined;
      this._ioThreadSched.internalValue = undefined;
      this._memoryTune.internalValue = undefined;
      this._period = undefined;
      this._quota = undefined;
      this._shares = undefined;
      this._vcpuPin.internalValue = undefined;
      this._vcpuSched.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cacheTune.internalValue = value.cacheTune;
      this._emulatorPeriod = value.emulatorPeriod;
      this._emulatorPin.internalValue = value.emulatorPin;
      this._emulatorQuota = value.emulatorQuota;
      this._emulatorSched.internalValue = value.emulatorSched;
      this._globalPeriod = value.globalPeriod;
      this._globalQuota = value.globalQuota;
      this._ioThreadPeriod = value.ioThreadPeriod;
      this._ioThreadPin.internalValue = value.ioThreadPin;
      this._ioThreadQuota = value.ioThreadQuota;
      this._ioThreadSched.internalValue = value.ioThreadSched;
      this._memoryTune.internalValue = value.memoryTune;
      this._period = value.period;
      this._quota = value.quota;
      this._shares = value.shares;
      this._vcpuPin.internalValue = value.vcpuPin;
      this._vcpuSched.internalValue = value.vcpuSched;
    }
  }

  // cache_tune - computed: false, optional: true, required: false
  private _cacheTune = new DomainCpuTuneCacheTuneList(this, "cache_tune", false);
  public get cacheTune() {
    return this._cacheTune;
  }
  public putCacheTune(value: DomainCpuTuneCacheTune[] | cdktf.IResolvable) {
    this._cacheTune.internalValue = value;
  }
  public resetCacheTune() {
    this._cacheTune.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cacheTuneInput() {
    return this._cacheTune.internalValue;
  }

  // emulator_period - computed: false, optional: true, required: false
  private _emulatorPeriod?: number; 
  public get emulatorPeriod() {
    return this.getNumberAttribute('emulator_period');
  }
  public set emulatorPeriod(value: number) {
    this._emulatorPeriod = value;
  }
  public resetEmulatorPeriod() {
    this._emulatorPeriod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get emulatorPeriodInput() {
    return this._emulatorPeriod;
  }

  // emulator_pin - computed: false, optional: true, required: false
  private _emulatorPin = new DomainCpuTuneEmulatorPinOutputReference(this, "emulator_pin");
  public get emulatorPin() {
    return this._emulatorPin;
  }
  public putEmulatorPin(value: DomainCpuTuneEmulatorPin) {
    this._emulatorPin.internalValue = value;
  }
  public resetEmulatorPin() {
    this._emulatorPin.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get emulatorPinInput() {
    return this._emulatorPin.internalValue;
  }

  // emulator_quota - computed: false, optional: true, required: false
  private _emulatorQuota?: number; 
  public get emulatorQuota() {
    return this.getNumberAttribute('emulator_quota');
  }
  public set emulatorQuota(value: number) {
    this._emulatorQuota = value;
  }
  public resetEmulatorQuota() {
    this._emulatorQuota = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get emulatorQuotaInput() {
    return this._emulatorQuota;
  }

  // emulator_sched - computed: false, optional: true, required: false
  private _emulatorSched = new DomainCpuTuneEmulatorSchedOutputReference(this, "emulator_sched");
  public get emulatorSched() {
    return this._emulatorSched;
  }
  public putEmulatorSched(value: DomainCpuTuneEmulatorSched) {
    this._emulatorSched.internalValue = value;
  }
  public resetEmulatorSched() {
    this._emulatorSched.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get emulatorSchedInput() {
    return this._emulatorSched.internalValue;
  }

  // global_period - computed: false, optional: true, required: false
  private _globalPeriod?: number; 
  public get globalPeriod() {
    return this.getNumberAttribute('global_period');
  }
  public set globalPeriod(value: number) {
    this._globalPeriod = value;
  }
  public resetGlobalPeriod() {
    this._globalPeriod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get globalPeriodInput() {
    return this._globalPeriod;
  }

  // global_quota - computed: false, optional: true, required: false
  private _globalQuota?: number; 
  public get globalQuota() {
    return this.getNumberAttribute('global_quota');
  }
  public set globalQuota(value: number) {
    this._globalQuota = value;
  }
  public resetGlobalQuota() {
    this._globalQuota = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get globalQuotaInput() {
    return this._globalQuota;
  }

  // io_thread_period - computed: false, optional: true, required: false
  private _ioThreadPeriod?: number; 
  public get ioThreadPeriod() {
    return this.getNumberAttribute('io_thread_period');
  }
  public set ioThreadPeriod(value: number) {
    this._ioThreadPeriod = value;
  }
  public resetIoThreadPeriod() {
    this._ioThreadPeriod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ioThreadPeriodInput() {
    return this._ioThreadPeriod;
  }

  // io_thread_pin - computed: false, optional: true, required: false
  private _ioThreadPin = new DomainCpuTuneIoThreadPinList(this, "io_thread_pin", false);
  public get ioThreadPin() {
    return this._ioThreadPin;
  }
  public putIoThreadPin(value: DomainCpuTuneIoThreadPin[] | cdktf.IResolvable) {
    this._ioThreadPin.internalValue = value;
  }
  public resetIoThreadPin() {
    this._ioThreadPin.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ioThreadPinInput() {
    return this._ioThreadPin.internalValue;
  }

  // io_thread_quota - computed: false, optional: true, required: false
  private _ioThreadQuota?: number; 
  public get ioThreadQuota() {
    return this.getNumberAttribute('io_thread_quota');
  }
  public set ioThreadQuota(value: number) {
    this._ioThreadQuota = value;
  }
  public resetIoThreadQuota() {
    this._ioThreadQuota = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ioThreadQuotaInput() {
    return this._ioThreadQuota;
  }

  // io_thread_sched - computed: false, optional: true, required: false
  private _ioThreadSched = new DomainCpuTuneIoThreadSchedList(this, "io_thread_sched", false);
  public get ioThreadSched() {
    return this._ioThreadSched;
  }
  public putIoThreadSched(value: DomainCpuTuneIoThreadSched[] | cdktf.IResolvable) {
    this._ioThreadSched.internalValue = value;
  }
  public resetIoThreadSched() {
    this._ioThreadSched.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ioThreadSchedInput() {
    return this._ioThreadSched.internalValue;
  }

  // memory_tune - computed: false, optional: true, required: false
  private _memoryTune = new DomainCpuTuneMemoryTuneList(this, "memory_tune", false);
  public get memoryTune() {
    return this._memoryTune;
  }
  public putMemoryTune(value: DomainCpuTuneMemoryTune[] | cdktf.IResolvable) {
    this._memoryTune.internalValue = value;
  }
  public resetMemoryTune() {
    this._memoryTune.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryTuneInput() {
    return this._memoryTune.internalValue;
  }

  // period - computed: false, optional: true, required: false
  private _period?: number; 
  public get period() {
    return this.getNumberAttribute('period');
  }
  public set period(value: number) {
    this._period = value;
  }
  public resetPeriod() {
    this._period = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get periodInput() {
    return this._period;
  }

  // quota - computed: false, optional: true, required: false
  private _quota?: number; 
  public get quota() {
    return this.getNumberAttribute('quota');
  }
  public set quota(value: number) {
    this._quota = value;
  }
  public resetQuota() {
    this._quota = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get quotaInput() {
    return this._quota;
  }

  // shares - computed: false, optional: true, required: false
  private _shares?: number; 
  public get shares() {
    return this.getNumberAttribute('shares');
  }
  public set shares(value: number) {
    this._shares = value;
  }
  public resetShares() {
    this._shares = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sharesInput() {
    return this._shares;
  }

  // vcpu_pin - computed: false, optional: true, required: false
  private _vcpuPin = new DomainCpuTuneVcpuPinList(this, "vcpu_pin", false);
  public get vcpuPin() {
    return this._vcpuPin;
  }
  public putVcpuPin(value: DomainCpuTuneVcpuPin[] | cdktf.IResolvable) {
    this._vcpuPin.internalValue = value;
  }
  public resetVcpuPin() {
    this._vcpuPin.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vcpuPinInput() {
    return this._vcpuPin.internalValue;
  }

  // vcpu_sched - computed: false, optional: true, required: false
  private _vcpuSched = new DomainCpuTuneVcpuSchedList(this, "vcpu_sched", false);
  public get vcpuSched() {
    return this._vcpuSched;
  }
  public putVcpuSched(value: DomainCpuTuneVcpuSched[] | cdktf.IResolvable) {
    this._vcpuSched.internalValue = value;
  }
  public resetVcpuSched() {
    this._vcpuSched.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vcpuSchedInput() {
    return this._vcpuSched.internalValue;
  }
}
export interface DomainCreate {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#autodestroy Domain#autodestroy}
  */
  readonly autodestroy?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bypass_cache Domain#bypass_cache}
  */
  readonly bypassCache?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#force_boot Domain#force_boot}
  */
  readonly forceBoot?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#paused Domain#paused}
  */
  readonly paused?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reset_nvram Domain#reset_nvram}
  */
  readonly resetNvram?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#validate Domain#validate}
  */
  readonly validate?: boolean | cdktf.IResolvable;
}

export function domainCreateToTerraform(struct?: DomainCreate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    autodestroy: cdktf.booleanToTerraform(struct!.autodestroy),
    bypass_cache: cdktf.booleanToTerraform(struct!.bypassCache),
    force_boot: cdktf.booleanToTerraform(struct!.forceBoot),
    paused: cdktf.booleanToTerraform(struct!.paused),
    reset_nvram: cdktf.booleanToTerraform(struct!.resetNvram),
    validate: cdktf.booleanToTerraform(struct!.validate),
  }
}


export function domainCreateToHclTerraform(struct?: DomainCreate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    autodestroy: {
      value: cdktf.booleanToHclTerraform(struct!.autodestroy),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    bypass_cache: {
      value: cdktf.booleanToHclTerraform(struct!.bypassCache),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    force_boot: {
      value: cdktf.booleanToHclTerraform(struct!.forceBoot),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    paused: {
      value: cdktf.booleanToHclTerraform(struct!.paused),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reset_nvram: {
      value: cdktf.booleanToHclTerraform(struct!.resetNvram),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    validate: {
      value: cdktf.booleanToHclTerraform(struct!.validate),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainCreateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainCreate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._autodestroy !== undefined) {
      hasAnyValues = true;
      internalValueResult.autodestroy = this._autodestroy;
    }
    if (this._bypassCache !== undefined) {
      hasAnyValues = true;
      internalValueResult.bypassCache = this._bypassCache;
    }
    if (this._forceBoot !== undefined) {
      hasAnyValues = true;
      internalValueResult.forceBoot = this._forceBoot;
    }
    if (this._paused !== undefined) {
      hasAnyValues = true;
      internalValueResult.paused = this._paused;
    }
    if (this._resetNvram !== undefined) {
      hasAnyValues = true;
      internalValueResult.resetNvram = this._resetNvram;
    }
    if (this._validate !== undefined) {
      hasAnyValues = true;
      internalValueResult.validate = this._validate;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainCreate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._autodestroy = undefined;
      this._bypassCache = undefined;
      this._forceBoot = undefined;
      this._paused = undefined;
      this._resetNvram = undefined;
      this._validate = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._autodestroy = value.autodestroy;
      this._bypassCache = value.bypassCache;
      this._forceBoot = value.forceBoot;
      this._paused = value.paused;
      this._resetNvram = value.resetNvram;
      this._validate = value.validate;
    }
  }

  // autodestroy - computed: false, optional: true, required: false
  private _autodestroy?: boolean | cdktf.IResolvable; 
  public get autodestroy() {
    return this.getBooleanAttribute('autodestroy');
  }
  public set autodestroy(value: boolean | cdktf.IResolvable) {
    this._autodestroy = value;
  }
  public resetAutodestroy() {
    this._autodestroy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autodestroyInput() {
    return this._autodestroy;
  }

  // bypass_cache - computed: false, optional: true, required: false
  private _bypassCache?: boolean | cdktf.IResolvable; 
  public get bypassCache() {
    return this.getBooleanAttribute('bypass_cache');
  }
  public set bypassCache(value: boolean | cdktf.IResolvable) {
    this._bypassCache = value;
  }
  public resetBypassCache() {
    this._bypassCache = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bypassCacheInput() {
    return this._bypassCache;
  }

  // force_boot - computed: false, optional: true, required: false
  private _forceBoot?: boolean | cdktf.IResolvable; 
  public get forceBoot() {
    return this.getBooleanAttribute('force_boot');
  }
  public set forceBoot(value: boolean | cdktf.IResolvable) {
    this._forceBoot = value;
  }
  public resetForceBoot() {
    this._forceBoot = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get forceBootInput() {
    return this._forceBoot;
  }

  // paused - computed: false, optional: true, required: false
  private _paused?: boolean | cdktf.IResolvable; 
  public get paused() {
    return this.getBooleanAttribute('paused');
  }
  public set paused(value: boolean | cdktf.IResolvable) {
    this._paused = value;
  }
  public resetPaused() {
    this._paused = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pausedInput() {
    return this._paused;
  }

  // reset_nvram - computed: false, optional: true, required: false
  private _resetNvram?: boolean | cdktf.IResolvable; 
  public get resetNvram() {
    return this.getBooleanAttribute('reset_nvram');
  }
  public set resetNvram(value: boolean | cdktf.IResolvable) {
    this._resetNvram = value;
  }
  public resetResetNvram() {
    this._resetNvram = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resetNvramInput() {
    return this._resetNvram;
  }

  // validate - computed: false, optional: true, required: false
  private _validate?: boolean | cdktf.IResolvable; 
  public get validate() {
    return this.getBooleanAttribute('validate');
  }
  public set validate(value: boolean | cdktf.IResolvable) {
    this._validate = value;
  }
  public resetValidate() {
    this._validate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get validateInput() {
    return this._validate;
  }
}
export interface DomainDefaultIoThread {
  /**
  * Sets the maximum number of threads in the default IOThread pool; value is user-provided and must be a non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#iothreads-allocation>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pool_max Domain#pool_max}
  */
  readonly poolMax?: number;
  /**
  * Sets the minimum number of threads in the default IOThread pool; value is user-provided and must be a non‑negative integer not greater than pool_max.
  * 
  * See: <https://libvirt.org/formatdomain.html#iothreads-allocation>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pool_min Domain#pool_min}
  */
  readonly poolMin?: number;
}

export function domainDefaultIoThreadToTerraform(struct?: DomainDefaultIoThread | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    pool_max: cdktf.numberToTerraform(struct!.poolMax),
    pool_min: cdktf.numberToTerraform(struct!.poolMin),
  }
}


export function domainDefaultIoThreadToHclTerraform(struct?: DomainDefaultIoThread | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    pool_max: {
      value: cdktf.numberToHclTerraform(struct!.poolMax),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pool_min: {
      value: cdktf.numberToHclTerraform(struct!.poolMin),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDefaultIoThreadOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDefaultIoThread | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._poolMax !== undefined) {
      hasAnyValues = true;
      internalValueResult.poolMax = this._poolMax;
    }
    if (this._poolMin !== undefined) {
      hasAnyValues = true;
      internalValueResult.poolMin = this._poolMin;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDefaultIoThread | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._poolMax = undefined;
      this._poolMin = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._poolMax = value.poolMax;
      this._poolMin = value.poolMin;
    }
  }

  // pool_max - computed: false, optional: true, required: false
  private _poolMax?: number; 
  public get poolMax() {
    return this.getNumberAttribute('pool_max');
  }
  public set poolMax(value: number) {
    this._poolMax = value;
  }
  public resetPoolMax() {
    this._poolMax = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get poolMaxInput() {
    return this._poolMax;
  }

  // pool_min - computed: false, optional: true, required: false
  private _poolMin?: number; 
  public get poolMin() {
    return this.getNumberAttribute('pool_min');
  }
  public set poolMin(value: number) {
    this._poolMin = value;
  }
  public resetPoolMin() {
    this._poolMin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get poolMinInput() {
    return this._poolMin;
  }
}
export interface DomainDestroy {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#graceful Domain#graceful}
  */
  readonly graceful?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#timeout Domain#timeout}
  */
  readonly timeout?: number;
}

export function domainDestroyToTerraform(struct?: DomainDestroy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    graceful: cdktf.booleanToTerraform(struct!.graceful),
    timeout: cdktf.numberToTerraform(struct!.timeout),
  }
}


export function domainDestroyToHclTerraform(struct?: DomainDestroy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    graceful: {
      value: cdktf.booleanToHclTerraform(struct!.graceful),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    timeout: {
      value: cdktf.numberToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDestroyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDestroy | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._graceful !== undefined) {
      hasAnyValues = true;
      internalValueResult.graceful = this._graceful;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDestroy | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._graceful = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._graceful = value.graceful;
      this._timeout = value.timeout;
    }
  }

  // graceful - computed: false, optional: true, required: false
  private _graceful?: boolean | cdktf.IResolvable; 
  public get graceful() {
    return this.getBooleanAttribute('graceful');
  }
  public set graceful(value: boolean | cdktf.IResolvable) {
    this._graceful = value;
  }
  public resetGraceful() {
    this._graceful = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gracefulInput() {
    return this._graceful;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: number; 
  public get timeout() {
    return this.getNumberAttribute('timeout');
  }
  public set timeout(value: number) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DomainDevicesAudiosAlsaInput {
  /**
  * Sets the ALSA device node used for audio output, as a host path string such as /dev/snd/pcmC0D0p.
  * 
  * See: <https://libvirt.org/formatdomain.html#alsa-audio-backend>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dev Domain#dev}
  */
  readonly dev?: string;
}

export function domainDevicesAudiosAlsaInputToTerraform(struct?: DomainDevicesAudiosAlsaInput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dev: cdktf.stringToTerraform(struct!.dev),
  }
}


export function domainDevicesAudiosAlsaInputToHclTerraform(struct?: DomainDevicesAudiosAlsaInput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dev: {
      value: cdktf.stringToHclTerraform(struct!.dev),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesAudiosAlsaInputOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesAudiosAlsaInput | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dev !== undefined) {
      hasAnyValues = true;
      internalValueResult.dev = this._dev;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesAudiosAlsaInput | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dev = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dev = value.dev;
    }
  }

  // dev - computed: false, optional: true, required: false
  private _dev?: string; 
  public get dev() {
    return this.getStringAttribute('dev');
  }
  public set dev(value: string) {
    this._dev = value;
  }
  public resetDev() {
    this._dev = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devInput() {
    return this._dev;
  }
}
export interface DomainDevicesAudiosAlsaOutput {
  /**
  * Sets the ALSA device node used for audio output, as a host path string such as /dev/snd/pcmC0D0p.
  * 
  * See: <https://libvirt.org/formatdomain.html#alsa-audio-backend>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dev Domain#dev}
  */
  readonly dev?: string;
}

export function domainDevicesAudiosAlsaOutputToTerraform(struct?: DomainDevicesAudiosAlsaOutput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dev: cdktf.stringToTerraform(struct!.dev),
  }
}


export function domainDevicesAudiosAlsaOutputToHclTerraform(struct?: DomainDevicesAudiosAlsaOutput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dev: {
      value: cdktf.stringToHclTerraform(struct!.dev),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesAudiosAlsaOutputOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesAudiosAlsaOutput | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dev !== undefined) {
      hasAnyValues = true;
      internalValueResult.dev = this._dev;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesAudiosAlsaOutput | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dev = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dev = value.dev;
    }
  }

  // dev - computed: false, optional: true, required: false
  private _dev?: string; 
  public get dev() {
    return this.getStringAttribute('dev');
  }
  public set dev(value: string) {
    this._dev = value;
  }
  public resetDev() {
    this._dev = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devInput() {
    return this._dev;
  }
}
export interface DomainDevicesAudiosAlsa {
  /**
  * Configures ALSA output (playback) settings for the audio backend.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#input Domain#input}
  */
  readonly input?: DomainDevicesAudiosAlsaInput;
  /**
  * Configures ALSA output (playback) settings for the audio backend.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#output Domain#output}
  */
  readonly output?: DomainDevicesAudiosAlsaOutput;
}

export function domainDevicesAudiosAlsaToTerraform(struct?: DomainDevicesAudiosAlsa | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    input: domainDevicesAudiosAlsaInputToTerraform(struct!.input),
    output: domainDevicesAudiosAlsaOutputToTerraform(struct!.output),
  }
}


export function domainDevicesAudiosAlsaToHclTerraform(struct?: DomainDevicesAudiosAlsa | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    input: {
      value: domainDevicesAudiosAlsaInputToHclTerraform(struct!.input),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesAudiosAlsaInput",
    },
    output: {
      value: domainDevicesAudiosAlsaOutputToHclTerraform(struct!.output),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesAudiosAlsaOutput",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesAudiosAlsaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesAudiosAlsa | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._input?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.input = this._input?.internalValue;
    }
    if (this._output?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesAudiosAlsa | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._input.internalValue = undefined;
      this._output.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._input.internalValue = value.input;
      this._output.internalValue = value.output;
    }
  }

  // input - computed: false, optional: true, required: false
  private _input = new DomainDevicesAudiosAlsaInputOutputReference(this, "input");
  public get input() {
    return this._input;
  }
  public putInput(value: DomainDevicesAudiosAlsaInput) {
    this._input.internalValue = value;
  }
  public resetInput() {
    this._input.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inputInput() {
    return this._input.internalValue;
  }

  // output - computed: false, optional: true, required: false
  private _output = new DomainDevicesAudiosAlsaOutputOutputReference(this, "output");
  public get output() {
    return this._output;
  }
  public putOutput(value: DomainDevicesAudiosAlsaOutput) {
    this._output.internalValue = value;
  }
  public resetOutput() {
    this._output.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output.internalValue;
  }
}
export interface DomainDevicesAudiosCoreAudioInput {
  /**
  * Sets the number of audio buffers CoreAudio uses for output; value is a user‑provided non‑negative integer (for example 4 or 8).
  * 
  * See: <https://libvirt.org/formatdomain.html#coreaudio-audio-backend>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#buffer_count Domain#buffer_count}
  */
  readonly bufferCount?: number;
}

export function domainDevicesAudiosCoreAudioInputToTerraform(struct?: DomainDevicesAudiosCoreAudioInput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    buffer_count: cdktf.numberToTerraform(struct!.bufferCount),
  }
}


export function domainDevicesAudiosCoreAudioInputToHclTerraform(struct?: DomainDevicesAudiosCoreAudioInput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    buffer_count: {
      value: cdktf.numberToHclTerraform(struct!.bufferCount),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesAudiosCoreAudioInputOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesAudiosCoreAudioInput | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bufferCount !== undefined) {
      hasAnyValues = true;
      internalValueResult.bufferCount = this._bufferCount;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesAudiosCoreAudioInput | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bufferCount = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bufferCount = value.bufferCount;
    }
  }

  // buffer_count - computed: false, optional: true, required: false
  private _bufferCount?: number; 
  public get bufferCount() {
    return this.getNumberAttribute('buffer_count');
  }
  public set bufferCount(value: number) {
    this._bufferCount = value;
  }
  public resetBufferCount() {
    this._bufferCount = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bufferCountInput() {
    return this._bufferCount;
  }
}
export interface DomainDevicesAudiosCoreAudioOutput {
  /**
  * Sets the number of audio buffers CoreAudio uses for output; value is a user‑provided non‑negative integer (for example 4 or 8).
  * 
  * See: <https://libvirt.org/formatdomain.html#coreaudio-audio-backend>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#buffer_count Domain#buffer_count}
  */
  readonly bufferCount?: number;
}

export function domainDevicesAudiosCoreAudioOutputToTerraform(struct?: DomainDevicesAudiosCoreAudioOutput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    buffer_count: cdktf.numberToTerraform(struct!.bufferCount),
  }
}


export function domainDevicesAudiosCoreAudioOutputToHclTerraform(struct?: DomainDevicesAudiosCoreAudioOutput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    buffer_count: {
      value: cdktf.numberToHclTerraform(struct!.bufferCount),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesAudiosCoreAudioOutputOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesAudiosCoreAudioOutput | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bufferCount !== undefined) {
      hasAnyValues = true;
      internalValueResult.bufferCount = this._bufferCount;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesAudiosCoreAudioOutput | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bufferCount = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bufferCount = value.bufferCount;
    }
  }

  // buffer_count - computed: false, optional: true, required: false
  private _bufferCount?: number; 
  public get bufferCount() {
    return this.getNumberAttribute('buffer_count');
  }
  public set bufferCount(value: number) {
    this._bufferCount = value;
  }
  public resetBufferCount() {
    this._bufferCount = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bufferCountInput() {
    return this._bufferCount;
  }
}
export interface DomainDevicesAudiosCoreAudio {
  /**
  * Configures CoreAudio output (playback) parameters for the audio backend.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#input Domain#input}
  */
  readonly input?: DomainDevicesAudiosCoreAudioInput;
  /**
  * Configures CoreAudio output (playback) parameters for the audio backend.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#output Domain#output}
  */
  readonly output?: DomainDevicesAudiosCoreAudioOutput;
}

export function domainDevicesAudiosCoreAudioToTerraform(struct?: DomainDevicesAudiosCoreAudio | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    input: domainDevicesAudiosCoreAudioInputToTerraform(struct!.input),
    output: domainDevicesAudiosCoreAudioOutputToTerraform(struct!.output),
  }
}


export function domainDevicesAudiosCoreAudioToHclTerraform(struct?: DomainDevicesAudiosCoreAudio | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    input: {
      value: domainDevicesAudiosCoreAudioInputToHclTerraform(struct!.input),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesAudiosCoreAudioInput",
    },
    output: {
      value: domainDevicesAudiosCoreAudioOutputToHclTerraform(struct!.output),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesAudiosCoreAudioOutput",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesAudiosCoreAudioOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesAudiosCoreAudio | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._input?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.input = this._input?.internalValue;
    }
    if (this._output?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesAudiosCoreAudio | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._input.internalValue = undefined;
      this._output.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._input.internalValue = value.input;
      this._output.internalValue = value.output;
    }
  }

  // input - computed: false, optional: true, required: false
  private _input = new DomainDevicesAudiosCoreAudioInputOutputReference(this, "input");
  public get input() {
    return this._input;
  }
  public putInput(value: DomainDevicesAudiosCoreAudioInput) {
    this._input.internalValue = value;
  }
  public resetInput() {
    this._input.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inputInput() {
    return this._input.internalValue;
  }

  // output - computed: false, optional: true, required: false
  private _output = new DomainDevicesAudiosCoreAudioOutputOutputReference(this, "output");
  public get output() {
    return this._output;
  }
  public putOutput(value: DomainDevicesAudiosCoreAudioOutput) {
    this._output.internalValue = value;
  }
  public resetOutput() {
    this._output.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output.internalValue;
  }
}
export interface DomainDevicesAudiosDbusInput {
}

export function domainDevicesAudiosDbusInputToTerraform(struct?: DomainDevicesAudiosDbusInput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function domainDevicesAudiosDbusInputToHclTerraform(struct?: DomainDevicesAudiosDbusInput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DomainDevicesAudiosDbusInputOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesAudiosDbusInput | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesAudiosDbusInput | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DomainDevicesAudiosDbusOutput {
}

export function domainDevicesAudiosDbusOutputToTerraform(struct?: DomainDevicesAudiosDbusOutput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function domainDevicesAudiosDbusOutputToHclTerraform(struct?: DomainDevicesAudiosDbusOutput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DomainDevicesAudiosDbusOutputOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesAudiosDbusOutput | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesAudiosDbusOutput | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DomainDevicesAudiosDbus {
  /**
  * Enables and configures output (playback) for the D‑Bus audio backend; no additional attributes are defined beyond presence.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#input Domain#input}
  */
  readonly input?: DomainDevicesAudiosDbusInput;
  /**
  * Enables and configures output (playback) for the D‑Bus audio backend; no additional attributes are defined beyond presence.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#output Domain#output}
  */
  readonly output?: DomainDevicesAudiosDbusOutput;
}

export function domainDevicesAudiosDbusToTerraform(struct?: DomainDevicesAudiosDbus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    input: domainDevicesAudiosDbusInputToTerraform(struct!.input),
    output: domainDevicesAudiosDbusOutputToTerraform(struct!.output),
  }
}


export function domainDevicesAudiosDbusToHclTerraform(struct?: DomainDevicesAudiosDbus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    input: {
      value: domainDevicesAudiosDbusInputToHclTerraform(struct!.input),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesAudiosDbusInput",
    },
    output: {
      value: domainDevicesAudiosDbusOutputToHclTerraform(struct!.output),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesAudiosDbusOutput",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesAudiosDbusOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesAudiosDbus | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._input?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.input = this._input?.internalValue;
    }
    if (this._output?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesAudiosDbus | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._input.internalValue = undefined;
      this._output.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._input.internalValue = value.input;
      this._output.internalValue = value.output;
    }
  }

  // input - computed: false, optional: true, required: false
  private _input = new DomainDevicesAudiosDbusInputOutputReference(this, "input");
  public get input() {
    return this._input;
  }
  public putInput(value: DomainDevicesAudiosDbusInput) {
    this._input.internalValue = value;
  }
  public resetInput() {
    this._input.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inputInput() {
    return this._input.internalValue;
  }

  // output - computed: false, optional: true, required: false
  private _output = new DomainDevicesAudiosDbusOutputOutputReference(this, "output");
  public get output() {
    return this._output;
  }
  public putOutput(value: DomainDevicesAudiosDbusOutput) {
    this._output.internalValue = value;
  }
  public resetOutput() {
    this._output.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output.internalValue;
  }
}
export interface DomainDevicesAudiosFileInput {
}

export function domainDevicesAudiosFileInputToTerraform(struct?: DomainDevicesAudiosFileInput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function domainDevicesAudiosFileInputToHclTerraform(struct?: DomainDevicesAudiosFileInput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DomainDevicesAudiosFileInputOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesAudiosFileInput | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesAudiosFileInput | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DomainDevicesAudiosFileOutput {
}

export function domainDevicesAudiosFileOutputToTerraform(struct?: DomainDevicesAudiosFileOutput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function domainDevicesAudiosFileOutputToHclTerraform(struct?: DomainDevicesAudiosFileOutput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DomainDevicesAudiosFileOutputOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesAudiosFileOutput | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesAudiosFileOutput | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DomainDevicesAudiosFile {
  /**
  * Enables and configures the output (playback) side of the file audio backend; presence controls whether guest output audio is written to file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#input Domain#input}
  */
  readonly input?: DomainDevicesAudiosFileInput;
  /**
  * Enables and configures the output (playback) side of the file audio backend; presence controls whether guest output audio is written to file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#output Domain#output}
  */
  readonly output?: DomainDevicesAudiosFileOutput;
  /**
  * Sets the host file path used by the file audio backend to store the recorded audio stream; the value is a user-provided filesystem path (for example, `/var/lib/libvirt/sound.wav`).
  * 
  * See: <https://libvirt.org/formatdomain.html#file-audio-backend>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path?: string;
}

export function domainDevicesAudiosFileToTerraform(struct?: DomainDevicesAudiosFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    input: domainDevicesAudiosFileInputToTerraform(struct!.input),
    output: domainDevicesAudiosFileOutputToTerraform(struct!.output),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function domainDevicesAudiosFileToHclTerraform(struct?: DomainDevicesAudiosFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    input: {
      value: domainDevicesAudiosFileInputToHclTerraform(struct!.input),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesAudiosFileInput",
    },
    output: {
      value: domainDevicesAudiosFileOutputToHclTerraform(struct!.output),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesAudiosFileOutput",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesAudiosFileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesAudiosFile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._input?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.input = this._input?.internalValue;
    }
    if (this._output?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output?.internalValue;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesAudiosFile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._input.internalValue = undefined;
      this._output.internalValue = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._input.internalValue = value.input;
      this._output.internalValue = value.output;
      this._path = value.path;
    }
  }

  // input - computed: false, optional: true, required: false
  private _input = new DomainDevicesAudiosFileInputOutputReference(this, "input");
  public get input() {
    return this._input;
  }
  public putInput(value: DomainDevicesAudiosFileInput) {
    this._input.internalValue = value;
  }
  public resetInput() {
    this._input.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inputInput() {
    return this._input.internalValue;
  }

  // output - computed: false, optional: true, required: false
  private _output = new DomainDevicesAudiosFileOutputOutputReference(this, "output");
  public get output() {
    return this._output;
  }
  public putOutput(value: DomainDevicesAudiosFileOutput) {
    this._output.internalValue = value;
  }
  public resetOutput() {
    this._output.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output.internalValue;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface DomainDevicesAudiosJackInput {
  /**
  * Sets the Jack client name used for the output stream; the value is user-provided and identifies the Jack client.
  * 
  * See: <https://libvirt.org/formatdomain.html#jack-audio-backend>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#client_name Domain#client_name}
  */
  readonly clientName?: string;
  /**
  * Controls whether the Jack backend automatically connects the output stream to Jack ports (`"yes"` or `"no"`).
  * 
  * See: <https://libvirt.org/formatdomain.html#jack-audio-backend>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#connect_ports Domain#connect_ports}
  */
  readonly connectPorts?: string;
  /**
  * Specifies whether the Jack client name for output must match exactly (`"yes"` or `"no"`), influencing how Jack selects the client.
  * 
  * See: <https://libvirt.org/formatdomain.html#jack-audio-backend>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#exact_name Domain#exact_name}
  */
  readonly exactName?: string;
  /**
  * Sets the Jack server name to which the output stream connects; the value is user-provided and must correspond to a running Jack server.
  * 
  * See: <https://libvirt.org/formatdomain.html#jack-audio-backend>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#server_name Domain#server_name}
  */
  readonly serverName?: string;
}

export function domainDevicesAudiosJackInputToTerraform(struct?: DomainDevicesAudiosJackInput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    client_name: cdktf.stringToTerraform(struct!.clientName),
    connect_ports: cdktf.stringToTerraform(struct!.connectPorts),
    exact_name: cdktf.stringToTerraform(struct!.exactName),
    server_name: cdktf.stringToTerraform(struct!.serverName),
  }
}


export function domainDevicesAudiosJackInputToHclTerraform(struct?: DomainDevicesAudiosJackInput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    client_name: {
      value: cdktf.stringToHclTerraform(struct!.clientName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connect_ports: {
      value: cdktf.stringToHclTerraform(struct!.connectPorts),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    exact_name: {
      value: cdktf.stringToHclTerraform(struct!.exactName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_name: {
      value: cdktf.stringToHclTerraform(struct!.serverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesAudiosJackInputOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesAudiosJackInput | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clientName !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientName = this._clientName;
    }
    if (this._connectPorts !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectPorts = this._connectPorts;
    }
    if (this._exactName !== undefined) {
      hasAnyValues = true;
      internalValueResult.exactName = this._exactName;
    }
    if (this._serverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverName = this._serverName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesAudiosJackInput | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clientName = undefined;
      this._connectPorts = undefined;
      this._exactName = undefined;
      this._serverName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clientName = value.clientName;
      this._connectPorts = value.connectPorts;
      this._exactName = value.exactName;
      this._serverName = value.serverName;
    }
  }

  // client_name - computed: false, optional: true, required: false
  private _clientName?: string; 
  public get clientName() {
    return this.getStringAttribute('client_name');
  }
  public set clientName(value: string) {
    this._clientName = value;
  }
  public resetClientName() {
    this._clientName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientNameInput() {
    return this._clientName;
  }

  // connect_ports - computed: false, optional: true, required: false
  private _connectPorts?: string; 
  public get connectPorts() {
    return this.getStringAttribute('connect_ports');
  }
  public set connectPorts(value: string) {
    this._connectPorts = value;
  }
  public resetConnectPorts() {
    this._connectPorts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectPortsInput() {
    return this._connectPorts;
  }

  // exact_name - computed: false, optional: true, required: false
  private _exactName?: string; 
  public get exactName() {
    return this.getStringAttribute('exact_name');
  }
  public set exactName(value: string) {
    this._exactName = value;
  }
  public resetExactName() {
    this._exactName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exactNameInput() {
    return this._exactName;
  }

  // server_name - computed: false, optional: true, required: false
  private _serverName?: string; 
  public get serverName() {
    return this.getStringAttribute('server_name');
  }
  public set serverName(value: string) {
    this._serverName = value;
  }
  public resetServerName() {
    this._serverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverNameInput() {
    return this._serverName;
  }
}
export interface DomainDevicesAudiosJackOutput {
  /**
  * Sets the Jack client name used for the output stream; the value is user-provided and identifies the Jack client.
  * 
  * See: <https://libvirt.org/formatdomain.html#jack-audio-backend>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#client_name Domain#client_name}
  */
  readonly clientName?: string;
  /**
  * Controls whether the Jack backend automatically connects the output stream to Jack ports (`"yes"` or `"no"`).
  * 
  * See: <https://libvirt.org/formatdomain.html#jack-audio-backend>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#connect_ports Domain#connect_ports}
  */
  readonly connectPorts?: string;
  /**
  * Specifies whether the Jack client name for output must match exactly (`"yes"` or `"no"`), influencing how Jack selects the client.
  * 
  * See: <https://libvirt.org/formatdomain.html#jack-audio-backend>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#exact_name Domain#exact_name}
  */
  readonly exactName?: string;
  /**
  * Sets the Jack server name to which the output stream connects; the value is user-provided and must correspond to a running Jack server.
  * 
  * See: <https://libvirt.org/formatdomain.html#jack-audio-backend>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#server_name Domain#server_name}
  */
  readonly serverName?: string;
}

export function domainDevicesAudiosJackOutputToTerraform(struct?: DomainDevicesAudiosJackOutput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    client_name: cdktf.stringToTerraform(struct!.clientName),
    connect_ports: cdktf.stringToTerraform(struct!.connectPorts),
    exact_name: cdktf.stringToTerraform(struct!.exactName),
    server_name: cdktf.stringToTerraform(struct!.serverName),
  }
}


export function domainDevicesAudiosJackOutputToHclTerraform(struct?: DomainDevicesAudiosJackOutput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    client_name: {
      value: cdktf.stringToHclTerraform(struct!.clientName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connect_ports: {
      value: cdktf.stringToHclTerraform(struct!.connectPorts),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    exact_name: {
      value: cdktf.stringToHclTerraform(struct!.exactName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_name: {
      value: cdktf.stringToHclTerraform(struct!.serverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesAudiosJackOutputOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesAudiosJackOutput | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clientName !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientName = this._clientName;
    }
    if (this._connectPorts !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectPorts = this._connectPorts;
    }
    if (this._exactName !== undefined) {
      hasAnyValues = true;
      internalValueResult.exactName = this._exactName;
    }
    if (this._serverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverName = this._serverName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesAudiosJackOutput | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clientName = undefined;
      this._connectPorts = undefined;
      this._exactName = undefined;
      this._serverName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clientName = value.clientName;
      this._connectPorts = value.connectPorts;
      this._exactName = value.exactName;
      this._serverName = value.serverName;
    }
  }

  // client_name - computed: false, optional: true, required: false
  private _clientName?: string; 
  public get clientName() {
    return this.getStringAttribute('client_name');
  }
  public set clientName(value: string) {
    this._clientName = value;
  }
  public resetClientName() {
    this._clientName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientNameInput() {
    return this._clientName;
  }

  // connect_ports - computed: false, optional: true, required: false
  private _connectPorts?: string; 
  public get connectPorts() {
    return this.getStringAttribute('connect_ports');
  }
  public set connectPorts(value: string) {
    this._connectPorts = value;
  }
  public resetConnectPorts() {
    this._connectPorts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectPortsInput() {
    return this._connectPorts;
  }

  // exact_name - computed: false, optional: true, required: false
  private _exactName?: string; 
  public get exactName() {
    return this.getStringAttribute('exact_name');
  }
  public set exactName(value: string) {
    this._exactName = value;
  }
  public resetExactName() {
    this._exactName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exactNameInput() {
    return this._exactName;
  }

  // server_name - computed: false, optional: true, required: false
  private _serverName?: string; 
  public get serverName() {
    return this.getStringAttribute('server_name');
  }
  public set serverName(value: string) {
    this._serverName = value;
  }
  public resetServerName() {
    this._serverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverNameInput() {
    return this._serverName;
  }
}
export interface DomainDevicesAudiosJack {
  /**
  * Enables and configures the output (playback) side of the Jack audio backend.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#input Domain#input}
  */
  readonly input?: DomainDevicesAudiosJackInput;
  /**
  * Enables and configures the output (playback) side of the Jack audio backend.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#output Domain#output}
  */
  readonly output?: DomainDevicesAudiosJackOutput;
}

export function domainDevicesAudiosJackToTerraform(struct?: DomainDevicesAudiosJack | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    input: domainDevicesAudiosJackInputToTerraform(struct!.input),
    output: domainDevicesAudiosJackOutputToTerraform(struct!.output),
  }
}


export function domainDevicesAudiosJackToHclTerraform(struct?: DomainDevicesAudiosJack | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    input: {
      value: domainDevicesAudiosJackInputToHclTerraform(struct!.input),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesAudiosJackInput",
    },
    output: {
      value: domainDevicesAudiosJackOutputToHclTerraform(struct!.output),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesAudiosJackOutput",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesAudiosJackOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesAudiosJack | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._input?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.input = this._input?.internalValue;
    }
    if (this._output?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesAudiosJack | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._input.internalValue = undefined;
      this._output.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._input.internalValue = value.input;
      this._output.internalValue = value.output;
    }
  }

  // input - computed: false, optional: true, required: false
  private _input = new DomainDevicesAudiosJackInputOutputReference(this, "input");
  public get input() {
    return this._input;
  }
  public putInput(value: DomainDevicesAudiosJackInput) {
    this._input.internalValue = value;
  }
  public resetInput() {
    this._input.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inputInput() {
    return this._input.internalValue;
  }

  // output - computed: false, optional: true, required: false
  private _output = new DomainDevicesAudiosJackOutputOutputReference(this, "output");
  public get output() {
    return this._output;
  }
  public putOutput(value: DomainDevicesAudiosJackOutput) {
    this._output.internalValue = value;
  }
  public resetOutput() {
    this._output.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output.internalValue;
  }
}
export interface DomainDevicesAudiosNoneInput {
}

export function domainDevicesAudiosNoneInputToTerraform(struct?: DomainDevicesAudiosNoneInput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function domainDevicesAudiosNoneInputToHclTerraform(struct?: DomainDevicesAudiosNoneInput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DomainDevicesAudiosNoneInputOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesAudiosNoneInput | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesAudiosNoneInput | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DomainDevicesAudiosNoneOutput {
}

export function domainDevicesAudiosNoneOutputToTerraform(struct?: DomainDevicesAudiosNoneOutput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function domainDevicesAudiosNoneOutputToHclTerraform(struct?: DomainDevicesAudiosNoneOutput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DomainDevicesAudiosNoneOutputOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesAudiosNoneOutput | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesAudiosNoneOutput | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DomainDevicesAudiosNone {
  /**
  * Enables a logical output side for the `"none"` audio backend; presence is for symmetry and does not connect to a real host output device.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#input Domain#input}
  */
  readonly input?: DomainDevicesAudiosNoneInput;
  /**
  * Enables a logical output side for the `"none"` audio backend; presence is for symmetry and does not connect to a real host output device.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#output Domain#output}
  */
  readonly output?: DomainDevicesAudiosNoneOutput;
}

export function domainDevicesAudiosNoneToTerraform(struct?: DomainDevicesAudiosNone | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    input: domainDevicesAudiosNoneInputToTerraform(struct!.input),
    output: domainDevicesAudiosNoneOutputToTerraform(struct!.output),
  }
}


export function domainDevicesAudiosNoneToHclTerraform(struct?: DomainDevicesAudiosNone | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    input: {
      value: domainDevicesAudiosNoneInputToHclTerraform(struct!.input),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesAudiosNoneInput",
    },
    output: {
      value: domainDevicesAudiosNoneOutputToHclTerraform(struct!.output),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesAudiosNoneOutput",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesAudiosNoneOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesAudiosNone | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._input?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.input = this._input?.internalValue;
    }
    if (this._output?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesAudiosNone | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._input.internalValue = undefined;
      this._output.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._input.internalValue = value.input;
      this._output.internalValue = value.output;
    }
  }

  // input - computed: false, optional: true, required: false
  private _input = new DomainDevicesAudiosNoneInputOutputReference(this, "input");
  public get input() {
    return this._input;
  }
  public putInput(value: DomainDevicesAudiosNoneInput) {
    this._input.internalValue = value;
  }
  public resetInput() {
    this._input.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inputInput() {
    return this._input.internalValue;
  }

  // output - computed: false, optional: true, required: false
  private _output = new DomainDevicesAudiosNoneOutputOutputReference(this, "output");
  public get output() {
    return this._output;
  }
  public putOutput(value: DomainDevicesAudiosNoneOutput) {
    this._output.internalValue = value;
  }
  public resetOutput() {
    this._output.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output.internalValue;
  }
}
export interface DomainDevicesAudiosOssInput {
  /**
  * Sets the number of audio buffers used by the OSS output stream; the value is a user-provided positive integer controlling playback latency versus smoothness.
  * 
  * See: <https://libvirt.org/formatdomain.html#oss-audio-backend>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#buffer_count Domain#buffer_count}
  */
  readonly bufferCount?: number;
  /**
  * Sets the OSS device node used for audio output, as a user-provided path such as "/dev/dsp" or another OSS playback device.
  * 
  * See: <https://libvirt.org/formatdomain.html#oss-audio-backend>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dev Domain#dev}
  */
  readonly dev?: string;
  /**
  * Controls whether the OSS output stream attempts to use poll-based I/O instead of blocking I/O, typically as a yes/no boolean string accepted by QEMU.
  * 
  * See: <https://libvirt.org/formatdomain.html#oss-audio-backend>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#try_poll Domain#try_poll}
  */
  readonly tryPoll?: string;
}

export function domainDevicesAudiosOssInputToTerraform(struct?: DomainDevicesAudiosOssInput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    buffer_count: cdktf.numberToTerraform(struct!.bufferCount),
    dev: cdktf.stringToTerraform(struct!.dev),
    try_poll: cdktf.stringToTerraform(struct!.tryPoll),
  }
}


export function domainDevicesAudiosOssInputToHclTerraform(struct?: DomainDevicesAudiosOssInput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    buffer_count: {
      value: cdktf.numberToHclTerraform(struct!.bufferCount),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    dev: {
      value: cdktf.stringToHclTerraform(struct!.dev),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    try_poll: {
      value: cdktf.stringToHclTerraform(struct!.tryPoll),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesAudiosOssInputOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesAudiosOssInput | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bufferCount !== undefined) {
      hasAnyValues = true;
      internalValueResult.bufferCount = this._bufferCount;
    }
    if (this._dev !== undefined) {
      hasAnyValues = true;
      internalValueResult.dev = this._dev;
    }
    if (this._tryPoll !== undefined) {
      hasAnyValues = true;
      internalValueResult.tryPoll = this._tryPoll;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesAudiosOssInput | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bufferCount = undefined;
      this._dev = undefined;
      this._tryPoll = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bufferCount = value.bufferCount;
      this._dev = value.dev;
      this._tryPoll = value.tryPoll;
    }
  }

  // buffer_count - computed: false, optional: true, required: false
  private _bufferCount?: number; 
  public get bufferCount() {
    return this.getNumberAttribute('buffer_count');
  }
  public set bufferCount(value: number) {
    this._bufferCount = value;
  }
  public resetBufferCount() {
    this._bufferCount = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bufferCountInput() {
    return this._bufferCount;
  }

  // dev - computed: false, optional: true, required: false
  private _dev?: string; 
  public get dev() {
    return this.getStringAttribute('dev');
  }
  public set dev(value: string) {
    this._dev = value;
  }
  public resetDev() {
    this._dev = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devInput() {
    return this._dev;
  }

  // try_poll - computed: false, optional: true, required: false
  private _tryPoll?: string; 
  public get tryPoll() {
    return this.getStringAttribute('try_poll');
  }
  public set tryPoll(value: string) {
    this._tryPoll = value;
  }
  public resetTryPoll() {
    this._tryPoll = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tryPollInput() {
    return this._tryPoll;
  }
}
export interface DomainDevicesAudiosOssOutput {
  /**
  * Sets the number of audio buffers used by the OSS output stream; the value is a user-provided positive integer controlling playback latency versus smoothness.
  * 
  * See: <https://libvirt.org/formatdomain.html#oss-audio-backend>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#buffer_count Domain#buffer_count}
  */
  readonly bufferCount?: number;
  /**
  * Sets the OSS device node used for audio output, as a user-provided path such as "/dev/dsp" or another OSS playback device.
  * 
  * See: <https://libvirt.org/formatdomain.html#oss-audio-backend>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dev Domain#dev}
  */
  readonly dev?: string;
  /**
  * Controls whether the OSS output stream attempts to use poll-based I/O instead of blocking I/O, typically as a yes/no boolean string accepted by QEMU.
  * 
  * See: <https://libvirt.org/formatdomain.html#oss-audio-backend>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#try_poll Domain#try_poll}
  */
  readonly tryPoll?: string;
}

export function domainDevicesAudiosOssOutputToTerraform(struct?: DomainDevicesAudiosOssOutput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    buffer_count: cdktf.numberToTerraform(struct!.bufferCount),
    dev: cdktf.stringToTerraform(struct!.dev),
    try_poll: cdktf.stringToTerraform(struct!.tryPoll),
  }
}


export function domainDevicesAudiosOssOutputToHclTerraform(struct?: DomainDevicesAudiosOssOutput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    buffer_count: {
      value: cdktf.numberToHclTerraform(struct!.bufferCount),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    dev: {
      value: cdktf.stringToHclTerraform(struct!.dev),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    try_poll: {
      value: cdktf.stringToHclTerraform(struct!.tryPoll),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesAudiosOssOutputOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesAudiosOssOutput | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bufferCount !== undefined) {
      hasAnyValues = true;
      internalValueResult.bufferCount = this._bufferCount;
    }
    if (this._dev !== undefined) {
      hasAnyValues = true;
      internalValueResult.dev = this._dev;
    }
    if (this._tryPoll !== undefined) {
      hasAnyValues = true;
      internalValueResult.tryPoll = this._tryPoll;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesAudiosOssOutput | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bufferCount = undefined;
      this._dev = undefined;
      this._tryPoll = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bufferCount = value.bufferCount;
      this._dev = value.dev;
      this._tryPoll = value.tryPoll;
    }
  }

  // buffer_count - computed: false, optional: true, required: false
  private _bufferCount?: number; 
  public get bufferCount() {
    return this.getNumberAttribute('buffer_count');
  }
  public set bufferCount(value: number) {
    this._bufferCount = value;
  }
  public resetBufferCount() {
    this._bufferCount = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bufferCountInput() {
    return this._bufferCount;
  }

  // dev - computed: false, optional: true, required: false
  private _dev?: string; 
  public get dev() {
    return this.getStringAttribute('dev');
  }
  public set dev(value: string) {
    this._dev = value;
  }
  public resetDev() {
    this._dev = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devInput() {
    return this._dev;
  }

  // try_poll - computed: false, optional: true, required: false
  private _tryPoll?: string; 
  public get tryPoll() {
    return this.getStringAttribute('try_poll');
  }
  public set tryPoll(value: string) {
    this._tryPoll = value;
  }
  public resetTryPoll() {
    this._tryPoll = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tryPollInput() {
    return this._tryPoll;
  }
}
export interface DomainDevicesAudiosOss {
  /**
  * Configures the OSS backend DSP scheduling policy used for the guest audio device; the value is user-provided and passed through to the OSS layer (for example, an integer priority or policy code as expected by the host OSS implementation).
  * 
  * See: <https://libvirt.org/formatdomain.html#oss-audio-backend>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dsp_policy Domain#dsp_policy}
  */
  readonly dspPolicy?: number;
  /**
  * Controls whether the OSS backend opens the host audio device in exclusive mode, typically as a yes/no boolean string accepted by QEMU (for example, "on"/"off" or "yes"/"no").
  * 
  * See: <https://libvirt.org/formatdomain.html#oss-audio-backend>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#exclusive Domain#exclusive}
  */
  readonly exclusive?: string;
  /**
  * Enables and configures the OSS audio output (playback) stream for the guest; presence of this block turns on playback via OSS with the specified attributes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#input Domain#input}
  */
  readonly input?: DomainDevicesAudiosOssInput;
  /**
  * Enables and configures the OSS audio output (playback) stream for the guest; presence of this block turns on playback via OSS with the specified attributes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#output Domain#output}
  */
  readonly output?: DomainDevicesAudiosOssOutput;
  /**
  * Controls whether the OSS backend attempts to use mmap(2)-based data transfer to the host OSS device, typically as a yes/no boolean string accepted by QEMU.
  * 
  * See: <https://libvirt.org/formatdomain.html#oss-audio-backend>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#try_m_map Domain#try_m_map}
  */
  readonly tryMMap?: string;
}

export function domainDevicesAudiosOssToTerraform(struct?: DomainDevicesAudiosOss | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dsp_policy: cdktf.numberToTerraform(struct!.dspPolicy),
    exclusive: cdktf.stringToTerraform(struct!.exclusive),
    input: domainDevicesAudiosOssInputToTerraform(struct!.input),
    output: domainDevicesAudiosOssOutputToTerraform(struct!.output),
    try_m_map: cdktf.stringToTerraform(struct!.tryMMap),
  }
}


export function domainDevicesAudiosOssToHclTerraform(struct?: DomainDevicesAudiosOss | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dsp_policy: {
      value: cdktf.numberToHclTerraform(struct!.dspPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    exclusive: {
      value: cdktf.stringToHclTerraform(struct!.exclusive),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    input: {
      value: domainDevicesAudiosOssInputToHclTerraform(struct!.input),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesAudiosOssInput",
    },
    output: {
      value: domainDevicesAudiosOssOutputToHclTerraform(struct!.output),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesAudiosOssOutput",
    },
    try_m_map: {
      value: cdktf.stringToHclTerraform(struct!.tryMMap),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesAudiosOssOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesAudiosOss | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dspPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.dspPolicy = this._dspPolicy;
    }
    if (this._exclusive !== undefined) {
      hasAnyValues = true;
      internalValueResult.exclusive = this._exclusive;
    }
    if (this._input?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.input = this._input?.internalValue;
    }
    if (this._output?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output?.internalValue;
    }
    if (this._tryMMap !== undefined) {
      hasAnyValues = true;
      internalValueResult.tryMMap = this._tryMMap;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesAudiosOss | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dspPolicy = undefined;
      this._exclusive = undefined;
      this._input.internalValue = undefined;
      this._output.internalValue = undefined;
      this._tryMMap = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dspPolicy = value.dspPolicy;
      this._exclusive = value.exclusive;
      this._input.internalValue = value.input;
      this._output.internalValue = value.output;
      this._tryMMap = value.tryMMap;
    }
  }

  // dsp_policy - computed: false, optional: true, required: false
  private _dspPolicy?: number; 
  public get dspPolicy() {
    return this.getNumberAttribute('dsp_policy');
  }
  public set dspPolicy(value: number) {
    this._dspPolicy = value;
  }
  public resetDspPolicy() {
    this._dspPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dspPolicyInput() {
    return this._dspPolicy;
  }

  // exclusive - computed: false, optional: true, required: false
  private _exclusive?: string; 
  public get exclusive() {
    return this.getStringAttribute('exclusive');
  }
  public set exclusive(value: string) {
    this._exclusive = value;
  }
  public resetExclusive() {
    this._exclusive = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exclusiveInput() {
    return this._exclusive;
  }

  // input - computed: false, optional: true, required: false
  private _input = new DomainDevicesAudiosOssInputOutputReference(this, "input");
  public get input() {
    return this._input;
  }
  public putInput(value: DomainDevicesAudiosOssInput) {
    this._input.internalValue = value;
  }
  public resetInput() {
    this._input.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inputInput() {
    return this._input.internalValue;
  }

  // output - computed: false, optional: true, required: false
  private _output = new DomainDevicesAudiosOssOutputOutputReference(this, "output");
  public get output() {
    return this._output;
  }
  public putOutput(value: DomainDevicesAudiosOssOutput) {
    this._output.internalValue = value;
  }
  public resetOutput() {
    this._output.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output.internalValue;
  }

  // try_m_map - computed: false, optional: true, required: false
  private _tryMMap?: string; 
  public get tryMMap() {
    return this.getStringAttribute('try_m_map');
  }
  public set tryMMap(value: string) {
    this._tryMMap = value;
  }
  public resetTryMMap() {
    this._tryMMap = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tryMMapInput() {
    return this._tryMMap;
  }
}
export interface DomainDevicesAudiosPipeWireInput {
  /**
  * Sets the desired latency for the PipeWire output stream as a user-provided value (for example, in microseconds or milliseconds as supported by QEMU/PipeWire).
  * 
  * See: <https://libvirt.org/formatdomain.html#pipewire-audio-backend>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#latency Domain#latency}
  */
  readonly latency?: number;
  /**
  * Sets the PipeWire sink name that the guest output stream should connect to, as a user-provided string matching a PipeWire node (for example, "alsa_output.pci-0000_00_1b.0").
  * 
  * See: <https://libvirt.org/formatdomain.html#pipewire-audio-backend>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name?: string;
  /**
  * Sets the logical stream name used for the PipeWire output stream, as a user-provided label shown in PipeWire clients (for example, "vm-audio").
  * 
  * See: <https://libvirt.org/formatdomain.html#pipewire-audio-backend>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#stream_name Domain#stream_name}
  */
  readonly streamName?: string;
}

export function domainDevicesAudiosPipeWireInputToTerraform(struct?: DomainDevicesAudiosPipeWireInput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    latency: cdktf.numberToTerraform(struct!.latency),
    name: cdktf.stringToTerraform(struct!.name),
    stream_name: cdktf.stringToTerraform(struct!.streamName),
  }
}


export function domainDevicesAudiosPipeWireInputToHclTerraform(struct?: DomainDevicesAudiosPipeWireInput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    latency: {
      value: cdktf.numberToHclTerraform(struct!.latency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    stream_name: {
      value: cdktf.stringToHclTerraform(struct!.streamName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesAudiosPipeWireInputOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesAudiosPipeWireInput | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._latency !== undefined) {
      hasAnyValues = true;
      internalValueResult.latency = this._latency;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._streamName !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamName = this._streamName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesAudiosPipeWireInput | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._latency = undefined;
      this._name = undefined;
      this._streamName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._latency = value.latency;
      this._name = value.name;
      this._streamName = value.streamName;
    }
  }

  // latency - computed: false, optional: true, required: false
  private _latency?: number; 
  public get latency() {
    return this.getNumberAttribute('latency');
  }
  public set latency(value: number) {
    this._latency = value;
  }
  public resetLatency() {
    this._latency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get latencyInput() {
    return this._latency;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // stream_name - computed: false, optional: true, required: false
  private _streamName?: string; 
  public get streamName() {
    return this.getStringAttribute('stream_name');
  }
  public set streamName(value: string) {
    this._streamName = value;
  }
  public resetStreamName() {
    this._streamName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamNameInput() {
    return this._streamName;
  }
}
export interface DomainDevicesAudiosPipeWireOutput {
  /**
  * Sets the desired latency for the PipeWire output stream as a user-provided value (for example, in microseconds or milliseconds as supported by QEMU/PipeWire).
  * 
  * See: <https://libvirt.org/formatdomain.html#pipewire-audio-backend>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#latency Domain#latency}
  */
  readonly latency?: number;
  /**
  * Sets the PipeWire sink name that the guest output stream should connect to, as a user-provided string matching a PipeWire node (for example, "alsa_output.pci-0000_00_1b.0").
  * 
  * See: <https://libvirt.org/formatdomain.html#pipewire-audio-backend>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name?: string;
  /**
  * Sets the logical stream name used for the PipeWire output stream, as a user-provided label shown in PipeWire clients (for example, "vm-audio").
  * 
  * See: <https://libvirt.org/formatdomain.html#pipewire-audio-backend>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#stream_name Domain#stream_name}
  */
  readonly streamName?: string;
}

export function domainDevicesAudiosPipeWireOutputToTerraform(struct?: DomainDevicesAudiosPipeWireOutput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    latency: cdktf.numberToTerraform(struct!.latency),
    name: cdktf.stringToTerraform(struct!.name),
    stream_name: cdktf.stringToTerraform(struct!.streamName),
  }
}


export function domainDevicesAudiosPipeWireOutputToHclTerraform(struct?: DomainDevicesAudiosPipeWireOutput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    latency: {
      value: cdktf.numberToHclTerraform(struct!.latency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    stream_name: {
      value: cdktf.stringToHclTerraform(struct!.streamName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesAudiosPipeWireOutputOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesAudiosPipeWireOutput | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._latency !== undefined) {
      hasAnyValues = true;
      internalValueResult.latency = this._latency;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._streamName !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamName = this._streamName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesAudiosPipeWireOutput | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._latency = undefined;
      this._name = undefined;
      this._streamName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._latency = value.latency;
      this._name = value.name;
      this._streamName = value.streamName;
    }
  }

  // latency - computed: false, optional: true, required: false
  private _latency?: number; 
  public get latency() {
    return this.getNumberAttribute('latency');
  }
  public set latency(value: number) {
    this._latency = value;
  }
  public resetLatency() {
    this._latency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get latencyInput() {
    return this._latency;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // stream_name - computed: false, optional: true, required: false
  private _streamName?: string; 
  public get streamName() {
    return this.getStringAttribute('stream_name');
  }
  public set streamName(value: string) {
    this._streamName = value;
  }
  public resetStreamName() {
    this._streamName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamNameInput() {
    return this._streamName;
  }
}
export interface DomainDevicesAudiosPipeWire {
  /**
  * Enables and configures the PipeWire output (playback) stream for the guest, allowing selection of sink name, stream name, and latency.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#input Domain#input}
  */
  readonly input?: DomainDevicesAudiosPipeWireInput;
  /**
  * Enables and configures the PipeWire output (playback) stream for the guest, allowing selection of sink name, stream name, and latency.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#output Domain#output}
  */
  readonly output?: DomainDevicesAudiosPipeWireOutput;
  /**
  * Sets the directory path used for locating the PipeWire runtime socket and related resources for the PipeWire audio backend; the value is a user-provided filesystem path (for example `/run/user/1000`).
  * 
  * See: <https://libvirt.org/formatdomain.html#pipewire-audio-backend>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#runtime_dir Domain#runtime_dir}
  */
  readonly runtimeDir?: string;
}

export function domainDevicesAudiosPipeWireToTerraform(struct?: DomainDevicesAudiosPipeWire | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    input: domainDevicesAudiosPipeWireInputToTerraform(struct!.input),
    output: domainDevicesAudiosPipeWireOutputToTerraform(struct!.output),
    runtime_dir: cdktf.stringToTerraform(struct!.runtimeDir),
  }
}


export function domainDevicesAudiosPipeWireToHclTerraform(struct?: DomainDevicesAudiosPipeWire | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    input: {
      value: domainDevicesAudiosPipeWireInputToHclTerraform(struct!.input),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesAudiosPipeWireInput",
    },
    output: {
      value: domainDevicesAudiosPipeWireOutputToHclTerraform(struct!.output),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesAudiosPipeWireOutput",
    },
    runtime_dir: {
      value: cdktf.stringToHclTerraform(struct!.runtimeDir),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesAudiosPipeWireOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesAudiosPipeWire | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._input?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.input = this._input?.internalValue;
    }
    if (this._output?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output?.internalValue;
    }
    if (this._runtimeDir !== undefined) {
      hasAnyValues = true;
      internalValueResult.runtimeDir = this._runtimeDir;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesAudiosPipeWire | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._input.internalValue = undefined;
      this._output.internalValue = undefined;
      this._runtimeDir = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._input.internalValue = value.input;
      this._output.internalValue = value.output;
      this._runtimeDir = value.runtimeDir;
    }
  }

  // input - computed: false, optional: true, required: false
  private _input = new DomainDevicesAudiosPipeWireInputOutputReference(this, "input");
  public get input() {
    return this._input;
  }
  public putInput(value: DomainDevicesAudiosPipeWireInput) {
    this._input.internalValue = value;
  }
  public resetInput() {
    this._input.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inputInput() {
    return this._input.internalValue;
  }

  // output - computed: false, optional: true, required: false
  private _output = new DomainDevicesAudiosPipeWireOutputOutputReference(this, "output");
  public get output() {
    return this._output;
  }
  public putOutput(value: DomainDevicesAudiosPipeWireOutput) {
    this._output.internalValue = value;
  }
  public resetOutput() {
    this._output.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output.internalValue;
  }

  // runtime_dir - computed: false, optional: true, required: false
  private _runtimeDir?: string; 
  public get runtimeDir() {
    return this.getStringAttribute('runtime_dir');
  }
  public set runtimeDir(value: string) {
    this._runtimeDir = value;
  }
  public resetRuntimeDir() {
    this._runtimeDir = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runtimeDirInput() {
    return this._runtimeDir;
  }
}
export interface DomainDevicesAudiosPulseAudioInput {
  /**
  * Sets the desired latency for the PipeWire output stream as a user-provided value (for example, in microseconds or milliseconds as supported by QEMU/PipeWire).
  * 
  * See: <https://libvirt.org/formatdomain.html#pipewire-audio-backend>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#latency Domain#latency}
  */
  readonly latency?: number;
  /**
  * Sets the PipeWire sink name that the guest output stream should connect to, as a user-provided string matching a PipeWire node (for example, "alsa_output.pci-0000_00_1b.0").
  * 
  * See: <https://libvirt.org/formatdomain.html#pipewire-audio-backend>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name?: string;
  /**
  * Sets the logical stream name used for the PipeWire output stream, as a user-provided label shown in PipeWire clients (for example, "vm-audio").
  * 
  * See: <https://libvirt.org/formatdomain.html#pipewire-audio-backend>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#stream_name Domain#stream_name}
  */
  readonly streamName?: string;
}

export function domainDevicesAudiosPulseAudioInputToTerraform(struct?: DomainDevicesAudiosPulseAudioInput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    latency: cdktf.numberToTerraform(struct!.latency),
    name: cdktf.stringToTerraform(struct!.name),
    stream_name: cdktf.stringToTerraform(struct!.streamName),
  }
}


export function domainDevicesAudiosPulseAudioInputToHclTerraform(struct?: DomainDevicesAudiosPulseAudioInput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    latency: {
      value: cdktf.numberToHclTerraform(struct!.latency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    stream_name: {
      value: cdktf.stringToHclTerraform(struct!.streamName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesAudiosPulseAudioInputOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesAudiosPulseAudioInput | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._latency !== undefined) {
      hasAnyValues = true;
      internalValueResult.latency = this._latency;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._streamName !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamName = this._streamName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesAudiosPulseAudioInput | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._latency = undefined;
      this._name = undefined;
      this._streamName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._latency = value.latency;
      this._name = value.name;
      this._streamName = value.streamName;
    }
  }

  // latency - computed: false, optional: true, required: false
  private _latency?: number; 
  public get latency() {
    return this.getNumberAttribute('latency');
  }
  public set latency(value: number) {
    this._latency = value;
  }
  public resetLatency() {
    this._latency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get latencyInput() {
    return this._latency;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // stream_name - computed: false, optional: true, required: false
  private _streamName?: string; 
  public get streamName() {
    return this.getStringAttribute('stream_name');
  }
  public set streamName(value: string) {
    this._streamName = value;
  }
  public resetStreamName() {
    this._streamName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamNameInput() {
    return this._streamName;
  }
}
export interface DomainDevicesAudiosPulseAudioOutput {
  /**
  * Sets the desired latency for the PipeWire output stream as a user-provided value (for example, in microseconds or milliseconds as supported by QEMU/PipeWire).
  * 
  * See: <https://libvirt.org/formatdomain.html#pipewire-audio-backend>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#latency Domain#latency}
  */
  readonly latency?: number;
  /**
  * Sets the PipeWire sink name that the guest output stream should connect to, as a user-provided string matching a PipeWire node (for example, "alsa_output.pci-0000_00_1b.0").
  * 
  * See: <https://libvirt.org/formatdomain.html#pipewire-audio-backend>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name?: string;
  /**
  * Sets the logical stream name used for the PipeWire output stream, as a user-provided label shown in PipeWire clients (for example, "vm-audio").
  * 
  * See: <https://libvirt.org/formatdomain.html#pipewire-audio-backend>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#stream_name Domain#stream_name}
  */
  readonly streamName?: string;
}

export function domainDevicesAudiosPulseAudioOutputToTerraform(struct?: DomainDevicesAudiosPulseAudioOutput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    latency: cdktf.numberToTerraform(struct!.latency),
    name: cdktf.stringToTerraform(struct!.name),
    stream_name: cdktf.stringToTerraform(struct!.streamName),
  }
}


export function domainDevicesAudiosPulseAudioOutputToHclTerraform(struct?: DomainDevicesAudiosPulseAudioOutput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    latency: {
      value: cdktf.numberToHclTerraform(struct!.latency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    stream_name: {
      value: cdktf.stringToHclTerraform(struct!.streamName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesAudiosPulseAudioOutputOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesAudiosPulseAudioOutput | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._latency !== undefined) {
      hasAnyValues = true;
      internalValueResult.latency = this._latency;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._streamName !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamName = this._streamName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesAudiosPulseAudioOutput | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._latency = undefined;
      this._name = undefined;
      this._streamName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._latency = value.latency;
      this._name = value.name;
      this._streamName = value.streamName;
    }
  }

  // latency - computed: false, optional: true, required: false
  private _latency?: number; 
  public get latency() {
    return this.getNumberAttribute('latency');
  }
  public set latency(value: number) {
    this._latency = value;
  }
  public resetLatency() {
    this._latency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get latencyInput() {
    return this._latency;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // stream_name - computed: false, optional: true, required: false
  private _streamName?: string; 
  public get streamName() {
    return this.getStringAttribute('stream_name');
  }
  public set streamName(value: string) {
    this._streamName = value;
  }
  public resetStreamName() {
    this._streamName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamNameInput() {
    return this._streamName;
  }
}
export interface DomainDevicesAudiosPulseAudio {
  /**
  * Enables and configures the PipeWire output (playback) stream for the guest, allowing selection of sink name, stream name, and latency.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#input Domain#input}
  */
  readonly input?: DomainDevicesAudiosPulseAudioInput;
  /**
  * Enables and configures the PipeWire output (playback) stream for the guest, allowing selection of sink name, stream name, and latency.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#output Domain#output}
  */
  readonly output?: DomainDevicesAudiosPulseAudioOutput;
  /**
  * Sets the hostname or address of the PulseAudio server the domain should connect to; if omitted, PulseAudio’s default server discovery is used.
  * 
  * See: <https://libvirt.org/formatdomain.html#pulseaudio-audio-backend>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#server_name Domain#server_name}
  */
  readonly serverName?: string;
}

export function domainDevicesAudiosPulseAudioToTerraform(struct?: DomainDevicesAudiosPulseAudio | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    input: domainDevicesAudiosPulseAudioInputToTerraform(struct!.input),
    output: domainDevicesAudiosPulseAudioOutputToTerraform(struct!.output),
    server_name: cdktf.stringToTerraform(struct!.serverName),
  }
}


export function domainDevicesAudiosPulseAudioToHclTerraform(struct?: DomainDevicesAudiosPulseAudio | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    input: {
      value: domainDevicesAudiosPulseAudioInputToHclTerraform(struct!.input),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesAudiosPulseAudioInput",
    },
    output: {
      value: domainDevicesAudiosPulseAudioOutputToHclTerraform(struct!.output),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesAudiosPulseAudioOutput",
    },
    server_name: {
      value: cdktf.stringToHclTerraform(struct!.serverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesAudiosPulseAudioOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesAudiosPulseAudio | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._input?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.input = this._input?.internalValue;
    }
    if (this._output?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output?.internalValue;
    }
    if (this._serverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverName = this._serverName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesAudiosPulseAudio | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._input.internalValue = undefined;
      this._output.internalValue = undefined;
      this._serverName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._input.internalValue = value.input;
      this._output.internalValue = value.output;
      this._serverName = value.serverName;
    }
  }

  // input - computed: false, optional: true, required: false
  private _input = new DomainDevicesAudiosPulseAudioInputOutputReference(this, "input");
  public get input() {
    return this._input;
  }
  public putInput(value: DomainDevicesAudiosPulseAudioInput) {
    this._input.internalValue = value;
  }
  public resetInput() {
    this._input.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inputInput() {
    return this._input.internalValue;
  }

  // output - computed: false, optional: true, required: false
  private _output = new DomainDevicesAudiosPulseAudioOutputOutputReference(this, "output");
  public get output() {
    return this._output;
  }
  public putOutput(value: DomainDevicesAudiosPulseAudioOutput) {
    this._output.internalValue = value;
  }
  public resetOutput() {
    this._output.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output.internalValue;
  }

  // server_name - computed: false, optional: true, required: false
  private _serverName?: string; 
  public get serverName() {
    return this.getStringAttribute('server_name');
  }
  public set serverName(value: string) {
    this._serverName = value;
  }
  public resetServerName() {
    this._serverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverNameInput() {
    return this._serverName;
  }
}
export interface DomainDevicesAudiosSdlInput {
  /**
  * Sets the number of audio buffers used for SDL output; the value is a user-provided non-negative integer controlling playback buffering depth.
  * 
  * See: <https://libvirt.org/formatdomain.html#sdl-audio-backend>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#buffer_count Domain#buffer_count}
  */
  readonly bufferCount?: number;
}

export function domainDevicesAudiosSdlInputToTerraform(struct?: DomainDevicesAudiosSdlInput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    buffer_count: cdktf.numberToTerraform(struct!.bufferCount),
  }
}


export function domainDevicesAudiosSdlInputToHclTerraform(struct?: DomainDevicesAudiosSdlInput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    buffer_count: {
      value: cdktf.numberToHclTerraform(struct!.bufferCount),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesAudiosSdlInputOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesAudiosSdlInput | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bufferCount !== undefined) {
      hasAnyValues = true;
      internalValueResult.bufferCount = this._bufferCount;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesAudiosSdlInput | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bufferCount = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bufferCount = value.bufferCount;
    }
  }

  // buffer_count - computed: false, optional: true, required: false
  private _bufferCount?: number; 
  public get bufferCount() {
    return this.getNumberAttribute('buffer_count');
  }
  public set bufferCount(value: number) {
    this._bufferCount = value;
  }
  public resetBufferCount() {
    this._bufferCount = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bufferCountInput() {
    return this._bufferCount;
  }
}
export interface DomainDevicesAudiosSdlOutput {
  /**
  * Sets the number of audio buffers used for SDL output; the value is a user-provided non-negative integer controlling playback buffering depth.
  * 
  * See: <https://libvirt.org/formatdomain.html#sdl-audio-backend>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#buffer_count Domain#buffer_count}
  */
  readonly bufferCount?: number;
}

export function domainDevicesAudiosSdlOutputToTerraform(struct?: DomainDevicesAudiosSdlOutput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    buffer_count: cdktf.numberToTerraform(struct!.bufferCount),
  }
}


export function domainDevicesAudiosSdlOutputToHclTerraform(struct?: DomainDevicesAudiosSdlOutput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    buffer_count: {
      value: cdktf.numberToHclTerraform(struct!.bufferCount),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesAudiosSdlOutputOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesAudiosSdlOutput | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bufferCount !== undefined) {
      hasAnyValues = true;
      internalValueResult.bufferCount = this._bufferCount;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesAudiosSdlOutput | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bufferCount = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bufferCount = value.bufferCount;
    }
  }

  // buffer_count - computed: false, optional: true, required: false
  private _bufferCount?: number; 
  public get bufferCount() {
    return this.getNumberAttribute('buffer_count');
  }
  public set bufferCount(value: number) {
    this._bufferCount = value;
  }
  public resetBufferCount() {
    this._bufferCount = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bufferCountInput() {
    return this._bufferCount;
  }
}
export interface DomainDevicesAudiosSdl {
  /**
  * Sets the SDL audio driver name to use (mapped to the `SDL_AUDIODRIVER` value); the string is user-provided and should match a valid SDL audio driver on the host (for example `alsa` or `pulseaudio`).
  * 
  * See: <https://libvirt.org/formatdomain.html#sdl-audio-backend>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#driver Domain#driver}
  */
  readonly driver?: string;
  /**
  * Configures output (playback) options for the SDL audio backend, including buffer sizing for the output stream.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#input Domain#input}
  */
  readonly input?: DomainDevicesAudiosSdlInput;
  /**
  * Configures output (playback) options for the SDL audio backend, including buffer sizing for the output stream.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#output Domain#output}
  */
  readonly output?: DomainDevicesAudiosSdlOutput;
}

export function domainDevicesAudiosSdlToTerraform(struct?: DomainDevicesAudiosSdl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    driver: cdktf.stringToTerraform(struct!.driver),
    input: domainDevicesAudiosSdlInputToTerraform(struct!.input),
    output: domainDevicesAudiosSdlOutputToTerraform(struct!.output),
  }
}


export function domainDevicesAudiosSdlToHclTerraform(struct?: DomainDevicesAudiosSdl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    driver: {
      value: cdktf.stringToHclTerraform(struct!.driver),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    input: {
      value: domainDevicesAudiosSdlInputToHclTerraform(struct!.input),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesAudiosSdlInput",
    },
    output: {
      value: domainDevicesAudiosSdlOutputToHclTerraform(struct!.output),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesAudiosSdlOutput",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesAudiosSdlOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesAudiosSdl | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._driver !== undefined) {
      hasAnyValues = true;
      internalValueResult.driver = this._driver;
    }
    if (this._input?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.input = this._input?.internalValue;
    }
    if (this._output?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesAudiosSdl | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._driver = undefined;
      this._input.internalValue = undefined;
      this._output.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._driver = value.driver;
      this._input.internalValue = value.input;
      this._output.internalValue = value.output;
    }
  }

  // driver - computed: false, optional: true, required: false
  private _driver?: string; 
  public get driver() {
    return this.getStringAttribute('driver');
  }
  public set driver(value: string) {
    this._driver = value;
  }
  public resetDriver() {
    this._driver = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get driverInput() {
    return this._driver;
  }

  // input - computed: false, optional: true, required: false
  private _input = new DomainDevicesAudiosSdlInputOutputReference(this, "input");
  public get input() {
    return this._input;
  }
  public putInput(value: DomainDevicesAudiosSdlInput) {
    this._input.internalValue = value;
  }
  public resetInput() {
    this._input.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inputInput() {
    return this._input.internalValue;
  }

  // output - computed: false, optional: true, required: false
  private _output = new DomainDevicesAudiosSdlOutputOutputReference(this, "output");
  public get output() {
    return this._output;
  }
  public putOutput(value: DomainDevicesAudiosSdlOutput) {
    this._output.internalValue = value;
  }
  public resetOutput() {
    this._output.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output.internalValue;
  }
}
export interface DomainDevicesAudiosSpiceInput {
}

export function domainDevicesAudiosSpiceInputToTerraform(struct?: DomainDevicesAudiosSpiceInput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function domainDevicesAudiosSpiceInputToHclTerraform(struct?: DomainDevicesAudiosSpiceInput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DomainDevicesAudiosSpiceInputOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesAudiosSpiceInput | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesAudiosSpiceInput | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DomainDevicesAudiosSpiceOutput {
}

export function domainDevicesAudiosSpiceOutputToTerraform(struct?: DomainDevicesAudiosSpiceOutput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function domainDevicesAudiosSpiceOutputToHclTerraform(struct?: DomainDevicesAudiosSpiceOutput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DomainDevicesAudiosSpiceOutputOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesAudiosSpiceOutput | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesAudiosSpiceOutput | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DomainDevicesAudiosSpice {
  /**
  * Declares an output (playback) stream for the SPICE audio backend; presence of this block enables SPICE audio playback with default stream properties.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#input Domain#input}
  */
  readonly input?: DomainDevicesAudiosSpiceInput;
  /**
  * Declares an output (playback) stream for the SPICE audio backend; presence of this block enables SPICE audio playback with default stream properties.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#output Domain#output}
  */
  readonly output?: DomainDevicesAudiosSpiceOutput;
}

export function domainDevicesAudiosSpiceToTerraform(struct?: DomainDevicesAudiosSpice | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    input: domainDevicesAudiosSpiceInputToTerraform(struct!.input),
    output: domainDevicesAudiosSpiceOutputToTerraform(struct!.output),
  }
}


export function domainDevicesAudiosSpiceToHclTerraform(struct?: DomainDevicesAudiosSpice | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    input: {
      value: domainDevicesAudiosSpiceInputToHclTerraform(struct!.input),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesAudiosSpiceInput",
    },
    output: {
      value: domainDevicesAudiosSpiceOutputToHclTerraform(struct!.output),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesAudiosSpiceOutput",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesAudiosSpiceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesAudiosSpice | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._input?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.input = this._input?.internalValue;
    }
    if (this._output?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesAudiosSpice | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._input.internalValue = undefined;
      this._output.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._input.internalValue = value.input;
      this._output.internalValue = value.output;
    }
  }

  // input - computed: false, optional: true, required: false
  private _input = new DomainDevicesAudiosSpiceInputOutputReference(this, "input");
  public get input() {
    return this._input;
  }
  public putInput(value: DomainDevicesAudiosSpiceInput) {
    this._input.internalValue = value;
  }
  public resetInput() {
    this._input.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inputInput() {
    return this._input.internalValue;
  }

  // output - computed: false, optional: true, required: false
  private _output = new DomainDevicesAudiosSpiceOutputOutputReference(this, "output");
  public get output() {
    return this._output;
  }
  public putOutput(value: DomainDevicesAudiosSpiceOutput) {
    this._output.internalValue = value;
  }
  public resetOutput() {
    this._output.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output.internalValue;
  }
}
export interface DomainDevicesAudios {
  /**
  * Configures an ALSA audio backend, delegating guest audio I/O to the host ALSA framework.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#alsa Domain#alsa}
  */
  readonly alsa?: DomainDevicesAudiosAlsa;
  /**
  * Configures a CoreAudio audio backend, delegating guest audio I/O to the macOS CoreAudio framework.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#core_audio Domain#core_audio}
  */
  readonly coreAudio?: DomainDevicesAudiosCoreAudio;
  /**
  * Configures a D‑Bus audio backend, which exposes audio via D‑Bus rather than a host audio framework.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dbus Domain#dbus}
  */
  readonly dbus?: DomainDevicesAudiosDbus;
  /**
  * Configures the file-based audio backend, which records guest audio streams to a host file instead of a real audio device.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file?: DomainDevicesAudiosFile;
  /**
  * Configures the Jack audio backend, delegating guest audio I/O to a Jack daemon.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#jack Domain#jack}
  */
  readonly jack?: DomainDevicesAudiosJack;
  /**
  * Configures the dummy `"none"` audio backend, which does not use any host audio framework but still allows remote desktop protocols to carry audio.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#none Domain#none}
  */
  readonly none?: DomainDevicesAudiosNone;
  /**
  * Configures the OSS audio backend, delegating guest audio I/O to the host OSS framework and allowing additional OSS-specific options on the audio element.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#oss Domain#oss}
  */
  readonly oss?: DomainDevicesAudiosOss;
  /**
  * Enables and configures a PipeWire audio backend for the guest, delegating audio I/O to a PipeWire daemon with optional per-stream settings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pipe_wire Domain#pipe_wire}
  */
  readonly pipeWire?: DomainDevicesAudiosPipeWire;
  /**
  * Enables configuration of a PulseAudio audio backend attached to the domain, allowing you to specify connection and stream properties for PulseAudio input/output.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pulse_audio Domain#pulse_audio}
  */
  readonly pulseAudio?: DomainDevicesAudiosPulseAudio;
  /**
  * Enables configuration of an SDL-based audio backend for the domain, allowing you to tune the underlying SDL audio driver and buffer settings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sdl Domain#sdl}
  */
  readonly sdl?: DomainDevicesAudiosSdl;
  /**
  * Enables configuration of a SPICE-only audio backend, which routes audio exclusively through a SPICE server without using a host audio framework.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#spice Domain#spice}
  */
  readonly spice?: DomainDevicesAudiosSpice;
  /**
  * Sets the audio backend timer period in milliseconds, controlling how often audio buffers are processed; the value is user-provided and should be a positive integer supported by the chosen backend.
  * 
  * See: <https://libvirt.org/formatdomain.html#audio-backends>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#timer_period Domain#timer_period}
  */
  readonly timerPeriod?: number;
}

export function domainDevicesAudiosToTerraform(struct?: DomainDevicesAudios | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    alsa: domainDevicesAudiosAlsaToTerraform(struct!.alsa),
    core_audio: domainDevicesAudiosCoreAudioToTerraform(struct!.coreAudio),
    dbus: domainDevicesAudiosDbusToTerraform(struct!.dbus),
    file: domainDevicesAudiosFileToTerraform(struct!.file),
    jack: domainDevicesAudiosJackToTerraform(struct!.jack),
    none: domainDevicesAudiosNoneToTerraform(struct!.none),
    oss: domainDevicesAudiosOssToTerraform(struct!.oss),
    pipe_wire: domainDevicesAudiosPipeWireToTerraform(struct!.pipeWire),
    pulse_audio: domainDevicesAudiosPulseAudioToTerraform(struct!.pulseAudio),
    sdl: domainDevicesAudiosSdlToTerraform(struct!.sdl),
    spice: domainDevicesAudiosSpiceToTerraform(struct!.spice),
    timer_period: cdktf.numberToTerraform(struct!.timerPeriod),
  }
}


export function domainDevicesAudiosToHclTerraform(struct?: DomainDevicesAudios | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    alsa: {
      value: domainDevicesAudiosAlsaToHclTerraform(struct!.alsa),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesAudiosAlsa",
    },
    core_audio: {
      value: domainDevicesAudiosCoreAudioToHclTerraform(struct!.coreAudio),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesAudiosCoreAudio",
    },
    dbus: {
      value: domainDevicesAudiosDbusToHclTerraform(struct!.dbus),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesAudiosDbus",
    },
    file: {
      value: domainDevicesAudiosFileToHclTerraform(struct!.file),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesAudiosFile",
    },
    jack: {
      value: domainDevicesAudiosJackToHclTerraform(struct!.jack),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesAudiosJack",
    },
    none: {
      value: domainDevicesAudiosNoneToHclTerraform(struct!.none),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesAudiosNone",
    },
    oss: {
      value: domainDevicesAudiosOssToHclTerraform(struct!.oss),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesAudiosOss",
    },
    pipe_wire: {
      value: domainDevicesAudiosPipeWireToHclTerraform(struct!.pipeWire),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesAudiosPipeWire",
    },
    pulse_audio: {
      value: domainDevicesAudiosPulseAudioToHclTerraform(struct!.pulseAudio),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesAudiosPulseAudio",
    },
    sdl: {
      value: domainDevicesAudiosSdlToHclTerraform(struct!.sdl),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesAudiosSdl",
    },
    spice: {
      value: domainDevicesAudiosSpiceToHclTerraform(struct!.spice),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesAudiosSpice",
    },
    timer_period: {
      value: cdktf.numberToHclTerraform(struct!.timerPeriod),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesAudiosOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesAudios | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._alsa?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.alsa = this._alsa?.internalValue;
    }
    if (this._coreAudio?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.coreAudio = this._coreAudio?.internalValue;
    }
    if (this._dbus?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dbus = this._dbus?.internalValue;
    }
    if (this._file?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file?.internalValue;
    }
    if (this._jack?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jack = this._jack?.internalValue;
    }
    if (this._none?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.none = this._none?.internalValue;
    }
    if (this._oss?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oss = this._oss?.internalValue;
    }
    if (this._pipeWire?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeWire = this._pipeWire?.internalValue;
    }
    if (this._pulseAudio?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pulseAudio = this._pulseAudio?.internalValue;
    }
    if (this._sdl?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sdl = this._sdl?.internalValue;
    }
    if (this._spice?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spice = this._spice?.internalValue;
    }
    if (this._timerPeriod !== undefined) {
      hasAnyValues = true;
      internalValueResult.timerPeriod = this._timerPeriod;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesAudios | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._alsa.internalValue = undefined;
      this._coreAudio.internalValue = undefined;
      this._dbus.internalValue = undefined;
      this._file.internalValue = undefined;
      this._jack.internalValue = undefined;
      this._none.internalValue = undefined;
      this._oss.internalValue = undefined;
      this._pipeWire.internalValue = undefined;
      this._pulseAudio.internalValue = undefined;
      this._sdl.internalValue = undefined;
      this._spice.internalValue = undefined;
      this._timerPeriod = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._alsa.internalValue = value.alsa;
      this._coreAudio.internalValue = value.coreAudio;
      this._dbus.internalValue = value.dbus;
      this._file.internalValue = value.file;
      this._jack.internalValue = value.jack;
      this._none.internalValue = value.none;
      this._oss.internalValue = value.oss;
      this._pipeWire.internalValue = value.pipeWire;
      this._pulseAudio.internalValue = value.pulseAudio;
      this._sdl.internalValue = value.sdl;
      this._spice.internalValue = value.spice;
      this._timerPeriod = value.timerPeriod;
    }
  }

  // alsa - computed: false, optional: true, required: false
  private _alsa = new DomainDevicesAudiosAlsaOutputReference(this, "alsa");
  public get alsa() {
    return this._alsa;
  }
  public putAlsa(value: DomainDevicesAudiosAlsa) {
    this._alsa.internalValue = value;
  }
  public resetAlsa() {
    this._alsa.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get alsaInput() {
    return this._alsa.internalValue;
  }

  // core_audio - computed: false, optional: true, required: false
  private _coreAudio = new DomainDevicesAudiosCoreAudioOutputReference(this, "core_audio");
  public get coreAudio() {
    return this._coreAudio;
  }
  public putCoreAudio(value: DomainDevicesAudiosCoreAudio) {
    this._coreAudio.internalValue = value;
  }
  public resetCoreAudio() {
    this._coreAudio.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get coreAudioInput() {
    return this._coreAudio.internalValue;
  }

  // dbus - computed: false, optional: true, required: false
  private _dbus = new DomainDevicesAudiosDbusOutputReference(this, "dbus");
  public get dbus() {
    return this._dbus;
  }
  public putDbus(value: DomainDevicesAudiosDbus) {
    this._dbus.internalValue = value;
  }
  public resetDbus() {
    this._dbus.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dbusInput() {
    return this._dbus.internalValue;
  }

  // file - computed: false, optional: true, required: false
  private _file = new DomainDevicesAudiosFileOutputReference(this, "file");
  public get file() {
    return this._file;
  }
  public putFile(value: DomainDevicesAudiosFile) {
    this._file.internalValue = value;
  }
  public resetFile() {
    this._file.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file.internalValue;
  }

  // id - computed: true, optional: false, required: false
  public get id() {
    return this.getNumberAttribute('id');
  }

  // jack - computed: false, optional: true, required: false
  private _jack = new DomainDevicesAudiosJackOutputReference(this, "jack");
  public get jack() {
    return this._jack;
  }
  public putJack(value: DomainDevicesAudiosJack) {
    this._jack.internalValue = value;
  }
  public resetJack() {
    this._jack.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jackInput() {
    return this._jack.internalValue;
  }

  // none - computed: false, optional: true, required: false
  private _none = new DomainDevicesAudiosNoneOutputReference(this, "none");
  public get none() {
    return this._none;
  }
  public putNone(value: DomainDevicesAudiosNone) {
    this._none.internalValue = value;
  }
  public resetNone() {
    this._none.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get noneInput() {
    return this._none.internalValue;
  }

  // oss - computed: false, optional: true, required: false
  private _oss = new DomainDevicesAudiosOssOutputReference(this, "oss");
  public get oss() {
    return this._oss;
  }
  public putOss(value: DomainDevicesAudiosOss) {
    this._oss.internalValue = value;
  }
  public resetOss() {
    this._oss.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ossInput() {
    return this._oss.internalValue;
  }

  // pipe_wire - computed: false, optional: true, required: false
  private _pipeWire = new DomainDevicesAudiosPipeWireOutputReference(this, "pipe_wire");
  public get pipeWire() {
    return this._pipeWire;
  }
  public putPipeWire(value: DomainDevicesAudiosPipeWire) {
    this._pipeWire.internalValue = value;
  }
  public resetPipeWire() {
    this._pipeWire.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipeWireInput() {
    return this._pipeWire.internalValue;
  }

  // pulse_audio - computed: false, optional: true, required: false
  private _pulseAudio = new DomainDevicesAudiosPulseAudioOutputReference(this, "pulse_audio");
  public get pulseAudio() {
    return this._pulseAudio;
  }
  public putPulseAudio(value: DomainDevicesAudiosPulseAudio) {
    this._pulseAudio.internalValue = value;
  }
  public resetPulseAudio() {
    this._pulseAudio.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pulseAudioInput() {
    return this._pulseAudio.internalValue;
  }

  // sdl - computed: false, optional: true, required: false
  private _sdl = new DomainDevicesAudiosSdlOutputReference(this, "sdl");
  public get sdl() {
    return this._sdl;
  }
  public putSdl(value: DomainDevicesAudiosSdl) {
    this._sdl.internalValue = value;
  }
  public resetSdl() {
    this._sdl.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sdlInput() {
    return this._sdl.internalValue;
  }

  // spice - computed: false, optional: true, required: false
  private _spice = new DomainDevicesAudiosSpiceOutputReference(this, "spice");
  public get spice() {
    return this._spice;
  }
  public putSpice(value: DomainDevicesAudiosSpice) {
    this._spice.internalValue = value;
  }
  public resetSpice() {
    this._spice.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spiceInput() {
    return this._spice.internalValue;
  }

  // timer_period - computed: false, optional: true, required: false
  private _timerPeriod?: number; 
  public get timerPeriod() {
    return this.getNumberAttribute('timer_period');
  }
  public set timerPeriod(value: number) {
    this._timerPeriod = value;
  }
  public resetTimerPeriod() {
    this._timerPeriod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timerPeriodInput() {
    return this._timerPeriod;
  }
}

export class DomainDevicesAudiosList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesAudios[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesAudiosOutputReference {
    return new DomainDevicesAudiosOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesChannelsAcpi {
  /**
  * Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#pstore>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#index Domain#index}
  */
  readonly index?: number;
}

export function domainDevicesChannelsAcpiToTerraform(struct?: DomainDevicesChannelsAcpi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    index: cdktf.numberToTerraform(struct!.index),
  }
}


export function domainDevicesChannelsAcpiToHclTerraform(struct?: DomainDevicesChannelsAcpi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    index: {
      value: cdktf.numberToHclTerraform(struct!.index),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesChannelsAcpiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesChannelsAcpi | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._index !== undefined) {
      hasAnyValues = true;
      internalValueResult.index = this._index;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesChannelsAcpi | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._index = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._index = value.index;
    }
  }

  // index - computed: false, optional: true, required: false
  private _index?: number; 
  public get index() {
    return this.getNumberAttribute('index');
  }
  public set index(value: number) {
    this._index = value;
  }
  public resetIndex() {
    this._index = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get indexInput() {
    return this._index;
  }
}
export interface DomainDevicesChannelsAddress {
}

export function domainDevicesChannelsAddressToTerraform(struct?: DomainDevicesChannelsAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function domainDevicesChannelsAddressToHclTerraform(struct?: DomainDevicesChannelsAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DomainDevicesChannelsAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesChannelsAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesChannelsAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DomainDevicesChannelsAlias {
  /**
  * Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
}

export function domainDevicesChannelsAliasToTerraform(struct?: DomainDevicesChannelsAlias | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function domainDevicesChannelsAliasToHclTerraform(struct?: DomainDevicesChannelsAlias | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesChannelsAliasOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesChannelsAlias | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesChannelsAlias | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DomainDevicesChannelsLog {
  /**
  * Controls whether the channel log file is appended to (`"yes"`) or truncated (`"no"`) on start; this is a yes/no string flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#device-logfile>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#append Domain#append}
  */
  readonly append?: string;
  /**
  * Sets the absolute or relative path of the host file where channel I/O is logged.
  * 
  * See: <https://libvirt.org/formatdomain.html#device-logfile>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file: string;
}

export function domainDevicesChannelsLogToTerraform(struct?: DomainDevicesChannelsLog | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.stringToTerraform(struct!.append),
    file: cdktf.stringToTerraform(struct!.file),
  }
}


export function domainDevicesChannelsLogToHclTerraform(struct?: DomainDevicesChannelsLog | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.stringToHclTerraform(struct!.append),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    file: {
      value: cdktf.stringToHclTerraform(struct!.file),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesChannelsLogOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesChannelsLog | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append;
    }
    if (this._file !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesChannelsLog | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append = undefined;
      this._file = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append = value.append;
      this._file = value.file;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append?: string; 
  public get append() {
    return this.getStringAttribute('append');
  }
  public set append(value: string) {
    this._append = value;
  }
  public resetAppend() {
    this._append = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append;
  }

  // file - computed: false, optional: false, required: true
  private _file?: string; 
  public get file() {
    return this.getStringAttribute('file');
  }
  public set file(value: string) {
    this._file = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file;
  }
}
export interface DomainDevicesChannelsProtocol {
  /**
  * Sets the EGD transport type, such as "tcp" or "unix"; value is a user-provided string supported by the hypervisor.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type: string;
}

export function domainDevicesChannelsProtocolToTerraform(struct?: DomainDevicesChannelsProtocol | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function domainDevicesChannelsProtocolToHclTerraform(struct?: DomainDevicesChannelsProtocol | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesChannelsProtocolOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesChannelsProtocol | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesChannelsProtocol | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._type = value.type;
    }
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DomainDevicesChannelsSourceDbus {
  /**
  * Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#channel Domain#channel}
  */
  readonly channel?: string;
}

export function domainDevicesChannelsSourceDbusToTerraform(struct?: DomainDevicesChannelsSourceDbus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    channel: cdktf.stringToTerraform(struct!.channel),
  }
}


export function domainDevicesChannelsSourceDbusToHclTerraform(struct?: DomainDevicesChannelsSourceDbus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    channel: {
      value: cdktf.stringToHclTerraform(struct!.channel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesChannelsSourceDbusOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesChannelsSourceDbus | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._channel !== undefined) {
      hasAnyValues = true;
      internalValueResult.channel = this._channel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesChannelsSourceDbus | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._channel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._channel = value.channel;
    }
  }

  // channel - computed: false, optional: true, required: false
  private _channel?: string; 
  public get channel() {
    return this.getStringAttribute('channel');
  }
  public set channel(value: string) {
    this._channel = value;
  }
  public resetChannel() {
    this._channel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get channelInput() {
    return this._channel;
  }
}
export interface DomainDevicesChannelsSourceDevSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesChannelsSourceDevSecLabelToTerraform(struct?: DomainDevicesChannelsSourceDevSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesChannelsSourceDevSecLabelToHclTerraform(struct?: DomainDevicesChannelsSourceDevSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesChannelsSourceDevSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesChannelsSourceDevSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesChannelsSourceDevSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesChannelsSourceDevSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesChannelsSourceDevSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesChannelsSourceDevSecLabelOutputReference {
    return new DomainDevicesChannelsSourceDevSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesChannelsSourceDev {
  /**
  * Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesChannelsSourceDevSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesChannelsSourceDevToTerraform(struct?: DomainDevicesChannelsSourceDev | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesChannelsSourceDevSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesChannelsSourceDevToHclTerraform(struct?: DomainDevicesChannelsSourceDev | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesChannelsSourceDevSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesChannelsSourceDevSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesChannelsSourceDevOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesChannelsSourceDev | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesChannelsSourceDev | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesChannelsSourceDevSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesChannelsSourceDevSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesChannelsSourceFileSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesChannelsSourceFileSecLabelToTerraform(struct?: DomainDevicesChannelsSourceFileSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesChannelsSourceFileSecLabelToHclTerraform(struct?: DomainDevicesChannelsSourceFileSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesChannelsSourceFileSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesChannelsSourceFileSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesChannelsSourceFileSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesChannelsSourceFileSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesChannelsSourceFileSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesChannelsSourceFileSecLabelOutputReference {
    return new DomainDevicesChannelsSourceFileSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesChannelsSourceFile {
  /**
  * Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.
  * 
  * See: <https://libvirt.org/formatdomain.html#device-logfile>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#append Domain#append}
  */
  readonly append?: string;
  /**
  * Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesChannelsSourceFileSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesChannelsSourceFileToTerraform(struct?: DomainDevicesChannelsSourceFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.stringToTerraform(struct!.append),
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesChannelsSourceFileSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesChannelsSourceFileToHclTerraform(struct?: DomainDevicesChannelsSourceFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.stringToHclTerraform(struct!.append),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesChannelsSourceFileSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesChannelsSourceFileSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesChannelsSourceFileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesChannelsSourceFile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesChannelsSourceFile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append = value.append;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append?: string; 
  public get append() {
    return this.getStringAttribute('append');
  }
  public set append(value: string) {
    this._append = value;
  }
  public resetAppend() {
    this._append = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append;
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesChannelsSourceFileSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesChannelsSourceFileSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesChannelsSourceNmdm {
  /**
  * Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.
  * 
  * See: <https://libvirt.org/formatdomain.html#nmdm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#master Domain#master}
  */
  readonly master: string;
  /**
  * Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.
  * 
  * See: <https://libvirt.org/formatdomain.html#nmdm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#slave Domain#slave}
  */
  readonly slave: string;
}

export function domainDevicesChannelsSourceNmdmToTerraform(struct?: DomainDevicesChannelsSourceNmdm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    master: cdktf.stringToTerraform(struct!.master),
    slave: cdktf.stringToTerraform(struct!.slave),
  }
}


export function domainDevicesChannelsSourceNmdmToHclTerraform(struct?: DomainDevicesChannelsSourceNmdm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    master: {
      value: cdktf.stringToHclTerraform(struct!.master),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    slave: {
      value: cdktf.stringToHclTerraform(struct!.slave),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesChannelsSourceNmdmOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesChannelsSourceNmdm | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._master !== undefined) {
      hasAnyValues = true;
      internalValueResult.master = this._master;
    }
    if (this._slave !== undefined) {
      hasAnyValues = true;
      internalValueResult.slave = this._slave;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesChannelsSourceNmdm | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._master = undefined;
      this._slave = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._master = value.master;
      this._slave = value.slave;
    }
  }

  // master - computed: false, optional: false, required: true
  private _master?: string; 
  public get master() {
    return this.getStringAttribute('master');
  }
  public set master(value: string) {
    this._master = value;
  }
  // Temporarily expose input value. Use with caution.
  public get masterInput() {
    return this._master;
  }

  // slave - computed: false, optional: false, required: true
  private _slave?: string; 
  public get slave() {
    return this.getStringAttribute('slave');
  }
  public set slave(value: string) {
    this._slave = value;
  }
  // Temporarily expose input value. Use with caution.
  public get slaveInput() {
    return this._slave;
  }
}
export interface DomainDevicesChannelsSourcePipeSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesChannelsSourcePipeSecLabelToTerraform(struct?: DomainDevicesChannelsSourcePipeSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesChannelsSourcePipeSecLabelToHclTerraform(struct?: DomainDevicesChannelsSourcePipeSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesChannelsSourcePipeSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesChannelsSourcePipeSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesChannelsSourcePipeSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesChannelsSourcePipeSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesChannelsSourcePipeSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesChannelsSourcePipeSecLabelOutputReference {
    return new DomainDevicesChannelsSourcePipeSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesChannelsSourcePipe {
  /**
  * Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesChannelsSourcePipeSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesChannelsSourcePipeToTerraform(struct?: DomainDevicesChannelsSourcePipe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesChannelsSourcePipeSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesChannelsSourcePipeToHclTerraform(struct?: DomainDevicesChannelsSourcePipe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesChannelsSourcePipeSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesChannelsSourcePipeSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesChannelsSourcePipeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesChannelsSourcePipe | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesChannelsSourcePipe | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesChannelsSourcePipeSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesChannelsSourcePipeSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesChannelsSourcePtySecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesChannelsSourcePtySecLabelToTerraform(struct?: DomainDevicesChannelsSourcePtySecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesChannelsSourcePtySecLabelToHclTerraform(struct?: DomainDevicesChannelsSourcePtySecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesChannelsSourcePtySecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesChannelsSourcePtySecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesChannelsSourcePtySecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesChannelsSourcePtySecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesChannelsSourcePtySecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesChannelsSourcePtySecLabelOutputReference {
    return new DomainDevicesChannelsSourcePtySecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesChannelsSourcePty {
  /**
  * Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesChannelsSourcePtySecLabel[] | cdktf.IResolvable;
}

export function domainDevicesChannelsSourcePtyToTerraform(struct?: DomainDevicesChannelsSourcePty | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesChannelsSourcePtySecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesChannelsSourcePtyToHclTerraform(struct?: DomainDevicesChannelsSourcePty | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesChannelsSourcePtySecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesChannelsSourcePtySecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesChannelsSourcePtyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesChannelsSourcePty | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesChannelsSourcePty | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesChannelsSourcePtySecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesChannelsSourcePtySecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesChannelsSourceQemuvdAgentClipBoard {
  /**
  * Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#copy_paste Domain#copy_paste}
  */
  readonly copyPaste: string;
}

export function domainDevicesChannelsSourceQemuvdAgentClipBoardToTerraform(struct?: DomainDevicesChannelsSourceQemuvdAgentClipBoard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    copy_paste: cdktf.stringToTerraform(struct!.copyPaste),
  }
}


export function domainDevicesChannelsSourceQemuvdAgentClipBoardToHclTerraform(struct?: DomainDevicesChannelsSourceQemuvdAgentClipBoard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    copy_paste: {
      value: cdktf.stringToHclTerraform(struct!.copyPaste),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesChannelsSourceQemuvdAgentClipBoardOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesChannelsSourceQemuvdAgentClipBoard | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._copyPaste !== undefined) {
      hasAnyValues = true;
      internalValueResult.copyPaste = this._copyPaste;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesChannelsSourceQemuvdAgentClipBoard | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._copyPaste = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._copyPaste = value.copyPaste;
    }
  }

  // copy_paste - computed: false, optional: false, required: true
  private _copyPaste?: string; 
  public get copyPaste() {
    return this.getStringAttribute('copy_paste');
  }
  public set copyPaste(value: string) {
    this._copyPaste = value;
  }
  // Temporarily expose input value. Use with caution.
  public get copyPasteInput() {
    return this._copyPaste;
  }
}
export interface DomainDevicesChannelsSourceQemuvdAgentMouse {
  /**
  * Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).
  * 
  * See: <https://libvirt.org/formatdomain.html#channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode: string;
}

export function domainDevicesChannelsSourceQemuvdAgentMouseToTerraform(struct?: DomainDevicesChannelsSourceQemuvdAgentMouse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
  }
}


export function domainDevicesChannelsSourceQemuvdAgentMouseToHclTerraform(struct?: DomainDevicesChannelsSourceQemuvdAgentMouse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesChannelsSourceQemuvdAgentMouseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesChannelsSourceQemuvdAgentMouse | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesChannelsSourceQemuvdAgentMouse | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
    }
  }

  // mode - computed: false, optional: false, required: true
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }
}
export interface DomainDevicesChannelsSourceQemuvdAgent {
  /**
  * Configures clipboard-related behavior for the QEMU vdagent–based EGD source, controlling whether clipboard data exchange is allowed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#clip_board Domain#clip_board}
  */
  readonly clipBoard?: DomainDevicesChannelsSourceQemuvdAgentClipBoard;
  /**
  * Configures mouse integration options for the QEMU vdagent–based EGD source, such as how mouse events are handled.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mouse Domain#mouse}
  */
  readonly mouse?: DomainDevicesChannelsSourceQemuvdAgentMouse;
}

export function domainDevicesChannelsSourceQemuvdAgentToTerraform(struct?: DomainDevicesChannelsSourceQemuvdAgent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    clip_board: domainDevicesChannelsSourceQemuvdAgentClipBoardToTerraform(struct!.clipBoard),
    mouse: domainDevicesChannelsSourceQemuvdAgentMouseToTerraform(struct!.mouse),
  }
}


export function domainDevicesChannelsSourceQemuvdAgentToHclTerraform(struct?: DomainDevicesChannelsSourceQemuvdAgent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    clip_board: {
      value: domainDevicesChannelsSourceQemuvdAgentClipBoardToHclTerraform(struct!.clipBoard),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesChannelsSourceQemuvdAgentClipBoard",
    },
    mouse: {
      value: domainDevicesChannelsSourceQemuvdAgentMouseToHclTerraform(struct!.mouse),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesChannelsSourceQemuvdAgentMouse",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesChannelsSourceQemuvdAgentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesChannelsSourceQemuvdAgent | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clipBoard?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clipBoard = this._clipBoard?.internalValue;
    }
    if (this._mouse?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.mouse = this._mouse?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesChannelsSourceQemuvdAgent | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clipBoard.internalValue = undefined;
      this._mouse.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clipBoard.internalValue = value.clipBoard;
      this._mouse.internalValue = value.mouse;
    }
  }

  // clip_board - computed: false, optional: true, required: false
  private _clipBoard = new DomainDevicesChannelsSourceQemuvdAgentClipBoardOutputReference(this, "clip_board");
  public get clipBoard() {
    return this._clipBoard;
  }
  public putClipBoard(value: DomainDevicesChannelsSourceQemuvdAgentClipBoard) {
    this._clipBoard.internalValue = value;
  }
  public resetClipBoard() {
    this._clipBoard.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clipBoardInput() {
    return this._clipBoard.internalValue;
  }

  // mouse - computed: false, optional: true, required: false
  private _mouse = new DomainDevicesChannelsSourceQemuvdAgentMouseOutputReference(this, "mouse");
  public get mouse() {
    return this._mouse;
  }
  public putMouse(value: DomainDevicesChannelsSourceQemuvdAgentMouse) {
    this._mouse.internalValue = value;
  }
  public resetMouse() {
    this._mouse.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mouseInput() {
    return this._mouse.internalValue;
  }
}
export interface DomainDevicesChannelsSourceSpicePort {
  /**
  * Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#channel Domain#channel}
  */
  readonly channel: string;
}

export function domainDevicesChannelsSourceSpicePortToTerraform(struct?: DomainDevicesChannelsSourceSpicePort | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    channel: cdktf.stringToTerraform(struct!.channel),
  }
}


export function domainDevicesChannelsSourceSpicePortToHclTerraform(struct?: DomainDevicesChannelsSourceSpicePort | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    channel: {
      value: cdktf.stringToHclTerraform(struct!.channel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesChannelsSourceSpicePortOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesChannelsSourceSpicePort | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._channel !== undefined) {
      hasAnyValues = true;
      internalValueResult.channel = this._channel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesChannelsSourceSpicePort | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._channel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._channel = value.channel;
    }
  }

  // channel - computed: false, optional: false, required: true
  private _channel?: string; 
  public get channel() {
    return this.getStringAttribute('channel');
  }
  public set channel(value: string) {
    this._channel = value;
  }
  // Temporarily expose input value. Use with caution.
  public get channelInput() {
    return this._channel;
  }
}
export interface DomainDevicesChannelsSourceTcpReconnect {
  /**
  * Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enabled Domain#enabled}
  */
  readonly enabled: string;
  /**
  * Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#timeout Domain#timeout}
  */
  readonly timeout?: number;
}

export function domainDevicesChannelsSourceTcpReconnectToTerraform(struct?: DomainDevicesChannelsSourceTcpReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.stringToTerraform(struct!.enabled),
    timeout: cdktf.numberToTerraform(struct!.timeout),
  }
}


export function domainDevicesChannelsSourceTcpReconnectToHclTerraform(struct?: DomainDevicesChannelsSourceTcpReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.stringToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.numberToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesChannelsSourceTcpReconnectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesChannelsSourceTcpReconnect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesChannelsSourceTcpReconnect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._timeout = value.timeout;
    }
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: string; 
  public get enabled() {
    return this.getStringAttribute('enabled');
  }
  public set enabled(value: string) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: number; 
  public get timeout() {
    return this.getNumberAttribute('timeout');
  }
  public set timeout(value: number) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DomainDevicesChannelsSourceTcp {
  /**
  * Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#host Domain#host}
  */
  readonly host?: string;
  /**
  * Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode?: string;
  /**
  * Enables and configures automatic reconnection behavior for a UNIX socket–based EGD entropy source; the content and attributes are user-provided according to desired policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reconnect Domain#reconnect}
  */
  readonly reconnect?: DomainDevicesChannelsSourceTcpReconnect;
  /**
  * Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#service Domain#service}
  */
  readonly service?: string;
  /**
  * Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tls Domain#tls}
  */
  readonly tls?: string;
}

export function domainDevicesChannelsSourceTcpToTerraform(struct?: DomainDevicesChannelsSourceTcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    mode: cdktf.stringToTerraform(struct!.mode),
    reconnect: domainDevicesChannelsSourceTcpReconnectToTerraform(struct!.reconnect),
    service: cdktf.stringToTerraform(struct!.service),
    tls: cdktf.stringToTerraform(struct!.tls),
  }
}


export function domainDevicesChannelsSourceTcpToHclTerraform(struct?: DomainDevicesChannelsSourceTcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reconnect: {
      value: domainDevicesChannelsSourceTcpReconnectToHclTerraform(struct!.reconnect),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesChannelsSourceTcpReconnect",
    },
    service: {
      value: cdktf.stringToHclTerraform(struct!.service),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: cdktf.stringToHclTerraform(struct!.tls),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesChannelsSourceTcpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesChannelsSourceTcp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._reconnect?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.reconnect = this._reconnect?.internalValue;
    }
    if (this._service !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service;
    }
    if (this._tls !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesChannelsSourceTcp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host = undefined;
      this._mode = undefined;
      this._reconnect.internalValue = undefined;
      this._service = undefined;
      this._tls = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host = value.host;
      this._mode = value.mode;
      this._reconnect.internalValue = value.reconnect;
      this._service = value.service;
      this._tls = value.tls;
    }
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // reconnect - computed: false, optional: true, required: false
  private _reconnect = new DomainDevicesChannelsSourceTcpReconnectOutputReference(this, "reconnect");
  public get reconnect() {
    return this._reconnect;
  }
  public putReconnect(value: DomainDevicesChannelsSourceTcpReconnect) {
    this._reconnect.internalValue = value;
  }
  public resetReconnect() {
    this._reconnect.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reconnectInput() {
    return this._reconnect.internalValue;
  }

  // service - computed: false, optional: true, required: false
  private _service?: string; 
  public get service() {
    return this.getStringAttribute('service');
  }
  public set service(value: string) {
    this._service = value;
  }
  public resetService() {
    this._service = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service;
  }

  // tls - computed: false, optional: true, required: false
  private _tls?: string; 
  public get tls() {
    return this.getStringAttribute('tls');
  }
  public set tls(value: string) {
    this._tls = value;
  }
  public resetTls() {
    this._tls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls;
  }
}
export interface DomainDevicesChannelsSourceUdp {
  /**
  * Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bind_host Domain#bind_host}
  */
  readonly bindHost: string;
  /**
  * Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bind_service Domain#bind_service}
  */
  readonly bindService: string;
  /**
  * Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#connect_host Domain#connect_host}
  */
  readonly connectHost: string;
  /**
  * Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#connect_service Domain#connect_service}
  */
  readonly connectService: string;
}

export function domainDevicesChannelsSourceUdpToTerraform(struct?: DomainDevicesChannelsSourceUdp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_host: cdktf.stringToTerraform(struct!.bindHost),
    bind_service: cdktf.stringToTerraform(struct!.bindService),
    connect_host: cdktf.stringToTerraform(struct!.connectHost),
    connect_service: cdktf.stringToTerraform(struct!.connectService),
  }
}


export function domainDevicesChannelsSourceUdpToHclTerraform(struct?: DomainDevicesChannelsSourceUdp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_host: {
      value: cdktf.stringToHclTerraform(struct!.bindHost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bind_service: {
      value: cdktf.stringToHclTerraform(struct!.bindService),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connect_host: {
      value: cdktf.stringToHclTerraform(struct!.connectHost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connect_service: {
      value: cdktf.stringToHclTerraform(struct!.connectService),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesChannelsSourceUdpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesChannelsSourceUdp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindHost !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindHost = this._bindHost;
    }
    if (this._bindService !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindService = this._bindService;
    }
    if (this._connectHost !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectHost = this._connectHost;
    }
    if (this._connectService !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectService = this._connectService;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesChannelsSourceUdp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bindHost = undefined;
      this._bindService = undefined;
      this._connectHost = undefined;
      this._connectService = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bindHost = value.bindHost;
      this._bindService = value.bindService;
      this._connectHost = value.connectHost;
      this._connectService = value.connectService;
    }
  }

  // bind_host - computed: false, optional: false, required: true
  private _bindHost?: string; 
  public get bindHost() {
    return this.getStringAttribute('bind_host');
  }
  public set bindHost(value: string) {
    this._bindHost = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bindHostInput() {
    return this._bindHost;
  }

  // bind_service - computed: false, optional: false, required: true
  private _bindService?: string; 
  public get bindService() {
    return this.getStringAttribute('bind_service');
  }
  public set bindService(value: string) {
    this._bindService = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bindServiceInput() {
    return this._bindService;
  }

  // connect_host - computed: false, optional: false, required: true
  private _connectHost?: string; 
  public get connectHost() {
    return this.getStringAttribute('connect_host');
  }
  public set connectHost(value: string) {
    this._connectHost = value;
  }
  // Temporarily expose input value. Use with caution.
  public get connectHostInput() {
    return this._connectHost;
  }

  // connect_service - computed: false, optional: false, required: true
  private _connectService?: string; 
  public get connectService() {
    return this.getStringAttribute('connect_service');
  }
  public set connectService(value: string) {
    this._connectService = value;
  }
  // Temporarily expose input value. Use with caution.
  public get connectServiceInput() {
    return this._connectService;
  }
}
export interface DomainDevicesChannelsSourceUnixReconnect {
  /**
  * Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enabled Domain#enabled}
  */
  readonly enabled: string;
  /**
  * Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#timeout Domain#timeout}
  */
  readonly timeout?: number;
}

export function domainDevicesChannelsSourceUnixReconnectToTerraform(struct?: DomainDevicesChannelsSourceUnixReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.stringToTerraform(struct!.enabled),
    timeout: cdktf.numberToTerraform(struct!.timeout),
  }
}


export function domainDevicesChannelsSourceUnixReconnectToHclTerraform(struct?: DomainDevicesChannelsSourceUnixReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.stringToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.numberToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesChannelsSourceUnixReconnectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesChannelsSourceUnixReconnect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesChannelsSourceUnixReconnect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._timeout = value.timeout;
    }
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: string; 
  public get enabled() {
    return this.getStringAttribute('enabled');
  }
  public set enabled(value: string) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: number; 
  public get timeout() {
    return this.getNumberAttribute('timeout');
  }
  public set timeout(value: number) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DomainDevicesChannelsSourceUnixSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesChannelsSourceUnixSecLabelToTerraform(struct?: DomainDevicesChannelsSourceUnixSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesChannelsSourceUnixSecLabelToHclTerraform(struct?: DomainDevicesChannelsSourceUnixSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesChannelsSourceUnixSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesChannelsSourceUnixSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesChannelsSourceUnixSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesChannelsSourceUnixSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesChannelsSourceUnixSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesChannelsSourceUnixSecLabelOutputReference {
    return new DomainDevicesChannelsSourceUnixSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesChannelsSourceUnix {
  /**
  * Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode?: string;
  /**
  * Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path?: string;
  /**
  * Enables and configures automatic reconnection behavior for a UNIX socket–based EGD entropy source; the content and attributes are user-provided according to desired policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reconnect Domain#reconnect}
  */
  readonly reconnect?: DomainDevicesChannelsSourceUnixReconnect;
  /**
  * Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesChannelsSourceUnixSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesChannelsSourceUnixToTerraform(struct?: DomainDevicesChannelsSourceUnix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
    reconnect: domainDevicesChannelsSourceUnixReconnectToTerraform(struct!.reconnect),
    sec_label: cdktf.listMapper(domainDevicesChannelsSourceUnixSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesChannelsSourceUnixToHclTerraform(struct?: DomainDevicesChannelsSourceUnix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reconnect: {
      value: domainDevicesChannelsSourceUnixReconnectToHclTerraform(struct!.reconnect),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesChannelsSourceUnixReconnect",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesChannelsSourceUnixSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesChannelsSourceUnixSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesChannelsSourceUnixOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesChannelsSourceUnix | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._reconnect?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.reconnect = this._reconnect?.internalValue;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesChannelsSourceUnix | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
      this._path = undefined;
      this._reconnect.internalValue = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
      this._path = value.path;
      this._reconnect.internalValue = value.reconnect;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // reconnect - computed: false, optional: true, required: false
  private _reconnect = new DomainDevicesChannelsSourceUnixReconnectOutputReference(this, "reconnect");
  public get reconnect() {
    return this._reconnect;
  }
  public putReconnect(value: DomainDevicesChannelsSourceUnixReconnect) {
    this._reconnect.internalValue = value;
  }
  public resetReconnect() {
    this._reconnect.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reconnectInput() {
    return this._reconnect.internalValue;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesChannelsSourceUnixSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesChannelsSourceUnixSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesChannelsSource {
  /**
  * Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dbus Domain#dbus}
  */
  readonly dbus?: DomainDevicesChannelsSourceDbus;
  /**
  * Configures an EGD RNG backend that reads entropy from a host character device node.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dev Domain#dev}
  */
  readonly dev?: DomainDevicesChannelsSourceDev;
  /**
  * Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file?: DomainDevicesChannelsSourceFile;
  /**
  * Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#nmdm Domain#nmdm}
  */
  readonly nmdm?: DomainDevicesChannelsSourceNmdm;
  /**
  * Enables use of a null backend for the EGD RNG source, discarding all data written and providing no entropy; when this boolean is true the <Null> source is emitted, and when false or unset it is omitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#null Domain#null}
  */
  readonly null?: boolean | cdktf.IResolvable;
  /**
  * Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pipe Domain#pipe}
  */
  readonly pipe?: DomainDevicesChannelsSourcePipe;
  /**
  * Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pty Domain#pty}
  */
  readonly pty?: DomainDevicesChannelsSourcePty;
  /**
  * Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#qemuvd_agent Domain#qemuvd_agent}
  */
  readonly qemuvdAgent?: DomainDevicesChannelsSourceQemuvdAgent;
  /**
  * Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#spice_port Domain#spice_port}
  */
  readonly spicePort?: DomainDevicesChannelsSourceSpicePort;
  /**
  * Enables using a SPICE virtio serial management channel (spicevmc) as the entropy source for the EGD RNG backend when set to true; when false or unset, the element is omitted.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#spice_vmc Domain#spice_vmc}
  */
  readonly spiceVmc?: boolean | cdktf.IResolvable;
  /**
  * Enables using the QEMU process standard I/O stream as the entropy source for the EGD RNG backend when set to true; when false or unset, the element is omitted.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#std_io Domain#std_io}
  */
  readonly stdIo?: boolean | cdktf.IResolvable;
  /**
  * Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tcp Domain#tcp}
  */
  readonly tcp?: DomainDevicesChannelsSourceTcp;
  /**
  * Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#udp Domain#udp}
  */
  readonly udp?: DomainDevicesChannelsSourceUdp;
  /**
  * Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#unix Domain#unix}
  */
  readonly unix?: DomainDevicesChannelsSourceUnix;
  /**
  * Enables use of a virtual console device as the entropy source for the EGD RNG backend when set (presence-only element; omitting it disables this source).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vc Domain#vc}
  */
  readonly vc?: boolean | cdktf.IResolvable;
}

export function domainDevicesChannelsSourceToTerraform(struct?: DomainDevicesChannelsSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dbus: domainDevicesChannelsSourceDbusToTerraform(struct!.dbus),
    dev: domainDevicesChannelsSourceDevToTerraform(struct!.dev),
    file: domainDevicesChannelsSourceFileToTerraform(struct!.file),
    nmdm: domainDevicesChannelsSourceNmdmToTerraform(struct!.nmdm),
    null: cdktf.booleanToTerraform(struct!.null),
    pipe: domainDevicesChannelsSourcePipeToTerraform(struct!.pipe),
    pty: domainDevicesChannelsSourcePtyToTerraform(struct!.pty),
    qemuvd_agent: domainDevicesChannelsSourceQemuvdAgentToTerraform(struct!.qemuvdAgent),
    spice_port: domainDevicesChannelsSourceSpicePortToTerraform(struct!.spicePort),
    spice_vmc: cdktf.booleanToTerraform(struct!.spiceVmc),
    std_io: cdktf.booleanToTerraform(struct!.stdIo),
    tcp: domainDevicesChannelsSourceTcpToTerraform(struct!.tcp),
    udp: domainDevicesChannelsSourceUdpToTerraform(struct!.udp),
    unix: domainDevicesChannelsSourceUnixToTerraform(struct!.unix),
    vc: cdktf.booleanToTerraform(struct!.vc),
  }
}


export function domainDevicesChannelsSourceToHclTerraform(struct?: DomainDevicesChannelsSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dbus: {
      value: domainDevicesChannelsSourceDbusToHclTerraform(struct!.dbus),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesChannelsSourceDbus",
    },
    dev: {
      value: domainDevicesChannelsSourceDevToHclTerraform(struct!.dev),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesChannelsSourceDev",
    },
    file: {
      value: domainDevicesChannelsSourceFileToHclTerraform(struct!.file),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesChannelsSourceFile",
    },
    nmdm: {
      value: domainDevicesChannelsSourceNmdmToHclTerraform(struct!.nmdm),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesChannelsSourceNmdm",
    },
    null: {
      value: cdktf.booleanToHclTerraform(struct!.null),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    pipe: {
      value: domainDevicesChannelsSourcePipeToHclTerraform(struct!.pipe),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesChannelsSourcePipe",
    },
    pty: {
      value: domainDevicesChannelsSourcePtyToHclTerraform(struct!.pty),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesChannelsSourcePty",
    },
    qemuvd_agent: {
      value: domainDevicesChannelsSourceQemuvdAgentToHclTerraform(struct!.qemuvdAgent),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesChannelsSourceQemuvdAgent",
    },
    spice_port: {
      value: domainDevicesChannelsSourceSpicePortToHclTerraform(struct!.spicePort),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesChannelsSourceSpicePort",
    },
    spice_vmc: {
      value: cdktf.booleanToHclTerraform(struct!.spiceVmc),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    std_io: {
      value: cdktf.booleanToHclTerraform(struct!.stdIo),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tcp: {
      value: domainDevicesChannelsSourceTcpToHclTerraform(struct!.tcp),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesChannelsSourceTcp",
    },
    udp: {
      value: domainDevicesChannelsSourceUdpToHclTerraform(struct!.udp),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesChannelsSourceUdp",
    },
    unix: {
      value: domainDevicesChannelsSourceUnixToHclTerraform(struct!.unix),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesChannelsSourceUnix",
    },
    vc: {
      value: cdktf.booleanToHclTerraform(struct!.vc),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesChannelsSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesChannelsSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dbus?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dbus = this._dbus?.internalValue;
    }
    if (this._dev?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dev = this._dev?.internalValue;
    }
    if (this._file?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file?.internalValue;
    }
    if (this._nmdm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nmdm = this._nmdm?.internalValue;
    }
    if (this._null !== undefined) {
      hasAnyValues = true;
      internalValueResult.null = this._null;
    }
    if (this._pipe?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipe = this._pipe?.internalValue;
    }
    if (this._pty?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pty = this._pty?.internalValue;
    }
    if (this._qemuvdAgent?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.qemuvdAgent = this._qemuvdAgent?.internalValue;
    }
    if (this._spicePort?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spicePort = this._spicePort?.internalValue;
    }
    if (this._spiceVmc !== undefined) {
      hasAnyValues = true;
      internalValueResult.spiceVmc = this._spiceVmc;
    }
    if (this._stdIo !== undefined) {
      hasAnyValues = true;
      internalValueResult.stdIo = this._stdIo;
    }
    if (this._tcp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tcp = this._tcp?.internalValue;
    }
    if (this._udp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.udp = this._udp?.internalValue;
    }
    if (this._unix?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.unix = this._unix?.internalValue;
    }
    if (this._vc !== undefined) {
      hasAnyValues = true;
      internalValueResult.vc = this._vc;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesChannelsSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dbus.internalValue = undefined;
      this._dev.internalValue = undefined;
      this._file.internalValue = undefined;
      this._nmdm.internalValue = undefined;
      this._null = undefined;
      this._pipe.internalValue = undefined;
      this._pty.internalValue = undefined;
      this._qemuvdAgent.internalValue = undefined;
      this._spicePort.internalValue = undefined;
      this._spiceVmc = undefined;
      this._stdIo = undefined;
      this._tcp.internalValue = undefined;
      this._udp.internalValue = undefined;
      this._unix.internalValue = undefined;
      this._vc = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dbus.internalValue = value.dbus;
      this._dev.internalValue = value.dev;
      this._file.internalValue = value.file;
      this._nmdm.internalValue = value.nmdm;
      this._null = value.null;
      this._pipe.internalValue = value.pipe;
      this._pty.internalValue = value.pty;
      this._qemuvdAgent.internalValue = value.qemuvdAgent;
      this._spicePort.internalValue = value.spicePort;
      this._spiceVmc = value.spiceVmc;
      this._stdIo = value.stdIo;
      this._tcp.internalValue = value.tcp;
      this._udp.internalValue = value.udp;
      this._unix.internalValue = value.unix;
      this._vc = value.vc;
    }
  }

  // dbus - computed: false, optional: true, required: false
  private _dbus = new DomainDevicesChannelsSourceDbusOutputReference(this, "dbus");
  public get dbus() {
    return this._dbus;
  }
  public putDbus(value: DomainDevicesChannelsSourceDbus) {
    this._dbus.internalValue = value;
  }
  public resetDbus() {
    this._dbus.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dbusInput() {
    return this._dbus.internalValue;
  }

  // dev - computed: false, optional: true, required: false
  private _dev = new DomainDevicesChannelsSourceDevOutputReference(this, "dev");
  public get dev() {
    return this._dev;
  }
  public putDev(value: DomainDevicesChannelsSourceDev) {
    this._dev.internalValue = value;
  }
  public resetDev() {
    this._dev.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devInput() {
    return this._dev.internalValue;
  }

  // file - computed: false, optional: true, required: false
  private _file = new DomainDevicesChannelsSourceFileOutputReference(this, "file");
  public get file() {
    return this._file;
  }
  public putFile(value: DomainDevicesChannelsSourceFile) {
    this._file.internalValue = value;
  }
  public resetFile() {
    this._file.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file.internalValue;
  }

  // nmdm - computed: false, optional: true, required: false
  private _nmdm = new DomainDevicesChannelsSourceNmdmOutputReference(this, "nmdm");
  public get nmdm() {
    return this._nmdm;
  }
  public putNmdm(value: DomainDevicesChannelsSourceNmdm) {
    this._nmdm.internalValue = value;
  }
  public resetNmdm() {
    this._nmdm.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nmdmInput() {
    return this._nmdm.internalValue;
  }

  // null - computed: false, optional: true, required: false
  private _null?: boolean | cdktf.IResolvable; 
  public get null() {
    return this.getBooleanAttribute('null');
  }
  public set null(value: boolean | cdktf.IResolvable) {
    this._null = value;
  }
  public resetNull() {
    this._null = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nullInput() {
    return this._null;
  }

  // pipe - computed: false, optional: true, required: false
  private _pipe = new DomainDevicesChannelsSourcePipeOutputReference(this, "pipe");
  public get pipe() {
    return this._pipe;
  }
  public putPipe(value: DomainDevicesChannelsSourcePipe) {
    this._pipe.internalValue = value;
  }
  public resetPipe() {
    this._pipe.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipeInput() {
    return this._pipe.internalValue;
  }

  // pty - computed: false, optional: true, required: false
  private _pty = new DomainDevicesChannelsSourcePtyOutputReference(this, "pty");
  public get pty() {
    return this._pty;
  }
  public putPty(value: DomainDevicesChannelsSourcePty) {
    this._pty.internalValue = value;
  }
  public resetPty() {
    this._pty.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ptyInput() {
    return this._pty.internalValue;
  }

  // qemuvd_agent - computed: false, optional: true, required: false
  private _qemuvdAgent = new DomainDevicesChannelsSourceQemuvdAgentOutputReference(this, "qemuvd_agent");
  public get qemuvdAgent() {
    return this._qemuvdAgent;
  }
  public putQemuvdAgent(value: DomainDevicesChannelsSourceQemuvdAgent) {
    this._qemuvdAgent.internalValue = value;
  }
  public resetQemuvdAgent() {
    this._qemuvdAgent.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get qemuvdAgentInput() {
    return this._qemuvdAgent.internalValue;
  }

  // spice_port - computed: false, optional: true, required: false
  private _spicePort = new DomainDevicesChannelsSourceSpicePortOutputReference(this, "spice_port");
  public get spicePort() {
    return this._spicePort;
  }
  public putSpicePort(value: DomainDevicesChannelsSourceSpicePort) {
    this._spicePort.internalValue = value;
  }
  public resetSpicePort() {
    this._spicePort.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spicePortInput() {
    return this._spicePort.internalValue;
  }

  // spice_vmc - computed: false, optional: true, required: false
  private _spiceVmc?: boolean | cdktf.IResolvable; 
  public get spiceVmc() {
    return this.getBooleanAttribute('spice_vmc');
  }
  public set spiceVmc(value: boolean | cdktf.IResolvable) {
    this._spiceVmc = value;
  }
  public resetSpiceVmc() {
    this._spiceVmc = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spiceVmcInput() {
    return this._spiceVmc;
  }

  // std_io - computed: false, optional: true, required: false
  private _stdIo?: boolean | cdktf.IResolvable; 
  public get stdIo() {
    return this.getBooleanAttribute('std_io');
  }
  public set stdIo(value: boolean | cdktf.IResolvable) {
    this._stdIo = value;
  }
  public resetStdIo() {
    this._stdIo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stdIoInput() {
    return this._stdIo;
  }

  // tcp - computed: false, optional: true, required: false
  private _tcp = new DomainDevicesChannelsSourceTcpOutputReference(this, "tcp");
  public get tcp() {
    return this._tcp;
  }
  public putTcp(value: DomainDevicesChannelsSourceTcp) {
    this._tcp.internalValue = value;
  }
  public resetTcp() {
    this._tcp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tcpInput() {
    return this._tcp.internalValue;
  }

  // udp - computed: false, optional: true, required: false
  private _udp = new DomainDevicesChannelsSourceUdpOutputReference(this, "udp");
  public get udp() {
    return this._udp;
  }
  public putUdp(value: DomainDevicesChannelsSourceUdp) {
    this._udp.internalValue = value;
  }
  public resetUdp() {
    this._udp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get udpInput() {
    return this._udp.internalValue;
  }

  // unix - computed: false, optional: true, required: false
  private _unix = new DomainDevicesChannelsSourceUnixOutputReference(this, "unix");
  public get unix() {
    return this._unix;
  }
  public putUnix(value: DomainDevicesChannelsSourceUnix) {
    this._unix.internalValue = value;
  }
  public resetUnix() {
    this._unix.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unixInput() {
    return this._unix.internalValue;
  }

  // vc - computed: false, optional: true, required: false
  private _vc?: boolean | cdktf.IResolvable; 
  public get vc() {
    return this.getBooleanAttribute('vc');
  }
  public set vc(value: boolean | cdktf.IResolvable) {
    this._vc = value;
  }
  public resetVc() {
    this._vc = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vcInput() {
    return this._vc;
  }
}
export interface DomainDevicesChannelsTargetGuestFwd {
  /**
  * Sets the host IP address or hostname that the guestfwd channel forwards traffic to; value is user-provided (e.g. "127.0.0.1").
  * 
  * See: <https://libvirt.org/formatdomain.html#channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: string;
  /**
  * Sets the TCP port number on the host that the guestfwd channel forwards traffic to; must be a valid TCP port (1–65535).
  * 
  * See: <https://libvirt.org/formatdomain.html#channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#port Domain#port}
  */
  readonly port?: string;
}

export function domainDevicesChannelsTargetGuestFwdToTerraform(struct?: DomainDevicesChannelsTargetGuestFwd | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
    port: cdktf.stringToTerraform(struct!.port),
  }
}


export function domainDevicesChannelsTargetGuestFwdToHclTerraform(struct?: DomainDevicesChannelsTargetGuestFwd | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.stringToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesChannelsTargetGuestFwdOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesChannelsTargetGuestFwd | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesChannelsTargetGuestFwd | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
      this._port = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
      this._port = value.port;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  public resetAddress() {
    this._address = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }

  // port - computed: false, optional: true, required: false
  private _port?: string; 
  public get port() {
    return this.getStringAttribute('port');
  }
  public set port(value: string) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }
}
export interface DomainDevicesChannelsTargetVirtIo {
  /**
  * Sets the virtio channel name exposed inside the guest (for example "org.qemu.guest_agent.0"); value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name?: string;
  /**
  * Sets the initial connection state of the virtio channel target; typically "connected" or "disconnected" when supported, value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainDevicesChannelsTargetVirtIoToTerraform(struct?: DomainDevicesChannelsTargetVirtIo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainDevicesChannelsTargetVirtIoToHclTerraform(struct?: DomainDevicesChannelsTargetVirtIo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesChannelsTargetVirtIoOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesChannelsTargetVirtIo | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesChannelsTargetVirtIo | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._state = value.state;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainDevicesChannelsTargetXen {
  /**
  * Sets the Xen guest channel name used inside the guest to identify this channel; value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name?: string;
  /**
  * Sets the initial connection state of the Xen channel target; typically "connected" or "disconnected" when supported, value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainDevicesChannelsTargetXenToTerraform(struct?: DomainDevicesChannelsTargetXen | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainDevicesChannelsTargetXenToHclTerraform(struct?: DomainDevicesChannelsTargetXen | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesChannelsTargetXenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesChannelsTargetXen | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesChannelsTargetXen | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._state = value.state;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainDevicesChannelsTarget {
  /**
  * Configures a guestfwd-style channel target that forwards guest TCP connections to a host-side TCP endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#guest_fwd Domain#guest_fwd}
  */
  readonly guestFwd?: DomainDevicesChannelsTargetGuestFwd;
  /**
  * Configures a virtio-based channel target, making the channel visible as a virtio-serial device in the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#virt_io Domain#virt_io}
  */
  readonly virtIo?: DomainDevicesChannelsTargetVirtIo;
  /**
  * Configures a Xen-style channel target, exposing the channel via the Xen guest interface mechanism.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#xen Domain#xen}
  */
  readonly xen?: DomainDevicesChannelsTargetXen;
}

export function domainDevicesChannelsTargetToTerraform(struct?: DomainDevicesChannelsTarget | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    guest_fwd: domainDevicesChannelsTargetGuestFwdToTerraform(struct!.guestFwd),
    virt_io: domainDevicesChannelsTargetVirtIoToTerraform(struct!.virtIo),
    xen: domainDevicesChannelsTargetXenToTerraform(struct!.xen),
  }
}


export function domainDevicesChannelsTargetToHclTerraform(struct?: DomainDevicesChannelsTarget | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    guest_fwd: {
      value: domainDevicesChannelsTargetGuestFwdToHclTerraform(struct!.guestFwd),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesChannelsTargetGuestFwd",
    },
    virt_io: {
      value: domainDevicesChannelsTargetVirtIoToHclTerraform(struct!.virtIo),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesChannelsTargetVirtIo",
    },
    xen: {
      value: domainDevicesChannelsTargetXenToHclTerraform(struct!.xen),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesChannelsTargetXen",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesChannelsTargetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesChannelsTarget | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._guestFwd?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.guestFwd = this._guestFwd?.internalValue;
    }
    if (this._virtIo?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.virtIo = this._virtIo?.internalValue;
    }
    if (this._xen?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.xen = this._xen?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesChannelsTarget | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._guestFwd.internalValue = undefined;
      this._virtIo.internalValue = undefined;
      this._xen.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._guestFwd.internalValue = value.guestFwd;
      this._virtIo.internalValue = value.virtIo;
      this._xen.internalValue = value.xen;
    }
  }

  // guest_fwd - computed: false, optional: true, required: false
  private _guestFwd = new DomainDevicesChannelsTargetGuestFwdOutputReference(this, "guest_fwd");
  public get guestFwd() {
    return this._guestFwd;
  }
  public putGuestFwd(value: DomainDevicesChannelsTargetGuestFwd) {
    this._guestFwd.internalValue = value;
  }
  public resetGuestFwd() {
    this._guestFwd.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get guestFwdInput() {
    return this._guestFwd.internalValue;
  }

  // virt_io - computed: false, optional: true, required: false
  private _virtIo = new DomainDevicesChannelsTargetVirtIoOutputReference(this, "virt_io");
  public get virtIo() {
    return this._virtIo;
  }
  public putVirtIo(value: DomainDevicesChannelsTargetVirtIo) {
    this._virtIo.internalValue = value;
  }
  public resetVirtIo() {
    this._virtIo.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get virtIoInput() {
    return this._virtIo.internalValue;
  }

  // xen - computed: false, optional: true, required: false
  private _xen = new DomainDevicesChannelsTargetXenOutputReference(this, "xen");
  public get xen() {
    return this._xen;
  }
  public putXen(value: DomainDevicesChannelsTargetXen) {
    this._xen.internalValue = value;
  }
  public resetXen() {
    this._xen.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get xenInput() {
    return this._xen.internalValue;
  }
}
export interface DomainDevicesChannels {
  /**
  * Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#acpi Domain#acpi}
  */
  readonly acpi?: DomainDevicesChannelsAcpi;
  /**
  * Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: DomainDevicesChannelsAddress;
  /**
  * Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#alias Domain#alias}
  */
  readonly alias?: DomainDevicesChannelsAlias;
  /**
  * Enables logging of data sent through the channel to a host file and configures how that logging behaves.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#log Domain#log}
  */
  readonly log?: DomainDevicesChannelsLog;
  /**
  * Configures the transport protocol used by the EGD backend connection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#protocol Domain#protocol}
  */
  readonly protocol?: DomainDevicesChannelsProtocol;
  /**
  * Defines the source endpoint for the EGD backend, such as a socket path or network address, depending on the chosen protocol.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#source Domain#source}
  */
  readonly source?: DomainDevicesChannelsSource;
  /**
  * Configures the guest-side target for the channel, selecting how the guest sees and uses the channel (e.g. virtio, xen, guestfwd).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#target Domain#target}
  */
  readonly target?: DomainDevicesChannelsTarget;
}

export function domainDevicesChannelsToTerraform(struct?: DomainDevicesChannels | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    acpi: domainDevicesChannelsAcpiToTerraform(struct!.acpi),
    address: domainDevicesChannelsAddressToTerraform(struct!.address),
    alias: domainDevicesChannelsAliasToTerraform(struct!.alias),
    log: domainDevicesChannelsLogToTerraform(struct!.log),
    protocol: domainDevicesChannelsProtocolToTerraform(struct!.protocol),
    source: domainDevicesChannelsSourceToTerraform(struct!.source),
    target: domainDevicesChannelsTargetToTerraform(struct!.target),
  }
}


export function domainDevicesChannelsToHclTerraform(struct?: DomainDevicesChannels | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    acpi: {
      value: domainDevicesChannelsAcpiToHclTerraform(struct!.acpi),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesChannelsAcpi",
    },
    address: {
      value: domainDevicesChannelsAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesChannelsAddress",
    },
    alias: {
      value: domainDevicesChannelsAliasToHclTerraform(struct!.alias),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesChannelsAlias",
    },
    log: {
      value: domainDevicesChannelsLogToHclTerraform(struct!.log),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesChannelsLog",
    },
    protocol: {
      value: domainDevicesChannelsProtocolToHclTerraform(struct!.protocol),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesChannelsProtocol",
    },
    source: {
      value: domainDevicesChannelsSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesChannelsSource",
    },
    target: {
      value: domainDevicesChannelsTargetToHclTerraform(struct!.target),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesChannelsTarget",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesChannelsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesChannels | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._acpi?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.acpi = this._acpi?.internalValue;
    }
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._alias?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.alias = this._alias?.internalValue;
    }
    if (this._log?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.log = this._log?.internalValue;
    }
    if (this._protocol?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol?.internalValue;
    }
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    if (this._target?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.target = this._target?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesChannels | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._acpi.internalValue = undefined;
      this._address.internalValue = undefined;
      this._alias.internalValue = undefined;
      this._log.internalValue = undefined;
      this._protocol.internalValue = undefined;
      this._source.internalValue = undefined;
      this._target.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._acpi.internalValue = value.acpi;
      this._address.internalValue = value.address;
      this._alias.internalValue = value.alias;
      this._log.internalValue = value.log;
      this._protocol.internalValue = value.protocol;
      this._source.internalValue = value.source;
      this._target.internalValue = value.target;
    }
  }

  // acpi - computed: false, optional: true, required: false
  private _acpi = new DomainDevicesChannelsAcpiOutputReference(this, "acpi");
  public get acpi() {
    return this._acpi;
  }
  public putAcpi(value: DomainDevicesChannelsAcpi) {
    this._acpi.internalValue = value;
  }
  public resetAcpi() {
    this._acpi.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get acpiInput() {
    return this._acpi.internalValue;
  }

  // address - computed: false, optional: true, required: false
  private _address = new DomainDevicesChannelsAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DomainDevicesChannelsAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // alias - computed: false, optional: true, required: false
  private _alias = new DomainDevicesChannelsAliasOutputReference(this, "alias");
  public get alias() {
    return this._alias;
  }
  public putAlias(value: DomainDevicesChannelsAlias) {
    this._alias.internalValue = value;
  }
  public resetAlias() {
    this._alias.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aliasInput() {
    return this._alias.internalValue;
  }

  // log - computed: false, optional: true, required: false
  private _log = new DomainDevicesChannelsLogOutputReference(this, "log");
  public get log() {
    return this._log;
  }
  public putLog(value: DomainDevicesChannelsLog) {
    this._log.internalValue = value;
  }
  public resetLog() {
    this._log.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logInput() {
    return this._log.internalValue;
  }

  // protocol - computed: false, optional: true, required: false
  private _protocol = new DomainDevicesChannelsProtocolOutputReference(this, "protocol");
  public get protocol() {
    return this._protocol;
  }
  public putProtocol(value: DomainDevicesChannelsProtocol) {
    this._protocol.internalValue = value;
  }
  public resetProtocol() {
    this._protocol.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol.internalValue;
  }

  // source - computed: false, optional: true, required: false
  private _source = new DomainDevicesChannelsSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: DomainDevicesChannelsSource) {
    this._source.internalValue = value;
  }
  public resetSource() {
    this._source.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }

  // target - computed: false, optional: true, required: false
  private _target = new DomainDevicesChannelsTargetOutputReference(this, "target");
  public get target() {
    return this._target;
  }
  public putTarget(value: DomainDevicesChannelsTarget) {
    this._target.internalValue = value;
  }
  public resetTarget() {
    this._target.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetInput() {
    return this._target.internalValue;
  }
}

export class DomainDevicesChannelsList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesChannels[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesChannelsOutputReference {
    return new DomainDevicesChannelsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesConsolesAcpi {
  /**
  * Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#pstore>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#index Domain#index}
  */
  readonly index?: number;
}

export function domainDevicesConsolesAcpiToTerraform(struct?: DomainDevicesConsolesAcpi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    index: cdktf.numberToTerraform(struct!.index),
  }
}


export function domainDevicesConsolesAcpiToHclTerraform(struct?: DomainDevicesConsolesAcpi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    index: {
      value: cdktf.numberToHclTerraform(struct!.index),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesConsolesAcpiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesConsolesAcpi | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._index !== undefined) {
      hasAnyValues = true;
      internalValueResult.index = this._index;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesConsolesAcpi | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._index = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._index = value.index;
    }
  }

  // index - computed: false, optional: true, required: false
  private _index?: number; 
  public get index() {
    return this.getNumberAttribute('index');
  }
  public set index(value: number) {
    this._index = value;
  }
  public resetIndex() {
    this._index = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get indexInput() {
    return this._index;
  }
}
export interface DomainDevicesConsolesAddress {
}

export function domainDevicesConsolesAddressToTerraform(struct?: DomainDevicesConsolesAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function domainDevicesConsolesAddressToHclTerraform(struct?: DomainDevicesConsolesAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DomainDevicesConsolesAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesConsolesAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesConsolesAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DomainDevicesConsolesAlias {
  /**
  * Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
}

export function domainDevicesConsolesAliasToTerraform(struct?: DomainDevicesConsolesAlias | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function domainDevicesConsolesAliasToHclTerraform(struct?: DomainDevicesConsolesAlias | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesConsolesAliasOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesConsolesAlias | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesConsolesAlias | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DomainDevicesConsolesLog {
  /**
  * Controls whether the channel log file is appended to (`"yes"`) or truncated (`"no"`) on start; this is a yes/no string flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#device-logfile>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#append Domain#append}
  */
  readonly append?: string;
  /**
  * Sets the absolute or relative path of the host file where channel I/O is logged.
  * 
  * See: <https://libvirt.org/formatdomain.html#device-logfile>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file: string;
}

export function domainDevicesConsolesLogToTerraform(struct?: DomainDevicesConsolesLog | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.stringToTerraform(struct!.append),
    file: cdktf.stringToTerraform(struct!.file),
  }
}


export function domainDevicesConsolesLogToHclTerraform(struct?: DomainDevicesConsolesLog | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.stringToHclTerraform(struct!.append),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    file: {
      value: cdktf.stringToHclTerraform(struct!.file),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesConsolesLogOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesConsolesLog | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append;
    }
    if (this._file !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesConsolesLog | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append = undefined;
      this._file = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append = value.append;
      this._file = value.file;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append?: string; 
  public get append() {
    return this.getStringAttribute('append');
  }
  public set append(value: string) {
    this._append = value;
  }
  public resetAppend() {
    this._append = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append;
  }

  // file - computed: false, optional: false, required: true
  private _file?: string; 
  public get file() {
    return this.getStringAttribute('file');
  }
  public set file(value: string) {
    this._file = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file;
  }
}
export interface DomainDevicesConsolesProtocol {
  /**
  * Sets the EGD transport type, such as "tcp" or "unix"; value is a user-provided string supported by the hypervisor.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type: string;
}

export function domainDevicesConsolesProtocolToTerraform(struct?: DomainDevicesConsolesProtocol | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function domainDevicesConsolesProtocolToHclTerraform(struct?: DomainDevicesConsolesProtocol | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesConsolesProtocolOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesConsolesProtocol | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesConsolesProtocol | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._type = value.type;
    }
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DomainDevicesConsolesSourceDbus {
  /**
  * Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#channel Domain#channel}
  */
  readonly channel?: string;
}

export function domainDevicesConsolesSourceDbusToTerraform(struct?: DomainDevicesConsolesSourceDbus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    channel: cdktf.stringToTerraform(struct!.channel),
  }
}


export function domainDevicesConsolesSourceDbusToHclTerraform(struct?: DomainDevicesConsolesSourceDbus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    channel: {
      value: cdktf.stringToHclTerraform(struct!.channel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesConsolesSourceDbusOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesConsolesSourceDbus | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._channel !== undefined) {
      hasAnyValues = true;
      internalValueResult.channel = this._channel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesConsolesSourceDbus | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._channel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._channel = value.channel;
    }
  }

  // channel - computed: false, optional: true, required: false
  private _channel?: string; 
  public get channel() {
    return this.getStringAttribute('channel');
  }
  public set channel(value: string) {
    this._channel = value;
  }
  public resetChannel() {
    this._channel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get channelInput() {
    return this._channel;
  }
}
export interface DomainDevicesConsolesSourceDevSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesConsolesSourceDevSecLabelToTerraform(struct?: DomainDevicesConsolesSourceDevSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesConsolesSourceDevSecLabelToHclTerraform(struct?: DomainDevicesConsolesSourceDevSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesConsolesSourceDevSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesConsolesSourceDevSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesConsolesSourceDevSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesConsolesSourceDevSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesConsolesSourceDevSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesConsolesSourceDevSecLabelOutputReference {
    return new DomainDevicesConsolesSourceDevSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesConsolesSourceDev {
  /**
  * Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesConsolesSourceDevSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesConsolesSourceDevToTerraform(struct?: DomainDevicesConsolesSourceDev | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesConsolesSourceDevSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesConsolesSourceDevToHclTerraform(struct?: DomainDevicesConsolesSourceDev | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesConsolesSourceDevSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesConsolesSourceDevSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesConsolesSourceDevOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesConsolesSourceDev | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesConsolesSourceDev | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesConsolesSourceDevSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesConsolesSourceDevSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesConsolesSourceFileSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesConsolesSourceFileSecLabelToTerraform(struct?: DomainDevicesConsolesSourceFileSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesConsolesSourceFileSecLabelToHclTerraform(struct?: DomainDevicesConsolesSourceFileSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesConsolesSourceFileSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesConsolesSourceFileSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesConsolesSourceFileSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesConsolesSourceFileSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesConsolesSourceFileSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesConsolesSourceFileSecLabelOutputReference {
    return new DomainDevicesConsolesSourceFileSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesConsolesSourceFile {
  /**
  * Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.
  * 
  * See: <https://libvirt.org/formatdomain.html#device-logfile>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#append Domain#append}
  */
  readonly append?: string;
  /**
  * Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesConsolesSourceFileSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesConsolesSourceFileToTerraform(struct?: DomainDevicesConsolesSourceFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.stringToTerraform(struct!.append),
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesConsolesSourceFileSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesConsolesSourceFileToHclTerraform(struct?: DomainDevicesConsolesSourceFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.stringToHclTerraform(struct!.append),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesConsolesSourceFileSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesConsolesSourceFileSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesConsolesSourceFileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesConsolesSourceFile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesConsolesSourceFile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append = value.append;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append?: string; 
  public get append() {
    return this.getStringAttribute('append');
  }
  public set append(value: string) {
    this._append = value;
  }
  public resetAppend() {
    this._append = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append;
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesConsolesSourceFileSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesConsolesSourceFileSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesConsolesSourceNmdm {
  /**
  * Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.
  * 
  * See: <https://libvirt.org/formatdomain.html#nmdm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#master Domain#master}
  */
  readonly master: string;
  /**
  * Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.
  * 
  * See: <https://libvirt.org/formatdomain.html#nmdm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#slave Domain#slave}
  */
  readonly slave: string;
}

export function domainDevicesConsolesSourceNmdmToTerraform(struct?: DomainDevicesConsolesSourceNmdm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    master: cdktf.stringToTerraform(struct!.master),
    slave: cdktf.stringToTerraform(struct!.slave),
  }
}


export function domainDevicesConsolesSourceNmdmToHclTerraform(struct?: DomainDevicesConsolesSourceNmdm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    master: {
      value: cdktf.stringToHclTerraform(struct!.master),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    slave: {
      value: cdktf.stringToHclTerraform(struct!.slave),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesConsolesSourceNmdmOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesConsolesSourceNmdm | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._master !== undefined) {
      hasAnyValues = true;
      internalValueResult.master = this._master;
    }
    if (this._slave !== undefined) {
      hasAnyValues = true;
      internalValueResult.slave = this._slave;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesConsolesSourceNmdm | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._master = undefined;
      this._slave = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._master = value.master;
      this._slave = value.slave;
    }
  }

  // master - computed: false, optional: false, required: true
  private _master?: string; 
  public get master() {
    return this.getStringAttribute('master');
  }
  public set master(value: string) {
    this._master = value;
  }
  // Temporarily expose input value. Use with caution.
  public get masterInput() {
    return this._master;
  }

  // slave - computed: false, optional: false, required: true
  private _slave?: string; 
  public get slave() {
    return this.getStringAttribute('slave');
  }
  public set slave(value: string) {
    this._slave = value;
  }
  // Temporarily expose input value. Use with caution.
  public get slaveInput() {
    return this._slave;
  }
}
export interface DomainDevicesConsolesSourcePipeSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesConsolesSourcePipeSecLabelToTerraform(struct?: DomainDevicesConsolesSourcePipeSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesConsolesSourcePipeSecLabelToHclTerraform(struct?: DomainDevicesConsolesSourcePipeSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesConsolesSourcePipeSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesConsolesSourcePipeSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesConsolesSourcePipeSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesConsolesSourcePipeSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesConsolesSourcePipeSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesConsolesSourcePipeSecLabelOutputReference {
    return new DomainDevicesConsolesSourcePipeSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesConsolesSourcePipe {
  /**
  * Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesConsolesSourcePipeSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesConsolesSourcePipeToTerraform(struct?: DomainDevicesConsolesSourcePipe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesConsolesSourcePipeSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesConsolesSourcePipeToHclTerraform(struct?: DomainDevicesConsolesSourcePipe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesConsolesSourcePipeSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesConsolesSourcePipeSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesConsolesSourcePipeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesConsolesSourcePipe | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesConsolesSourcePipe | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesConsolesSourcePipeSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesConsolesSourcePipeSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesConsolesSourcePtySecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesConsolesSourcePtySecLabelToTerraform(struct?: DomainDevicesConsolesSourcePtySecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesConsolesSourcePtySecLabelToHclTerraform(struct?: DomainDevicesConsolesSourcePtySecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesConsolesSourcePtySecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesConsolesSourcePtySecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesConsolesSourcePtySecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesConsolesSourcePtySecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesConsolesSourcePtySecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesConsolesSourcePtySecLabelOutputReference {
    return new DomainDevicesConsolesSourcePtySecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesConsolesSourcePty {
  /**
  * Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesConsolesSourcePtySecLabel[] | cdktf.IResolvable;
}

export function domainDevicesConsolesSourcePtyToTerraform(struct?: DomainDevicesConsolesSourcePty | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesConsolesSourcePtySecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesConsolesSourcePtyToHclTerraform(struct?: DomainDevicesConsolesSourcePty | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesConsolesSourcePtySecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesConsolesSourcePtySecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesConsolesSourcePtyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesConsolesSourcePty | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesConsolesSourcePty | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesConsolesSourcePtySecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesConsolesSourcePtySecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesConsolesSourceQemuvdAgentClipBoard {
  /**
  * Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#copy_paste Domain#copy_paste}
  */
  readonly copyPaste: string;
}

export function domainDevicesConsolesSourceQemuvdAgentClipBoardToTerraform(struct?: DomainDevicesConsolesSourceQemuvdAgentClipBoard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    copy_paste: cdktf.stringToTerraform(struct!.copyPaste),
  }
}


export function domainDevicesConsolesSourceQemuvdAgentClipBoardToHclTerraform(struct?: DomainDevicesConsolesSourceQemuvdAgentClipBoard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    copy_paste: {
      value: cdktf.stringToHclTerraform(struct!.copyPaste),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesConsolesSourceQemuvdAgentClipBoardOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesConsolesSourceQemuvdAgentClipBoard | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._copyPaste !== undefined) {
      hasAnyValues = true;
      internalValueResult.copyPaste = this._copyPaste;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesConsolesSourceQemuvdAgentClipBoard | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._copyPaste = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._copyPaste = value.copyPaste;
    }
  }

  // copy_paste - computed: false, optional: false, required: true
  private _copyPaste?: string; 
  public get copyPaste() {
    return this.getStringAttribute('copy_paste');
  }
  public set copyPaste(value: string) {
    this._copyPaste = value;
  }
  // Temporarily expose input value. Use with caution.
  public get copyPasteInput() {
    return this._copyPaste;
  }
}
export interface DomainDevicesConsolesSourceQemuvdAgentMouse {
  /**
  * Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).
  * 
  * See: <https://libvirt.org/formatdomain.html#channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode: string;
}

export function domainDevicesConsolesSourceQemuvdAgentMouseToTerraform(struct?: DomainDevicesConsolesSourceQemuvdAgentMouse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
  }
}


export function domainDevicesConsolesSourceQemuvdAgentMouseToHclTerraform(struct?: DomainDevicesConsolesSourceQemuvdAgentMouse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesConsolesSourceQemuvdAgentMouseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesConsolesSourceQemuvdAgentMouse | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesConsolesSourceQemuvdAgentMouse | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
    }
  }

  // mode - computed: false, optional: false, required: true
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }
}
export interface DomainDevicesConsolesSourceQemuvdAgent {
  /**
  * Configures clipboard-related behavior for the QEMU vdagent–based EGD source, controlling whether clipboard data exchange is allowed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#clip_board Domain#clip_board}
  */
  readonly clipBoard?: DomainDevicesConsolesSourceQemuvdAgentClipBoard;
  /**
  * Configures mouse integration options for the QEMU vdagent–based EGD source, such as how mouse events are handled.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mouse Domain#mouse}
  */
  readonly mouse?: DomainDevicesConsolesSourceQemuvdAgentMouse;
}

export function domainDevicesConsolesSourceQemuvdAgentToTerraform(struct?: DomainDevicesConsolesSourceQemuvdAgent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    clip_board: domainDevicesConsolesSourceQemuvdAgentClipBoardToTerraform(struct!.clipBoard),
    mouse: domainDevicesConsolesSourceQemuvdAgentMouseToTerraform(struct!.mouse),
  }
}


export function domainDevicesConsolesSourceQemuvdAgentToHclTerraform(struct?: DomainDevicesConsolesSourceQemuvdAgent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    clip_board: {
      value: domainDevicesConsolesSourceQemuvdAgentClipBoardToHclTerraform(struct!.clipBoard),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesConsolesSourceQemuvdAgentClipBoard",
    },
    mouse: {
      value: domainDevicesConsolesSourceQemuvdAgentMouseToHclTerraform(struct!.mouse),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesConsolesSourceQemuvdAgentMouse",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesConsolesSourceQemuvdAgentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesConsolesSourceQemuvdAgent | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clipBoard?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clipBoard = this._clipBoard?.internalValue;
    }
    if (this._mouse?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.mouse = this._mouse?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesConsolesSourceQemuvdAgent | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clipBoard.internalValue = undefined;
      this._mouse.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clipBoard.internalValue = value.clipBoard;
      this._mouse.internalValue = value.mouse;
    }
  }

  // clip_board - computed: false, optional: true, required: false
  private _clipBoard = new DomainDevicesConsolesSourceQemuvdAgentClipBoardOutputReference(this, "clip_board");
  public get clipBoard() {
    return this._clipBoard;
  }
  public putClipBoard(value: DomainDevicesConsolesSourceQemuvdAgentClipBoard) {
    this._clipBoard.internalValue = value;
  }
  public resetClipBoard() {
    this._clipBoard.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clipBoardInput() {
    return this._clipBoard.internalValue;
  }

  // mouse - computed: false, optional: true, required: false
  private _mouse = new DomainDevicesConsolesSourceQemuvdAgentMouseOutputReference(this, "mouse");
  public get mouse() {
    return this._mouse;
  }
  public putMouse(value: DomainDevicesConsolesSourceQemuvdAgentMouse) {
    this._mouse.internalValue = value;
  }
  public resetMouse() {
    this._mouse.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mouseInput() {
    return this._mouse.internalValue;
  }
}
export interface DomainDevicesConsolesSourceSpicePort {
  /**
  * Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#channel Domain#channel}
  */
  readonly channel: string;
}

export function domainDevicesConsolesSourceSpicePortToTerraform(struct?: DomainDevicesConsolesSourceSpicePort | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    channel: cdktf.stringToTerraform(struct!.channel),
  }
}


export function domainDevicesConsolesSourceSpicePortToHclTerraform(struct?: DomainDevicesConsolesSourceSpicePort | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    channel: {
      value: cdktf.stringToHclTerraform(struct!.channel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesConsolesSourceSpicePortOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesConsolesSourceSpicePort | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._channel !== undefined) {
      hasAnyValues = true;
      internalValueResult.channel = this._channel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesConsolesSourceSpicePort | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._channel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._channel = value.channel;
    }
  }

  // channel - computed: false, optional: false, required: true
  private _channel?: string; 
  public get channel() {
    return this.getStringAttribute('channel');
  }
  public set channel(value: string) {
    this._channel = value;
  }
  // Temporarily expose input value. Use with caution.
  public get channelInput() {
    return this._channel;
  }
}
export interface DomainDevicesConsolesSourceTcpReconnect {
  /**
  * Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enabled Domain#enabled}
  */
  readonly enabled: string;
  /**
  * Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#timeout Domain#timeout}
  */
  readonly timeout?: number;
}

export function domainDevicesConsolesSourceTcpReconnectToTerraform(struct?: DomainDevicesConsolesSourceTcpReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.stringToTerraform(struct!.enabled),
    timeout: cdktf.numberToTerraform(struct!.timeout),
  }
}


export function domainDevicesConsolesSourceTcpReconnectToHclTerraform(struct?: DomainDevicesConsolesSourceTcpReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.stringToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.numberToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesConsolesSourceTcpReconnectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesConsolesSourceTcpReconnect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesConsolesSourceTcpReconnect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._timeout = value.timeout;
    }
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: string; 
  public get enabled() {
    return this.getStringAttribute('enabled');
  }
  public set enabled(value: string) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: number; 
  public get timeout() {
    return this.getNumberAttribute('timeout');
  }
  public set timeout(value: number) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DomainDevicesConsolesSourceTcp {
  /**
  * Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#host Domain#host}
  */
  readonly host?: string;
  /**
  * Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode?: string;
  /**
  * Enables and configures automatic reconnection behavior for a UNIX socket–based EGD entropy source; the content and attributes are user-provided according to desired policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reconnect Domain#reconnect}
  */
  readonly reconnect?: DomainDevicesConsolesSourceTcpReconnect;
  /**
  * Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#service Domain#service}
  */
  readonly service?: string;
  /**
  * Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tls Domain#tls}
  */
  readonly tls?: string;
}

export function domainDevicesConsolesSourceTcpToTerraform(struct?: DomainDevicesConsolesSourceTcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    mode: cdktf.stringToTerraform(struct!.mode),
    reconnect: domainDevicesConsolesSourceTcpReconnectToTerraform(struct!.reconnect),
    service: cdktf.stringToTerraform(struct!.service),
    tls: cdktf.stringToTerraform(struct!.tls),
  }
}


export function domainDevicesConsolesSourceTcpToHclTerraform(struct?: DomainDevicesConsolesSourceTcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reconnect: {
      value: domainDevicesConsolesSourceTcpReconnectToHclTerraform(struct!.reconnect),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesConsolesSourceTcpReconnect",
    },
    service: {
      value: cdktf.stringToHclTerraform(struct!.service),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: cdktf.stringToHclTerraform(struct!.tls),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesConsolesSourceTcpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesConsolesSourceTcp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._reconnect?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.reconnect = this._reconnect?.internalValue;
    }
    if (this._service !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service;
    }
    if (this._tls !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesConsolesSourceTcp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host = undefined;
      this._mode = undefined;
      this._reconnect.internalValue = undefined;
      this._service = undefined;
      this._tls = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host = value.host;
      this._mode = value.mode;
      this._reconnect.internalValue = value.reconnect;
      this._service = value.service;
      this._tls = value.tls;
    }
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // reconnect - computed: false, optional: true, required: false
  private _reconnect = new DomainDevicesConsolesSourceTcpReconnectOutputReference(this, "reconnect");
  public get reconnect() {
    return this._reconnect;
  }
  public putReconnect(value: DomainDevicesConsolesSourceTcpReconnect) {
    this._reconnect.internalValue = value;
  }
  public resetReconnect() {
    this._reconnect.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reconnectInput() {
    return this._reconnect.internalValue;
  }

  // service - computed: false, optional: true, required: false
  private _service?: string; 
  public get service() {
    return this.getStringAttribute('service');
  }
  public set service(value: string) {
    this._service = value;
  }
  public resetService() {
    this._service = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service;
  }

  // tls - computed: false, optional: true, required: false
  private _tls?: string; 
  public get tls() {
    return this.getStringAttribute('tls');
  }
  public set tls(value: string) {
    this._tls = value;
  }
  public resetTls() {
    this._tls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls;
  }
}
export interface DomainDevicesConsolesSourceUdp {
  /**
  * Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bind_host Domain#bind_host}
  */
  readonly bindHost: string;
  /**
  * Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bind_service Domain#bind_service}
  */
  readonly bindService: string;
  /**
  * Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#connect_host Domain#connect_host}
  */
  readonly connectHost: string;
  /**
  * Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#connect_service Domain#connect_service}
  */
  readonly connectService: string;
}

export function domainDevicesConsolesSourceUdpToTerraform(struct?: DomainDevicesConsolesSourceUdp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_host: cdktf.stringToTerraform(struct!.bindHost),
    bind_service: cdktf.stringToTerraform(struct!.bindService),
    connect_host: cdktf.stringToTerraform(struct!.connectHost),
    connect_service: cdktf.stringToTerraform(struct!.connectService),
  }
}


export function domainDevicesConsolesSourceUdpToHclTerraform(struct?: DomainDevicesConsolesSourceUdp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_host: {
      value: cdktf.stringToHclTerraform(struct!.bindHost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bind_service: {
      value: cdktf.stringToHclTerraform(struct!.bindService),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connect_host: {
      value: cdktf.stringToHclTerraform(struct!.connectHost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connect_service: {
      value: cdktf.stringToHclTerraform(struct!.connectService),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesConsolesSourceUdpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesConsolesSourceUdp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindHost !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindHost = this._bindHost;
    }
    if (this._bindService !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindService = this._bindService;
    }
    if (this._connectHost !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectHost = this._connectHost;
    }
    if (this._connectService !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectService = this._connectService;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesConsolesSourceUdp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bindHost = undefined;
      this._bindService = undefined;
      this._connectHost = undefined;
      this._connectService = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bindHost = value.bindHost;
      this._bindService = value.bindService;
      this._connectHost = value.connectHost;
      this._connectService = value.connectService;
    }
  }

  // bind_host - computed: false, optional: false, required: true
  private _bindHost?: string; 
  public get bindHost() {
    return this.getStringAttribute('bind_host');
  }
  public set bindHost(value: string) {
    this._bindHost = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bindHostInput() {
    return this._bindHost;
  }

  // bind_service - computed: false, optional: false, required: true
  private _bindService?: string; 
  public get bindService() {
    return this.getStringAttribute('bind_service');
  }
  public set bindService(value: string) {
    this._bindService = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bindServiceInput() {
    return this._bindService;
  }

  // connect_host - computed: false, optional: false, required: true
  private _connectHost?: string; 
  public get connectHost() {
    return this.getStringAttribute('connect_host');
  }
  public set connectHost(value: string) {
    this._connectHost = value;
  }
  // Temporarily expose input value. Use with caution.
  public get connectHostInput() {
    return this._connectHost;
  }

  // connect_service - computed: false, optional: false, required: true
  private _connectService?: string; 
  public get connectService() {
    return this.getStringAttribute('connect_service');
  }
  public set connectService(value: string) {
    this._connectService = value;
  }
  // Temporarily expose input value. Use with caution.
  public get connectServiceInput() {
    return this._connectService;
  }
}
export interface DomainDevicesConsolesSourceUnixReconnect {
  /**
  * Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enabled Domain#enabled}
  */
  readonly enabled: string;
  /**
  * Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#timeout Domain#timeout}
  */
  readonly timeout?: number;
}

export function domainDevicesConsolesSourceUnixReconnectToTerraform(struct?: DomainDevicesConsolesSourceUnixReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.stringToTerraform(struct!.enabled),
    timeout: cdktf.numberToTerraform(struct!.timeout),
  }
}


export function domainDevicesConsolesSourceUnixReconnectToHclTerraform(struct?: DomainDevicesConsolesSourceUnixReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.stringToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.numberToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesConsolesSourceUnixReconnectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesConsolesSourceUnixReconnect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesConsolesSourceUnixReconnect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._timeout = value.timeout;
    }
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: string; 
  public get enabled() {
    return this.getStringAttribute('enabled');
  }
  public set enabled(value: string) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: number; 
  public get timeout() {
    return this.getNumberAttribute('timeout');
  }
  public set timeout(value: number) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DomainDevicesConsolesSourceUnixSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesConsolesSourceUnixSecLabelToTerraform(struct?: DomainDevicesConsolesSourceUnixSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesConsolesSourceUnixSecLabelToHclTerraform(struct?: DomainDevicesConsolesSourceUnixSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesConsolesSourceUnixSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesConsolesSourceUnixSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesConsolesSourceUnixSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesConsolesSourceUnixSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesConsolesSourceUnixSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesConsolesSourceUnixSecLabelOutputReference {
    return new DomainDevicesConsolesSourceUnixSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesConsolesSourceUnix {
  /**
  * Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode?: string;
  /**
  * Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path?: string;
  /**
  * Enables and configures automatic reconnection behavior for a UNIX socket–based EGD entropy source; the content and attributes are user-provided according to desired policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reconnect Domain#reconnect}
  */
  readonly reconnect?: DomainDevicesConsolesSourceUnixReconnect;
  /**
  * Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesConsolesSourceUnixSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesConsolesSourceUnixToTerraform(struct?: DomainDevicesConsolesSourceUnix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
    reconnect: domainDevicesConsolesSourceUnixReconnectToTerraform(struct!.reconnect),
    sec_label: cdktf.listMapper(domainDevicesConsolesSourceUnixSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesConsolesSourceUnixToHclTerraform(struct?: DomainDevicesConsolesSourceUnix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reconnect: {
      value: domainDevicesConsolesSourceUnixReconnectToHclTerraform(struct!.reconnect),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesConsolesSourceUnixReconnect",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesConsolesSourceUnixSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesConsolesSourceUnixSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesConsolesSourceUnixOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesConsolesSourceUnix | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._reconnect?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.reconnect = this._reconnect?.internalValue;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesConsolesSourceUnix | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
      this._path = undefined;
      this._reconnect.internalValue = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
      this._path = value.path;
      this._reconnect.internalValue = value.reconnect;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // reconnect - computed: false, optional: true, required: false
  private _reconnect = new DomainDevicesConsolesSourceUnixReconnectOutputReference(this, "reconnect");
  public get reconnect() {
    return this._reconnect;
  }
  public putReconnect(value: DomainDevicesConsolesSourceUnixReconnect) {
    this._reconnect.internalValue = value;
  }
  public resetReconnect() {
    this._reconnect.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reconnectInput() {
    return this._reconnect.internalValue;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesConsolesSourceUnixSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesConsolesSourceUnixSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesConsolesSource {
  /**
  * Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dbus Domain#dbus}
  */
  readonly dbus?: DomainDevicesConsolesSourceDbus;
  /**
  * Configures an EGD RNG backend that reads entropy from a host character device node.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dev Domain#dev}
  */
  readonly dev?: DomainDevicesConsolesSourceDev;
  /**
  * Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file?: DomainDevicesConsolesSourceFile;
  /**
  * Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#nmdm Domain#nmdm}
  */
  readonly nmdm?: DomainDevicesConsolesSourceNmdm;
  /**
  * Enables use of a null backend for the EGD RNG source, discarding all data written and providing no entropy; when this boolean is true the <Null> source is emitted, and when false or unset it is omitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#null Domain#null}
  */
  readonly null?: boolean | cdktf.IResolvable;
  /**
  * Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pipe Domain#pipe}
  */
  readonly pipe?: DomainDevicesConsolesSourcePipe;
  /**
  * Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pty Domain#pty}
  */
  readonly pty?: DomainDevicesConsolesSourcePty;
  /**
  * Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#qemuvd_agent Domain#qemuvd_agent}
  */
  readonly qemuvdAgent?: DomainDevicesConsolesSourceQemuvdAgent;
  /**
  * Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#spice_port Domain#spice_port}
  */
  readonly spicePort?: DomainDevicesConsolesSourceSpicePort;
  /**
  * Enables using a SPICE virtio serial management channel (spicevmc) as the entropy source for the EGD RNG backend when set to true; when false or unset, the element is omitted.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#spice_vmc Domain#spice_vmc}
  */
  readonly spiceVmc?: boolean | cdktf.IResolvable;
  /**
  * Enables using the QEMU process standard I/O stream as the entropy source for the EGD RNG backend when set to true; when false or unset, the element is omitted.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#std_io Domain#std_io}
  */
  readonly stdIo?: boolean | cdktf.IResolvable;
  /**
  * Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tcp Domain#tcp}
  */
  readonly tcp?: DomainDevicesConsolesSourceTcp;
  /**
  * Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#udp Domain#udp}
  */
  readonly udp?: DomainDevicesConsolesSourceUdp;
  /**
  * Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#unix Domain#unix}
  */
  readonly unix?: DomainDevicesConsolesSourceUnix;
  /**
  * Enables use of a virtual console device as the entropy source for the EGD RNG backend when set (presence-only element; omitting it disables this source).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vc Domain#vc}
  */
  readonly vc?: boolean | cdktf.IResolvable;
}

export function domainDevicesConsolesSourceToTerraform(struct?: DomainDevicesConsolesSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dbus: domainDevicesConsolesSourceDbusToTerraform(struct!.dbus),
    dev: domainDevicesConsolesSourceDevToTerraform(struct!.dev),
    file: domainDevicesConsolesSourceFileToTerraform(struct!.file),
    nmdm: domainDevicesConsolesSourceNmdmToTerraform(struct!.nmdm),
    null: cdktf.booleanToTerraform(struct!.null),
    pipe: domainDevicesConsolesSourcePipeToTerraform(struct!.pipe),
    pty: domainDevicesConsolesSourcePtyToTerraform(struct!.pty),
    qemuvd_agent: domainDevicesConsolesSourceQemuvdAgentToTerraform(struct!.qemuvdAgent),
    spice_port: domainDevicesConsolesSourceSpicePortToTerraform(struct!.spicePort),
    spice_vmc: cdktf.booleanToTerraform(struct!.spiceVmc),
    std_io: cdktf.booleanToTerraform(struct!.stdIo),
    tcp: domainDevicesConsolesSourceTcpToTerraform(struct!.tcp),
    udp: domainDevicesConsolesSourceUdpToTerraform(struct!.udp),
    unix: domainDevicesConsolesSourceUnixToTerraform(struct!.unix),
    vc: cdktf.booleanToTerraform(struct!.vc),
  }
}


export function domainDevicesConsolesSourceToHclTerraform(struct?: DomainDevicesConsolesSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dbus: {
      value: domainDevicesConsolesSourceDbusToHclTerraform(struct!.dbus),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesConsolesSourceDbus",
    },
    dev: {
      value: domainDevicesConsolesSourceDevToHclTerraform(struct!.dev),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesConsolesSourceDev",
    },
    file: {
      value: domainDevicesConsolesSourceFileToHclTerraform(struct!.file),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesConsolesSourceFile",
    },
    nmdm: {
      value: domainDevicesConsolesSourceNmdmToHclTerraform(struct!.nmdm),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesConsolesSourceNmdm",
    },
    null: {
      value: cdktf.booleanToHclTerraform(struct!.null),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    pipe: {
      value: domainDevicesConsolesSourcePipeToHclTerraform(struct!.pipe),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesConsolesSourcePipe",
    },
    pty: {
      value: domainDevicesConsolesSourcePtyToHclTerraform(struct!.pty),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesConsolesSourcePty",
    },
    qemuvd_agent: {
      value: domainDevicesConsolesSourceQemuvdAgentToHclTerraform(struct!.qemuvdAgent),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesConsolesSourceQemuvdAgent",
    },
    spice_port: {
      value: domainDevicesConsolesSourceSpicePortToHclTerraform(struct!.spicePort),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesConsolesSourceSpicePort",
    },
    spice_vmc: {
      value: cdktf.booleanToHclTerraform(struct!.spiceVmc),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    std_io: {
      value: cdktf.booleanToHclTerraform(struct!.stdIo),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tcp: {
      value: domainDevicesConsolesSourceTcpToHclTerraform(struct!.tcp),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesConsolesSourceTcp",
    },
    udp: {
      value: domainDevicesConsolesSourceUdpToHclTerraform(struct!.udp),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesConsolesSourceUdp",
    },
    unix: {
      value: domainDevicesConsolesSourceUnixToHclTerraform(struct!.unix),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesConsolesSourceUnix",
    },
    vc: {
      value: cdktf.booleanToHclTerraform(struct!.vc),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesConsolesSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesConsolesSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dbus?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dbus = this._dbus?.internalValue;
    }
    if (this._dev?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dev = this._dev?.internalValue;
    }
    if (this._file?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file?.internalValue;
    }
    if (this._nmdm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nmdm = this._nmdm?.internalValue;
    }
    if (this._null !== undefined) {
      hasAnyValues = true;
      internalValueResult.null = this._null;
    }
    if (this._pipe?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipe = this._pipe?.internalValue;
    }
    if (this._pty?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pty = this._pty?.internalValue;
    }
    if (this._qemuvdAgent?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.qemuvdAgent = this._qemuvdAgent?.internalValue;
    }
    if (this._spicePort?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spicePort = this._spicePort?.internalValue;
    }
    if (this._spiceVmc !== undefined) {
      hasAnyValues = true;
      internalValueResult.spiceVmc = this._spiceVmc;
    }
    if (this._stdIo !== undefined) {
      hasAnyValues = true;
      internalValueResult.stdIo = this._stdIo;
    }
    if (this._tcp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tcp = this._tcp?.internalValue;
    }
    if (this._udp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.udp = this._udp?.internalValue;
    }
    if (this._unix?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.unix = this._unix?.internalValue;
    }
    if (this._vc !== undefined) {
      hasAnyValues = true;
      internalValueResult.vc = this._vc;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesConsolesSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dbus.internalValue = undefined;
      this._dev.internalValue = undefined;
      this._file.internalValue = undefined;
      this._nmdm.internalValue = undefined;
      this._null = undefined;
      this._pipe.internalValue = undefined;
      this._pty.internalValue = undefined;
      this._qemuvdAgent.internalValue = undefined;
      this._spicePort.internalValue = undefined;
      this._spiceVmc = undefined;
      this._stdIo = undefined;
      this._tcp.internalValue = undefined;
      this._udp.internalValue = undefined;
      this._unix.internalValue = undefined;
      this._vc = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dbus.internalValue = value.dbus;
      this._dev.internalValue = value.dev;
      this._file.internalValue = value.file;
      this._nmdm.internalValue = value.nmdm;
      this._null = value.null;
      this._pipe.internalValue = value.pipe;
      this._pty.internalValue = value.pty;
      this._qemuvdAgent.internalValue = value.qemuvdAgent;
      this._spicePort.internalValue = value.spicePort;
      this._spiceVmc = value.spiceVmc;
      this._stdIo = value.stdIo;
      this._tcp.internalValue = value.tcp;
      this._udp.internalValue = value.udp;
      this._unix.internalValue = value.unix;
      this._vc = value.vc;
    }
  }

  // dbus - computed: false, optional: true, required: false
  private _dbus = new DomainDevicesConsolesSourceDbusOutputReference(this, "dbus");
  public get dbus() {
    return this._dbus;
  }
  public putDbus(value: DomainDevicesConsolesSourceDbus) {
    this._dbus.internalValue = value;
  }
  public resetDbus() {
    this._dbus.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dbusInput() {
    return this._dbus.internalValue;
  }

  // dev - computed: false, optional: true, required: false
  private _dev = new DomainDevicesConsolesSourceDevOutputReference(this, "dev");
  public get dev() {
    return this._dev;
  }
  public putDev(value: DomainDevicesConsolesSourceDev) {
    this._dev.internalValue = value;
  }
  public resetDev() {
    this._dev.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devInput() {
    return this._dev.internalValue;
  }

  // file - computed: false, optional: true, required: false
  private _file = new DomainDevicesConsolesSourceFileOutputReference(this, "file");
  public get file() {
    return this._file;
  }
  public putFile(value: DomainDevicesConsolesSourceFile) {
    this._file.internalValue = value;
  }
  public resetFile() {
    this._file.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file.internalValue;
  }

  // nmdm - computed: false, optional: true, required: false
  private _nmdm = new DomainDevicesConsolesSourceNmdmOutputReference(this, "nmdm");
  public get nmdm() {
    return this._nmdm;
  }
  public putNmdm(value: DomainDevicesConsolesSourceNmdm) {
    this._nmdm.internalValue = value;
  }
  public resetNmdm() {
    this._nmdm.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nmdmInput() {
    return this._nmdm.internalValue;
  }

  // null - computed: false, optional: true, required: false
  private _null?: boolean | cdktf.IResolvable; 
  public get null() {
    return this.getBooleanAttribute('null');
  }
  public set null(value: boolean | cdktf.IResolvable) {
    this._null = value;
  }
  public resetNull() {
    this._null = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nullInput() {
    return this._null;
  }

  // pipe - computed: false, optional: true, required: false
  private _pipe = new DomainDevicesConsolesSourcePipeOutputReference(this, "pipe");
  public get pipe() {
    return this._pipe;
  }
  public putPipe(value: DomainDevicesConsolesSourcePipe) {
    this._pipe.internalValue = value;
  }
  public resetPipe() {
    this._pipe.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipeInput() {
    return this._pipe.internalValue;
  }

  // pty - computed: false, optional: true, required: false
  private _pty = new DomainDevicesConsolesSourcePtyOutputReference(this, "pty");
  public get pty() {
    return this._pty;
  }
  public putPty(value: DomainDevicesConsolesSourcePty) {
    this._pty.internalValue = value;
  }
  public resetPty() {
    this._pty.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ptyInput() {
    return this._pty.internalValue;
  }

  // qemuvd_agent - computed: false, optional: true, required: false
  private _qemuvdAgent = new DomainDevicesConsolesSourceQemuvdAgentOutputReference(this, "qemuvd_agent");
  public get qemuvdAgent() {
    return this._qemuvdAgent;
  }
  public putQemuvdAgent(value: DomainDevicesConsolesSourceQemuvdAgent) {
    this._qemuvdAgent.internalValue = value;
  }
  public resetQemuvdAgent() {
    this._qemuvdAgent.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get qemuvdAgentInput() {
    return this._qemuvdAgent.internalValue;
  }

  // spice_port - computed: false, optional: true, required: false
  private _spicePort = new DomainDevicesConsolesSourceSpicePortOutputReference(this, "spice_port");
  public get spicePort() {
    return this._spicePort;
  }
  public putSpicePort(value: DomainDevicesConsolesSourceSpicePort) {
    this._spicePort.internalValue = value;
  }
  public resetSpicePort() {
    this._spicePort.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spicePortInput() {
    return this._spicePort.internalValue;
  }

  // spice_vmc - computed: false, optional: true, required: false
  private _spiceVmc?: boolean | cdktf.IResolvable; 
  public get spiceVmc() {
    return this.getBooleanAttribute('spice_vmc');
  }
  public set spiceVmc(value: boolean | cdktf.IResolvable) {
    this._spiceVmc = value;
  }
  public resetSpiceVmc() {
    this._spiceVmc = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spiceVmcInput() {
    return this._spiceVmc;
  }

  // std_io - computed: false, optional: true, required: false
  private _stdIo?: boolean | cdktf.IResolvable; 
  public get stdIo() {
    return this.getBooleanAttribute('std_io');
  }
  public set stdIo(value: boolean | cdktf.IResolvable) {
    this._stdIo = value;
  }
  public resetStdIo() {
    this._stdIo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stdIoInput() {
    return this._stdIo;
  }

  // tcp - computed: false, optional: true, required: false
  private _tcp = new DomainDevicesConsolesSourceTcpOutputReference(this, "tcp");
  public get tcp() {
    return this._tcp;
  }
  public putTcp(value: DomainDevicesConsolesSourceTcp) {
    this._tcp.internalValue = value;
  }
  public resetTcp() {
    this._tcp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tcpInput() {
    return this._tcp.internalValue;
  }

  // udp - computed: false, optional: true, required: false
  private _udp = new DomainDevicesConsolesSourceUdpOutputReference(this, "udp");
  public get udp() {
    return this._udp;
  }
  public putUdp(value: DomainDevicesConsolesSourceUdp) {
    this._udp.internalValue = value;
  }
  public resetUdp() {
    this._udp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get udpInput() {
    return this._udp.internalValue;
  }

  // unix - computed: false, optional: true, required: false
  private _unix = new DomainDevicesConsolesSourceUnixOutputReference(this, "unix");
  public get unix() {
    return this._unix;
  }
  public putUnix(value: DomainDevicesConsolesSourceUnix) {
    this._unix.internalValue = value;
  }
  public resetUnix() {
    this._unix.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unixInput() {
    return this._unix.internalValue;
  }

  // vc - computed: false, optional: true, required: false
  private _vc?: boolean | cdktf.IResolvable; 
  public get vc() {
    return this.getBooleanAttribute('vc');
  }
  public set vc(value: boolean | cdktf.IResolvable) {
    this._vc = value;
  }
  public resetVc() {
    this._vc = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vcInput() {
    return this._vc;
  }
}
export interface DomainDevicesConsolesTarget {
  /**
  * Sets the guest-side console port number, starting from 0; the value is a user-provided non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#guest-interface>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#port Domain#port}
  */
  readonly port?: number;
  /**
  * Sets the target device type for the console within the guest (e.g. "serial", "virtio", "xen", "sclp"); the value must match a libvirt-supported console type.
  * 
  * See: <https://libvirt.org/formatdomain.html#guest-interface>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type?: string;
}

export function domainDevicesConsolesTargetToTerraform(struct?: DomainDevicesConsolesTarget | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    port: cdktf.numberToTerraform(struct!.port),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function domainDevicesConsolesTargetToHclTerraform(struct?: DomainDevicesConsolesTarget | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesConsolesTargetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesConsolesTarget | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesConsolesTarget | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._port = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._port = value.port;
      this._type = value.type;
    }
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DomainDevicesConsoles {
  /**
  * Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#acpi Domain#acpi}
  */
  readonly acpi?: DomainDevicesConsolesAcpi;
  /**
  * Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: DomainDevicesConsolesAddress;
  /**
  * Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#alias Domain#alias}
  */
  readonly alias?: DomainDevicesConsolesAlias;
  /**
  * Enables logging of data sent through the channel to a host file and configures how that logging behaves.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#log Domain#log}
  */
  readonly log?: DomainDevicesConsolesLog;
  /**
  * Configures the transport protocol used by the EGD backend connection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#protocol Domain#protocol}
  */
  readonly protocol?: DomainDevicesConsolesProtocol;
  /**
  * Defines the source endpoint for the EGD backend, such as a socket path or network address, depending on the chosen protocol.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#source Domain#source}
  */
  readonly source?: DomainDevicesConsolesSource;
  /**
  * Configures how the console appears inside the guest (e.g. which guest console/serial port it is attached to).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#target Domain#target}
  */
  readonly target?: DomainDevicesConsolesTarget;
  /**
  * Records or overrides the host-side TTY or device path associated with this console (for example "/dev/pts/3"); value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#pseudo-tty>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tty Domain#tty}
  */
  readonly tty?: string;
}

export function domainDevicesConsolesToTerraform(struct?: DomainDevicesConsoles | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    acpi: domainDevicesConsolesAcpiToTerraform(struct!.acpi),
    address: domainDevicesConsolesAddressToTerraform(struct!.address),
    alias: domainDevicesConsolesAliasToTerraform(struct!.alias),
    log: domainDevicesConsolesLogToTerraform(struct!.log),
    protocol: domainDevicesConsolesProtocolToTerraform(struct!.protocol),
    source: domainDevicesConsolesSourceToTerraform(struct!.source),
    target: domainDevicesConsolesTargetToTerraform(struct!.target),
    tty: cdktf.stringToTerraform(struct!.tty),
  }
}


export function domainDevicesConsolesToHclTerraform(struct?: DomainDevicesConsoles | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    acpi: {
      value: domainDevicesConsolesAcpiToHclTerraform(struct!.acpi),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesConsolesAcpi",
    },
    address: {
      value: domainDevicesConsolesAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesConsolesAddress",
    },
    alias: {
      value: domainDevicesConsolesAliasToHclTerraform(struct!.alias),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesConsolesAlias",
    },
    log: {
      value: domainDevicesConsolesLogToHclTerraform(struct!.log),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesConsolesLog",
    },
    protocol: {
      value: domainDevicesConsolesProtocolToHclTerraform(struct!.protocol),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesConsolesProtocol",
    },
    source: {
      value: domainDevicesConsolesSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesConsolesSource",
    },
    target: {
      value: domainDevicesConsolesTargetToHclTerraform(struct!.target),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesConsolesTarget",
    },
    tty: {
      value: cdktf.stringToHclTerraform(struct!.tty),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesConsolesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesConsoles | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._acpi?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.acpi = this._acpi?.internalValue;
    }
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._alias?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.alias = this._alias?.internalValue;
    }
    if (this._log?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.log = this._log?.internalValue;
    }
    if (this._protocol?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol?.internalValue;
    }
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    if (this._target?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.target = this._target?.internalValue;
    }
    if (this._tty !== undefined) {
      hasAnyValues = true;
      internalValueResult.tty = this._tty;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesConsoles | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._acpi.internalValue = undefined;
      this._address.internalValue = undefined;
      this._alias.internalValue = undefined;
      this._log.internalValue = undefined;
      this._protocol.internalValue = undefined;
      this._source.internalValue = undefined;
      this._target.internalValue = undefined;
      this._tty = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._acpi.internalValue = value.acpi;
      this._address.internalValue = value.address;
      this._alias.internalValue = value.alias;
      this._log.internalValue = value.log;
      this._protocol.internalValue = value.protocol;
      this._source.internalValue = value.source;
      this._target.internalValue = value.target;
      this._tty = value.tty;
    }
  }

  // acpi - computed: false, optional: true, required: false
  private _acpi = new DomainDevicesConsolesAcpiOutputReference(this, "acpi");
  public get acpi() {
    return this._acpi;
  }
  public putAcpi(value: DomainDevicesConsolesAcpi) {
    this._acpi.internalValue = value;
  }
  public resetAcpi() {
    this._acpi.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get acpiInput() {
    return this._acpi.internalValue;
  }

  // address - computed: false, optional: true, required: false
  private _address = new DomainDevicesConsolesAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DomainDevicesConsolesAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // alias - computed: false, optional: true, required: false
  private _alias = new DomainDevicesConsolesAliasOutputReference(this, "alias");
  public get alias() {
    return this._alias;
  }
  public putAlias(value: DomainDevicesConsolesAlias) {
    this._alias.internalValue = value;
  }
  public resetAlias() {
    this._alias.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aliasInput() {
    return this._alias.internalValue;
  }

  // log - computed: false, optional: true, required: false
  private _log = new DomainDevicesConsolesLogOutputReference(this, "log");
  public get log() {
    return this._log;
  }
  public putLog(value: DomainDevicesConsolesLog) {
    this._log.internalValue = value;
  }
  public resetLog() {
    this._log.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logInput() {
    return this._log.internalValue;
  }

  // protocol - computed: false, optional: true, required: false
  private _protocol = new DomainDevicesConsolesProtocolOutputReference(this, "protocol");
  public get protocol() {
    return this._protocol;
  }
  public putProtocol(value: DomainDevicesConsolesProtocol) {
    this._protocol.internalValue = value;
  }
  public resetProtocol() {
    this._protocol.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol.internalValue;
  }

  // source - computed: false, optional: true, required: false
  private _source = new DomainDevicesConsolesSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: DomainDevicesConsolesSource) {
    this._source.internalValue = value;
  }
  public resetSource() {
    this._source.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }

  // target - computed: false, optional: true, required: false
  private _target = new DomainDevicesConsolesTargetOutputReference(this, "target");
  public get target() {
    return this._target;
  }
  public putTarget(value: DomainDevicesConsolesTarget) {
    this._target.internalValue = value;
  }
  public resetTarget() {
    this._target.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetInput() {
    return this._target.internalValue;
  }

  // tty - computed: false, optional: true, required: false
  private _tty?: string; 
  public get tty() {
    return this.getStringAttribute('tty');
  }
  public set tty(value: string) {
    this._tty = value;
  }
  public resetTty() {
    this._tty = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ttyInput() {
    return this._tty;
  }
}

export class DomainDevicesConsolesList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesConsoles[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesConsolesOutputReference {
    return new DomainDevicesConsolesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesControllersAcpi {
  /**
  * Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#pstore>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#index Domain#index}
  */
  readonly index?: number;
}

export function domainDevicesControllersAcpiToTerraform(struct?: DomainDevicesControllersAcpi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    index: cdktf.numberToTerraform(struct!.index),
  }
}


export function domainDevicesControllersAcpiToHclTerraform(struct?: DomainDevicesControllersAcpi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    index: {
      value: cdktf.numberToHclTerraform(struct!.index),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesControllersAcpiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesControllersAcpi | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._index !== undefined) {
      hasAnyValues = true;
      internalValueResult.index = this._index;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesControllersAcpi | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._index = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._index = value.index;
    }
  }

  // index - computed: false, optional: true, required: false
  private _index?: number; 
  public get index() {
    return this.getNumberAttribute('index');
  }
  public set index(value: number) {
    this._index = value;
  }
  public resetIndex() {
    this._index = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get indexInput() {
    return this._index;
  }
}
export interface DomainDevicesControllersAddress {
}

export function domainDevicesControllersAddressToTerraform(struct?: DomainDevicesControllersAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function domainDevicesControllersAddressToHclTerraform(struct?: DomainDevicesControllersAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DomainDevicesControllersAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesControllersAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesControllersAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DomainDevicesControllersAlias {
  /**
  * Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
}

export function domainDevicesControllersAliasToTerraform(struct?: DomainDevicesControllersAlias | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function domainDevicesControllersAliasToHclTerraform(struct?: DomainDevicesControllersAlias | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesControllersAliasOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesControllersAlias | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesControllersAlias | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DomainDevicesControllersDriverIoThreadsIoThreadQueues {
}

export function domainDevicesControllersDriverIoThreadsIoThreadQueuesToTerraform(struct?: DomainDevicesControllersDriverIoThreadsIoThreadQueues | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function domainDevicesControllersDriverIoThreadsIoThreadQueuesToHclTerraform(struct?: DomainDevicesControllersDriverIoThreadsIoThreadQueues | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DomainDevicesControllersDriverIoThreadsIoThreadQueuesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesControllersDriverIoThreadsIoThreadQueues | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesControllersDriverIoThreadsIoThreadQueues | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }

  // id - computed: true, optional: false, required: false
  public get id() {
    return this.getNumberAttribute('id');
  }
}

export class DomainDevicesControllersDriverIoThreadsIoThreadQueuesList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesControllersDriverIoThreadsIoThreadQueues[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesControllersDriverIoThreadsIoThreadQueuesOutputReference {
    return new DomainDevicesControllersDriverIoThreadsIoThreadQueuesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesControllersDriverIoThreadsIoThread {
  /**
  * Defines one or more queues handled by this IOThread for the controller, allowing fine-grained mapping of queue ids to threads.
  * 
  * See: <https://libvirt.org/formatdomain.html#controllers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#queues Domain#queues}
  */
  readonly queues?: DomainDevicesControllersDriverIoThreadsIoThreadQueues[] | cdktf.IResolvable;
}

export function domainDevicesControllersDriverIoThreadsIoThreadToTerraform(struct?: DomainDevicesControllersDriverIoThreadsIoThread | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    queues: cdktf.listMapper(domainDevicesControllersDriverIoThreadsIoThreadQueuesToTerraform, false)(struct!.queues),
  }
}


export function domainDevicesControllersDriverIoThreadsIoThreadToHclTerraform(struct?: DomainDevicesControllersDriverIoThreadsIoThread | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    queues: {
      value: cdktf.listMapperHcl(domainDevicesControllersDriverIoThreadsIoThreadQueuesToHclTerraform, false)(struct!.queues),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesControllersDriverIoThreadsIoThreadQueuesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesControllersDriverIoThreadsIoThreadOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesControllersDriverIoThreadsIoThread | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._queues?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.queues = this._queues?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesControllersDriverIoThreadsIoThread | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._queues.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._queues.internalValue = value.queues;
    }
  }

  // id - computed: true, optional: false, required: false
  public get id() {
    return this.getNumberAttribute('id');
  }

  // queues - computed: false, optional: true, required: false
  private _queues = new DomainDevicesControllersDriverIoThreadsIoThreadQueuesList(this, "queues", false);
  public get queues() {
    return this._queues;
  }
  public putQueues(value: DomainDevicesControllersDriverIoThreadsIoThreadQueues[] | cdktf.IResolvable) {
    this._queues.internalValue = value;
  }
  public resetQueues() {
    this._queues.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queuesInput() {
    return this._queues.internalValue;
  }
}

export class DomainDevicesControllersDriverIoThreadsIoThreadList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesControllersDriverIoThreadsIoThread[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesControllersDriverIoThreadsIoThreadOutputReference {
    return new DomainDevicesControllersDriverIoThreadsIoThreadOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesControllersDriverIoThreads {
  /**
  * Describes a single IOThread used by the controller, optionally including an explicit id and associated queues.
  * 
  * See: <https://libvirt.org/formatdomain.html#controllers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#io_thread Domain#io_thread}
  */
  readonly ioThread?: DomainDevicesControllersDriverIoThreadsIoThread[] | cdktf.IResolvable;
}

export function domainDevicesControllersDriverIoThreadsToTerraform(struct?: DomainDevicesControllersDriverIoThreads | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    io_thread: cdktf.listMapper(domainDevicesControllersDriverIoThreadsIoThreadToTerraform, false)(struct!.ioThread),
  }
}


export function domainDevicesControllersDriverIoThreadsToHclTerraform(struct?: DomainDevicesControllersDriverIoThreads | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    io_thread: {
      value: cdktf.listMapperHcl(domainDevicesControllersDriverIoThreadsIoThreadToHclTerraform, false)(struct!.ioThread),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesControllersDriverIoThreadsIoThreadList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesControllersDriverIoThreadsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesControllersDriverIoThreads | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ioThread?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ioThread = this._ioThread?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesControllersDriverIoThreads | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ioThread.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ioThread.internalValue = value.ioThread;
    }
  }

  // io_thread - computed: false, optional: true, required: false
  private _ioThread = new DomainDevicesControllersDriverIoThreadsIoThreadList(this, "io_thread", false);
  public get ioThread() {
    return this._ioThread;
  }
  public putIoThread(value: DomainDevicesControllersDriverIoThreadsIoThread[] | cdktf.IResolvable) {
    this._ioThread.internalValue = value;
  }
  public resetIoThread() {
    this._ioThread.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ioThreadInput() {
    return this._ioThread.internalValue;
  }
}
export interface DomainDevicesControllersDriver {
  /**
  * Controls whether Address Translation Service (ATS) support is enabled for a virtio controller when used with an emulated IOMMU; this is a yes/no style boolean (e.g. "on"/"off" or "yes"/"no") depending on hypervisor support.
  * 
  * See: <https://libvirt.org/formatdomain.html#virtio-related-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#ats Domain#ats}
  */
  readonly ats?: string;
  /**
  * Sets the maximum number of outstanding commands per LUN for SCSI/virtio-scsi controllers; value is a positive integer defining the per-LUN queue depth (for example 128, 256).
  * 
  * See: <https://libvirt.org/formatdomain.html#controllers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#cmd_per_lun Domain#cmd_per_lun}
  */
  readonly cmdPerLun?: number;
  /**
  * Controls whether ioeventfd is used for the controller to reduce exits between guest and host on I/O operations; value is a yes/no style boolean (for example "on"/"off").
  * 
  * See: <https://libvirt.org/formatdomain.html#controllers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#io_event_fd Domain#io_event_fd}
  */
  readonly ioEventFd?: string;
  /**
  * Assigns the controller to use a specific IOThread by referencing an existing iothread id; value is a positive integer matching an IOThread defined in the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#controllers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#io_thread Domain#io_thread}
  */
  readonly ioThread?: number;
  /**
  * Defines per-IOThread configuration for the controller, allowing multiple IOThreads each with their own queue assignments; contents are user-provided and must match defined IOThread ids.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#io_threads Domain#io_threads}
  */
  readonly ioThreads?: DomainDevicesControllersDriverIoThreads;
  /**
  * Enables or disables use of an emulated IOMMU by the controller’s virtio devices; value is a yes/no style boolean (for example "on"/"off") and is only meaningful when an IOMMU device is present.
  * 
  * See: <https://libvirt.org/formatdomain.html#virtio-related-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#iommu Domain#iommu}
  */
  readonly iommu?: string;
  /**
  * Sets the maximum number of 512-byte sectors that can be transferred in a single I/O request through this controller; value is a positive integer tuned for performance and host constraints.
  * 
  * See: <https://libvirt.org/formatdomain.html#controllers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#max_sectors Domain#max_sectors}
  */
  readonly maxSectors?: number;
  /**
  * Controls whether the virtio packed ring layout is used for queues on this controller; value is a yes/no style boolean (for example "on"/"off") and requires guest/host support.
  * 
  * See: <https://libvirt.org/formatdomain.html#virtio-related-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#packed Domain#packed}
  */
  readonly packed?: string;
  /**
  * Controls whether each virtqueue uses its own memory page (page-per-vq) on this controller; value is a yes/no style boolean and is primarily a tuning/compatibility option.
  * 
  * See: <https://libvirt.org/formatdomain.html#virtio-related-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#page_per_vq Domain#page_per_vq}
  */
  readonly pagePerVq?: string;
  /**
  * Specifies the total number of hardware queues for the controller (for example for virtio-scsi or virtio-blk controllers); value is a positive integer, often matching the number of vCPUs or IOThreads.
  * 
  * See: <https://libvirt.org/formatdomain.html#controllers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#queues Domain#queues}
  */
  readonly queues?: number;
}

export function domainDevicesControllersDriverToTerraform(struct?: DomainDevicesControllersDriver | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ats: cdktf.stringToTerraform(struct!.ats),
    cmd_per_lun: cdktf.numberToTerraform(struct!.cmdPerLun),
    io_event_fd: cdktf.stringToTerraform(struct!.ioEventFd),
    io_thread: cdktf.numberToTerraform(struct!.ioThread),
    io_threads: domainDevicesControllersDriverIoThreadsToTerraform(struct!.ioThreads),
    iommu: cdktf.stringToTerraform(struct!.iommu),
    max_sectors: cdktf.numberToTerraform(struct!.maxSectors),
    packed: cdktf.stringToTerraform(struct!.packed),
    page_per_vq: cdktf.stringToTerraform(struct!.pagePerVq),
    queues: cdktf.numberToTerraform(struct!.queues),
  }
}


export function domainDevicesControllersDriverToHclTerraform(struct?: DomainDevicesControllersDriver | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ats: {
      value: cdktf.stringToHclTerraform(struct!.ats),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cmd_per_lun: {
      value: cdktf.numberToHclTerraform(struct!.cmdPerLun),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    io_event_fd: {
      value: cdktf.stringToHclTerraform(struct!.ioEventFd),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    io_thread: {
      value: cdktf.numberToHclTerraform(struct!.ioThread),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    io_threads: {
      value: domainDevicesControllersDriverIoThreadsToHclTerraform(struct!.ioThreads),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesControllersDriverIoThreads",
    },
    iommu: {
      value: cdktf.stringToHclTerraform(struct!.iommu),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_sectors: {
      value: cdktf.numberToHclTerraform(struct!.maxSectors),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    packed: {
      value: cdktf.stringToHclTerraform(struct!.packed),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    page_per_vq: {
      value: cdktf.stringToHclTerraform(struct!.pagePerVq),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    queues: {
      value: cdktf.numberToHclTerraform(struct!.queues),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesControllersDriverOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesControllersDriver | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ats !== undefined) {
      hasAnyValues = true;
      internalValueResult.ats = this._ats;
    }
    if (this._cmdPerLun !== undefined) {
      hasAnyValues = true;
      internalValueResult.cmdPerLun = this._cmdPerLun;
    }
    if (this._ioEventFd !== undefined) {
      hasAnyValues = true;
      internalValueResult.ioEventFd = this._ioEventFd;
    }
    if (this._ioThread !== undefined) {
      hasAnyValues = true;
      internalValueResult.ioThread = this._ioThread;
    }
    if (this._ioThreads?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ioThreads = this._ioThreads?.internalValue;
    }
    if (this._iommu !== undefined) {
      hasAnyValues = true;
      internalValueResult.iommu = this._iommu;
    }
    if (this._maxSectors !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSectors = this._maxSectors;
    }
    if (this._packed !== undefined) {
      hasAnyValues = true;
      internalValueResult.packed = this._packed;
    }
    if (this._pagePerVq !== undefined) {
      hasAnyValues = true;
      internalValueResult.pagePerVq = this._pagePerVq;
    }
    if (this._queues !== undefined) {
      hasAnyValues = true;
      internalValueResult.queues = this._queues;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesControllersDriver | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ats = undefined;
      this._cmdPerLun = undefined;
      this._ioEventFd = undefined;
      this._ioThread = undefined;
      this._ioThreads.internalValue = undefined;
      this._iommu = undefined;
      this._maxSectors = undefined;
      this._packed = undefined;
      this._pagePerVq = undefined;
      this._queues = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ats = value.ats;
      this._cmdPerLun = value.cmdPerLun;
      this._ioEventFd = value.ioEventFd;
      this._ioThread = value.ioThread;
      this._ioThreads.internalValue = value.ioThreads;
      this._iommu = value.iommu;
      this._maxSectors = value.maxSectors;
      this._packed = value.packed;
      this._pagePerVq = value.pagePerVq;
      this._queues = value.queues;
    }
  }

  // ats - computed: false, optional: true, required: false
  private _ats?: string; 
  public get ats() {
    return this.getStringAttribute('ats');
  }
  public set ats(value: string) {
    this._ats = value;
  }
  public resetAts() {
    this._ats = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get atsInput() {
    return this._ats;
  }

  // cmd_per_lun - computed: false, optional: true, required: false
  private _cmdPerLun?: number; 
  public get cmdPerLun() {
    return this.getNumberAttribute('cmd_per_lun');
  }
  public set cmdPerLun(value: number) {
    this._cmdPerLun = value;
  }
  public resetCmdPerLun() {
    this._cmdPerLun = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cmdPerLunInput() {
    return this._cmdPerLun;
  }

  // io_event_fd - computed: false, optional: true, required: false
  private _ioEventFd?: string; 
  public get ioEventFd() {
    return this.getStringAttribute('io_event_fd');
  }
  public set ioEventFd(value: string) {
    this._ioEventFd = value;
  }
  public resetIoEventFd() {
    this._ioEventFd = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ioEventFdInput() {
    return this._ioEventFd;
  }

  // io_thread - computed: false, optional: true, required: false
  private _ioThread?: number; 
  public get ioThread() {
    return this.getNumberAttribute('io_thread');
  }
  public set ioThread(value: number) {
    this._ioThread = value;
  }
  public resetIoThread() {
    this._ioThread = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ioThreadInput() {
    return this._ioThread;
  }

  // io_threads - computed: false, optional: true, required: false
  private _ioThreads = new DomainDevicesControllersDriverIoThreadsOutputReference(this, "io_threads");
  public get ioThreads() {
    return this._ioThreads;
  }
  public putIoThreads(value: DomainDevicesControllersDriverIoThreads) {
    this._ioThreads.internalValue = value;
  }
  public resetIoThreads() {
    this._ioThreads.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ioThreadsInput() {
    return this._ioThreads.internalValue;
  }

  // iommu - computed: false, optional: true, required: false
  private _iommu?: string; 
  public get iommu() {
    return this.getStringAttribute('iommu');
  }
  public set iommu(value: string) {
    this._iommu = value;
  }
  public resetIommu() {
    this._iommu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get iommuInput() {
    return this._iommu;
  }

  // max_sectors - computed: false, optional: true, required: false
  private _maxSectors?: number; 
  public get maxSectors() {
    return this.getNumberAttribute('max_sectors');
  }
  public set maxSectors(value: number) {
    this._maxSectors = value;
  }
  public resetMaxSectors() {
    this._maxSectors = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSectorsInput() {
    return this._maxSectors;
  }

  // packed - computed: false, optional: true, required: false
  private _packed?: string; 
  public get packed() {
    return this.getStringAttribute('packed');
  }
  public set packed(value: string) {
    this._packed = value;
  }
  public resetPacked() {
    this._packed = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get packedInput() {
    return this._packed;
  }

  // page_per_vq - computed: false, optional: true, required: false
  private _pagePerVq?: string; 
  public get pagePerVq() {
    return this.getStringAttribute('page_per_vq');
  }
  public set pagePerVq(value: string) {
    this._pagePerVq = value;
  }
  public resetPagePerVq() {
    this._pagePerVq = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pagePerVqInput() {
    return this._pagePerVq;
  }

  // queues - computed: false, optional: true, required: false
  private _queues?: number; 
  public get queues() {
    return this.getNumberAttribute('queues');
  }
  public set queues(value: number) {
    this._queues = value;
  }
  public resetQueues() {
    this._queues = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queuesInput() {
    return this._queues;
  }
}
export interface DomainDevicesControllersNvme {
  /**
  * Sets the NVMe controller serial identifier exposed to the guest; the value is user-provided and typically an ASCII string (for example, "nvme0-ctrl1").
  * 
  * See: <https://libvirt.org/formatdomain.html#controllers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#serial Domain#serial}
  */
  readonly serial?: string;
}

export function domainDevicesControllersNvmeToTerraform(struct?: DomainDevicesControllersNvme | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    serial: cdktf.stringToTerraform(struct!.serial),
  }
}


export function domainDevicesControllersNvmeToHclTerraform(struct?: DomainDevicesControllersNvme | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    serial: {
      value: cdktf.stringToHclTerraform(struct!.serial),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesControllersNvmeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesControllersNvme | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._serial !== undefined) {
      hasAnyValues = true;
      internalValueResult.serial = this._serial;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesControllersNvme | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._serial = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._serial = value.serial;
    }
  }

  // serial - computed: false, optional: true, required: false
  private _serial?: string; 
  public get serial() {
    return this.getStringAttribute('serial');
  }
  public set serial(value: string) {
    this._serial = value;
  }
  public resetSerial() {
    this._serial = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serialInput() {
    return this._serial;
  }
}
export interface DomainDevicesControllersPciModel {
  /**
  * Sets the model name of the PCI controller; must be one of the controller models supported by the chosen machine type (for example, "pci-root", "pcie-root-port", "pci-bridge").
  * 
  * See: <https://libvirt.org/formatdomain.html#controllers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
}

export function domainDevicesControllersPciModelToTerraform(struct?: DomainDevicesControllersPciModel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function domainDevicesControllersPciModelToHclTerraform(struct?: DomainDevicesControllersPciModel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesControllersPciModelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesControllersPciModel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesControllersPciModel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DomainDevicesControllersPciTarget {
}

export function domainDevicesControllersPciTargetToTerraform(struct?: DomainDevicesControllersPciTarget | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function domainDevicesControllersPciTargetToHclTerraform(struct?: DomainDevicesControllersPciTarget | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DomainDevicesControllersPciTargetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesControllersPciTarget | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesControllersPciTarget | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DomainDevicesControllersPci {
  /**
  * Sets the size of the 64‑bit PCI memory hole available to guest PCI devices; value is user-provided and interpreted together with hole64_unit.
  * 
  * See: <https://libvirt.org/formatdomain.html#controllers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#hole64 Domain#hole64}
  */
  readonly hole64?: number;
  /**
  * Specifies the unit for the pci.hole64 size (for example, "KiB", "MiB", "GiB"), paired with the hole64 value to define the 64‑bit PCI memory hole size.
  * 
  * See: <https://libvirt.org/formatdomain.html#controllers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#hole64_unit Domain#hole64_unit}
  */
  readonly hole64Unit?: string;
  /**
  * Configures the PCI/PCIe controller model, determining the controller implementation used by the guest (for example, "pci-root" or "pcie-root-port").
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: DomainDevicesControllersPciModel;
  /**
  * Configures additional PCI controller target parameters such as bus or port indices that control how the controller is placed in the guest topology; values are user-provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#target Domain#target}
  */
  readonly target?: DomainDevicesControllersPciTarget;
}

export function domainDevicesControllersPciToTerraform(struct?: DomainDevicesControllersPci | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hole64: cdktf.numberToTerraform(struct!.hole64),
    hole64_unit: cdktf.stringToTerraform(struct!.hole64Unit),
    model: domainDevicesControllersPciModelToTerraform(struct!.model),
    target: domainDevicesControllersPciTargetToTerraform(struct!.target),
  }
}


export function domainDevicesControllersPciToHclTerraform(struct?: DomainDevicesControllersPci | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hole64: {
      value: cdktf.numberToHclTerraform(struct!.hole64),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    hole64_unit: {
      value: cdktf.stringToHclTerraform(struct!.hole64Unit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: domainDevicesControllersPciModelToHclTerraform(struct!.model),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesControllersPciModel",
    },
    target: {
      value: domainDevicesControllersPciTargetToHclTerraform(struct!.target),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesControllersPciTarget",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesControllersPciOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesControllersPci | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hole64 !== undefined) {
      hasAnyValues = true;
      internalValueResult.hole64 = this._hole64;
    }
    if (this._hole64Unit !== undefined) {
      hasAnyValues = true;
      internalValueResult.hole64Unit = this._hole64Unit;
    }
    if (this._model?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model?.internalValue;
    }
    if (this._target?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.target = this._target?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesControllersPci | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hole64 = undefined;
      this._hole64Unit = undefined;
      this._model.internalValue = undefined;
      this._target.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hole64 = value.hole64;
      this._hole64Unit = value.hole64Unit;
      this._model.internalValue = value.model;
      this._target.internalValue = value.target;
    }
  }

  // hole64 - computed: false, optional: true, required: false
  private _hole64?: number; 
  public get hole64() {
    return this.getNumberAttribute('hole64');
  }
  public set hole64(value: number) {
    this._hole64 = value;
  }
  public resetHole64() {
    this._hole64 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hole64Input() {
    return this._hole64;
  }

  // hole64_unit - computed: false, optional: true, required: false
  private _hole64Unit?: string; 
  public get hole64Unit() {
    return this.getStringAttribute('hole64_unit');
  }
  public set hole64Unit(value: string) {
    this._hole64Unit = value;
  }
  public resetHole64Unit() {
    this._hole64Unit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hole64UnitInput() {
    return this._hole64Unit;
  }

  // model - computed: false, optional: true, required: false
  private _model = new DomainDevicesControllersPciModelOutputReference(this, "model");
  public get model() {
    return this._model;
  }
  public putModel(value: DomainDevicesControllersPciModel) {
    this._model.internalValue = value;
  }
  public resetModel() {
    this._model.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model.internalValue;
  }

  // target - computed: false, optional: true, required: false
  private _target = new DomainDevicesControllersPciTargetOutputReference(this, "target");
  public get target() {
    return this._target;
  }
  public putTarget(value: DomainDevicesControllersPciTarget) {
    this._target.internalValue = value;
  }
  public resetTarget() {
    this._target.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetInput() {
    return this._target.internalValue;
  }
}
export interface DomainDevicesControllersUsbMaster {
  /**
  * Sets the starting port number on the master USB controller that this controller manages; value is a required non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#controllers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#start_port Domain#start_port}
  */
  readonly startPort: number;
}

export function domainDevicesControllersUsbMasterToTerraform(struct?: DomainDevicesControllersUsbMaster | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    start_port: cdktf.numberToTerraform(struct!.startPort),
  }
}


export function domainDevicesControllersUsbMasterToHclTerraform(struct?: DomainDevicesControllersUsbMaster | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    start_port: {
      value: cdktf.numberToHclTerraform(struct!.startPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesControllersUsbMasterOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesControllersUsbMaster | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._startPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.startPort = this._startPort;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesControllersUsbMaster | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._startPort = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._startPort = value.startPort;
    }
  }

  // start_port - computed: false, optional: false, required: true
  private _startPort?: number; 
  public get startPort() {
    return this.getNumberAttribute('start_port');
  }
  public set startPort(value: number) {
    this._startPort = value;
  }
  // Temporarily expose input value. Use with caution.
  public get startPortInput() {
    return this._startPort;
  }
}
export interface DomainDevicesControllersUsb {
  /**
  * Configures the master USB controller relationship, defining how this USB controller is chained or grouped with others.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#master Domain#master}
  */
  readonly master?: DomainDevicesControllersUsbMaster;
  /**
  * Sets the total number of USB ports exposed by this controller; value is a user-provided positive integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#controllers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#port Domain#port}
  */
  readonly port?: number;
}

export function domainDevicesControllersUsbToTerraform(struct?: DomainDevicesControllersUsb | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    master: domainDevicesControllersUsbMasterToTerraform(struct!.master),
    port: cdktf.numberToTerraform(struct!.port),
  }
}


export function domainDevicesControllersUsbToHclTerraform(struct?: DomainDevicesControllersUsb | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    master: {
      value: domainDevicesControllersUsbMasterToHclTerraform(struct!.master),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesControllersUsbMaster",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesControllersUsbOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesControllersUsb | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._master?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.master = this._master?.internalValue;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesControllersUsb | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._master.internalValue = undefined;
      this._port = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._master.internalValue = value.master;
      this._port = value.port;
    }
  }

  // master - computed: false, optional: true, required: false
  private _master = new DomainDevicesControllersUsbMasterOutputReference(this, "master");
  public get master() {
    return this._master;
  }
  public putMaster(value: DomainDevicesControllersUsbMaster) {
    this._master.internalValue = value;
  }
  public resetMaster() {
    this._master.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get masterInput() {
    return this._master.internalValue;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }
}
export interface DomainDevicesControllersVirtIoSerial {
  /**
  * Sets the maximum number of virtio-serial ports that this controller can provide; value is a user-provided positive integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#controllers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#ports Domain#ports}
  */
  readonly ports?: number;
  /**
  * Sets the number of MSI/MSI‑X vectors used by the virtio-serial controller for interrupts; value is a user-provided positive integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#controllers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vectors Domain#vectors}
  */
  readonly vectors?: number;
}

export function domainDevicesControllersVirtIoSerialToTerraform(struct?: DomainDevicesControllersVirtIoSerial | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ports: cdktf.numberToTerraform(struct!.ports),
    vectors: cdktf.numberToTerraform(struct!.vectors),
  }
}


export function domainDevicesControllersVirtIoSerialToHclTerraform(struct?: DomainDevicesControllersVirtIoSerial | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ports: {
      value: cdktf.numberToHclTerraform(struct!.ports),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    vectors: {
      value: cdktf.numberToHclTerraform(struct!.vectors),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesControllersVirtIoSerialOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesControllersVirtIoSerial | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ports !== undefined) {
      hasAnyValues = true;
      internalValueResult.ports = this._ports;
    }
    if (this._vectors !== undefined) {
      hasAnyValues = true;
      internalValueResult.vectors = this._vectors;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesControllersVirtIoSerial | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ports = undefined;
      this._vectors = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ports = value.ports;
      this._vectors = value.vectors;
    }
  }

  // ports - computed: false, optional: true, required: false
  private _ports?: number; 
  public get ports() {
    return this.getNumberAttribute('ports');
  }
  public set ports(value: number) {
    this._ports = value;
  }
  public resetPorts() {
    this._ports = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portsInput() {
    return this._ports;
  }

  // vectors - computed: false, optional: true, required: false
  private _vectors?: number; 
  public get vectors() {
    return this.getNumberAttribute('vectors');
  }
  public set vectors(value: number) {
    this._vectors = value;
  }
  public resetVectors() {
    this._vectors = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vectorsInput() {
    return this._vectors;
  }
}
export interface DomainDevicesControllersXenBus {
  /**
  * Sets the maximum number of Xen event channels available via this Xen bus controller; value is a user-provided positive integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#controllers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#max_event_channels Domain#max_event_channels}
  */
  readonly maxEventChannels?: number;
  /**
  * Sets the maximum number of grant frames for shared memory operations on this Xen bus controller; value is a user-provided positive integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#controllers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#max_grant_frames Domain#max_grant_frames}
  */
  readonly maxGrantFrames?: number;
}

export function domainDevicesControllersXenBusToTerraform(struct?: DomainDevicesControllersXenBus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_event_channels: cdktf.numberToTerraform(struct!.maxEventChannels),
    max_grant_frames: cdktf.numberToTerraform(struct!.maxGrantFrames),
  }
}


export function domainDevicesControllersXenBusToHclTerraform(struct?: DomainDevicesControllersXenBus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_event_channels: {
      value: cdktf.numberToHclTerraform(struct!.maxEventChannels),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_grant_frames: {
      value: cdktf.numberToHclTerraform(struct!.maxGrantFrames),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesControllersXenBusOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesControllersXenBus | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxEventChannels !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxEventChannels = this._maxEventChannels;
    }
    if (this._maxGrantFrames !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxGrantFrames = this._maxGrantFrames;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesControllersXenBus | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxEventChannels = undefined;
      this._maxGrantFrames = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxEventChannels = value.maxEventChannels;
      this._maxGrantFrames = value.maxGrantFrames;
    }
  }

  // max_event_channels - computed: false, optional: true, required: false
  private _maxEventChannels?: number; 
  public get maxEventChannels() {
    return this.getNumberAttribute('max_event_channels');
  }
  public set maxEventChannels(value: number) {
    this._maxEventChannels = value;
  }
  public resetMaxEventChannels() {
    this._maxEventChannels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxEventChannelsInput() {
    return this._maxEventChannels;
  }

  // max_grant_frames - computed: false, optional: true, required: false
  private _maxGrantFrames?: number; 
  public get maxGrantFrames() {
    return this.getNumberAttribute('max_grant_frames');
  }
  public set maxGrantFrames(value: number) {
    this._maxGrantFrames = value;
  }
  public resetMaxGrantFrames() {
    this._maxGrantFrames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxGrantFramesInput() {
    return this._maxGrantFrames;
  }
}
export interface DomainDevicesControllers {
  /**
  * Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#acpi Domain#acpi}
  */
  readonly acpi?: DomainDevicesControllersAcpi;
  /**
  * Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: DomainDevicesControllersAddress;
  /**
  * Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#alias Domain#alias}
  */
  readonly alias?: DomainDevicesControllersAlias;
  /**
  * Configures driver-specific options for the controller, such as virtio transport features and queue parameters; all child attributes are optional and user-defined within hypervisor constraints.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#driver Domain#driver}
  */
  readonly driver?: DomainDevicesControllersDriver;
  /**
  * Sets the controller index number used to distinguish multiple controllers of the same type; value is a non-negative integer and must be unique per controller type.
  * 
  * See: <https://libvirt.org/formatdomain.html#controllers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#index Domain#index}
  */
  readonly index?: number;
  /**
  * Selects the controller model (for example "virtio-scsi", "pci-root", "pcie-root-port", "ide", "usb") as supported by the hypervisor and guest; value is a user-provided model name that must be valid for the chosen controller type.
  * 
  * See: <https://libvirt.org/formatdomain.html#controllers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Configures an NVMe controller device for the guest, allowing you to add and customize an NVMe bus for NVMe disks.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#nvme Domain#nvme}
  */
  readonly nvme?: DomainDevicesControllersNvme;
  /**
  * Configures a PCI or PCIe controller, controlling how PCI buses are exposed to the guest for attaching PCI devices.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pci Domain#pci}
  */
  readonly pci?: DomainDevicesControllersPci;
  /**
  * Sets the controller type for this entry; must be one of the supported controller buses such as "pci", "usb", "virtio-serial", "scsi", "ide", "nvme", or "xenbus" depending on usage.
  * 
  * See: <https://libvirt.org/formatdomain.html#controllers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type: string;
  /**
  * Configures a USB controller for the guest, defining how USB ports and hubs are exposed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#usb Domain#usb}
  */
  readonly usb?: DomainDevicesControllersUsb;
  /**
  * Configures a virtio-serial controller, which provides multiple virtio-based serial or channel ports to the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#virt_io_serial Domain#virt_io_serial}
  */
  readonly virtIoSerial?: DomainDevicesControllersVirtIoSerial;
  /**
  * Configures a Xen bus controller, which provides bus resources for Xen paravirtualized devices.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#xen_bus Domain#xen_bus}
  */
  readonly xenBus?: DomainDevicesControllersXenBus;
}

export function domainDevicesControllersToTerraform(struct?: DomainDevicesControllers | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    acpi: domainDevicesControllersAcpiToTerraform(struct!.acpi),
    address: domainDevicesControllersAddressToTerraform(struct!.address),
    alias: domainDevicesControllersAliasToTerraform(struct!.alias),
    driver: domainDevicesControllersDriverToTerraform(struct!.driver),
    index: cdktf.numberToTerraform(struct!.index),
    model: cdktf.stringToTerraform(struct!.model),
    nvme: domainDevicesControllersNvmeToTerraform(struct!.nvme),
    pci: domainDevicesControllersPciToTerraform(struct!.pci),
    type: cdktf.stringToTerraform(struct!.type),
    usb: domainDevicesControllersUsbToTerraform(struct!.usb),
    virt_io_serial: domainDevicesControllersVirtIoSerialToTerraform(struct!.virtIoSerial),
    xen_bus: domainDevicesControllersXenBusToTerraform(struct!.xenBus),
  }
}


export function domainDevicesControllersToHclTerraform(struct?: DomainDevicesControllers | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    acpi: {
      value: domainDevicesControllersAcpiToHclTerraform(struct!.acpi),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesControllersAcpi",
    },
    address: {
      value: domainDevicesControllersAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesControllersAddress",
    },
    alias: {
      value: domainDevicesControllersAliasToHclTerraform(struct!.alias),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesControllersAlias",
    },
    driver: {
      value: domainDevicesControllersDriverToHclTerraform(struct!.driver),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesControllersDriver",
    },
    index: {
      value: cdktf.numberToHclTerraform(struct!.index),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    nvme: {
      value: domainDevicesControllersNvmeToHclTerraform(struct!.nvme),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesControllersNvme",
    },
    pci: {
      value: domainDevicesControllersPciToHclTerraform(struct!.pci),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesControllersPci",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    usb: {
      value: domainDevicesControllersUsbToHclTerraform(struct!.usb),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesControllersUsb",
    },
    virt_io_serial: {
      value: domainDevicesControllersVirtIoSerialToHclTerraform(struct!.virtIoSerial),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesControllersVirtIoSerial",
    },
    xen_bus: {
      value: domainDevicesControllersXenBusToHclTerraform(struct!.xenBus),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesControllersXenBus",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesControllersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesControllers | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._acpi?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.acpi = this._acpi?.internalValue;
    }
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._alias?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.alias = this._alias?.internalValue;
    }
    if (this._driver?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.driver = this._driver?.internalValue;
    }
    if (this._index !== undefined) {
      hasAnyValues = true;
      internalValueResult.index = this._index;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._nvme?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nvme = this._nvme?.internalValue;
    }
    if (this._pci?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pci = this._pci?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._usb?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.usb = this._usb?.internalValue;
    }
    if (this._virtIoSerial?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.virtIoSerial = this._virtIoSerial?.internalValue;
    }
    if (this._xenBus?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.xenBus = this._xenBus?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesControllers | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._acpi.internalValue = undefined;
      this._address.internalValue = undefined;
      this._alias.internalValue = undefined;
      this._driver.internalValue = undefined;
      this._index = undefined;
      this._model = undefined;
      this._nvme.internalValue = undefined;
      this._pci.internalValue = undefined;
      this._type = undefined;
      this._usb.internalValue = undefined;
      this._virtIoSerial.internalValue = undefined;
      this._xenBus.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._acpi.internalValue = value.acpi;
      this._address.internalValue = value.address;
      this._alias.internalValue = value.alias;
      this._driver.internalValue = value.driver;
      this._index = value.index;
      this._model = value.model;
      this._nvme.internalValue = value.nvme;
      this._pci.internalValue = value.pci;
      this._type = value.type;
      this._usb.internalValue = value.usb;
      this._virtIoSerial.internalValue = value.virtIoSerial;
      this._xenBus.internalValue = value.xenBus;
    }
  }

  // acpi - computed: false, optional: true, required: false
  private _acpi = new DomainDevicesControllersAcpiOutputReference(this, "acpi");
  public get acpi() {
    return this._acpi;
  }
  public putAcpi(value: DomainDevicesControllersAcpi) {
    this._acpi.internalValue = value;
  }
  public resetAcpi() {
    this._acpi.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get acpiInput() {
    return this._acpi.internalValue;
  }

  // address - computed: false, optional: true, required: false
  private _address = new DomainDevicesControllersAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DomainDevicesControllersAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // alias - computed: false, optional: true, required: false
  private _alias = new DomainDevicesControllersAliasOutputReference(this, "alias");
  public get alias() {
    return this._alias;
  }
  public putAlias(value: DomainDevicesControllersAlias) {
    this._alias.internalValue = value;
  }
  public resetAlias() {
    this._alias.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aliasInput() {
    return this._alias.internalValue;
  }

  // driver - computed: false, optional: true, required: false
  private _driver = new DomainDevicesControllersDriverOutputReference(this, "driver");
  public get driver() {
    return this._driver;
  }
  public putDriver(value: DomainDevicesControllersDriver) {
    this._driver.internalValue = value;
  }
  public resetDriver() {
    this._driver.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get driverInput() {
    return this._driver.internalValue;
  }

  // index - computed: false, optional: true, required: false
  private _index?: number; 
  public get index() {
    return this.getNumberAttribute('index');
  }
  public set index(value: number) {
    this._index = value;
  }
  public resetIndex() {
    this._index = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get indexInput() {
    return this._index;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // nvme - computed: false, optional: true, required: false
  private _nvme = new DomainDevicesControllersNvmeOutputReference(this, "nvme");
  public get nvme() {
    return this._nvme;
  }
  public putNvme(value: DomainDevicesControllersNvme) {
    this._nvme.internalValue = value;
  }
  public resetNvme() {
    this._nvme.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nvmeInput() {
    return this._nvme.internalValue;
  }

  // pci - computed: false, optional: true, required: false
  private _pci = new DomainDevicesControllersPciOutputReference(this, "pci");
  public get pci() {
    return this._pci;
  }
  public putPci(value: DomainDevicesControllersPci) {
    this._pci.internalValue = value;
  }
  public resetPci() {
    this._pci.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pciInput() {
    return this._pci.internalValue;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // usb - computed: false, optional: true, required: false
  private _usb = new DomainDevicesControllersUsbOutputReference(this, "usb");
  public get usb() {
    return this._usb;
  }
  public putUsb(value: DomainDevicesControllersUsb) {
    this._usb.internalValue = value;
  }
  public resetUsb() {
    this._usb.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usbInput() {
    return this._usb.internalValue;
  }

  // virt_io_serial - computed: false, optional: true, required: false
  private _virtIoSerial = new DomainDevicesControllersVirtIoSerialOutputReference(this, "virt_io_serial");
  public get virtIoSerial() {
    return this._virtIoSerial;
  }
  public putVirtIoSerial(value: DomainDevicesControllersVirtIoSerial) {
    this._virtIoSerial.internalValue = value;
  }
  public resetVirtIoSerial() {
    this._virtIoSerial.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get virtIoSerialInput() {
    return this._virtIoSerial.internalValue;
  }

  // xen_bus - computed: false, optional: true, required: false
  private _xenBus = new DomainDevicesControllersXenBusOutputReference(this, "xen_bus");
  public get xenBus() {
    return this._xenBus;
  }
  public putXenBus(value: DomainDevicesControllersXenBus) {
    this._xenBus.internalValue = value;
  }
  public resetXenBus() {
    this._xenBus.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get xenBusInput() {
    return this._xenBus.internalValue;
  }
}

export class DomainDevicesControllersList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesControllers[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesControllersOutputReference {
    return new DomainDevicesControllersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesCryptoAddress {
}

export function domainDevicesCryptoAddressToTerraform(struct?: DomainDevicesCryptoAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function domainDevicesCryptoAddressToHclTerraform(struct?: DomainDevicesCryptoAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DomainDevicesCryptoAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesCryptoAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesCryptoAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DomainDevicesCryptoAlias {
  /**
  * Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
}

export function domainDevicesCryptoAliasToTerraform(struct?: DomainDevicesCryptoAlias | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function domainDevicesCryptoAliasToHclTerraform(struct?: DomainDevicesCryptoAlias | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesCryptoAliasOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesCryptoAlias | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesCryptoAlias | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DomainDevicesCryptoBackend {
  /**
  * Enables the built-in backend for the crypto device when set; this is a presence-only flag, so omitting or setting it to false leaves the element out.
  * 
  * See: <https://libvirt.org/formatdomain.html#crypto>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#built_in Domain#built_in}
  */
  readonly builtIn?: boolean | cdktf.IResolvable;
  /**
  * Enables the LKCF-based backend for the crypto device when set; this is a presence-only flag, so omitting or setting it to false leaves the element out.
  * 
  * See: <https://libvirt.org/formatdomain.html#crypto>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#lkcf Domain#lkcf}
  */
  readonly lkcf?: boolean | cdktf.IResolvable;
  /**
  * Sets the number of queues used by the crypto backend; the value is a user-provided non-negative integer tuned for performance.
  * 
  * See: <https://libvirt.org/formatdomain.html#crypto>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#queues Domain#queues}
  */
  readonly queues?: number;
}

export function domainDevicesCryptoBackendToTerraform(struct?: DomainDevicesCryptoBackend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    built_in: cdktf.booleanToTerraform(struct!.builtIn),
    lkcf: cdktf.booleanToTerraform(struct!.lkcf),
    queues: cdktf.numberToTerraform(struct!.queues),
  }
}


export function domainDevicesCryptoBackendToHclTerraform(struct?: DomainDevicesCryptoBackend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    built_in: {
      value: cdktf.booleanToHclTerraform(struct!.builtIn),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    lkcf: {
      value: cdktf.booleanToHclTerraform(struct!.lkcf),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    queues: {
      value: cdktf.numberToHclTerraform(struct!.queues),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesCryptoBackendOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesCryptoBackend | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._builtIn !== undefined) {
      hasAnyValues = true;
      internalValueResult.builtIn = this._builtIn;
    }
    if (this._lkcf !== undefined) {
      hasAnyValues = true;
      internalValueResult.lkcf = this._lkcf;
    }
    if (this._queues !== undefined) {
      hasAnyValues = true;
      internalValueResult.queues = this._queues;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesCryptoBackend | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._builtIn = undefined;
      this._lkcf = undefined;
      this._queues = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._builtIn = value.builtIn;
      this._lkcf = value.lkcf;
      this._queues = value.queues;
    }
  }

  // built_in - computed: false, optional: true, required: false
  private _builtIn?: boolean | cdktf.IResolvable; 
  public get builtIn() {
    return this.getBooleanAttribute('built_in');
  }
  public set builtIn(value: boolean | cdktf.IResolvable) {
    this._builtIn = value;
  }
  public resetBuiltIn() {
    this._builtIn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get builtInInput() {
    return this._builtIn;
  }

  // lkcf - computed: false, optional: true, required: false
  private _lkcf?: boolean | cdktf.IResolvable; 
  public get lkcf() {
    return this.getBooleanAttribute('lkcf');
  }
  public set lkcf(value: boolean | cdktf.IResolvable) {
    this._lkcf = value;
  }
  public resetLkcf() {
    this._lkcf = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lkcfInput() {
    return this._lkcf;
  }

  // queues - computed: false, optional: true, required: false
  private _queues?: number; 
  public get queues() {
    return this.getNumberAttribute('queues');
  }
  public set queues(value: number) {
    this._queues = value;
  }
  public resetQueues() {
    this._queues = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queuesInput() {
    return this._queues;
  }
}
export interface DomainDevicesCrypto {
  /**
  * Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: DomainDevicesCryptoAddress;
  /**
  * Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#alias Domain#alias}
  */
  readonly alias?: DomainDevicesCryptoAlias;
  /**
  * Configures the backend implementation details for the crypto device, such as whether it is built-in or uses the LKCF kernel framework.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#backend Domain#backend}
  */
  readonly backend?: DomainDevicesCryptoBackend;
  /**
  * Selects the crypto device model; for recent libvirt/QEMU this must be a virtio variant such as "virtio", "virtio-transitional", or "virtio-non-transitional".
  * 
  * See: <https://libvirt.org/formatdomain.html#crypto>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Selects the crypto device type/implementation, which currently supports "qemu"; the value is user-provided but must be supported by the hypervisor.
  * 
  * See: <https://libvirt.org/formatdomain.html#crypto>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type?: string;
}

export function domainDevicesCryptoToTerraform(struct?: DomainDevicesCrypto | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: domainDevicesCryptoAddressToTerraform(struct!.address),
    alias: domainDevicesCryptoAliasToTerraform(struct!.alias),
    backend: domainDevicesCryptoBackendToTerraform(struct!.backend),
    model: cdktf.stringToTerraform(struct!.model),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function domainDevicesCryptoToHclTerraform(struct?: DomainDevicesCrypto | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: domainDevicesCryptoAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesCryptoAddress",
    },
    alias: {
      value: domainDevicesCryptoAliasToHclTerraform(struct!.alias),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesCryptoAlias",
    },
    backend: {
      value: domainDevicesCryptoBackendToHclTerraform(struct!.backend),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesCryptoBackend",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesCryptoOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesCrypto | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._alias?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.alias = this._alias?.internalValue;
    }
    if (this._backend?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.backend = this._backend?.internalValue;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesCrypto | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._alias.internalValue = undefined;
      this._backend.internalValue = undefined;
      this._model = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._alias.internalValue = value.alias;
      this._backend.internalValue = value.backend;
      this._model = value.model;
      this._type = value.type;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address = new DomainDevicesCryptoAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DomainDevicesCryptoAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // alias - computed: false, optional: true, required: false
  private _alias = new DomainDevicesCryptoAliasOutputReference(this, "alias");
  public get alias() {
    return this._alias;
  }
  public putAlias(value: DomainDevicesCryptoAlias) {
    this._alias.internalValue = value;
  }
  public resetAlias() {
    this._alias.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aliasInput() {
    return this._alias.internalValue;
  }

  // backend - computed: false, optional: true, required: false
  private _backend = new DomainDevicesCryptoBackendOutputReference(this, "backend");
  public get backend() {
    return this._backend;
  }
  public putBackend(value: DomainDevicesCryptoBackend) {
    this._backend.internalValue = value;
  }
  public resetBackend() {
    this._backend.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backendInput() {
    return this._backend.internalValue;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}

export class DomainDevicesCryptoList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesCrypto[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesCryptoOutputReference {
    return new DomainDevicesCryptoOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksAcpi {
  /**
  * Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#pstore>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#index Domain#index}
  */
  readonly index?: number;
}

export function domainDevicesDisksAcpiToTerraform(struct?: DomainDevicesDisksAcpi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    index: cdktf.numberToTerraform(struct!.index),
  }
}


export function domainDevicesDisksAcpiToHclTerraform(struct?: DomainDevicesDisksAcpi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    index: {
      value: cdktf.numberToHclTerraform(struct!.index),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksAcpiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksAcpi | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._index !== undefined) {
      hasAnyValues = true;
      internalValueResult.index = this._index;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksAcpi | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._index = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._index = value.index;
    }
  }

  // index - computed: false, optional: true, required: false
  private _index?: number; 
  public get index() {
    return this.getNumberAttribute('index');
  }
  public set index(value: number) {
    this._index = value;
  }
  public resetIndex() {
    this._index = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get indexInput() {
    return this._index;
  }
}
export interface DomainDevicesDisksAddress {
}

export function domainDevicesDisksAddressToTerraform(struct?: DomainDevicesDisksAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function domainDevicesDisksAddressToHclTerraform(struct?: DomainDevicesDisksAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DomainDevicesDisksAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DomainDevicesDisksAlias {
  /**
  * Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
}

export function domainDevicesDisksAliasToTerraform(struct?: DomainDevicesDisksAlias | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function domainDevicesDisksAliasToHclTerraform(struct?: DomainDevicesDisksAlias | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksAliasOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksAlias | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksAlias | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DomainDevicesDisksAuthSecret {
  /**
  * Sets how the referenced secret is identified; typical values are user-provided strings such as "uuid" or "usage" depending on how the secret is looked up.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type?: string;
  /**
  * Sets the libvirt secret usage name when referencing the iSCSI auth secret by usage; the value is a user-provided identifier such as an iSCSI target name.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#usage Domain#usage}
  */
  readonly usage?: string;
}

export function domainDevicesDisksAuthSecretToTerraform(struct?: DomainDevicesDisksAuthSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    type: cdktf.stringToTerraform(struct!.type),
    usage: cdktf.stringToTerraform(struct!.usage),
  }
}


export function domainDevicesDisksAuthSecretToHclTerraform(struct?: DomainDevicesDisksAuthSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    usage: {
      value: cdktf.stringToHclTerraform(struct!.usage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksAuthSecretOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksAuthSecret | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._usage !== undefined) {
      hasAnyValues = true;
      internalValueResult.usage = this._usage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksAuthSecret | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._type = undefined;
      this._usage = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._type = value.type;
      this._usage = value.usage;
    }
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // usage - computed: false, optional: true, required: false
  private _usage?: string; 
  public get usage() {
    return this.getStringAttribute('usage');
  }
  public set usage(value: string) {
    this._usage = value;
  }
  public resetUsage() {
    this._usage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usageInput() {
    return this._usage;
  }

  // uuid - computed: true, optional: false, required: false
  public get uuid() {
    return this.getStringAttribute('uuid');
  }
}
export interface DomainDevicesDisksAuth {
  /**
  * Configures the libvirt secret object used to hold the iSCSI authentication password for this hostdev; this references an existing libvirt secret, not the clear-text secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#secret Domain#secret}
  */
  readonly secret?: DomainDevicesDisksAuthSecret;
  /**
  * Sets the CHAP username used when authenticating to the iSCSI target for this SCSI hostdev; the value is user-provided (for example, "chapuser1").
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#username Domain#username}
  */
  readonly username?: string;
}

export function domainDevicesDisksAuthToTerraform(struct?: DomainDevicesDisksAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret: domainDevicesDisksAuthSecretToTerraform(struct!.secret),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function domainDevicesDisksAuthToHclTerraform(struct?: DomainDevicesDisksAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret: {
      value: domainDevicesDisksAuthSecretToHclTerraform(struct!.secret),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksAuthSecret",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secret?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret?.internalValue;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secret.internalValue = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secret.internalValue = value.secret;
      this._username = value.username;
    }
  }

  // secret - computed: false, optional: true, required: false
  private _secret = new DomainDevicesDisksAuthSecretOutputReference(this, "secret");
  public get secret() {
    return this._secret;
  }
  public putSecret(value: DomainDevicesDisksAuthSecret) {
    this._secret.internalValue = value;
  }
  public resetSecret() {
    this._secret.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret.internalValue;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface DomainDevicesDisksBackendDomain {
  /**
  * Sets the name of the backend (driver) domain that will host the network backend for this interface; value must match an existing domain name.
  * 
  * See: <https://libvirt.org/formatdomain.html#setting-up-a-network-backend-in-a-driver-domain>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
}

export function domainDevicesDisksBackendDomainToTerraform(struct?: DomainDevicesDisksBackendDomain | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function domainDevicesDisksBackendDomainToHclTerraform(struct?: DomainDevicesDisksBackendDomain | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackendDomainOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackendDomain | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackendDomain | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DomainDevicesDisksBackingStoreFormatMetadataCacheMaxSize {
  /**
  * Sets the unit used for the metadata cache maximum size; valid units follow libvirt size units such as "B", "KiB", "MiB", "GiB" and are user-chosen.
  * 
  * See: <https://libvirt.org/formatdomain.html#memory-allocation>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#unit Domain#unit}
  */
  readonly unit?: string;
  /**
  * Sets the numeric value for the metadata cache maximum size in the specified unit; this must be a positive integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#value Domain#value}
  */
  readonly value: number;
}

export function domainDevicesDisksBackingStoreFormatMetadataCacheMaxSizeToTerraform(struct?: DomainDevicesDisksBackingStoreFormatMetadataCacheMaxSize | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    unit: cdktf.stringToTerraform(struct!.unit),
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function domainDevicesDisksBackingStoreFormatMetadataCacheMaxSizeToHclTerraform(struct?: DomainDevicesDisksBackingStoreFormatMetadataCacheMaxSize | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    unit: {
      value: cdktf.stringToHclTerraform(struct!.unit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreFormatMetadataCacheMaxSizeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreFormatMetadataCacheMaxSize | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._unit !== undefined) {
      hasAnyValues = true;
      internalValueResult.unit = this._unit;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreFormatMetadataCacheMaxSize | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._unit = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._unit = value.unit;
      this._value = value.value;
    }
  }

  // unit - computed: false, optional: true, required: false
  private _unit?: string; 
  public get unit() {
    return this.getStringAttribute('unit');
  }
  public set unit(value: string) {
    this._unit = value;
  }
  public resetUnit() {
    this._unit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unitInput() {
    return this._unit;
  }

  // value - computed: false, optional: false, required: true
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DomainDevicesDisksBackingStoreFormatMetadataCache {
  /**
  * Sets the maximum size of the metadata cache used by the data store format; value and unit together define the limit (for example, 64 MiB).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#max_size Domain#max_size}
  */
  readonly maxSize?: DomainDevicesDisksBackingStoreFormatMetadataCacheMaxSize;
}

export function domainDevicesDisksBackingStoreFormatMetadataCacheToTerraform(struct?: DomainDevicesDisksBackingStoreFormatMetadataCache | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_size: domainDevicesDisksBackingStoreFormatMetadataCacheMaxSizeToTerraform(struct!.maxSize),
  }
}


export function domainDevicesDisksBackingStoreFormatMetadataCacheToHclTerraform(struct?: DomainDevicesDisksBackingStoreFormatMetadataCache | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_size: {
      value: domainDevicesDisksBackingStoreFormatMetadataCacheMaxSizeToHclTerraform(struct!.maxSize),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreFormatMetadataCacheMaxSize",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreFormatMetadataCacheOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreFormatMetadataCache | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxSize?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreFormatMetadataCache | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxSize.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxSize.internalValue = value.maxSize;
    }
  }

  // max_size - computed: false, optional: true, required: false
  private _maxSize = new DomainDevicesDisksBackingStoreFormatMetadataCacheMaxSizeOutputReference(this, "max_size");
  public get maxSize() {
    return this._maxSize;
  }
  public putMaxSize(value: DomainDevicesDisksBackingStoreFormatMetadataCacheMaxSize) {
    this._maxSize.internalValue = value;
  }
  public resetMaxSize() {
    this._maxSize.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize.internalValue;
  }
}
export interface DomainDevicesDisksBackingStoreFormat {
  /**
  * Configures metadata cache behavior for the mirrored backing store’s data store format (for example, limiting the size of cached metadata).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#metadata_cache Domain#metadata_cache}
  */
  readonly metadataCache?: DomainDevicesDisksBackingStoreFormatMetadataCache;
  /**
  * Sets the data store format type for the mirrored backing store (for example, "qcow2" or "raw"); the value is user-provided and must be a valid libvirt disk format name.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type: string;
}

export function domainDevicesDisksBackingStoreFormatToTerraform(struct?: DomainDevicesDisksBackingStoreFormat | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metadata_cache: domainDevicesDisksBackingStoreFormatMetadataCacheToTerraform(struct!.metadataCache),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function domainDevicesDisksBackingStoreFormatToHclTerraform(struct?: DomainDevicesDisksBackingStoreFormat | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metadata_cache: {
      value: domainDevicesDisksBackingStoreFormatMetadataCacheToHclTerraform(struct!.metadataCache),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStoreFormatMetadataCache",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreFormatOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreFormat | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metadataCache?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadataCache = this._metadataCache?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreFormat | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metadataCache.internalValue = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metadataCache.internalValue = value.metadataCache;
      this._type = value.type;
    }
  }

  // metadata_cache - computed: false, optional: true, required: false
  private _metadataCache = new DomainDevicesDisksBackingStoreFormatMetadataCacheOutputReference(this, "metadata_cache");
  public get metadataCache() {
    return this._metadataCache;
  }
  public putMetadataCache(value: DomainDevicesDisksBackingStoreFormatMetadataCache) {
    this._metadataCache.internalValue = value;
  }
  public resetMetadataCache() {
    this._metadataCache.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataCacheInput() {
    return this._metadataCache.internalValue;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DomainDevicesDisksBackingStoreSourceBlockSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksBackingStoreSourceBlockSecLabelToTerraform(struct?: DomainDevicesDisksBackingStoreSourceBlockSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksBackingStoreSourceBlockSecLabelToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceBlockSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceBlockSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceBlockSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceBlockSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksBackingStoreSourceBlockSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksBackingStoreSourceBlockSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksBackingStoreSourceBlockSecLabelOutputReference {
    return new DomainDevicesDisksBackingStoreSourceBlockSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksBackingStoreSourceBlock {
  /**
  * Sets the host block device path used as the mirror backing store source (for example "/dev/sdb1"); the value is user-provided and must reference an existing block device.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dev Domain#dev}
  */
  readonly dev?: string;
  /**
  * Configures an optional security label for the block-device backing store of the mirror, controlling how security drivers label this source.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksBackingStoreSourceBlockSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksBackingStoreSourceBlockToTerraform(struct?: DomainDevicesDisksBackingStoreSourceBlock | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dev: cdktf.stringToTerraform(struct!.dev),
    sec_label: cdktf.listMapper(domainDevicesDisksBackingStoreSourceBlockSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksBackingStoreSourceBlockToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceBlock | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dev: {
      value: cdktf.stringToHclTerraform(struct!.dev),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksBackingStoreSourceBlockSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksBackingStoreSourceBlockSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceBlockOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceBlock | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dev !== undefined) {
      hasAnyValues = true;
      internalValueResult.dev = this._dev;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceBlock | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dev = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dev = value.dev;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // dev - computed: false, optional: true, required: false
  private _dev?: string; 
  public get dev() {
    return this.getStringAttribute('dev');
  }
  public set dev(value: string) {
    this._dev = value;
  }
  public resetDev() {
    this._dev = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devInput() {
    return this._dev;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksBackingStoreSourceBlockSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksBackingStoreSourceBlockSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksBackingStoreSourceCookiesCookies {
  /**
  * Sets the cookie name for this backing store HTTP cookie; the value is user-provided and must be non-empty (for example, "sessionid").
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
  /**
  * Sets the cookie value for this backing store HTTP cookie; the value is user-provided and must be non-empty (for example, "abc123").
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#value Domain#value}
  */
  readonly value: string;
}

export function domainDevicesDisksBackingStoreSourceCookiesCookiesToTerraform(struct?: DomainDevicesDisksBackingStoreSourceCookiesCookies | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function domainDevicesDisksBackingStoreSourceCookiesCookiesToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceCookiesCookies | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceCookiesCookiesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceCookiesCookies | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceCookiesCookies | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DomainDevicesDisksBackingStoreSourceCookiesCookiesList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksBackingStoreSourceCookiesCookies[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksBackingStoreSourceCookiesCookiesOutputReference {
    return new DomainDevicesDisksBackingStoreSourceCookiesCookiesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksBackingStoreSourceCookies {
  /**
  * Configures one or more HTTP cookies to be sent when accessing the mirrored backing store over a network protocol that supports cookies (for example, HTTPS or HTTP-based storage).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#cookies Domain#cookies}
  */
  readonly cookies?: DomainDevicesDisksBackingStoreSourceCookiesCookies[] | cdktf.IResolvable;
}

export function domainDevicesDisksBackingStoreSourceCookiesToTerraform(struct?: DomainDevicesDisksBackingStoreSourceCookies | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cookies: cdktf.listMapper(domainDevicesDisksBackingStoreSourceCookiesCookiesToTerraform, false)(struct!.cookies),
  }
}


export function domainDevicesDisksBackingStoreSourceCookiesToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceCookies | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cookies: {
      value: cdktf.listMapperHcl(domainDevicesDisksBackingStoreSourceCookiesCookiesToHclTerraform, false)(struct!.cookies),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksBackingStoreSourceCookiesCookiesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceCookiesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceCookies | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cookies?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cookies = this._cookies?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceCookies | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cookies.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cookies.internalValue = value.cookies;
    }
  }

  // cookies - computed: false, optional: true, required: false
  private _cookies = new DomainDevicesDisksBackingStoreSourceCookiesCookiesList(this, "cookies", false);
  public get cookies() {
    return this._cookies;
  }
  public putCookies(value: DomainDevicesDisksBackingStoreSourceCookiesCookies[] | cdktf.IResolvable) {
    this._cookies.internalValue = value;
  }
  public resetCookies() {
    this._cookies.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cookiesInput() {
    return this._cookies.internalValue;
  }
}
export interface DomainDevicesDisksBackingStoreSourceDataStoreFormatMetadataCacheMaxSize {
  /**
  * Sets the unit used for the metadata cache maximum size; valid units follow libvirt size units such as "B", "KiB", "MiB", "GiB" and are user-chosen.
  * 
  * See: <https://libvirt.org/formatdomain.html#memory-allocation>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#unit Domain#unit}
  */
  readonly unit?: string;
  /**
  * Sets the numeric value for the metadata cache maximum size in the specified unit; this must be a positive integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#value Domain#value}
  */
  readonly value: number;
}

export function domainDevicesDisksBackingStoreSourceDataStoreFormatMetadataCacheMaxSizeToTerraform(struct?: DomainDevicesDisksBackingStoreSourceDataStoreFormatMetadataCacheMaxSize | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    unit: cdktf.stringToTerraform(struct!.unit),
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function domainDevicesDisksBackingStoreSourceDataStoreFormatMetadataCacheMaxSizeToHclTerraform(struct?: DomainDevicesDisksBackingStoreSourceDataStoreFormatMetadataCacheMaxSize | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    unit: {
      value: cdktf.stringToHclTerraform(struct!.unit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksBackingStoreSourceDataStoreFormatMetadataCacheMaxSizeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksBackingStoreSourceDataStoreFormatMetadataCacheMaxSize | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._unit !== undefined) {
      hasAnyValues = true;
      internalValueResult.unit = this._unit;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksBackingStoreSourceDataStoreFormatMetadataCacheMaxSize | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._unit = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._unit = value.unit;
      this._value = value.value;
    }
  }

  // unit - computed: false, optional: true, required: false
  private _unit?: string; 
  public get unit() {
    return this.getStringAttribute('unit');
  }
  public set unit(value: string) {
    this._unit = value;
  }
  public resetUnit() {
    this._unit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unitInput() {
    return this._unit;
  }

  // value - computed: false, optional: false, required: true
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
