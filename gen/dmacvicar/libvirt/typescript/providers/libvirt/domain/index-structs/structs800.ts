import * as cdktf from 'cdktf';
import { DomainDevicesDisksMirrorBackingStoreFormat,
domainDevicesDisksMirrorBackingStoreFormatToTerraform,
domainDevicesDisksMirrorBackingStoreFormatToHclTerraform,
DomainDevicesDisksMirrorBackingStoreFormatOutputReference,
DomainDevicesDisksMirrorBackingStoreSource,
domainDevicesDisksMirrorBackingStoreSourceToTerraform,
domainDevicesDisksMirrorBackingStoreSourceToHclTerraform,
DomainDevicesDisksMirrorBackingStoreSourceOutputReference,
DomainDevicesDisksBackingStore,
domainDevicesDisksBackingStoreToTerraform,
domainDevicesDisksBackingStoreToHclTerraform,
DomainDevicesDisksBackingStoreOutputReference,
DomainDevicesDisksBlockIo,
domainDevicesDisksBlockIoToTerraform,
domainDevicesDisksBlockIoToHclTerraform,
DomainDevicesDisksBlockIoOutputReference,
DomainDevicesDisksBoot,
domainDevicesDisksBootToTerraform,
domainDevicesDisksBootToHclTerraform,
DomainDevicesDisksBootOutputReference,
DomainDevicesDisksDriver,
domainDevicesDisksDriverToTerraform,
domainDevicesDisksDriverToHclTerraform,
DomainDevicesDisksDriverOutputReference,
DomainDevicesDisksEncryption,
domainDevicesDisksEncryptionToTerraform,
domainDevicesDisksEncryptionToHclTerraform,
DomainDevicesDisksEncryptionOutputReference,
DomainDevicesDisksGeometry,
domainDevicesDisksGeometryToTerraform,
domainDevicesDisksGeometryToHclTerraform,
DomainDevicesDisksGeometryOutputReference,
DomainDevicesDisksIoTune,
domainDevicesDisksIoTuneToTerraform,
domainDevicesDisksIoTuneToHclTerraform,
DomainDevicesDisksIoTuneOutputReference } from './structs400'
import { DomainDevicesDisksAcpi,
domainDevicesDisksAcpiToTerraform,
domainDevicesDisksAcpiToHclTerraform,
DomainDevicesDisksAcpiOutputReference,
DomainDevicesDisksAddress,
domainDevicesDisksAddressToTerraform,
domainDevicesDisksAddressToHclTerraform,
DomainDevicesDisksAddressOutputReference,
DomainDevicesDisksAlias,
domainDevicesDisksAliasToTerraform,
domainDevicesDisksAliasToHclTerraform,
DomainDevicesDisksAliasOutputReference,
DomainDevicesDisksAuth,
domainDevicesDisksAuthToTerraform,
domainDevicesDisksAuthToHclTerraform,
DomainDevicesDisksAuthOutputReference,
DomainDevicesDisksBackendDomain,
domainDevicesDisksBackendDomainToTerraform,
domainDevicesDisksBackendDomainToHclTerraform,
DomainDevicesDisksBackendDomainOutputReference } from './structs0'
export interface DomainDevicesDisksMirrorBackingStore {
  /**
  * Configures the on-disk format settings for the mirrored backing store’s data store, including format type and optional metadata cache tuning.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#format Domain#format}
  */
  readonly format?: DomainDevicesDisksMirrorBackingStoreFormat;
  /**
  * Sets the index of this backing store within the mirror’s backing chain, as an integer used to order multiple backingStore entries.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#index Domain#index}
  */
  readonly index?: number;
  /**
  * Defines the data source for the mirror backing store, such as a block device or file path.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#source Domain#source}
  */
  readonly source?: DomainDevicesDisksMirrorBackingStoreSource;
}

export function domainDevicesDisksMirrorBackingStoreToTerraform(struct?: DomainDevicesDisksMirrorBackingStore | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    format: domainDevicesDisksMirrorBackingStoreFormatToTerraform(struct!.format),
    index: cdktf.numberToTerraform(struct!.index),
    source: domainDevicesDisksMirrorBackingStoreSourceToTerraform(struct!.source),
  }
}


export function domainDevicesDisksMirrorBackingStoreToHclTerraform(struct?: DomainDevicesDisksMirrorBackingStore | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    format: {
      value: domainDevicesDisksMirrorBackingStoreFormatToHclTerraform(struct!.format),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreFormat",
    },
    index: {
      value: cdktf.numberToHclTerraform(struct!.index),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    source: {
      value: domainDevicesDisksMirrorBackingStoreSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStoreSource",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorBackingStoreOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorBackingStore | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._format?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format?.internalValue;
    }
    if (this._index !== undefined) {
      hasAnyValues = true;
      internalValueResult.index = this._index;
    }
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorBackingStore | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._format.internalValue = undefined;
      this._index = undefined;
      this._source.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._format.internalValue = value.format;
      this._index = value.index;
      this._source.internalValue = value.source;
    }
  }

  // format - computed: false, optional: true, required: false
  private _format = new DomainDevicesDisksMirrorBackingStoreFormatOutputReference(this, "format");
  public get format() {
    return this._format;
  }
  public putFormat(value: DomainDevicesDisksMirrorBackingStoreFormat) {
    this._format.internalValue = value;
  }
  public resetFormat() {
    this._format.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format.internalValue;
  }

  // index - computed: false, optional: true, required: false
  private _index?: number; 
  public get index() {
    return this.getNumberAttribute('index');
  }
  public set index(value: number) {
    this._index = value;
  }
  public resetIndex() {
    this._index = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get indexInput() {
    return this._index;
  }

  // source - computed: false, optional: true, required: false
  private _source = new DomainDevicesDisksMirrorBackingStoreSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: DomainDevicesDisksMirrorBackingStoreSource) {
    this._source.internalValue = value;
  }
  public resetSource() {
    this._source.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }
}
export interface DomainDevicesDisksMirrorFormatMetadataCacheMaxSize {
  /**
  * Sets the unit used for the metadata cache maximum size; valid units follow libvirt size units such as "B", "KiB", "MiB", "GiB" and are user-chosen.
  * 
  * See: <https://libvirt.org/formatdomain.html#memory-allocation>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#unit Domain#unit}
  */
  readonly unit?: string;
  /**
  * Sets the numeric value for the metadata cache maximum size in the specified unit; this must be a positive integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#value Domain#value}
  */
  readonly value: number;
}

export function domainDevicesDisksMirrorFormatMetadataCacheMaxSizeToTerraform(struct?: DomainDevicesDisksMirrorFormatMetadataCacheMaxSize | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    unit: cdktf.stringToTerraform(struct!.unit),
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function domainDevicesDisksMirrorFormatMetadataCacheMaxSizeToHclTerraform(struct?: DomainDevicesDisksMirrorFormatMetadataCacheMaxSize | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    unit: {
      value: cdktf.stringToHclTerraform(struct!.unit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorFormatMetadataCacheMaxSizeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorFormatMetadataCacheMaxSize | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._unit !== undefined) {
      hasAnyValues = true;
      internalValueResult.unit = this._unit;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorFormatMetadataCacheMaxSize | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._unit = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._unit = value.unit;
      this._value = value.value;
    }
  }

  // unit - computed: false, optional: true, required: false
  private _unit?: string; 
  public get unit() {
    return this.getStringAttribute('unit');
  }
  public set unit(value: string) {
    this._unit = value;
  }
  public resetUnit() {
    this._unit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unitInput() {
    return this._unit;
  }

  // value - computed: false, optional: false, required: true
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DomainDevicesDisksMirrorFormatMetadataCache {
  /**
  * Sets the maximum size of the metadata cache used by the data store format; value and unit together define the limit (for example, 64 MiB).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#max_size Domain#max_size}
  */
  readonly maxSize?: DomainDevicesDisksMirrorFormatMetadataCacheMaxSize;
}

export function domainDevicesDisksMirrorFormatMetadataCacheToTerraform(struct?: DomainDevicesDisksMirrorFormatMetadataCache | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_size: domainDevicesDisksMirrorFormatMetadataCacheMaxSizeToTerraform(struct!.maxSize),
  }
}


export function domainDevicesDisksMirrorFormatMetadataCacheToHclTerraform(struct?: DomainDevicesDisksMirrorFormatMetadataCache | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_size: {
      value: domainDevicesDisksMirrorFormatMetadataCacheMaxSizeToHclTerraform(struct!.maxSize),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorFormatMetadataCacheMaxSize",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorFormatMetadataCacheOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorFormatMetadataCache | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxSize?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorFormatMetadataCache | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxSize.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxSize.internalValue = value.maxSize;
    }
  }

  // max_size - computed: false, optional: true, required: false
  private _maxSize = new DomainDevicesDisksMirrorFormatMetadataCacheMaxSizeOutputReference(this, "max_size");
  public get maxSize() {
    return this._maxSize;
  }
  public putMaxSize(value: DomainDevicesDisksMirrorFormatMetadataCacheMaxSize) {
    this._maxSize.internalValue = value;
  }
  public resetMaxSize() {
    this._maxSize.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize.internalValue;
  }
}
export interface DomainDevicesDisksMirrorFormat {
  /**
  * Configures metadata cache behavior for the mirrored backing store’s data store format (for example, limiting the size of cached metadata).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#metadata_cache Domain#metadata_cache}
  */
  readonly metadataCache?: DomainDevicesDisksMirrorFormatMetadataCache;
  /**
  * Sets the data store format type for the mirrored backing store (for example, "qcow2" or "raw"); the value is user-provided and must be a valid libvirt disk format name.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type: string;
}

export function domainDevicesDisksMirrorFormatToTerraform(struct?: DomainDevicesDisksMirrorFormat | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metadata_cache: domainDevicesDisksMirrorFormatMetadataCacheToTerraform(struct!.metadataCache),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function domainDevicesDisksMirrorFormatToHclTerraform(struct?: DomainDevicesDisksMirrorFormat | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metadata_cache: {
      value: domainDevicesDisksMirrorFormatMetadataCacheToHclTerraform(struct!.metadataCache),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorFormatMetadataCache",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorFormatOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorFormat | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metadataCache?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadataCache = this._metadataCache?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorFormat | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metadataCache.internalValue = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metadataCache.internalValue = value.metadataCache;
      this._type = value.type;
    }
  }

  // metadata_cache - computed: false, optional: true, required: false
  private _metadataCache = new DomainDevicesDisksMirrorFormatMetadataCacheOutputReference(this, "metadata_cache");
  public get metadataCache() {
    return this._metadataCache;
  }
  public putMetadataCache(value: DomainDevicesDisksMirrorFormatMetadataCache) {
    this._metadataCache.internalValue = value;
  }
  public resetMetadataCache() {
    this._metadataCache.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataCacheInput() {
    return this._metadataCache.internalValue;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DomainDevicesDisksMirrorSourceBlockSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksMirrorSourceBlockSecLabelToTerraform(struct?: DomainDevicesDisksMirrorSourceBlockSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksMirrorSourceBlockSecLabelToHclTerraform(struct?: DomainDevicesDisksMirrorSourceBlockSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceBlockSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceBlockSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceBlockSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksMirrorSourceBlockSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksMirrorSourceBlockSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksMirrorSourceBlockSecLabelOutputReference {
    return new DomainDevicesDisksMirrorSourceBlockSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksMirrorSourceBlock {
  /**
  * Sets the host block device path used as the mirror backing store source (for example "/dev/sdb1"); the value is user-provided and must reference an existing block device.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dev Domain#dev}
  */
  readonly dev?: string;
  /**
  * Configures an optional security label for the block-device backing store of the mirror, controlling how security drivers label this source.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksMirrorSourceBlockSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksMirrorSourceBlockToTerraform(struct?: DomainDevicesDisksMirrorSourceBlock | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dev: cdktf.stringToTerraform(struct!.dev),
    sec_label: cdktf.listMapper(domainDevicesDisksMirrorSourceBlockSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksMirrorSourceBlockToHclTerraform(struct?: DomainDevicesDisksMirrorSourceBlock | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dev: {
      value: cdktf.stringToHclTerraform(struct!.dev),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksMirrorSourceBlockSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksMirrorSourceBlockSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceBlockOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceBlock | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dev !== undefined) {
      hasAnyValues = true;
      internalValueResult.dev = this._dev;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceBlock | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dev = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dev = value.dev;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // dev - computed: false, optional: true, required: false
  private _dev?: string; 
  public get dev() {
    return this.getStringAttribute('dev');
  }
  public set dev(value: string) {
    this._dev = value;
  }
  public resetDev() {
    this._dev = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devInput() {
    return this._dev;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksMirrorSourceBlockSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksMirrorSourceBlockSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksMirrorSourceCookiesCookies {
  /**
  * Sets the cookie name for this backing store HTTP cookie; the value is user-provided and must be non-empty (for example, "sessionid").
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
  /**
  * Sets the cookie value for this backing store HTTP cookie; the value is user-provided and must be non-empty (for example, "abc123").
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#value Domain#value}
  */
  readonly value: string;
}

export function domainDevicesDisksMirrorSourceCookiesCookiesToTerraform(struct?: DomainDevicesDisksMirrorSourceCookiesCookies | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function domainDevicesDisksMirrorSourceCookiesCookiesToHclTerraform(struct?: DomainDevicesDisksMirrorSourceCookiesCookies | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceCookiesCookiesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceCookiesCookies | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceCookiesCookies | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DomainDevicesDisksMirrorSourceCookiesCookiesList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksMirrorSourceCookiesCookies[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksMirrorSourceCookiesCookiesOutputReference {
    return new DomainDevicesDisksMirrorSourceCookiesCookiesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksMirrorSourceCookies {
  /**
  * Configures one or more HTTP cookies to be sent when accessing the mirrored backing store over a network protocol that supports cookies (for example, HTTPS or HTTP-based storage).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#cookies Domain#cookies}
  */
  readonly cookies?: DomainDevicesDisksMirrorSourceCookiesCookies[] | cdktf.IResolvable;
}

export function domainDevicesDisksMirrorSourceCookiesToTerraform(struct?: DomainDevicesDisksMirrorSourceCookies | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cookies: cdktf.listMapper(domainDevicesDisksMirrorSourceCookiesCookiesToTerraform, false)(struct!.cookies),
  }
}


export function domainDevicesDisksMirrorSourceCookiesToHclTerraform(struct?: DomainDevicesDisksMirrorSourceCookies | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cookies: {
      value: cdktf.listMapperHcl(domainDevicesDisksMirrorSourceCookiesCookiesToHclTerraform, false)(struct!.cookies),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksMirrorSourceCookiesCookiesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceCookiesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceCookies | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cookies?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cookies = this._cookies?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceCookies | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cookies.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cookies.internalValue = value.cookies;
    }
  }

  // cookies - computed: false, optional: true, required: false
  private _cookies = new DomainDevicesDisksMirrorSourceCookiesCookiesList(this, "cookies", false);
  public get cookies() {
    return this._cookies;
  }
  public putCookies(value: DomainDevicesDisksMirrorSourceCookiesCookies[] | cdktf.IResolvable) {
    this._cookies.internalValue = value;
  }
  public resetCookies() {
    this._cookies.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cookiesInput() {
    return this._cookies.internalValue;
  }
}
export interface DomainDevicesDisksMirrorSourceDataStoreFormatMetadataCacheMaxSize {
  /**
  * Sets the unit used for the metadata cache maximum size; valid units follow libvirt size units such as "B", "KiB", "MiB", "GiB" and are user-chosen.
  * 
  * See: <https://libvirt.org/formatdomain.html#memory-allocation>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#unit Domain#unit}
  */
  readonly unit?: string;
  /**
  * Sets the numeric value for the metadata cache maximum size in the specified unit; this must be a positive integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#value Domain#value}
  */
  readonly value: number;
}

export function domainDevicesDisksMirrorSourceDataStoreFormatMetadataCacheMaxSizeToTerraform(struct?: DomainDevicesDisksMirrorSourceDataStoreFormatMetadataCacheMaxSize | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    unit: cdktf.stringToTerraform(struct!.unit),
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function domainDevicesDisksMirrorSourceDataStoreFormatMetadataCacheMaxSizeToHclTerraform(struct?: DomainDevicesDisksMirrorSourceDataStoreFormatMetadataCacheMaxSize | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    unit: {
      value: cdktf.stringToHclTerraform(struct!.unit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceDataStoreFormatMetadataCacheMaxSizeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceDataStoreFormatMetadataCacheMaxSize | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._unit !== undefined) {
      hasAnyValues = true;
      internalValueResult.unit = this._unit;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceDataStoreFormatMetadataCacheMaxSize | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._unit = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._unit = value.unit;
      this._value = value.value;
    }
  }

  // unit - computed: false, optional: true, required: false
  private _unit?: string; 
  public get unit() {
    return this.getStringAttribute('unit');
  }
  public set unit(value: string) {
    this._unit = value;
  }
  public resetUnit() {
    this._unit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unitInput() {
    return this._unit;
  }

  // value - computed: false, optional: false, required: true
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DomainDevicesDisksMirrorSourceDataStoreFormatMetadataCache {
  /**
  * Sets the maximum size of the metadata cache used by the data store format; value and unit together define the limit (for example, 64 MiB).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#max_size Domain#max_size}
  */
  readonly maxSize?: DomainDevicesDisksMirrorSourceDataStoreFormatMetadataCacheMaxSize;
}

export function domainDevicesDisksMirrorSourceDataStoreFormatMetadataCacheToTerraform(struct?: DomainDevicesDisksMirrorSourceDataStoreFormatMetadataCache | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_size: domainDevicesDisksMirrorSourceDataStoreFormatMetadataCacheMaxSizeToTerraform(struct!.maxSize),
  }
}


export function domainDevicesDisksMirrorSourceDataStoreFormatMetadataCacheToHclTerraform(struct?: DomainDevicesDisksMirrorSourceDataStoreFormatMetadataCache | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_size: {
      value: domainDevicesDisksMirrorSourceDataStoreFormatMetadataCacheMaxSizeToHclTerraform(struct!.maxSize),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceDataStoreFormatMetadataCacheMaxSize",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceDataStoreFormatMetadataCacheOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceDataStoreFormatMetadataCache | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxSize?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceDataStoreFormatMetadataCache | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxSize.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxSize.internalValue = value.maxSize;
    }
  }

  // max_size - computed: false, optional: true, required: false
  private _maxSize = new DomainDevicesDisksMirrorSourceDataStoreFormatMetadataCacheMaxSizeOutputReference(this, "max_size");
  public get maxSize() {
    return this._maxSize;
  }
  public putMaxSize(value: DomainDevicesDisksMirrorSourceDataStoreFormatMetadataCacheMaxSize) {
    this._maxSize.internalValue = value;
  }
  public resetMaxSize() {
    this._maxSize.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize.internalValue;
  }
}
export interface DomainDevicesDisksMirrorSourceDataStoreFormat {
  /**
  * Configures metadata cache behavior for the mirrored backing store’s data store format (for example, limiting the size of cached metadata).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#metadata_cache Domain#metadata_cache}
  */
  readonly metadataCache?: DomainDevicesDisksMirrorSourceDataStoreFormatMetadataCache;
  /**
  * Sets the data store format type for the mirrored backing store (for example, "qcow2" or "raw"); the value is user-provided and must be a valid libvirt disk format name.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type: string;
}

export function domainDevicesDisksMirrorSourceDataStoreFormatToTerraform(struct?: DomainDevicesDisksMirrorSourceDataStoreFormat | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metadata_cache: domainDevicesDisksMirrorSourceDataStoreFormatMetadataCacheToTerraform(struct!.metadataCache),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function domainDevicesDisksMirrorSourceDataStoreFormatToHclTerraform(struct?: DomainDevicesDisksMirrorSourceDataStoreFormat | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metadata_cache: {
      value: domainDevicesDisksMirrorSourceDataStoreFormatMetadataCacheToHclTerraform(struct!.metadataCache),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceDataStoreFormatMetadataCache",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceDataStoreFormatOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceDataStoreFormat | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metadataCache?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadataCache = this._metadataCache?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceDataStoreFormat | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metadataCache.internalValue = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metadataCache.internalValue = value.metadataCache;
      this._type = value.type;
    }
  }

  // metadata_cache - computed: false, optional: true, required: false
  private _metadataCache = new DomainDevicesDisksMirrorSourceDataStoreFormatMetadataCacheOutputReference(this, "metadata_cache");
  public get metadataCache() {
    return this._metadataCache;
  }
  public putMetadataCache(value: DomainDevicesDisksMirrorSourceDataStoreFormatMetadataCache) {
    this._metadataCache.internalValue = value;
  }
  public resetMetadataCache() {
    this._metadataCache.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataCacheInput() {
    return this._metadataCache.internalValue;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DomainDevicesDisksMirrorSourceDataStore {
  /**
  * Configures the on-disk format settings for the mirrored backing store’s data store, including format type and optional metadata cache tuning.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#format Domain#format}
  */
  readonly format?: DomainDevicesDisksMirrorSourceDataStoreFormat;
}

export function domainDevicesDisksMirrorSourceDataStoreToTerraform(struct?: DomainDevicesDisksMirrorSourceDataStore | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    format: domainDevicesDisksMirrorSourceDataStoreFormatToTerraform(struct!.format),
  }
}


export function domainDevicesDisksMirrorSourceDataStoreToHclTerraform(struct?: DomainDevicesDisksMirrorSourceDataStore | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    format: {
      value: domainDevicesDisksMirrorSourceDataStoreFormatToHclTerraform(struct!.format),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceDataStoreFormat",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceDataStoreOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceDataStore | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._format?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceDataStore | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._format.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._format.internalValue = value.format;
    }
  }

  // format - computed: false, optional: true, required: false
  private _format = new DomainDevicesDisksMirrorSourceDataStoreFormatOutputReference(this, "format");
  public get format() {
    return this._format;
  }
  public putFormat(value: DomainDevicesDisksMirrorSourceDataStoreFormat) {
    this._format.internalValue = value;
  }
  public resetFormat() {
    this._format.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format.internalValue;
  }
}
export interface DomainDevicesDisksMirrorSourceDir {
  /**
  * Sets the host directory path used as the mirrored backing store source; this must be an absolute path on the host (for example, "/var/lib/libvirt/images").
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dir Domain#dir}
  */
  readonly dir?: string;
}

export function domainDevicesDisksMirrorSourceDirToTerraform(struct?: DomainDevicesDisksMirrorSourceDir | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dir: cdktf.stringToTerraform(struct!.dir),
  }
}


export function domainDevicesDisksMirrorSourceDirToHclTerraform(struct?: DomainDevicesDisksMirrorSourceDir | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dir: {
      value: cdktf.stringToHclTerraform(struct!.dir),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceDirOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceDir | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dir !== undefined) {
      hasAnyValues = true;
      internalValueResult.dir = this._dir;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceDir | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dir = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dir = value.dir;
    }
  }

  // dir - computed: false, optional: true, required: false
  private _dir?: string; 
  public get dir() {
    return this.getStringAttribute('dir');
  }
  public set dir(value: string) {
    this._dir = value;
  }
  public resetDir() {
    this._dir = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dirInput() {
    return this._dir;
  }
}
export interface DomainDevicesDisksMirrorSourceEncryptionSecrets {
  /**
  * Sets how the referenced secret is identified; typical values are user-provided strings such as "uuid" or "usage" depending on how the secret is looked up.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type?: string;
  /**
  * Sets the libvirt secret usage name when referencing the iSCSI auth secret by usage; the value is a user-provided identifier such as an iSCSI target name.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#usage Domain#usage}
  */
  readonly usage?: string;
}

export function domainDevicesDisksMirrorSourceEncryptionSecretsToTerraform(struct?: DomainDevicesDisksMirrorSourceEncryptionSecrets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    type: cdktf.stringToTerraform(struct!.type),
    usage: cdktf.stringToTerraform(struct!.usage),
  }
}


export function domainDevicesDisksMirrorSourceEncryptionSecretsToHclTerraform(struct?: DomainDevicesDisksMirrorSourceEncryptionSecrets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    usage: {
      value: cdktf.stringToHclTerraform(struct!.usage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceEncryptionSecretsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceEncryptionSecrets | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._usage !== undefined) {
      hasAnyValues = true;
      internalValueResult.usage = this._usage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceEncryptionSecrets | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._type = undefined;
      this._usage = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._type = value.type;
      this._usage = value.usage;
    }
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // usage - computed: false, optional: true, required: false
  private _usage?: string; 
  public get usage() {
    return this.getStringAttribute('usage');
  }
  public set usage(value: string) {
    this._usage = value;
  }
  public resetUsage() {
    this._usage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usageInput() {
    return this._usage;
  }

  // uuid - computed: true, optional: false, required: false
  public get uuid() {
    return this.getStringAttribute('uuid');
  }
}

export class DomainDevicesDisksMirrorSourceEncryptionSecretsList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksMirrorSourceEncryptionSecrets[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksMirrorSourceEncryptionSecretsOutputReference {
    return new DomainDevicesDisksMirrorSourceEncryptionSecretsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksMirrorSourceEncryption {
  /**
  * Sets the encryption engine/provider to use for the disk (user-provided string, e.g. implementation-specific engine name).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#engine Domain#engine}
  */
  readonly engine?: string;
  /**
  * Sets the disk encryption format, such as "luks" or another user-provided scheme supported by libvirt/qemu.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#format Domain#format}
  */
  readonly format?: string;
  /**
  * Defines one or more secret references used to access the encrypted disk, each describing how libvirt locates the secret material.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#secrets Domain#secrets}
  */
  readonly secrets?: DomainDevicesDisksMirrorSourceEncryptionSecrets[] | cdktf.IResolvable;
}

export function domainDevicesDisksMirrorSourceEncryptionToTerraform(struct?: DomainDevicesDisksMirrorSourceEncryption | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    engine: cdktf.stringToTerraform(struct!.engine),
    format: cdktf.stringToTerraform(struct!.format),
    secrets: cdktf.listMapper(domainDevicesDisksMirrorSourceEncryptionSecretsToTerraform, false)(struct!.secrets),
  }
}


export function domainDevicesDisksMirrorSourceEncryptionToHclTerraform(struct?: DomainDevicesDisksMirrorSourceEncryption | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    engine: {
      value: cdktf.stringToHclTerraform(struct!.engine),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secrets: {
      value: cdktf.listMapperHcl(domainDevicesDisksMirrorSourceEncryptionSecretsToHclTerraform, false)(struct!.secrets),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksMirrorSourceEncryptionSecretsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceEncryptionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceEncryption | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._engine !== undefined) {
      hasAnyValues = true;
      internalValueResult.engine = this._engine;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._secrets?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secrets = this._secrets?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceEncryption | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._engine = undefined;
      this._format = undefined;
      this._secrets.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._engine = value.engine;
      this._format = value.format;
      this._secrets.internalValue = value.secrets;
    }
  }

  // engine - computed: false, optional: true, required: false
  private _engine?: string; 
  public get engine() {
    return this.getStringAttribute('engine');
  }
  public set engine(value: string) {
    this._engine = value;
  }
  public resetEngine() {
    this._engine = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get engineInput() {
    return this._engine;
  }

  // format - computed: false, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // secrets - computed: false, optional: true, required: false
  private _secrets = new DomainDevicesDisksMirrorSourceEncryptionSecretsList(this, "secrets", false);
  public get secrets() {
    return this._secrets;
  }
  public putSecrets(value: DomainDevicesDisksMirrorSourceEncryptionSecrets[] | cdktf.IResolvable) {
    this._secrets.internalValue = value;
  }
  public resetSecrets() {
    this._secrets.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretsInput() {
    return this._secrets.internalValue;
  }
}
export interface DomainDevicesDisksMirrorSourceFileSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksMirrorSourceFileSecLabelToTerraform(struct?: DomainDevicesDisksMirrorSourceFileSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksMirrorSourceFileSecLabelToHclTerraform(struct?: DomainDevicesDisksMirrorSourceFileSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceFileSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceFileSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceFileSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksMirrorSourceFileSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksMirrorSourceFileSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksMirrorSourceFileSecLabelOutputReference {
    return new DomainDevicesDisksMirrorSourceFileSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksMirrorSourceFile {
  /**
  * Sets the name of an fdgroup whose pre-opened file descriptor is used for this backing store instead of opening the file path directly; value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#fd_group Domain#fd_group}
  */
  readonly fdGroup?: string;
  /**
  * Sets the absolute path on the host to the backing file used as the source for this mirrored disk (for example, /var/lib/libvirt/images/base.qcow2).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file?: string;
  /**
  * Configures an explicit security label for the file backing store, overriding default security driver labeling for this file.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksMirrorSourceFileSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksMirrorSourceFileToTerraform(struct?: DomainDevicesDisksMirrorSourceFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fd_group: cdktf.stringToTerraform(struct!.fdGroup),
    file: cdktf.stringToTerraform(struct!.file),
    sec_label: cdktf.listMapper(domainDevicesDisksMirrorSourceFileSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksMirrorSourceFileToHclTerraform(struct?: DomainDevicesDisksMirrorSourceFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fd_group: {
      value: cdktf.stringToHclTerraform(struct!.fdGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    file: {
      value: cdktf.stringToHclTerraform(struct!.file),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksMirrorSourceFileSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksMirrorSourceFileSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceFileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceFile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fdGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.fdGroup = this._fdGroup;
    }
    if (this._file !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceFile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fdGroup = undefined;
      this._file = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fdGroup = value.fdGroup;
      this._file = value.file;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // fd_group - computed: false, optional: true, required: false
  private _fdGroup?: string; 
  public get fdGroup() {
    return this.getStringAttribute('fd_group');
  }
  public set fdGroup(value: string) {
    this._fdGroup = value;
  }
  public resetFdGroup() {
    this._fdGroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fdGroupInput() {
    return this._fdGroup;
  }

  // file - computed: false, optional: true, required: false
  private _file?: string; 
  public get file() {
    return this.getStringAttribute('file');
  }
  public set file(value: string) {
    this._file = value;
  }
  public resetFile() {
    this._file = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksMirrorSourceFileSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksMirrorSourceFileSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksMirrorSourceNetworkAuthSecret {
  /**
  * Sets how the referenced secret is identified; typical values are user-provided strings such as "uuid" or "usage" depending on how the secret is looked up.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type?: string;
  /**
  * Sets the libvirt secret usage name when referencing the iSCSI auth secret by usage; the value is a user-provided identifier such as an iSCSI target name.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#usage Domain#usage}
  */
  readonly usage?: string;
}

export function domainDevicesDisksMirrorSourceNetworkAuthSecretToTerraform(struct?: DomainDevicesDisksMirrorSourceNetworkAuthSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    type: cdktf.stringToTerraform(struct!.type),
    usage: cdktf.stringToTerraform(struct!.usage),
  }
}


export function domainDevicesDisksMirrorSourceNetworkAuthSecretToHclTerraform(struct?: DomainDevicesDisksMirrorSourceNetworkAuthSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    usage: {
      value: cdktf.stringToHclTerraform(struct!.usage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceNetworkAuthSecretOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceNetworkAuthSecret | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._usage !== undefined) {
      hasAnyValues = true;
      internalValueResult.usage = this._usage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceNetworkAuthSecret | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._type = undefined;
      this._usage = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._type = value.type;
      this._usage = value.usage;
    }
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // usage - computed: false, optional: true, required: false
  private _usage?: string; 
  public get usage() {
    return this.getStringAttribute('usage');
  }
  public set usage(value: string) {
    this._usage = value;
  }
  public resetUsage() {
    this._usage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usageInput() {
    return this._usage;
  }

  // uuid - computed: true, optional: false, required: false
  public get uuid() {
    return this.getStringAttribute('uuid');
  }
}
export interface DomainDevicesDisksMirrorSourceNetworkAuth {
  /**
  * Configures the libvirt secret object used to hold the iSCSI authentication password for this hostdev; this references an existing libvirt secret, not the clear-text secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#secret Domain#secret}
  */
  readonly secret?: DomainDevicesDisksMirrorSourceNetworkAuthSecret;
  /**
  * Sets the CHAP username used when authenticating to the iSCSI target for this SCSI hostdev; the value is user-provided (for example, "chapuser1").
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#username Domain#username}
  */
  readonly username?: string;
}

export function domainDevicesDisksMirrorSourceNetworkAuthToTerraform(struct?: DomainDevicesDisksMirrorSourceNetworkAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret: domainDevicesDisksMirrorSourceNetworkAuthSecretToTerraform(struct!.secret),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function domainDevicesDisksMirrorSourceNetworkAuthToHclTerraform(struct?: DomainDevicesDisksMirrorSourceNetworkAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret: {
      value: domainDevicesDisksMirrorSourceNetworkAuthSecretToHclTerraform(struct!.secret),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceNetworkAuthSecret",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceNetworkAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceNetworkAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secret?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret?.internalValue;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceNetworkAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secret.internalValue = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secret.internalValue = value.secret;
      this._username = value.username;
    }
  }

  // secret - computed: false, optional: true, required: false
  private _secret = new DomainDevicesDisksMirrorSourceNetworkAuthSecretOutputReference(this, "secret");
  public get secret() {
    return this._secret;
  }
  public putSecret(value: DomainDevicesDisksMirrorSourceNetworkAuthSecret) {
    this._secret.internalValue = value;
  }
  public resetSecret() {
    this._secret.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret.internalValue;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface DomainDevicesDisksMirrorSourceNetworkConfig {
  /**
  * Sets the path to the configuration file used for the network backing store connection, such as a Ceph configuration file (/etc/ceph/ceph.conf).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file: string;
}

export function domainDevicesDisksMirrorSourceNetworkConfigToTerraform(struct?: DomainDevicesDisksMirrorSourceNetworkConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    file: cdktf.stringToTerraform(struct!.file),
  }
}


export function domainDevicesDisksMirrorSourceNetworkConfigToHclTerraform(struct?: DomainDevicesDisksMirrorSourceNetworkConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    file: {
      value: cdktf.stringToHclTerraform(struct!.file),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceNetworkConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceNetworkConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._file !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceNetworkConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._file = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._file = value.file;
    }
  }

  // file - computed: false, optional: false, required: true
  private _file?: string; 
  public get file() {
    return this.getStringAttribute('file');
  }
  public set file(value: string) {
    this._file = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file;
  }
}
export interface DomainDevicesDisksMirrorSourceNetworkHosts {
  /**
  * Sets the hostname or IP address of the iSCSI target portal (for example, "10.0.0.10" or "iscsi.example.com").
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name?: string;
  /**
  * Sets the TCP port of the iSCSI target portal; if omitted, libvirt/driver defaults (commonly 3260) are used.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#port Domain#port}
  */
  readonly port?: string;
  /**
  * Sets a UNIX domain socket path to connect to an iSCSI target via a local socket instead of TCP; value is a user-provided filesystem path.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#socket Domain#socket}
  */
  readonly socket?: string;
  /**
  * Sets the transport type used to reach the iSCSI target portal; valid values are user-provided strings as supported by the environment (for example, "tcp" or "iser").
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#transport Domain#transport}
  */
  readonly transport?: string;
}

export function domainDevicesDisksMirrorSourceNetworkHostsToTerraform(struct?: DomainDevicesDisksMirrorSourceNetworkHosts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    port: cdktf.stringToTerraform(struct!.port),
    socket: cdktf.stringToTerraform(struct!.socket),
    transport: cdktf.stringToTerraform(struct!.transport),
  }
}


export function domainDevicesDisksMirrorSourceNetworkHostsToHclTerraform(struct?: DomainDevicesDisksMirrorSourceNetworkHosts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.stringToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    socket: {
      value: cdktf.stringToHclTerraform(struct!.socket),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    transport: {
      value: cdktf.stringToHclTerraform(struct!.transport),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceNetworkHostsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceNetworkHosts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._socket !== undefined) {
      hasAnyValues = true;
      internalValueResult.socket = this._socket;
    }
    if (this._transport !== undefined) {
      hasAnyValues = true;
      internalValueResult.transport = this._transport;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceNetworkHosts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._port = undefined;
      this._socket = undefined;
      this._transport = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._port = value.port;
      this._socket = value.socket;
      this._transport = value.transport;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port - computed: false, optional: true, required: false
  private _port?: string; 
  public get port() {
    return this.getStringAttribute('port');
  }
  public set port(value: string) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // socket - computed: false, optional: true, required: false
  private _socket?: string; 
  public get socket() {
    return this.getStringAttribute('socket');
  }
  public set socket(value: string) {
    this._socket = value;
  }
  public resetSocket() {
    this._socket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketInput() {
    return this._socket;
  }

  // transport - computed: false, optional: true, required: false
  private _transport?: string; 
  public get transport() {
    return this.getStringAttribute('transport');
  }
  public set transport(value: string) {
    this._transport = value;
  }
  public resetTransport() {
    this._transport = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get transportInput() {
    return this._transport;
  }
}

export class DomainDevicesDisksMirrorSourceNetworkHostsList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksMirrorSourceNetworkHosts[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksMirrorSourceNetworkHostsOutputReference {
    return new DomainDevicesDisksMirrorSourceNetworkHostsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksMirrorSourceNetworkIdentity {
  /**
  * Sets the path to a local agent socket used for external authentication (for example, SASL or SSH agent) when connecting to the network backing store; value is a user-provided Unix socket path.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#agent_sock Domain#agent_sock}
  */
  readonly agentSock?: string;
  /**
  * Sets the group name to use for authentication or access control when connecting to the network backing store; value is user-provided and protocol-specific.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#group Domain#group}
  */
  readonly group?: string;
  /**
  * Sets the path to a private key file used for authenticating to the network backing store (for example, an SSH or TLS key); value is a user-provided filesystem path.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#keyfile Domain#keyfile}
  */
  readonly keyfile?: string;
  /**
  * Sets the user identifier used for authentication to the network backing store; value is user-provided and typically matches a remote account name.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#user Domain#user}
  */
  readonly user?: string;
  /**
  * Sets an explicit username string used for authentication to the network backing store, separate from any other user identity settings; value is user-provided (for example, "backupuser").
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#user_name Domain#user_name}
  */
  readonly userName?: string;
}

export function domainDevicesDisksMirrorSourceNetworkIdentityToTerraform(struct?: DomainDevicesDisksMirrorSourceNetworkIdentity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    agent_sock: cdktf.stringToTerraform(struct!.agentSock),
    group: cdktf.stringToTerraform(struct!.group),
    keyfile: cdktf.stringToTerraform(struct!.keyfile),
    user: cdktf.stringToTerraform(struct!.user),
    user_name: cdktf.stringToTerraform(struct!.userName),
  }
}


export function domainDevicesDisksMirrorSourceNetworkIdentityToHclTerraform(struct?: DomainDevicesDisksMirrorSourceNetworkIdentity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    agent_sock: {
      value: cdktf.stringToHclTerraform(struct!.agentSock),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    group: {
      value: cdktf.stringToHclTerraform(struct!.group),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keyfile: {
      value: cdktf.stringToHclTerraform(struct!.keyfile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user: {
      value: cdktf.stringToHclTerraform(struct!.user),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user_name: {
      value: cdktf.stringToHclTerraform(struct!.userName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceNetworkIdentityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceNetworkIdentity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._agentSock !== undefined) {
      hasAnyValues = true;
      internalValueResult.agentSock = this._agentSock;
    }
    if (this._group !== undefined) {
      hasAnyValues = true;
      internalValueResult.group = this._group;
    }
    if (this._keyfile !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyfile = this._keyfile;
    }
    if (this._user !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user;
    }
    if (this._userName !== undefined) {
      hasAnyValues = true;
      internalValueResult.userName = this._userName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceNetworkIdentity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._agentSock = undefined;
      this._group = undefined;
      this._keyfile = undefined;
      this._user = undefined;
      this._userName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._agentSock = value.agentSock;
      this._group = value.group;
      this._keyfile = value.keyfile;
      this._user = value.user;
      this._userName = value.userName;
    }
  }

  // agent_sock - computed: false, optional: true, required: false
  private _agentSock?: string; 
  public get agentSock() {
    return this.getStringAttribute('agent_sock');
  }
  public set agentSock(value: string) {
    this._agentSock = value;
  }
  public resetAgentSock() {
    this._agentSock = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get agentSockInput() {
    return this._agentSock;
  }

  // group - computed: false, optional: true, required: false
  private _group?: string; 
  public get group() {
    return this.getStringAttribute('group');
  }
  public set group(value: string) {
    this._group = value;
  }
  public resetGroup() {
    this._group = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupInput() {
    return this._group;
  }

  // keyfile - computed: false, optional: true, required: false
  private _keyfile?: string; 
  public get keyfile() {
    return this.getStringAttribute('keyfile');
  }
  public set keyfile(value: string) {
    this._keyfile = value;
  }
  public resetKeyfile() {
    this._keyfile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyfileInput() {
    return this._keyfile;
  }

  // user - computed: false, optional: true, required: false
  private _user?: string; 
  public get user() {
    return this.getStringAttribute('user');
  }
  public set user(value: string) {
    this._user = value;
  }
  public resetUser() {
    this._user = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user;
  }

  // user_name - computed: false, optional: true, required: false
  private _userName?: string; 
  public get userName() {
    return this.getStringAttribute('user_name');
  }
  public set userName(value: string) {
    this._userName = value;
  }
  public resetUserName() {
    this._userName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userNameInput() {
    return this._userName;
  }
}
export interface DomainDevicesDisksMirrorSourceNetworkInitiatorIqn {
  /**
  * Sets the initiator IQN string used when logging into an iSCSI target backing the mirrored disk; value must be a valid IQN (for example, iqn.2020-01.com.example:host1).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name?: string;
}

export function domainDevicesDisksMirrorSourceNetworkInitiatorIqnToTerraform(struct?: DomainDevicesDisksMirrorSourceNetworkInitiatorIqn | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function domainDevicesDisksMirrorSourceNetworkInitiatorIqnToHclTerraform(struct?: DomainDevicesDisksMirrorSourceNetworkInitiatorIqn | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceNetworkInitiatorIqnOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceNetworkInitiatorIqn | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceNetworkInitiatorIqn | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DomainDevicesDisksMirrorSourceNetworkInitiator {
  /**
  * Configures the iSCSI initiator IQN block for the mirrored network backing store, defining the initiator name presented to the target.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#iqn Domain#iqn}
  */
  readonly iqn?: DomainDevicesDisksMirrorSourceNetworkInitiatorIqn;
}

export function domainDevicesDisksMirrorSourceNetworkInitiatorToTerraform(struct?: DomainDevicesDisksMirrorSourceNetworkInitiator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    iqn: domainDevicesDisksMirrorSourceNetworkInitiatorIqnToTerraform(struct!.iqn),
  }
}


export function domainDevicesDisksMirrorSourceNetworkInitiatorToHclTerraform(struct?: DomainDevicesDisksMirrorSourceNetworkInitiator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    iqn: {
      value: domainDevicesDisksMirrorSourceNetworkInitiatorIqnToHclTerraform(struct!.iqn),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceNetworkInitiatorIqn",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceNetworkInitiatorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceNetworkInitiator | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._iqn?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.iqn = this._iqn?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceNetworkInitiator | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._iqn.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._iqn.internalValue = value.iqn;
    }
  }

  // iqn - computed: false, optional: true, required: false
  private _iqn = new DomainDevicesDisksMirrorSourceNetworkInitiatorIqnOutputReference(this, "iqn");
  public get iqn() {
    return this._iqn;
  }
  public putIqn(value: DomainDevicesDisksMirrorSourceNetworkInitiatorIqn) {
    this._iqn.internalValue = value;
  }
  public resetIqn() {
    this._iqn.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get iqnInput() {
    return this._iqn.internalValue;
  }
}
export interface DomainDevicesDisksMirrorSourceNetworkKnownHosts {
  /**
  * Sets the path to the known-hosts file used to verify the identity of the remote storage host; value is a required user-provided filesystem path (for example, /etc/libvirt/known_hosts).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
}

export function domainDevicesDisksMirrorSourceNetworkKnownHostsToTerraform(struct?: DomainDevicesDisksMirrorSourceNetworkKnownHosts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function domainDevicesDisksMirrorSourceNetworkKnownHostsToHclTerraform(struct?: DomainDevicesDisksMirrorSourceNetworkKnownHosts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceNetworkKnownHostsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceNetworkKnownHosts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceNetworkKnownHosts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface DomainDevicesDisksMirrorSourceNetworkReconnect {
  /**
  * Sets the reconnection delay (in seconds) before retrying a failed connection to the mirrored network backing store; value is a required user-provided non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#delay Domain#delay}
  */
  readonly delay: string;
}

export function domainDevicesDisksMirrorSourceNetworkReconnectToTerraform(struct?: DomainDevicesDisksMirrorSourceNetworkReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    delay: cdktf.stringToTerraform(struct!.delay),
  }
}


export function domainDevicesDisksMirrorSourceNetworkReconnectToHclTerraform(struct?: DomainDevicesDisksMirrorSourceNetworkReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    delay: {
      value: cdktf.stringToHclTerraform(struct!.delay),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceNetworkReconnectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceNetworkReconnect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._delay !== undefined) {
      hasAnyValues = true;
      internalValueResult.delay = this._delay;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceNetworkReconnect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._delay = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._delay = value.delay;
    }
  }

  // delay - computed: false, optional: false, required: true
  private _delay?: string; 
  public get delay() {
    return this.getStringAttribute('delay');
  }
  public set delay(value: string) {
    this._delay = value;
  }
  // Temporarily expose input value. Use with caution.
  public get delayInput() {
    return this._delay;
  }
}
export interface DomainDevicesDisksMirrorSourceNetworkSnapshot {
  /**
  * Sets the name of the network snapshot to use as the backing store for the mirrored disk’s network source; value is user-provided and must match an existing snapshot identifier on the storage backend.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
}

export function domainDevicesDisksMirrorSourceNetworkSnapshotToTerraform(struct?: DomainDevicesDisksMirrorSourceNetworkSnapshot | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function domainDevicesDisksMirrorSourceNetworkSnapshotToHclTerraform(struct?: DomainDevicesDisksMirrorSourceNetworkSnapshot | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceNetworkSnapshotOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceNetworkSnapshot | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceNetworkSnapshot | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DomainDevicesDisksMirrorSourceNetwork {
  /**
  * Configures CHAP authentication parameters for the iSCSI source backing an assigned SCSI host device; include this block only when the target requires authentication.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#auth Domain#auth}
  */
  readonly auth?: DomainDevicesDisksMirrorSourceNetworkAuth;
  /**
  * Points to an external configuration source for the network backing store (for example, an RBD or Ceph config file) that libvirt passes to the backend.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#config Domain#config}
  */
  readonly config?: DomainDevicesDisksMirrorSourceNetworkConfig;
  /**
  * Declares one or more network endpoints (hosts) for the backing store server, each with its own name/address and possibly additional attributes.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#hosts Domain#hosts}
  */
  readonly hosts?: DomainDevicesDisksMirrorSourceNetworkHosts[] | cdktf.IResolvable;
  /**
  * Configures authentication/identity parameters used when accessing the mirrored backing store over a network, such as user, group, keyfile, or agent socket, depending on the protocol.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#identity Domain#identity}
  */
  readonly identity?: DomainDevicesDisksMirrorSourceNetworkIdentity;
  /**
  * Configures initiator identity information (typically for iSCSI-like protocols) used when accessing the mirrored network backing store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#initiator Domain#initiator}
  */
  readonly initiator?: DomainDevicesDisksMirrorSourceNetworkInitiator;
  /**
  * Enables use of a known-hosts file to validate the remote host’s identity when connecting to the mirrored network backing store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#known_hosts Domain#known_hosts}
  */
  readonly knownHosts?: DomainDevicesDisksMirrorSourceNetworkKnownHosts;
  /**
  * Sets a name for the network source of the mirrored backing store, typically used by certain protocols (such as RBD pool or NBD export names); value is user-provided and protocol-specific.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name?: string;
  /**
  * Sets the network storage protocol used for the mirrored backing store; value is user-provided but must be a protocol supported by libvirt for network disks (for example, rbd, sheepdog, gluster, nbd).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#protocol Domain#protocol}
  */
  readonly protocol?: string;
  /**
  * Sets an optional query string or subresource specifier for the network storage URL of the mirrored backing store; value is user-provided and protocol-specific.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#query Domain#query}
  */
  readonly query?: string;
  /**
  * Configures automatic reconnection behavior for the mirrored network backing store after a connection loss.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reconnect Domain#reconnect}
  */
  readonly reconnect?: DomainDevicesDisksMirrorSourceNetworkReconnect;
  /**
  * Configures snapshot-related behavior for the network-based mirrored backing store, with semantics depending on the underlying protocol and storage implementation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#snapshot Domain#snapshot}
  */
  readonly snapshot?: DomainDevicesDisksMirrorSourceNetworkSnapshot;
  /**
  * Controls whether TLS is used for the mirrored disk’s network backing-store connection; value is user-provided and typically enabled only when the chosen protocol and backend support TLS.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tls Domain#tls}
  */
  readonly tls?: string;
  /**
  * Sets the expected TLS hostname for the mirrored disk’s network backing-store connection, used for certificate verification; value is user-provided and should match the server certificate’s hostname (for example, "storage.example.com").
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tls_hostname Domain#tls_hostname}
  */
  readonly tlsHostname?: string;
}

export function domainDevicesDisksMirrorSourceNetworkToTerraform(struct?: DomainDevicesDisksMirrorSourceNetwork | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: domainDevicesDisksMirrorSourceNetworkAuthToTerraform(struct!.auth),
    config: domainDevicesDisksMirrorSourceNetworkConfigToTerraform(struct!.config),
    hosts: cdktf.listMapper(domainDevicesDisksMirrorSourceNetworkHostsToTerraform, false)(struct!.hosts),
    identity: domainDevicesDisksMirrorSourceNetworkIdentityToTerraform(struct!.identity),
    initiator: domainDevicesDisksMirrorSourceNetworkInitiatorToTerraform(struct!.initiator),
    known_hosts: domainDevicesDisksMirrorSourceNetworkKnownHostsToTerraform(struct!.knownHosts),
    name: cdktf.stringToTerraform(struct!.name),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    query: cdktf.stringToTerraform(struct!.query),
    reconnect: domainDevicesDisksMirrorSourceNetworkReconnectToTerraform(struct!.reconnect),
    snapshot: domainDevicesDisksMirrorSourceNetworkSnapshotToTerraform(struct!.snapshot),
    tls: cdktf.stringToTerraform(struct!.tls),
    tls_hostname: cdktf.stringToTerraform(struct!.tlsHostname),
  }
}


export function domainDevicesDisksMirrorSourceNetworkToHclTerraform(struct?: DomainDevicesDisksMirrorSourceNetwork | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: domainDevicesDisksMirrorSourceNetworkAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceNetworkAuth",
    },
    config: {
      value: domainDevicesDisksMirrorSourceNetworkConfigToHclTerraform(struct!.config),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceNetworkConfig",
    },
    hosts: {
      value: cdktf.listMapperHcl(domainDevicesDisksMirrorSourceNetworkHostsToHclTerraform, false)(struct!.hosts),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksMirrorSourceNetworkHostsList",
    },
    identity: {
      value: domainDevicesDisksMirrorSourceNetworkIdentityToHclTerraform(struct!.identity),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceNetworkIdentity",
    },
    initiator: {
      value: domainDevicesDisksMirrorSourceNetworkInitiatorToHclTerraform(struct!.initiator),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceNetworkInitiator",
    },
    known_hosts: {
      value: domainDevicesDisksMirrorSourceNetworkKnownHostsToHclTerraform(struct!.knownHosts),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceNetworkKnownHosts",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    query: {
      value: cdktf.stringToHclTerraform(struct!.query),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reconnect: {
      value: domainDevicesDisksMirrorSourceNetworkReconnectToHclTerraform(struct!.reconnect),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceNetworkReconnect",
    },
    snapshot: {
      value: domainDevicesDisksMirrorSourceNetworkSnapshotToHclTerraform(struct!.snapshot),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceNetworkSnapshot",
    },
    tls: {
      value: cdktf.stringToHclTerraform(struct!.tls),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_hostname: {
      value: cdktf.stringToHclTerraform(struct!.tlsHostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceNetworkOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceNetwork | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._config?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.config = this._config?.internalValue;
    }
    if (this._hosts?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hosts = this._hosts?.internalValue;
    }
    if (this._identity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.identity = this._identity?.internalValue;
    }
    if (this._initiator?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.initiator = this._initiator?.internalValue;
    }
    if (this._knownHosts?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.knownHosts = this._knownHosts?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._query !== undefined) {
      hasAnyValues = true;
      internalValueResult.query = this._query;
    }
    if (this._reconnect?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.reconnect = this._reconnect?.internalValue;
    }
    if (this._snapshot?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.snapshot = this._snapshot?.internalValue;
    }
    if (this._tls !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls;
    }
    if (this._tlsHostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsHostname = this._tlsHostname;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceNetwork | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._config.internalValue = undefined;
      this._hosts.internalValue = undefined;
      this._identity.internalValue = undefined;
      this._initiator.internalValue = undefined;
      this._knownHosts.internalValue = undefined;
      this._name = undefined;
      this._protocol = undefined;
      this._query = undefined;
      this._reconnect.internalValue = undefined;
      this._snapshot.internalValue = undefined;
      this._tls = undefined;
      this._tlsHostname = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._config.internalValue = value.config;
      this._hosts.internalValue = value.hosts;
      this._identity.internalValue = value.identity;
      this._initiator.internalValue = value.initiator;
      this._knownHosts.internalValue = value.knownHosts;
      this._name = value.name;
      this._protocol = value.protocol;
      this._query = value.query;
      this._reconnect.internalValue = value.reconnect;
      this._snapshot.internalValue = value.snapshot;
      this._tls = value.tls;
      this._tlsHostname = value.tlsHostname;
    }
  }

  // auth - computed: false, optional: true, required: false
  private _auth = new DomainDevicesDisksMirrorSourceNetworkAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DomainDevicesDisksMirrorSourceNetworkAuth) {
    this._auth.internalValue = value;
  }
  public resetAuth() {
    this._auth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // config - computed: false, optional: true, required: false
  private _config = new DomainDevicesDisksMirrorSourceNetworkConfigOutputReference(this, "config");
  public get config() {
    return this._config;
  }
  public putConfig(value: DomainDevicesDisksMirrorSourceNetworkConfig) {
    this._config.internalValue = value;
  }
  public resetConfig() {
    this._config.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configInput() {
    return this._config.internalValue;
  }

  // hosts - computed: false, optional: true, required: false
  private _hosts = new DomainDevicesDisksMirrorSourceNetworkHostsList(this, "hosts", false);
  public get hosts() {
    return this._hosts;
  }
  public putHosts(value: DomainDevicesDisksMirrorSourceNetworkHosts[] | cdktf.IResolvable) {
    this._hosts.internalValue = value;
  }
  public resetHosts() {
    this._hosts.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostsInput() {
    return this._hosts.internalValue;
  }

  // identity - computed: false, optional: true, required: false
  private _identity = new DomainDevicesDisksMirrorSourceNetworkIdentityOutputReference(this, "identity");
  public get identity() {
    return this._identity;
  }
  public putIdentity(value: DomainDevicesDisksMirrorSourceNetworkIdentity) {
    this._identity.internalValue = value;
  }
  public resetIdentity() {
    this._identity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identityInput() {
    return this._identity.internalValue;
  }

  // initiator - computed: false, optional: true, required: false
  private _initiator = new DomainDevicesDisksMirrorSourceNetworkInitiatorOutputReference(this, "initiator");
  public get initiator() {
    return this._initiator;
  }
  public putInitiator(value: DomainDevicesDisksMirrorSourceNetworkInitiator) {
    this._initiator.internalValue = value;
  }
  public resetInitiator() {
    this._initiator.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initiatorInput() {
    return this._initiator.internalValue;
  }

  // known_hosts - computed: false, optional: true, required: false
  private _knownHosts = new DomainDevicesDisksMirrorSourceNetworkKnownHostsOutputReference(this, "known_hosts");
  public get knownHosts() {
    return this._knownHosts;
  }
  public putKnownHosts(value: DomainDevicesDisksMirrorSourceNetworkKnownHosts) {
    this._knownHosts.internalValue = value;
  }
  public resetKnownHosts() {
    this._knownHosts.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get knownHostsInput() {
    return this._knownHosts.internalValue;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // protocol - computed: false, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // query - computed: false, optional: true, required: false
  private _query?: string; 
  public get query() {
    return this.getStringAttribute('query');
  }
  public set query(value: string) {
    this._query = value;
  }
  public resetQuery() {
    this._query = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queryInput() {
    return this._query;
  }

  // reconnect - computed: false, optional: true, required: false
  private _reconnect = new DomainDevicesDisksMirrorSourceNetworkReconnectOutputReference(this, "reconnect");
  public get reconnect() {
    return this._reconnect;
  }
  public putReconnect(value: DomainDevicesDisksMirrorSourceNetworkReconnect) {
    this._reconnect.internalValue = value;
  }
  public resetReconnect() {
    this._reconnect.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reconnectInput() {
    return this._reconnect.internalValue;
  }

  // snapshot - computed: false, optional: true, required: false
  private _snapshot = new DomainDevicesDisksMirrorSourceNetworkSnapshotOutputReference(this, "snapshot");
  public get snapshot() {
    return this._snapshot;
  }
  public putSnapshot(value: DomainDevicesDisksMirrorSourceNetworkSnapshot) {
    this._snapshot.internalValue = value;
  }
  public resetSnapshot() {
    this._snapshot.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get snapshotInput() {
    return this._snapshot.internalValue;
  }

  // tls - computed: false, optional: true, required: false
  private _tls?: string; 
  public get tls() {
    return this.getStringAttribute('tls');
  }
  public set tls(value: string) {
    this._tls = value;
  }
  public resetTls() {
    this._tls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls;
  }

  // tls_hostname - computed: false, optional: true, required: false
  private _tlsHostname?: string; 
  public get tlsHostname() {
    return this.getStringAttribute('tls_hostname');
  }
  public set tlsHostname(value: string) {
    this._tlsHostname = value;
  }
  public resetTlsHostname() {
    this._tlsHostname = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsHostnameInput() {
    return this._tlsHostname;
  }
}
export interface DomainDevicesDisksMirrorSourceNvme {
}

export function domainDevicesDisksMirrorSourceNvmeToTerraform(struct?: DomainDevicesDisksMirrorSourceNvme | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function domainDevicesDisksMirrorSourceNvmeToHclTerraform(struct?: DomainDevicesDisksMirrorSourceNvme | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DomainDevicesDisksMirrorSourceNvmeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceNvme | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceNvme | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DomainDevicesDisksMirrorSourceReadahead {
  /**
  * Sets the read-ahead size for the mirrored disk’s backing store; value is a user-provided positive integer in bytes (for example, 65536 for 64 KiB).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#size Domain#size}
  */
  readonly size: string;
}

export function domainDevicesDisksMirrorSourceReadaheadToTerraform(struct?: DomainDevicesDisksMirrorSourceReadahead | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    size: cdktf.stringToTerraform(struct!.size),
  }
}


export function domainDevicesDisksMirrorSourceReadaheadToHclTerraform(struct?: DomainDevicesDisksMirrorSourceReadahead | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    size: {
      value: cdktf.stringToHclTerraform(struct!.size),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceReadaheadOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceReadahead | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._size !== undefined) {
      hasAnyValues = true;
      internalValueResult.size = this._size;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceReadahead | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._size = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._size = value.size;
    }
  }

  // size - computed: false, optional: false, required: true
  private _size?: string; 
  public get size() {
    return this.getStringAttribute('size');
  }
  public set size(value: string) {
    this._size = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sizeInput() {
    return this._size;
  }
}
export interface DomainDevicesDisksMirrorSourceReservationsSourceDbus {
  /**
  * Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#channel Domain#channel}
  */
  readonly channel?: string;
}

export function domainDevicesDisksMirrorSourceReservationsSourceDbusToTerraform(struct?: DomainDevicesDisksMirrorSourceReservationsSourceDbus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    channel: cdktf.stringToTerraform(struct!.channel),
  }
}


export function domainDevicesDisksMirrorSourceReservationsSourceDbusToHclTerraform(struct?: DomainDevicesDisksMirrorSourceReservationsSourceDbus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    channel: {
      value: cdktf.stringToHclTerraform(struct!.channel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceReservationsSourceDbusOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceReservationsSourceDbus | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._channel !== undefined) {
      hasAnyValues = true;
      internalValueResult.channel = this._channel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceReservationsSourceDbus | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._channel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._channel = value.channel;
    }
  }

  // channel - computed: false, optional: true, required: false
  private _channel?: string; 
  public get channel() {
    return this.getStringAttribute('channel');
  }
  public set channel(value: string) {
    this._channel = value;
  }
  public resetChannel() {
    this._channel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get channelInput() {
    return this._channel;
  }
}
export interface DomainDevicesDisksMirrorSourceReservationsSourceDevSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksMirrorSourceReservationsSourceDevSecLabelToTerraform(struct?: DomainDevicesDisksMirrorSourceReservationsSourceDevSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksMirrorSourceReservationsSourceDevSecLabelToHclTerraform(struct?: DomainDevicesDisksMirrorSourceReservationsSourceDevSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceReservationsSourceDevSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceReservationsSourceDevSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceReservationsSourceDevSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksMirrorSourceReservationsSourceDevSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksMirrorSourceReservationsSourceDevSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksMirrorSourceReservationsSourceDevSecLabelOutputReference {
    return new DomainDevicesDisksMirrorSourceReservationsSourceDevSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksMirrorSourceReservationsSourceDev {
  /**
  * Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksMirrorSourceReservationsSourceDevSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksMirrorSourceReservationsSourceDevToTerraform(struct?: DomainDevicesDisksMirrorSourceReservationsSourceDev | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesDisksMirrorSourceReservationsSourceDevSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksMirrorSourceReservationsSourceDevToHclTerraform(struct?: DomainDevicesDisksMirrorSourceReservationsSourceDev | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksMirrorSourceReservationsSourceDevSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksMirrorSourceReservationsSourceDevSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceReservationsSourceDevOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceReservationsSourceDev | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceReservationsSourceDev | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksMirrorSourceReservationsSourceDevSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksMirrorSourceReservationsSourceDevSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksMirrorSourceReservationsSourceFileSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksMirrorSourceReservationsSourceFileSecLabelToTerraform(struct?: DomainDevicesDisksMirrorSourceReservationsSourceFileSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksMirrorSourceReservationsSourceFileSecLabelToHclTerraform(struct?: DomainDevicesDisksMirrorSourceReservationsSourceFileSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceReservationsSourceFileSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceReservationsSourceFileSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceReservationsSourceFileSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksMirrorSourceReservationsSourceFileSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksMirrorSourceReservationsSourceFileSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksMirrorSourceReservationsSourceFileSecLabelOutputReference {
    return new DomainDevicesDisksMirrorSourceReservationsSourceFileSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksMirrorSourceReservationsSourceFile {
  /**
  * Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.
  * 
  * See: <https://libvirt.org/formatdomain.html#device-logfile>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#append Domain#append}
  */
  readonly append?: string;
  /**
  * Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksMirrorSourceReservationsSourceFileSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksMirrorSourceReservationsSourceFileToTerraform(struct?: DomainDevicesDisksMirrorSourceReservationsSourceFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.stringToTerraform(struct!.append),
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesDisksMirrorSourceReservationsSourceFileSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksMirrorSourceReservationsSourceFileToHclTerraform(struct?: DomainDevicesDisksMirrorSourceReservationsSourceFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.stringToHclTerraform(struct!.append),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksMirrorSourceReservationsSourceFileSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksMirrorSourceReservationsSourceFileSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceReservationsSourceFileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceReservationsSourceFile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceReservationsSourceFile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append = value.append;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append?: string; 
  public get append() {
    return this.getStringAttribute('append');
  }
  public set append(value: string) {
    this._append = value;
  }
  public resetAppend() {
    this._append = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append;
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksMirrorSourceReservationsSourceFileSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksMirrorSourceReservationsSourceFileSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksMirrorSourceReservationsSourceNmdm {
  /**
  * Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.
  * 
  * See: <https://libvirt.org/formatdomain.html#nmdm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#master Domain#master}
  */
  readonly master: string;
  /**
  * Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.
  * 
  * See: <https://libvirt.org/formatdomain.html#nmdm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#slave Domain#slave}
  */
  readonly slave: string;
}

export function domainDevicesDisksMirrorSourceReservationsSourceNmdmToTerraform(struct?: DomainDevicesDisksMirrorSourceReservationsSourceNmdm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    master: cdktf.stringToTerraform(struct!.master),
    slave: cdktf.stringToTerraform(struct!.slave),
  }
}


export function domainDevicesDisksMirrorSourceReservationsSourceNmdmToHclTerraform(struct?: DomainDevicesDisksMirrorSourceReservationsSourceNmdm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    master: {
      value: cdktf.stringToHclTerraform(struct!.master),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    slave: {
      value: cdktf.stringToHclTerraform(struct!.slave),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceReservationsSourceNmdmOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceReservationsSourceNmdm | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._master !== undefined) {
      hasAnyValues = true;
      internalValueResult.master = this._master;
    }
    if (this._slave !== undefined) {
      hasAnyValues = true;
      internalValueResult.slave = this._slave;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceReservationsSourceNmdm | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._master = undefined;
      this._slave = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._master = value.master;
      this._slave = value.slave;
    }
  }

  // master - computed: false, optional: false, required: true
  private _master?: string; 
  public get master() {
    return this.getStringAttribute('master');
  }
  public set master(value: string) {
    this._master = value;
  }
  // Temporarily expose input value. Use with caution.
  public get masterInput() {
    return this._master;
  }

  // slave - computed: false, optional: false, required: true
  private _slave?: string; 
  public get slave() {
    return this.getStringAttribute('slave');
  }
  public set slave(value: string) {
    this._slave = value;
  }
  // Temporarily expose input value. Use with caution.
  public get slaveInput() {
    return this._slave;
  }
}
export interface DomainDevicesDisksMirrorSourceReservationsSourcePipeSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksMirrorSourceReservationsSourcePipeSecLabelToTerraform(struct?: DomainDevicesDisksMirrorSourceReservationsSourcePipeSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksMirrorSourceReservationsSourcePipeSecLabelToHclTerraform(struct?: DomainDevicesDisksMirrorSourceReservationsSourcePipeSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceReservationsSourcePipeSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceReservationsSourcePipeSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceReservationsSourcePipeSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksMirrorSourceReservationsSourcePipeSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksMirrorSourceReservationsSourcePipeSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksMirrorSourceReservationsSourcePipeSecLabelOutputReference {
    return new DomainDevicesDisksMirrorSourceReservationsSourcePipeSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksMirrorSourceReservationsSourcePipe {
  /**
  * Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksMirrorSourceReservationsSourcePipeSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksMirrorSourceReservationsSourcePipeToTerraform(struct?: DomainDevicesDisksMirrorSourceReservationsSourcePipe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesDisksMirrorSourceReservationsSourcePipeSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksMirrorSourceReservationsSourcePipeToHclTerraform(struct?: DomainDevicesDisksMirrorSourceReservationsSourcePipe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksMirrorSourceReservationsSourcePipeSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksMirrorSourceReservationsSourcePipeSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceReservationsSourcePipeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceReservationsSourcePipe | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceReservationsSourcePipe | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksMirrorSourceReservationsSourcePipeSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksMirrorSourceReservationsSourcePipeSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksMirrorSourceReservationsSourcePtySecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksMirrorSourceReservationsSourcePtySecLabelToTerraform(struct?: DomainDevicesDisksMirrorSourceReservationsSourcePtySecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksMirrorSourceReservationsSourcePtySecLabelToHclTerraform(struct?: DomainDevicesDisksMirrorSourceReservationsSourcePtySecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceReservationsSourcePtySecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceReservationsSourcePtySecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceReservationsSourcePtySecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksMirrorSourceReservationsSourcePtySecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksMirrorSourceReservationsSourcePtySecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksMirrorSourceReservationsSourcePtySecLabelOutputReference {
    return new DomainDevicesDisksMirrorSourceReservationsSourcePtySecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksMirrorSourceReservationsSourcePty {
  /**
  * Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksMirrorSourceReservationsSourcePtySecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksMirrorSourceReservationsSourcePtyToTerraform(struct?: DomainDevicesDisksMirrorSourceReservationsSourcePty | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesDisksMirrorSourceReservationsSourcePtySecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksMirrorSourceReservationsSourcePtyToHclTerraform(struct?: DomainDevicesDisksMirrorSourceReservationsSourcePty | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksMirrorSourceReservationsSourcePtySecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksMirrorSourceReservationsSourcePtySecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceReservationsSourcePtyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceReservationsSourcePty | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceReservationsSourcePty | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksMirrorSourceReservationsSourcePtySecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksMirrorSourceReservationsSourcePtySecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksMirrorSourceReservationsSourceQemuvdAgentClipBoard {
  /**
  * Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#copy_paste Domain#copy_paste}
  */
  readonly copyPaste: string;
}

export function domainDevicesDisksMirrorSourceReservationsSourceQemuvdAgentClipBoardToTerraform(struct?: DomainDevicesDisksMirrorSourceReservationsSourceQemuvdAgentClipBoard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    copy_paste: cdktf.stringToTerraform(struct!.copyPaste),
  }
}


export function domainDevicesDisksMirrorSourceReservationsSourceQemuvdAgentClipBoardToHclTerraform(struct?: DomainDevicesDisksMirrorSourceReservationsSourceQemuvdAgentClipBoard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    copy_paste: {
      value: cdktf.stringToHclTerraform(struct!.copyPaste),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceReservationsSourceQemuvdAgentClipBoardOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceReservationsSourceQemuvdAgentClipBoard | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._copyPaste !== undefined) {
      hasAnyValues = true;
      internalValueResult.copyPaste = this._copyPaste;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceReservationsSourceQemuvdAgentClipBoard | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._copyPaste = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._copyPaste = value.copyPaste;
    }
  }

  // copy_paste - computed: false, optional: false, required: true
  private _copyPaste?: string; 
  public get copyPaste() {
    return this.getStringAttribute('copy_paste');
  }
  public set copyPaste(value: string) {
    this._copyPaste = value;
  }
  // Temporarily expose input value. Use with caution.
  public get copyPasteInput() {
    return this._copyPaste;
  }
}
export interface DomainDevicesDisksMirrorSourceReservationsSourceQemuvdAgentMouse {
  /**
  * Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).
  * 
  * See: <https://libvirt.org/formatdomain.html#channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode: string;
}

export function domainDevicesDisksMirrorSourceReservationsSourceQemuvdAgentMouseToTerraform(struct?: DomainDevicesDisksMirrorSourceReservationsSourceQemuvdAgentMouse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
  }
}


export function domainDevicesDisksMirrorSourceReservationsSourceQemuvdAgentMouseToHclTerraform(struct?: DomainDevicesDisksMirrorSourceReservationsSourceQemuvdAgentMouse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceReservationsSourceQemuvdAgentMouseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceReservationsSourceQemuvdAgentMouse | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceReservationsSourceQemuvdAgentMouse | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
    }
  }

  // mode - computed: false, optional: false, required: true
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }
}
export interface DomainDevicesDisksMirrorSourceReservationsSourceQemuvdAgent {
  /**
  * Configures clipboard-related behavior for the QEMU vdagent–based EGD source, controlling whether clipboard data exchange is allowed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#clip_board Domain#clip_board}
  */
  readonly clipBoard?: DomainDevicesDisksMirrorSourceReservationsSourceQemuvdAgentClipBoard;
  /**
  * Configures mouse integration options for the QEMU vdagent–based EGD source, such as how mouse events are handled.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mouse Domain#mouse}
  */
  readonly mouse?: DomainDevicesDisksMirrorSourceReservationsSourceQemuvdAgentMouse;
}

export function domainDevicesDisksMirrorSourceReservationsSourceQemuvdAgentToTerraform(struct?: DomainDevicesDisksMirrorSourceReservationsSourceQemuvdAgent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    clip_board: domainDevicesDisksMirrorSourceReservationsSourceQemuvdAgentClipBoardToTerraform(struct!.clipBoard),
    mouse: domainDevicesDisksMirrorSourceReservationsSourceQemuvdAgentMouseToTerraform(struct!.mouse),
  }
}


export function domainDevicesDisksMirrorSourceReservationsSourceQemuvdAgentToHclTerraform(struct?: DomainDevicesDisksMirrorSourceReservationsSourceQemuvdAgent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    clip_board: {
      value: domainDevicesDisksMirrorSourceReservationsSourceQemuvdAgentClipBoardToHclTerraform(struct!.clipBoard),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceReservationsSourceQemuvdAgentClipBoard",
    },
    mouse: {
      value: domainDevicesDisksMirrorSourceReservationsSourceQemuvdAgentMouseToHclTerraform(struct!.mouse),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceReservationsSourceQemuvdAgentMouse",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceReservationsSourceQemuvdAgentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceReservationsSourceQemuvdAgent | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clipBoard?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clipBoard = this._clipBoard?.internalValue;
    }
    if (this._mouse?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.mouse = this._mouse?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceReservationsSourceQemuvdAgent | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clipBoard.internalValue = undefined;
      this._mouse.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clipBoard.internalValue = value.clipBoard;
      this._mouse.internalValue = value.mouse;
    }
  }

  // clip_board - computed: false, optional: true, required: false
  private _clipBoard = new DomainDevicesDisksMirrorSourceReservationsSourceQemuvdAgentClipBoardOutputReference(this, "clip_board");
  public get clipBoard() {
    return this._clipBoard;
  }
  public putClipBoard(value: DomainDevicesDisksMirrorSourceReservationsSourceQemuvdAgentClipBoard) {
    this._clipBoard.internalValue = value;
  }
  public resetClipBoard() {
    this._clipBoard.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clipBoardInput() {
    return this._clipBoard.internalValue;
  }

  // mouse - computed: false, optional: true, required: false
  private _mouse = new DomainDevicesDisksMirrorSourceReservationsSourceQemuvdAgentMouseOutputReference(this, "mouse");
  public get mouse() {
    return this._mouse;
  }
  public putMouse(value: DomainDevicesDisksMirrorSourceReservationsSourceQemuvdAgentMouse) {
    this._mouse.internalValue = value;
  }
  public resetMouse() {
    this._mouse.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mouseInput() {
    return this._mouse.internalValue;
  }
}
export interface DomainDevicesDisksMirrorSourceReservationsSourceSpicePort {
  /**
  * Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#channel Domain#channel}
  */
  readonly channel: string;
}

export function domainDevicesDisksMirrorSourceReservationsSourceSpicePortToTerraform(struct?: DomainDevicesDisksMirrorSourceReservationsSourceSpicePort | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    channel: cdktf.stringToTerraform(struct!.channel),
  }
}


export function domainDevicesDisksMirrorSourceReservationsSourceSpicePortToHclTerraform(struct?: DomainDevicesDisksMirrorSourceReservationsSourceSpicePort | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    channel: {
      value: cdktf.stringToHclTerraform(struct!.channel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceReservationsSourceSpicePortOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceReservationsSourceSpicePort | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._channel !== undefined) {
      hasAnyValues = true;
      internalValueResult.channel = this._channel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceReservationsSourceSpicePort | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._channel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._channel = value.channel;
    }
  }

  // channel - computed: false, optional: false, required: true
  private _channel?: string; 
  public get channel() {
    return this.getStringAttribute('channel');
  }
  public set channel(value: string) {
    this._channel = value;
  }
  // Temporarily expose input value. Use with caution.
  public get channelInput() {
    return this._channel;
  }
}
export interface DomainDevicesDisksMirrorSourceReservationsSourceTcpReconnect {
  /**
  * Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enabled Domain#enabled}
  */
  readonly enabled: string;
  /**
  * Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#timeout Domain#timeout}
  */
  readonly timeout?: number;
}

export function domainDevicesDisksMirrorSourceReservationsSourceTcpReconnectToTerraform(struct?: DomainDevicesDisksMirrorSourceReservationsSourceTcpReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.stringToTerraform(struct!.enabled),
    timeout: cdktf.numberToTerraform(struct!.timeout),
  }
}


export function domainDevicesDisksMirrorSourceReservationsSourceTcpReconnectToHclTerraform(struct?: DomainDevicesDisksMirrorSourceReservationsSourceTcpReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.stringToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.numberToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceReservationsSourceTcpReconnectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceReservationsSourceTcpReconnect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceReservationsSourceTcpReconnect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._timeout = value.timeout;
    }
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: string; 
  public get enabled() {
    return this.getStringAttribute('enabled');
  }
  public set enabled(value: string) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: number; 
  public get timeout() {
    return this.getNumberAttribute('timeout');
  }
  public set timeout(value: number) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DomainDevicesDisksMirrorSourceReservationsSourceTcp {
  /**
  * Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#host Domain#host}
  */
  readonly host?: string;
  /**
  * Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode?: string;
  /**
  * Enables and configures automatic reconnection behavior for a UNIX socket–based EGD entropy source; the content and attributes are user-provided according to desired policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reconnect Domain#reconnect}
  */
  readonly reconnect?: DomainDevicesDisksMirrorSourceReservationsSourceTcpReconnect;
  /**
  * Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#service Domain#service}
  */
  readonly service?: string;
  /**
  * Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tls Domain#tls}
  */
  readonly tls?: string;
}

export function domainDevicesDisksMirrorSourceReservationsSourceTcpToTerraform(struct?: DomainDevicesDisksMirrorSourceReservationsSourceTcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    mode: cdktf.stringToTerraform(struct!.mode),
    reconnect: domainDevicesDisksMirrorSourceReservationsSourceTcpReconnectToTerraform(struct!.reconnect),
    service: cdktf.stringToTerraform(struct!.service),
    tls: cdktf.stringToTerraform(struct!.tls),
  }
}


export function domainDevicesDisksMirrorSourceReservationsSourceTcpToHclTerraform(struct?: DomainDevicesDisksMirrorSourceReservationsSourceTcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reconnect: {
      value: domainDevicesDisksMirrorSourceReservationsSourceTcpReconnectToHclTerraform(struct!.reconnect),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceReservationsSourceTcpReconnect",
    },
    service: {
      value: cdktf.stringToHclTerraform(struct!.service),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: cdktf.stringToHclTerraform(struct!.tls),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceReservationsSourceTcpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceReservationsSourceTcp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._reconnect?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.reconnect = this._reconnect?.internalValue;
    }
    if (this._service !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service;
    }
    if (this._tls !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceReservationsSourceTcp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host = undefined;
      this._mode = undefined;
      this._reconnect.internalValue = undefined;
      this._service = undefined;
      this._tls = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host = value.host;
      this._mode = value.mode;
      this._reconnect.internalValue = value.reconnect;
      this._service = value.service;
      this._tls = value.tls;
    }
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // reconnect - computed: false, optional: true, required: false
  private _reconnect = new DomainDevicesDisksMirrorSourceReservationsSourceTcpReconnectOutputReference(this, "reconnect");
  public get reconnect() {
    return this._reconnect;
  }
  public putReconnect(value: DomainDevicesDisksMirrorSourceReservationsSourceTcpReconnect) {
    this._reconnect.internalValue = value;
  }
  public resetReconnect() {
    this._reconnect.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reconnectInput() {
    return this._reconnect.internalValue;
  }

  // service - computed: false, optional: true, required: false
  private _service?: string; 
  public get service() {
    return this.getStringAttribute('service');
  }
  public set service(value: string) {
    this._service = value;
  }
  public resetService() {
    this._service = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service;
  }

  // tls - computed: false, optional: true, required: false
  private _tls?: string; 
  public get tls() {
    return this.getStringAttribute('tls');
  }
  public set tls(value: string) {
    this._tls = value;
  }
  public resetTls() {
    this._tls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls;
  }
}
export interface DomainDevicesDisksMirrorSourceReservationsSourceUdp {
  /**
  * Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bind_host Domain#bind_host}
  */
  readonly bindHost: string;
  /**
  * Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bind_service Domain#bind_service}
  */
  readonly bindService: string;
  /**
  * Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#connect_host Domain#connect_host}
  */
  readonly connectHost: string;
  /**
  * Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#connect_service Domain#connect_service}
  */
  readonly connectService: string;
}

export function domainDevicesDisksMirrorSourceReservationsSourceUdpToTerraform(struct?: DomainDevicesDisksMirrorSourceReservationsSourceUdp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_host: cdktf.stringToTerraform(struct!.bindHost),
    bind_service: cdktf.stringToTerraform(struct!.bindService),
    connect_host: cdktf.stringToTerraform(struct!.connectHost),
    connect_service: cdktf.stringToTerraform(struct!.connectService),
  }
}


export function domainDevicesDisksMirrorSourceReservationsSourceUdpToHclTerraform(struct?: DomainDevicesDisksMirrorSourceReservationsSourceUdp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_host: {
      value: cdktf.stringToHclTerraform(struct!.bindHost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bind_service: {
      value: cdktf.stringToHclTerraform(struct!.bindService),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connect_host: {
      value: cdktf.stringToHclTerraform(struct!.connectHost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connect_service: {
      value: cdktf.stringToHclTerraform(struct!.connectService),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceReservationsSourceUdpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceReservationsSourceUdp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindHost !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindHost = this._bindHost;
    }
    if (this._bindService !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindService = this._bindService;
    }
    if (this._connectHost !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectHost = this._connectHost;
    }
    if (this._connectService !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectService = this._connectService;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceReservationsSourceUdp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bindHost = undefined;
      this._bindService = undefined;
      this._connectHost = undefined;
      this._connectService = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bindHost = value.bindHost;
      this._bindService = value.bindService;
      this._connectHost = value.connectHost;
      this._connectService = value.connectService;
    }
  }

  // bind_host - computed: false, optional: false, required: true
  private _bindHost?: string; 
  public get bindHost() {
    return this.getStringAttribute('bind_host');
  }
  public set bindHost(value: string) {
    this._bindHost = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bindHostInput() {
    return this._bindHost;
  }

  // bind_service - computed: false, optional: false, required: true
  private _bindService?: string; 
  public get bindService() {
    return this.getStringAttribute('bind_service');
  }
  public set bindService(value: string) {
    this._bindService = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bindServiceInput() {
    return this._bindService;
  }

  // connect_host - computed: false, optional: false, required: true
  private _connectHost?: string; 
  public get connectHost() {
    return this.getStringAttribute('connect_host');
  }
  public set connectHost(value: string) {
    this._connectHost = value;
  }
  // Temporarily expose input value. Use with caution.
  public get connectHostInput() {
    return this._connectHost;
  }

  // connect_service - computed: false, optional: false, required: true
  private _connectService?: string; 
  public get connectService() {
    return this.getStringAttribute('connect_service');
  }
  public set connectService(value: string) {
    this._connectService = value;
  }
  // Temporarily expose input value. Use with caution.
  public get connectServiceInput() {
    return this._connectService;
  }
}
export interface DomainDevicesDisksMirrorSourceReservationsSourceUnixReconnect {
  /**
  * Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enabled Domain#enabled}
  */
  readonly enabled: string;
  /**
  * Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#timeout Domain#timeout}
  */
  readonly timeout?: number;
}

export function domainDevicesDisksMirrorSourceReservationsSourceUnixReconnectToTerraform(struct?: DomainDevicesDisksMirrorSourceReservationsSourceUnixReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.stringToTerraform(struct!.enabled),
    timeout: cdktf.numberToTerraform(struct!.timeout),
  }
}


export function domainDevicesDisksMirrorSourceReservationsSourceUnixReconnectToHclTerraform(struct?: DomainDevicesDisksMirrorSourceReservationsSourceUnixReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.stringToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.numberToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceReservationsSourceUnixReconnectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceReservationsSourceUnixReconnect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceReservationsSourceUnixReconnect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._timeout = value.timeout;
    }
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: string; 
  public get enabled() {
    return this.getStringAttribute('enabled');
  }
  public set enabled(value: string) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: number; 
  public get timeout() {
    return this.getNumberAttribute('timeout');
  }
  public set timeout(value: number) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DomainDevicesDisksMirrorSourceReservationsSourceUnixSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksMirrorSourceReservationsSourceUnixSecLabelToTerraform(struct?: DomainDevicesDisksMirrorSourceReservationsSourceUnixSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksMirrorSourceReservationsSourceUnixSecLabelToHclTerraform(struct?: DomainDevicesDisksMirrorSourceReservationsSourceUnixSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceReservationsSourceUnixSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceReservationsSourceUnixSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceReservationsSourceUnixSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksMirrorSourceReservationsSourceUnixSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksMirrorSourceReservationsSourceUnixSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksMirrorSourceReservationsSourceUnixSecLabelOutputReference {
    return new DomainDevicesDisksMirrorSourceReservationsSourceUnixSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksMirrorSourceReservationsSourceUnix {
  /**
  * Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode?: string;
  /**
  * Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path?: string;
  /**
  * Enables and configures automatic reconnection behavior for a UNIX socket–based EGD entropy source; the content and attributes are user-provided according to desired policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reconnect Domain#reconnect}
  */
  readonly reconnect?: DomainDevicesDisksMirrorSourceReservationsSourceUnixReconnect;
  /**
  * Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksMirrorSourceReservationsSourceUnixSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksMirrorSourceReservationsSourceUnixToTerraform(struct?: DomainDevicesDisksMirrorSourceReservationsSourceUnix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
    reconnect: domainDevicesDisksMirrorSourceReservationsSourceUnixReconnectToTerraform(struct!.reconnect),
    sec_label: cdktf.listMapper(domainDevicesDisksMirrorSourceReservationsSourceUnixSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksMirrorSourceReservationsSourceUnixToHclTerraform(struct?: DomainDevicesDisksMirrorSourceReservationsSourceUnix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reconnect: {
      value: domainDevicesDisksMirrorSourceReservationsSourceUnixReconnectToHclTerraform(struct!.reconnect),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceReservationsSourceUnixReconnect",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksMirrorSourceReservationsSourceUnixSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksMirrorSourceReservationsSourceUnixSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceReservationsSourceUnixOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceReservationsSourceUnix | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._reconnect?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.reconnect = this._reconnect?.internalValue;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceReservationsSourceUnix | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
      this._path = undefined;
      this._reconnect.internalValue = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
      this._path = value.path;
      this._reconnect.internalValue = value.reconnect;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // reconnect - computed: false, optional: true, required: false
  private _reconnect = new DomainDevicesDisksMirrorSourceReservationsSourceUnixReconnectOutputReference(this, "reconnect");
  public get reconnect() {
    return this._reconnect;
  }
  public putReconnect(value: DomainDevicesDisksMirrorSourceReservationsSourceUnixReconnect) {
    this._reconnect.internalValue = value;
  }
  public resetReconnect() {
    this._reconnect.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reconnectInput() {
    return this._reconnect.internalValue;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksMirrorSourceReservationsSourceUnixSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksMirrorSourceReservationsSourceUnixSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksMirrorSourceReservationsSource {
  /**
  * Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dbus Domain#dbus}
  */
  readonly dbus?: DomainDevicesDisksMirrorSourceReservationsSourceDbus;
  /**
  * Configures an EGD RNG backend that reads entropy from a host character device node.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dev Domain#dev}
  */
  readonly dev?: DomainDevicesDisksMirrorSourceReservationsSourceDev;
  /**
  * Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file?: DomainDevicesDisksMirrorSourceReservationsSourceFile;
  /**
  * Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#nmdm Domain#nmdm}
  */
  readonly nmdm?: DomainDevicesDisksMirrorSourceReservationsSourceNmdm;
  /**
  * Enables use of a null character device as the reservation backing source; when this boolean is true, a Null source is emitted and all written data is discarded.
  * 
  * See: <https://libvirt.org/formatdomain.html#null-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#null Domain#null}
  */
  readonly null?: boolean | cdktf.IResolvable;
  /**
  * Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pipe Domain#pipe}
  */
  readonly pipe?: DomainDevicesDisksMirrorSourceReservationsSourcePipe;
  /**
  * Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pty Domain#pty}
  */
  readonly pty?: DomainDevicesDisksMirrorSourceReservationsSourcePty;
  /**
  * Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#qemuvd_agent Domain#qemuvd_agent}
  */
  readonly qemuvdAgent?: DomainDevicesDisksMirrorSourceReservationsSourceQemuvdAgent;
  /**
  * Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#spice_port Domain#spice_port}
  */
  readonly spicePort?: DomainDevicesDisksMirrorSourceReservationsSourceSpicePort;
  /**
  * Enables a SPICE VMC (SPICE management channel) backend for this backing-store source; when set true the element is emitted, when false or null it is omitted.
  * 
  * See: <https://libvirt.org/formatdomain.html#spice-channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#spice_vmc Domain#spice_vmc}
  */
  readonly spiceVmc?: boolean | cdktf.IResolvable;
  /**
  * Connects the backing-store source’s character channel to the domain’s standard I/O (stdin/stdout/stderr); when true the element is emitted, when false or null it is omitted.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-interface>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#std_io Domain#std_io}
  */
  readonly stdIo?: boolean | cdktf.IResolvable;
  /**
  * Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tcp Domain#tcp}
  */
  readonly tcp?: DomainDevicesDisksMirrorSourceReservationsSourceTcp;
  /**
  * Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#udp Domain#udp}
  */
  readonly udp?: DomainDevicesDisksMirrorSourceReservationsSourceUdp;
  /**
  * Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#unix Domain#unix}
  */
  readonly unix?: DomainDevicesDisksMirrorSourceReservationsSourceUnix;
  /**
  * Enables use of a VC (virtual cluster or vendor-specific) reservation source when set; since this is presence-based, setting it to true emits the element and false/null omits it.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vc Domain#vc}
  */
  readonly vc?: boolean | cdktf.IResolvable;
}

export function domainDevicesDisksMirrorSourceReservationsSourceToTerraform(struct?: DomainDevicesDisksMirrorSourceReservationsSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dbus: domainDevicesDisksMirrorSourceReservationsSourceDbusToTerraform(struct!.dbus),
    dev: domainDevicesDisksMirrorSourceReservationsSourceDevToTerraform(struct!.dev),
    file: domainDevicesDisksMirrorSourceReservationsSourceFileToTerraform(struct!.file),
    nmdm: domainDevicesDisksMirrorSourceReservationsSourceNmdmToTerraform(struct!.nmdm),
    null: cdktf.booleanToTerraform(struct!.null),
    pipe: domainDevicesDisksMirrorSourceReservationsSourcePipeToTerraform(struct!.pipe),
    pty: domainDevicesDisksMirrorSourceReservationsSourcePtyToTerraform(struct!.pty),
    qemuvd_agent: domainDevicesDisksMirrorSourceReservationsSourceQemuvdAgentToTerraform(struct!.qemuvdAgent),
    spice_port: domainDevicesDisksMirrorSourceReservationsSourceSpicePortToTerraform(struct!.spicePort),
    spice_vmc: cdktf.booleanToTerraform(struct!.spiceVmc),
    std_io: cdktf.booleanToTerraform(struct!.stdIo),
    tcp: domainDevicesDisksMirrorSourceReservationsSourceTcpToTerraform(struct!.tcp),
    udp: domainDevicesDisksMirrorSourceReservationsSourceUdpToTerraform(struct!.udp),
    unix: domainDevicesDisksMirrorSourceReservationsSourceUnixToTerraform(struct!.unix),
    vc: cdktf.booleanToTerraform(struct!.vc),
  }
}


export function domainDevicesDisksMirrorSourceReservationsSourceToHclTerraform(struct?: DomainDevicesDisksMirrorSourceReservationsSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dbus: {
      value: domainDevicesDisksMirrorSourceReservationsSourceDbusToHclTerraform(struct!.dbus),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceReservationsSourceDbus",
    },
    dev: {
      value: domainDevicesDisksMirrorSourceReservationsSourceDevToHclTerraform(struct!.dev),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceReservationsSourceDev",
    },
    file: {
      value: domainDevicesDisksMirrorSourceReservationsSourceFileToHclTerraform(struct!.file),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceReservationsSourceFile",
    },
    nmdm: {
      value: domainDevicesDisksMirrorSourceReservationsSourceNmdmToHclTerraform(struct!.nmdm),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceReservationsSourceNmdm",
    },
    null: {
      value: cdktf.booleanToHclTerraform(struct!.null),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    pipe: {
      value: domainDevicesDisksMirrorSourceReservationsSourcePipeToHclTerraform(struct!.pipe),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceReservationsSourcePipe",
    },
    pty: {
      value: domainDevicesDisksMirrorSourceReservationsSourcePtyToHclTerraform(struct!.pty),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceReservationsSourcePty",
    },
    qemuvd_agent: {
      value: domainDevicesDisksMirrorSourceReservationsSourceQemuvdAgentToHclTerraform(struct!.qemuvdAgent),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceReservationsSourceQemuvdAgent",
    },
    spice_port: {
      value: domainDevicesDisksMirrorSourceReservationsSourceSpicePortToHclTerraform(struct!.spicePort),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceReservationsSourceSpicePort",
    },
    spice_vmc: {
      value: cdktf.booleanToHclTerraform(struct!.spiceVmc),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    std_io: {
      value: cdktf.booleanToHclTerraform(struct!.stdIo),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tcp: {
      value: domainDevicesDisksMirrorSourceReservationsSourceTcpToHclTerraform(struct!.tcp),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceReservationsSourceTcp",
    },
    udp: {
      value: domainDevicesDisksMirrorSourceReservationsSourceUdpToHclTerraform(struct!.udp),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceReservationsSourceUdp",
    },
    unix: {
      value: domainDevicesDisksMirrorSourceReservationsSourceUnixToHclTerraform(struct!.unix),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceReservationsSourceUnix",
    },
    vc: {
      value: cdktf.booleanToHclTerraform(struct!.vc),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceReservationsSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceReservationsSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dbus?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dbus = this._dbus?.internalValue;
    }
    if (this._dev?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dev = this._dev?.internalValue;
    }
    if (this._file?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file?.internalValue;
    }
    if (this._nmdm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nmdm = this._nmdm?.internalValue;
    }
    if (this._null !== undefined) {
      hasAnyValues = true;
      internalValueResult.null = this._null;
    }
    if (this._pipe?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipe = this._pipe?.internalValue;
    }
    if (this._pty?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pty = this._pty?.internalValue;
    }
    if (this._qemuvdAgent?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.qemuvdAgent = this._qemuvdAgent?.internalValue;
    }
    if (this._spicePort?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spicePort = this._spicePort?.internalValue;
    }
    if (this._spiceVmc !== undefined) {
      hasAnyValues = true;
      internalValueResult.spiceVmc = this._spiceVmc;
    }
    if (this._stdIo !== undefined) {
      hasAnyValues = true;
      internalValueResult.stdIo = this._stdIo;
    }
    if (this._tcp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tcp = this._tcp?.internalValue;
    }
    if (this._udp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.udp = this._udp?.internalValue;
    }
    if (this._unix?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.unix = this._unix?.internalValue;
    }
    if (this._vc !== undefined) {
      hasAnyValues = true;
      internalValueResult.vc = this._vc;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceReservationsSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dbus.internalValue = undefined;
      this._dev.internalValue = undefined;
      this._file.internalValue = undefined;
      this._nmdm.internalValue = undefined;
      this._null = undefined;
      this._pipe.internalValue = undefined;
      this._pty.internalValue = undefined;
      this._qemuvdAgent.internalValue = undefined;
      this._spicePort.internalValue = undefined;
      this._spiceVmc = undefined;
      this._stdIo = undefined;
      this._tcp.internalValue = undefined;
      this._udp.internalValue = undefined;
      this._unix.internalValue = undefined;
      this._vc = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dbus.internalValue = value.dbus;
      this._dev.internalValue = value.dev;
      this._file.internalValue = value.file;
      this._nmdm.internalValue = value.nmdm;
      this._null = value.null;
      this._pipe.internalValue = value.pipe;
      this._pty.internalValue = value.pty;
      this._qemuvdAgent.internalValue = value.qemuvdAgent;
      this._spicePort.internalValue = value.spicePort;
      this._spiceVmc = value.spiceVmc;
      this._stdIo = value.stdIo;
      this._tcp.internalValue = value.tcp;
      this._udp.internalValue = value.udp;
      this._unix.internalValue = value.unix;
      this._vc = value.vc;
    }
  }

  // dbus - computed: false, optional: true, required: false
  private _dbus = new DomainDevicesDisksMirrorSourceReservationsSourceDbusOutputReference(this, "dbus");
  public get dbus() {
    return this._dbus;
  }
  public putDbus(value: DomainDevicesDisksMirrorSourceReservationsSourceDbus) {
    this._dbus.internalValue = value;
  }
  public resetDbus() {
    this._dbus.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dbusInput() {
    return this._dbus.internalValue;
  }

  // dev - computed: false, optional: true, required: false
  private _dev = new DomainDevicesDisksMirrorSourceReservationsSourceDevOutputReference(this, "dev");
  public get dev() {
    return this._dev;
  }
  public putDev(value: DomainDevicesDisksMirrorSourceReservationsSourceDev) {
    this._dev.internalValue = value;
  }
  public resetDev() {
    this._dev.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devInput() {
    return this._dev.internalValue;
  }

  // file - computed: false, optional: true, required: false
  private _file = new DomainDevicesDisksMirrorSourceReservationsSourceFileOutputReference(this, "file");
  public get file() {
    return this._file;
  }
  public putFile(value: DomainDevicesDisksMirrorSourceReservationsSourceFile) {
    this._file.internalValue = value;
  }
  public resetFile() {
    this._file.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file.internalValue;
  }

  // nmdm - computed: false, optional: true, required: false
  private _nmdm = new DomainDevicesDisksMirrorSourceReservationsSourceNmdmOutputReference(this, "nmdm");
  public get nmdm() {
    return this._nmdm;
  }
  public putNmdm(value: DomainDevicesDisksMirrorSourceReservationsSourceNmdm) {
    this._nmdm.internalValue = value;
  }
  public resetNmdm() {
    this._nmdm.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nmdmInput() {
    return this._nmdm.internalValue;
  }

  // null - computed: false, optional: true, required: false
  private _null?: boolean | cdktf.IResolvable; 
  public get null() {
    return this.getBooleanAttribute('null');
  }
  public set null(value: boolean | cdktf.IResolvable) {
    this._null = value;
  }
  public resetNull() {
    this._null = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nullInput() {
    return this._null;
  }

  // pipe - computed: false, optional: true, required: false
  private _pipe = new DomainDevicesDisksMirrorSourceReservationsSourcePipeOutputReference(this, "pipe");
  public get pipe() {
    return this._pipe;
  }
  public putPipe(value: DomainDevicesDisksMirrorSourceReservationsSourcePipe) {
    this._pipe.internalValue = value;
  }
  public resetPipe() {
    this._pipe.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipeInput() {
    return this._pipe.internalValue;
  }

  // pty - computed: false, optional: true, required: false
  private _pty = new DomainDevicesDisksMirrorSourceReservationsSourcePtyOutputReference(this, "pty");
  public get pty() {
    return this._pty;
  }
  public putPty(value: DomainDevicesDisksMirrorSourceReservationsSourcePty) {
    this._pty.internalValue = value;
  }
  public resetPty() {
    this._pty.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ptyInput() {
    return this._pty.internalValue;
  }

  // qemuvd_agent - computed: false, optional: true, required: false
  private _qemuvdAgent = new DomainDevicesDisksMirrorSourceReservationsSourceQemuvdAgentOutputReference(this, "qemuvd_agent");
  public get qemuvdAgent() {
    return this._qemuvdAgent;
  }
  public putQemuvdAgent(value: DomainDevicesDisksMirrorSourceReservationsSourceQemuvdAgent) {
    this._qemuvdAgent.internalValue = value;
  }
  public resetQemuvdAgent() {
    this._qemuvdAgent.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get qemuvdAgentInput() {
    return this._qemuvdAgent.internalValue;
  }

  // spice_port - computed: false, optional: true, required: false
  private _spicePort = new DomainDevicesDisksMirrorSourceReservationsSourceSpicePortOutputReference(this, "spice_port");
  public get spicePort() {
    return this._spicePort;
  }
  public putSpicePort(value: DomainDevicesDisksMirrorSourceReservationsSourceSpicePort) {
    this._spicePort.internalValue = value;
  }
  public resetSpicePort() {
    this._spicePort.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spicePortInput() {
    return this._spicePort.internalValue;
  }

  // spice_vmc - computed: false, optional: true, required: false
  private _spiceVmc?: boolean | cdktf.IResolvable; 
  public get spiceVmc() {
    return this.getBooleanAttribute('spice_vmc');
  }
  public set spiceVmc(value: boolean | cdktf.IResolvable) {
    this._spiceVmc = value;
  }
  public resetSpiceVmc() {
    this._spiceVmc = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spiceVmcInput() {
    return this._spiceVmc;
  }

  // std_io - computed: false, optional: true, required: false
  private _stdIo?: boolean | cdktf.IResolvable; 
  public get stdIo() {
    return this.getBooleanAttribute('std_io');
  }
  public set stdIo(value: boolean | cdktf.IResolvable) {
    this._stdIo = value;
  }
  public resetStdIo() {
    this._stdIo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stdIoInput() {
    return this._stdIo;
  }

  // tcp - computed: false, optional: true, required: false
  private _tcp = new DomainDevicesDisksMirrorSourceReservationsSourceTcpOutputReference(this, "tcp");
  public get tcp() {
    return this._tcp;
  }
  public putTcp(value: DomainDevicesDisksMirrorSourceReservationsSourceTcp) {
    this._tcp.internalValue = value;
  }
  public resetTcp() {
    this._tcp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tcpInput() {
    return this._tcp.internalValue;
  }

  // udp - computed: false, optional: true, required: false
  private _udp = new DomainDevicesDisksMirrorSourceReservationsSourceUdpOutputReference(this, "udp");
  public get udp() {
    return this._udp;
  }
  public putUdp(value: DomainDevicesDisksMirrorSourceReservationsSourceUdp) {
    this._udp.internalValue = value;
  }
  public resetUdp() {
    this._udp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get udpInput() {
    return this._udp.internalValue;
  }

  // unix - computed: false, optional: true, required: false
  private _unix = new DomainDevicesDisksMirrorSourceReservationsSourceUnixOutputReference(this, "unix");
  public get unix() {
    return this._unix;
  }
  public putUnix(value: DomainDevicesDisksMirrorSourceReservationsSourceUnix) {
    this._unix.internalValue = value;
  }
  public resetUnix() {
    this._unix.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unixInput() {
    return this._unix.internalValue;
  }

  // vc - computed: false, optional: true, required: false
  private _vc?: boolean | cdktf.IResolvable; 
  public get vc() {
    return this.getBooleanAttribute('vc');
  }
  public set vc(value: boolean | cdktf.IResolvable) {
    this._vc = value;
  }
  public resetVc() {
    this._vc = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vcInput() {
    return this._vc;
  }
}
export interface DomainDevicesDisksMirrorSourceReservations {
  /**
  * Controls whether persistent reservations are enabled for the mirrored disk’s backing-store source; value is user-provided and typically expects "yes" or "no" semantics per libvirt.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enabled Domain#enabled}
  */
  readonly enabled?: string;
  /**
  * Indicates whether reservations are managed by libvirt ("yes") or externally ("no"); value is provided as a string and translated to a boolean, with "yes" meaning true and "no" meaning false.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#managed Domain#managed}
  */
  readonly managed?: boolean | cdktf.IResolvable;
  /**
  * Selects the mechanism used to provide reservation control for the mirrored backing-store source, such as a D-Bus service or a device/file endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#source Domain#source}
  */
  readonly source?: DomainDevicesDisksMirrorSourceReservationsSource;
}

export function domainDevicesDisksMirrorSourceReservationsToTerraform(struct?: DomainDevicesDisksMirrorSourceReservations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.stringToTerraform(struct!.enabled),
    managed: cdktf.booleanToTerraform(struct!.managed),
    source: domainDevicesDisksMirrorSourceReservationsSourceToTerraform(struct!.source),
  }
}


export function domainDevicesDisksMirrorSourceReservationsToHclTerraform(struct?: DomainDevicesDisksMirrorSourceReservations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.stringToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    managed: {
      value: cdktf.booleanToHclTerraform(struct!.managed),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    source: {
      value: domainDevicesDisksMirrorSourceReservationsSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceReservationsSource",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceReservationsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceReservations | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._managed !== undefined) {
      hasAnyValues = true;
      internalValueResult.managed = this._managed;
    }
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceReservations | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._managed = undefined;
      this._source.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._managed = value.managed;
      this._source.internalValue = value.source;
    }
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: string; 
  public get enabled() {
    return this.getStringAttribute('enabled');
  }
  public set enabled(value: string) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // managed - computed: false, optional: true, required: false
  private _managed?: boolean | cdktf.IResolvable; 
  public get managed() {
    return this.getBooleanAttribute('managed');
  }
  public set managed(value: boolean | cdktf.IResolvable) {
    this._managed = value;
  }
  public resetManaged() {
    this._managed = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get managedInput() {
    return this._managed;
  }

  // source - computed: false, optional: true, required: false
  private _source = new DomainDevicesDisksMirrorSourceReservationsSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: DomainDevicesDisksMirrorSourceReservationsSource) {
    this._source.internalValue = value;
  }
  public resetSource() {
    this._source.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }
}
export interface DomainDevicesDisksMirrorSourceSlicesSlices {
  /**
  * Sets the starting offset (in bytes) of this slice within the underlying backing-store source; must be a non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#offset Domain#offset}
  */
  readonly offset: number;
  /**
  * Sets the size (in bytes) of this slice within the underlying backing-store source; must be a positive integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#size Domain#size}
  */
  readonly size: number;
  /**
  * Specifies the type of slice mapping to use for this range; the value is user‑provided and must match a type supported by the hypervisor (for example, a particular mapping or layout scheme).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type: string;
}

export function domainDevicesDisksMirrorSourceSlicesSlicesToTerraform(struct?: DomainDevicesDisksMirrorSourceSlicesSlices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    offset: cdktf.numberToTerraform(struct!.offset),
    size: cdktf.numberToTerraform(struct!.size),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function domainDevicesDisksMirrorSourceSlicesSlicesToHclTerraform(struct?: DomainDevicesDisksMirrorSourceSlicesSlices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    offset: {
      value: cdktf.numberToHclTerraform(struct!.offset),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    size: {
      value: cdktf.numberToHclTerraform(struct!.size),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceSlicesSlicesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceSlicesSlices | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._offset !== undefined) {
      hasAnyValues = true;
      internalValueResult.offset = this._offset;
    }
    if (this._size !== undefined) {
      hasAnyValues = true;
      internalValueResult.size = this._size;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceSlicesSlices | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._offset = undefined;
      this._size = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._offset = value.offset;
      this._size = value.size;
      this._type = value.type;
    }
  }

  // offset - computed: false, optional: false, required: true
  private _offset?: number; 
  public get offset() {
    return this.getNumberAttribute('offset');
  }
  public set offset(value: number) {
    this._offset = value;
  }
  // Temporarily expose input value. Use with caution.
  public get offsetInput() {
    return this._offset;
  }

  // size - computed: false, optional: false, required: true
  private _size?: number; 
  public get size() {
    return this.getNumberAttribute('size');
  }
  public set size(value: number) {
    this._size = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sizeInput() {
    return this._size;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}

export class DomainDevicesDisksMirrorSourceSlicesSlicesList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksMirrorSourceSlicesSlices[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksMirrorSourceSlicesSlicesOutputReference {
    return new DomainDevicesDisksMirrorSourceSlicesSlicesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksMirrorSourceSlices {
  /**
  * Configures one or more slices of the backing-store source, each describing a contiguous portion of the underlying device or file that is exposed through this mirror backing store.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#slices Domain#slices}
  */
  readonly slices?: DomainDevicesDisksMirrorSourceSlicesSlices[] | cdktf.IResolvable;
}

export function domainDevicesDisksMirrorSourceSlicesToTerraform(struct?: DomainDevicesDisksMirrorSourceSlices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    slices: cdktf.listMapper(domainDevicesDisksMirrorSourceSlicesSlicesToTerraform, false)(struct!.slices),
  }
}


export function domainDevicesDisksMirrorSourceSlicesToHclTerraform(struct?: DomainDevicesDisksMirrorSourceSlices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    slices: {
      value: cdktf.listMapperHcl(domainDevicesDisksMirrorSourceSlicesSlicesToHclTerraform, false)(struct!.slices),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksMirrorSourceSlicesSlicesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceSlicesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceSlices | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._slices?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.slices = this._slices?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceSlices | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._slices.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._slices.internalValue = value.slices;
    }
  }

  // slices - computed: false, optional: true, required: false
  private _slices = new DomainDevicesDisksMirrorSourceSlicesSlicesList(this, "slices", false);
  public get slices() {
    return this._slices;
  }
  public putSlices(value: DomainDevicesDisksMirrorSourceSlicesSlices[] | cdktf.IResolvable) {
    this._slices.internalValue = value;
  }
  public resetSlices() {
    this._slices.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get slicesInput() {
    return this._slices.internalValue;
  }
}
export interface DomainDevicesDisksMirrorSourceSsl {
  /**
  * Controls certificate verification for SSL/TLS access to the mirrored backing-store source; typical values are "yes" or "no" to enable or disable verification.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#verify Domain#verify}
  */
  readonly verify: string;
}

export function domainDevicesDisksMirrorSourceSslToTerraform(struct?: DomainDevicesDisksMirrorSourceSsl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    verify: cdktf.stringToTerraform(struct!.verify),
  }
}


export function domainDevicesDisksMirrorSourceSslToHclTerraform(struct?: DomainDevicesDisksMirrorSourceSsl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    verify: {
      value: cdktf.stringToHclTerraform(struct!.verify),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceSslOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceSsl | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._verify !== undefined) {
      hasAnyValues = true;
      internalValueResult.verify = this._verify;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceSsl | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._verify = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._verify = value.verify;
    }
  }

  // verify - computed: false, optional: false, required: true
  private _verify?: string; 
  public get verify() {
    return this.getStringAttribute('verify');
  }
  public set verify(value: string) {
    this._verify = value;
  }
  // Temporarily expose input value. Use with caution.
  public get verifyInput() {
    return this._verify;
  }
}
export interface DomainDevicesDisksMirrorSourceTimeout {
  /**
  * Sets the timeout duration in seconds for accessing the mirrored backing-store source; must be a non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#seconds Domain#seconds}
  */
  readonly seconds: string;
}

export function domainDevicesDisksMirrorSourceTimeoutToTerraform(struct?: DomainDevicesDisksMirrorSourceTimeout | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    seconds: cdktf.stringToTerraform(struct!.seconds),
  }
}


export function domainDevicesDisksMirrorSourceTimeoutToHclTerraform(struct?: DomainDevicesDisksMirrorSourceTimeout | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    seconds: {
      value: cdktf.stringToHclTerraform(struct!.seconds),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceTimeoutOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceTimeout | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._seconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.seconds = this._seconds;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceTimeout | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._seconds = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._seconds = value.seconds;
    }
  }

  // seconds - computed: false, optional: false, required: true
  private _seconds?: string; 
  public get seconds() {
    return this.getStringAttribute('seconds');
  }
  public set seconds(value: string) {
    this._seconds = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secondsInput() {
    return this._seconds;
  }
}
export interface DomainDevicesDisksMirrorSourceVhostUserDbus {
  /**
  * Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#channel Domain#channel}
  */
  readonly channel?: string;
}

export function domainDevicesDisksMirrorSourceVhostUserDbusToTerraform(struct?: DomainDevicesDisksMirrorSourceVhostUserDbus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    channel: cdktf.stringToTerraform(struct!.channel),
  }
}


export function domainDevicesDisksMirrorSourceVhostUserDbusToHclTerraform(struct?: DomainDevicesDisksMirrorSourceVhostUserDbus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    channel: {
      value: cdktf.stringToHclTerraform(struct!.channel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceVhostUserDbusOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceVhostUserDbus | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._channel !== undefined) {
      hasAnyValues = true;
      internalValueResult.channel = this._channel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceVhostUserDbus | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._channel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._channel = value.channel;
    }
  }

  // channel - computed: false, optional: true, required: false
  private _channel?: string; 
  public get channel() {
    return this.getStringAttribute('channel');
  }
  public set channel(value: string) {
    this._channel = value;
  }
  public resetChannel() {
    this._channel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get channelInput() {
    return this._channel;
  }
}
export interface DomainDevicesDisksMirrorSourceVhostUserDevSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksMirrorSourceVhostUserDevSecLabelToTerraform(struct?: DomainDevicesDisksMirrorSourceVhostUserDevSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksMirrorSourceVhostUserDevSecLabelToHclTerraform(struct?: DomainDevicesDisksMirrorSourceVhostUserDevSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceVhostUserDevSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceVhostUserDevSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceVhostUserDevSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksMirrorSourceVhostUserDevSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksMirrorSourceVhostUserDevSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksMirrorSourceVhostUserDevSecLabelOutputReference {
    return new DomainDevicesDisksMirrorSourceVhostUserDevSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksMirrorSourceVhostUserDev {
  /**
  * Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksMirrorSourceVhostUserDevSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksMirrorSourceVhostUserDevToTerraform(struct?: DomainDevicesDisksMirrorSourceVhostUserDev | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesDisksMirrorSourceVhostUserDevSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksMirrorSourceVhostUserDevToHclTerraform(struct?: DomainDevicesDisksMirrorSourceVhostUserDev | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksMirrorSourceVhostUserDevSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksMirrorSourceVhostUserDevSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceVhostUserDevOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceVhostUserDev | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceVhostUserDev | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksMirrorSourceVhostUserDevSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksMirrorSourceVhostUserDevSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksMirrorSourceVhostUserFileSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksMirrorSourceVhostUserFileSecLabelToTerraform(struct?: DomainDevicesDisksMirrorSourceVhostUserFileSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksMirrorSourceVhostUserFileSecLabelToHclTerraform(struct?: DomainDevicesDisksMirrorSourceVhostUserFileSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceVhostUserFileSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceVhostUserFileSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceVhostUserFileSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksMirrorSourceVhostUserFileSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksMirrorSourceVhostUserFileSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksMirrorSourceVhostUserFileSecLabelOutputReference {
    return new DomainDevicesDisksMirrorSourceVhostUserFileSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksMirrorSourceVhostUserFile {
  /**
  * Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.
  * 
  * See: <https://libvirt.org/formatdomain.html#device-logfile>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#append Domain#append}
  */
  readonly append?: string;
  /**
  * Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksMirrorSourceVhostUserFileSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksMirrorSourceVhostUserFileToTerraform(struct?: DomainDevicesDisksMirrorSourceVhostUserFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.stringToTerraform(struct!.append),
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesDisksMirrorSourceVhostUserFileSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksMirrorSourceVhostUserFileToHclTerraform(struct?: DomainDevicesDisksMirrorSourceVhostUserFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.stringToHclTerraform(struct!.append),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksMirrorSourceVhostUserFileSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksMirrorSourceVhostUserFileSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceVhostUserFileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceVhostUserFile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceVhostUserFile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append = value.append;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append?: string; 
  public get append() {
    return this.getStringAttribute('append');
  }
  public set append(value: string) {
    this._append = value;
  }
  public resetAppend() {
    this._append = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append;
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksMirrorSourceVhostUserFileSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksMirrorSourceVhostUserFileSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksMirrorSourceVhostUserNmdm {
  /**
  * Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.
  * 
  * See: <https://libvirt.org/formatdomain.html#nmdm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#master Domain#master}
  */
  readonly master: string;
  /**
  * Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.
  * 
  * See: <https://libvirt.org/formatdomain.html#nmdm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#slave Domain#slave}
  */
  readonly slave: string;
}

export function domainDevicesDisksMirrorSourceVhostUserNmdmToTerraform(struct?: DomainDevicesDisksMirrorSourceVhostUserNmdm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    master: cdktf.stringToTerraform(struct!.master),
    slave: cdktf.stringToTerraform(struct!.slave),
  }
}


export function domainDevicesDisksMirrorSourceVhostUserNmdmToHclTerraform(struct?: DomainDevicesDisksMirrorSourceVhostUserNmdm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    master: {
      value: cdktf.stringToHclTerraform(struct!.master),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    slave: {
      value: cdktf.stringToHclTerraform(struct!.slave),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceVhostUserNmdmOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceVhostUserNmdm | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._master !== undefined) {
      hasAnyValues = true;
      internalValueResult.master = this._master;
    }
    if (this._slave !== undefined) {
      hasAnyValues = true;
      internalValueResult.slave = this._slave;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceVhostUserNmdm | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._master = undefined;
      this._slave = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._master = value.master;
      this._slave = value.slave;
    }
  }

  // master - computed: false, optional: false, required: true
  private _master?: string; 
  public get master() {
    return this.getStringAttribute('master');
  }
  public set master(value: string) {
    this._master = value;
  }
  // Temporarily expose input value. Use with caution.
  public get masterInput() {
    return this._master;
  }

  // slave - computed: false, optional: false, required: true
  private _slave?: string; 
  public get slave() {
    return this.getStringAttribute('slave');
  }
  public set slave(value: string) {
    this._slave = value;
  }
  // Temporarily expose input value. Use with caution.
  public get slaveInput() {
    return this._slave;
  }
}
export interface DomainDevicesDisksMirrorSourceVhostUserPipeSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksMirrorSourceVhostUserPipeSecLabelToTerraform(struct?: DomainDevicesDisksMirrorSourceVhostUserPipeSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksMirrorSourceVhostUserPipeSecLabelToHclTerraform(struct?: DomainDevicesDisksMirrorSourceVhostUserPipeSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceVhostUserPipeSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceVhostUserPipeSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceVhostUserPipeSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksMirrorSourceVhostUserPipeSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksMirrorSourceVhostUserPipeSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksMirrorSourceVhostUserPipeSecLabelOutputReference {
    return new DomainDevicesDisksMirrorSourceVhostUserPipeSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksMirrorSourceVhostUserPipe {
  /**
  * Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksMirrorSourceVhostUserPipeSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksMirrorSourceVhostUserPipeToTerraform(struct?: DomainDevicesDisksMirrorSourceVhostUserPipe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesDisksMirrorSourceVhostUserPipeSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksMirrorSourceVhostUserPipeToHclTerraform(struct?: DomainDevicesDisksMirrorSourceVhostUserPipe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksMirrorSourceVhostUserPipeSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksMirrorSourceVhostUserPipeSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceVhostUserPipeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceVhostUserPipe | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceVhostUserPipe | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksMirrorSourceVhostUserPipeSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksMirrorSourceVhostUserPipeSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksMirrorSourceVhostUserPtySecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksMirrorSourceVhostUserPtySecLabelToTerraform(struct?: DomainDevicesDisksMirrorSourceVhostUserPtySecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksMirrorSourceVhostUserPtySecLabelToHclTerraform(struct?: DomainDevicesDisksMirrorSourceVhostUserPtySecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceVhostUserPtySecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceVhostUserPtySecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceVhostUserPtySecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksMirrorSourceVhostUserPtySecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksMirrorSourceVhostUserPtySecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksMirrorSourceVhostUserPtySecLabelOutputReference {
    return new DomainDevicesDisksMirrorSourceVhostUserPtySecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksMirrorSourceVhostUserPty {
  /**
  * Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksMirrorSourceVhostUserPtySecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksMirrorSourceVhostUserPtyToTerraform(struct?: DomainDevicesDisksMirrorSourceVhostUserPty | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesDisksMirrorSourceVhostUserPtySecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksMirrorSourceVhostUserPtyToHclTerraform(struct?: DomainDevicesDisksMirrorSourceVhostUserPty | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksMirrorSourceVhostUserPtySecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksMirrorSourceVhostUserPtySecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceVhostUserPtyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceVhostUserPty | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceVhostUserPty | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksMirrorSourceVhostUserPtySecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksMirrorSourceVhostUserPtySecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksMirrorSourceVhostUserQemuvdAgentClipBoard {
  /**
  * Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#copy_paste Domain#copy_paste}
  */
  readonly copyPaste: string;
}

export function domainDevicesDisksMirrorSourceVhostUserQemuvdAgentClipBoardToTerraform(struct?: DomainDevicesDisksMirrorSourceVhostUserQemuvdAgentClipBoard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    copy_paste: cdktf.stringToTerraform(struct!.copyPaste),
  }
}


export function domainDevicesDisksMirrorSourceVhostUserQemuvdAgentClipBoardToHclTerraform(struct?: DomainDevicesDisksMirrorSourceVhostUserQemuvdAgentClipBoard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    copy_paste: {
      value: cdktf.stringToHclTerraform(struct!.copyPaste),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceVhostUserQemuvdAgentClipBoardOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceVhostUserQemuvdAgentClipBoard | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._copyPaste !== undefined) {
      hasAnyValues = true;
      internalValueResult.copyPaste = this._copyPaste;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceVhostUserQemuvdAgentClipBoard | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._copyPaste = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._copyPaste = value.copyPaste;
    }
  }

  // copy_paste - computed: false, optional: false, required: true
  private _copyPaste?: string; 
  public get copyPaste() {
    return this.getStringAttribute('copy_paste');
  }
  public set copyPaste(value: string) {
    this._copyPaste = value;
  }
  // Temporarily expose input value. Use with caution.
  public get copyPasteInput() {
    return this._copyPaste;
  }
}
export interface DomainDevicesDisksMirrorSourceVhostUserQemuvdAgentMouse {
  /**
  * Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).
  * 
  * See: <https://libvirt.org/formatdomain.html#channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode: string;
}

export function domainDevicesDisksMirrorSourceVhostUserQemuvdAgentMouseToTerraform(struct?: DomainDevicesDisksMirrorSourceVhostUserQemuvdAgentMouse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
  }
}


export function domainDevicesDisksMirrorSourceVhostUserQemuvdAgentMouseToHclTerraform(struct?: DomainDevicesDisksMirrorSourceVhostUserQemuvdAgentMouse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceVhostUserQemuvdAgentMouseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceVhostUserQemuvdAgentMouse | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceVhostUserQemuvdAgentMouse | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
    }
  }

  // mode - computed: false, optional: false, required: true
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }
}
export interface DomainDevicesDisksMirrorSourceVhostUserQemuvdAgent {
  /**
  * Configures clipboard-related behavior for the QEMU vdagent–based EGD source, controlling whether clipboard data exchange is allowed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#clip_board Domain#clip_board}
  */
  readonly clipBoard?: DomainDevicesDisksMirrorSourceVhostUserQemuvdAgentClipBoard;
  /**
  * Configures mouse integration options for the QEMU vdagent–based EGD source, such as how mouse events are handled.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mouse Domain#mouse}
  */
  readonly mouse?: DomainDevicesDisksMirrorSourceVhostUserQemuvdAgentMouse;
}

export function domainDevicesDisksMirrorSourceVhostUserQemuvdAgentToTerraform(struct?: DomainDevicesDisksMirrorSourceVhostUserQemuvdAgent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    clip_board: domainDevicesDisksMirrorSourceVhostUserQemuvdAgentClipBoardToTerraform(struct!.clipBoard),
    mouse: domainDevicesDisksMirrorSourceVhostUserQemuvdAgentMouseToTerraform(struct!.mouse),
  }
}


export function domainDevicesDisksMirrorSourceVhostUserQemuvdAgentToHclTerraform(struct?: DomainDevicesDisksMirrorSourceVhostUserQemuvdAgent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    clip_board: {
      value: domainDevicesDisksMirrorSourceVhostUserQemuvdAgentClipBoardToHclTerraform(struct!.clipBoard),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceVhostUserQemuvdAgentClipBoard",
    },
    mouse: {
      value: domainDevicesDisksMirrorSourceVhostUserQemuvdAgentMouseToHclTerraform(struct!.mouse),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceVhostUserQemuvdAgentMouse",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceVhostUserQemuvdAgentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceVhostUserQemuvdAgent | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clipBoard?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clipBoard = this._clipBoard?.internalValue;
    }
    if (this._mouse?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.mouse = this._mouse?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceVhostUserQemuvdAgent | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clipBoard.internalValue = undefined;
      this._mouse.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clipBoard.internalValue = value.clipBoard;
      this._mouse.internalValue = value.mouse;
    }
  }

  // clip_board - computed: false, optional: true, required: false
  private _clipBoard = new DomainDevicesDisksMirrorSourceVhostUserQemuvdAgentClipBoardOutputReference(this, "clip_board");
  public get clipBoard() {
    return this._clipBoard;
  }
  public putClipBoard(value: DomainDevicesDisksMirrorSourceVhostUserQemuvdAgentClipBoard) {
    this._clipBoard.internalValue = value;
  }
  public resetClipBoard() {
    this._clipBoard.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clipBoardInput() {
    return this._clipBoard.internalValue;
  }

  // mouse - computed: false, optional: true, required: false
  private _mouse = new DomainDevicesDisksMirrorSourceVhostUserQemuvdAgentMouseOutputReference(this, "mouse");
  public get mouse() {
    return this._mouse;
  }
  public putMouse(value: DomainDevicesDisksMirrorSourceVhostUserQemuvdAgentMouse) {
    this._mouse.internalValue = value;
  }
  public resetMouse() {
    this._mouse.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mouseInput() {
    return this._mouse.internalValue;
  }
}
export interface DomainDevicesDisksMirrorSourceVhostUserSpicePort {
  /**
  * Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#channel Domain#channel}
  */
  readonly channel: string;
}

export function domainDevicesDisksMirrorSourceVhostUserSpicePortToTerraform(struct?: DomainDevicesDisksMirrorSourceVhostUserSpicePort | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    channel: cdktf.stringToTerraform(struct!.channel),
  }
}


export function domainDevicesDisksMirrorSourceVhostUserSpicePortToHclTerraform(struct?: DomainDevicesDisksMirrorSourceVhostUserSpicePort | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    channel: {
      value: cdktf.stringToHclTerraform(struct!.channel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceVhostUserSpicePortOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceVhostUserSpicePort | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._channel !== undefined) {
      hasAnyValues = true;
      internalValueResult.channel = this._channel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceVhostUserSpicePort | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._channel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._channel = value.channel;
    }
  }

  // channel - computed: false, optional: false, required: true
  private _channel?: string; 
  public get channel() {
    return this.getStringAttribute('channel');
  }
  public set channel(value: string) {
    this._channel = value;
  }
  // Temporarily expose input value. Use with caution.
  public get channelInput() {
    return this._channel;
  }
}
export interface DomainDevicesDisksMirrorSourceVhostUserTcpReconnect {
  /**
  * Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enabled Domain#enabled}
  */
  readonly enabled: string;
  /**
  * Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#timeout Domain#timeout}
  */
  readonly timeout?: number;
}

export function domainDevicesDisksMirrorSourceVhostUserTcpReconnectToTerraform(struct?: DomainDevicesDisksMirrorSourceVhostUserTcpReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.stringToTerraform(struct!.enabled),
    timeout: cdktf.numberToTerraform(struct!.timeout),
  }
}


export function domainDevicesDisksMirrorSourceVhostUserTcpReconnectToHclTerraform(struct?: DomainDevicesDisksMirrorSourceVhostUserTcpReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.stringToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.numberToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceVhostUserTcpReconnectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceVhostUserTcpReconnect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceVhostUserTcpReconnect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._timeout = value.timeout;
    }
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: string; 
  public get enabled() {
    return this.getStringAttribute('enabled');
  }
  public set enabled(value: string) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: number; 
  public get timeout() {
    return this.getNumberAttribute('timeout');
  }
  public set timeout(value: number) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DomainDevicesDisksMirrorSourceVhostUserTcp {
  /**
  * Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#host Domain#host}
  */
  readonly host?: string;
  /**
  * Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode?: string;
  /**
  * Enables and configures automatic reconnection behavior for a UNIX socket–based EGD entropy source; the content and attributes are user-provided according to desired policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reconnect Domain#reconnect}
  */
  readonly reconnect?: DomainDevicesDisksMirrorSourceVhostUserTcpReconnect;
  /**
  * Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#service Domain#service}
  */
  readonly service?: string;
  /**
  * Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tls Domain#tls}
  */
  readonly tls?: string;
}

export function domainDevicesDisksMirrorSourceVhostUserTcpToTerraform(struct?: DomainDevicesDisksMirrorSourceVhostUserTcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    mode: cdktf.stringToTerraform(struct!.mode),
    reconnect: domainDevicesDisksMirrorSourceVhostUserTcpReconnectToTerraform(struct!.reconnect),
    service: cdktf.stringToTerraform(struct!.service),
    tls: cdktf.stringToTerraform(struct!.tls),
  }
}


export function domainDevicesDisksMirrorSourceVhostUserTcpToHclTerraform(struct?: DomainDevicesDisksMirrorSourceVhostUserTcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reconnect: {
      value: domainDevicesDisksMirrorSourceVhostUserTcpReconnectToHclTerraform(struct!.reconnect),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceVhostUserTcpReconnect",
    },
    service: {
      value: cdktf.stringToHclTerraform(struct!.service),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: cdktf.stringToHclTerraform(struct!.tls),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceVhostUserTcpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceVhostUserTcp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._reconnect?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.reconnect = this._reconnect?.internalValue;
    }
    if (this._service !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service;
    }
    if (this._tls !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceVhostUserTcp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host = undefined;
      this._mode = undefined;
      this._reconnect.internalValue = undefined;
      this._service = undefined;
      this._tls = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host = value.host;
      this._mode = value.mode;
      this._reconnect.internalValue = value.reconnect;
      this._service = value.service;
      this._tls = value.tls;
    }
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // reconnect - computed: false, optional: true, required: false
  private _reconnect = new DomainDevicesDisksMirrorSourceVhostUserTcpReconnectOutputReference(this, "reconnect");
  public get reconnect() {
    return this._reconnect;
  }
  public putReconnect(value: DomainDevicesDisksMirrorSourceVhostUserTcpReconnect) {
    this._reconnect.internalValue = value;
  }
  public resetReconnect() {
    this._reconnect.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reconnectInput() {
    return this._reconnect.internalValue;
  }

  // service - computed: false, optional: true, required: false
  private _service?: string; 
  public get service() {
    return this.getStringAttribute('service');
  }
  public set service(value: string) {
    this._service = value;
  }
  public resetService() {
    this._service = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service;
  }

  // tls - computed: false, optional: true, required: false
  private _tls?: string; 
  public get tls() {
    return this.getStringAttribute('tls');
  }
  public set tls(value: string) {
    this._tls = value;
  }
  public resetTls() {
    this._tls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls;
  }
}
export interface DomainDevicesDisksMirrorSourceVhostUserUdp {
  /**
  * Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bind_host Domain#bind_host}
  */
  readonly bindHost: string;
  /**
  * Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bind_service Domain#bind_service}
  */
  readonly bindService: string;
  /**
  * Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#connect_host Domain#connect_host}
  */
  readonly connectHost: string;
  /**
  * Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#connect_service Domain#connect_service}
  */
  readonly connectService: string;
}

export function domainDevicesDisksMirrorSourceVhostUserUdpToTerraform(struct?: DomainDevicesDisksMirrorSourceVhostUserUdp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_host: cdktf.stringToTerraform(struct!.bindHost),
    bind_service: cdktf.stringToTerraform(struct!.bindService),
    connect_host: cdktf.stringToTerraform(struct!.connectHost),
    connect_service: cdktf.stringToTerraform(struct!.connectService),
  }
}


export function domainDevicesDisksMirrorSourceVhostUserUdpToHclTerraform(struct?: DomainDevicesDisksMirrorSourceVhostUserUdp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_host: {
      value: cdktf.stringToHclTerraform(struct!.bindHost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bind_service: {
      value: cdktf.stringToHclTerraform(struct!.bindService),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connect_host: {
      value: cdktf.stringToHclTerraform(struct!.connectHost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connect_service: {
      value: cdktf.stringToHclTerraform(struct!.connectService),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceVhostUserUdpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceVhostUserUdp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindHost !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindHost = this._bindHost;
    }
    if (this._bindService !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindService = this._bindService;
    }
    if (this._connectHost !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectHost = this._connectHost;
    }
    if (this._connectService !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectService = this._connectService;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceVhostUserUdp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bindHost = undefined;
      this._bindService = undefined;
      this._connectHost = undefined;
      this._connectService = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bindHost = value.bindHost;
      this._bindService = value.bindService;
      this._connectHost = value.connectHost;
      this._connectService = value.connectService;
    }
  }

  // bind_host - computed: false, optional: false, required: true
  private _bindHost?: string; 
  public get bindHost() {
    return this.getStringAttribute('bind_host');
  }
  public set bindHost(value: string) {
    this._bindHost = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bindHostInput() {
    return this._bindHost;
  }

  // bind_service - computed: false, optional: false, required: true
  private _bindService?: string; 
  public get bindService() {
    return this.getStringAttribute('bind_service');
  }
  public set bindService(value: string) {
    this._bindService = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bindServiceInput() {
    return this._bindService;
  }

  // connect_host - computed: false, optional: false, required: true
  private _connectHost?: string; 
  public get connectHost() {
    return this.getStringAttribute('connect_host');
  }
  public set connectHost(value: string) {
    this._connectHost = value;
  }
  // Temporarily expose input value. Use with caution.
  public get connectHostInput() {
    return this._connectHost;
  }

  // connect_service - computed: false, optional: false, required: true
  private _connectService?: string; 
  public get connectService() {
    return this.getStringAttribute('connect_service');
  }
  public set connectService(value: string) {
    this._connectService = value;
  }
  // Temporarily expose input value. Use with caution.
  public get connectServiceInput() {
    return this._connectService;
  }
}
export interface DomainDevicesDisksMirrorSourceVhostUserUnixReconnect {
  /**
  * Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enabled Domain#enabled}
  */
  readonly enabled: string;
  /**
  * Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#timeout Domain#timeout}
  */
  readonly timeout?: number;
}

export function domainDevicesDisksMirrorSourceVhostUserUnixReconnectToTerraform(struct?: DomainDevicesDisksMirrorSourceVhostUserUnixReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.stringToTerraform(struct!.enabled),
    timeout: cdktf.numberToTerraform(struct!.timeout),
  }
}


export function domainDevicesDisksMirrorSourceVhostUserUnixReconnectToHclTerraform(struct?: DomainDevicesDisksMirrorSourceVhostUserUnixReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.stringToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.numberToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceVhostUserUnixReconnectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceVhostUserUnixReconnect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceVhostUserUnixReconnect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._timeout = value.timeout;
    }
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: string; 
  public get enabled() {
    return this.getStringAttribute('enabled');
  }
  public set enabled(value: string) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: number; 
  public get timeout() {
    return this.getNumberAttribute('timeout');
  }
  public set timeout(value: number) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DomainDevicesDisksMirrorSourceVhostUserUnixSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksMirrorSourceVhostUserUnixSecLabelToTerraform(struct?: DomainDevicesDisksMirrorSourceVhostUserUnixSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksMirrorSourceVhostUserUnixSecLabelToHclTerraform(struct?: DomainDevicesDisksMirrorSourceVhostUserUnixSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceVhostUserUnixSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceVhostUserUnixSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceVhostUserUnixSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksMirrorSourceVhostUserUnixSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksMirrorSourceVhostUserUnixSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksMirrorSourceVhostUserUnixSecLabelOutputReference {
    return new DomainDevicesDisksMirrorSourceVhostUserUnixSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksMirrorSourceVhostUserUnix {
  /**
  * Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode?: string;
  /**
  * Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path?: string;
  /**
  * Enables and configures automatic reconnection behavior for a UNIX socket–based EGD entropy source; the content and attributes are user-provided according to desired policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reconnect Domain#reconnect}
  */
  readonly reconnect?: DomainDevicesDisksMirrorSourceVhostUserUnixReconnect;
  /**
  * Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksMirrorSourceVhostUserUnixSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksMirrorSourceVhostUserUnixToTerraform(struct?: DomainDevicesDisksMirrorSourceVhostUserUnix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
    reconnect: domainDevicesDisksMirrorSourceVhostUserUnixReconnectToTerraform(struct!.reconnect),
    sec_label: cdktf.listMapper(domainDevicesDisksMirrorSourceVhostUserUnixSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksMirrorSourceVhostUserUnixToHclTerraform(struct?: DomainDevicesDisksMirrorSourceVhostUserUnix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reconnect: {
      value: domainDevicesDisksMirrorSourceVhostUserUnixReconnectToHclTerraform(struct!.reconnect),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceVhostUserUnixReconnect",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksMirrorSourceVhostUserUnixSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksMirrorSourceVhostUserUnixSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceVhostUserUnixOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceVhostUserUnix | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._reconnect?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.reconnect = this._reconnect?.internalValue;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceVhostUserUnix | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
      this._path = undefined;
      this._reconnect.internalValue = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
      this._path = value.path;
      this._reconnect.internalValue = value.reconnect;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // reconnect - computed: false, optional: true, required: false
  private _reconnect = new DomainDevicesDisksMirrorSourceVhostUserUnixReconnectOutputReference(this, "reconnect");
  public get reconnect() {
    return this._reconnect;
  }
  public putReconnect(value: DomainDevicesDisksMirrorSourceVhostUserUnixReconnect) {
    this._reconnect.internalValue = value;
  }
  public resetReconnect() {
    this._reconnect.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reconnectInput() {
    return this._reconnect.internalValue;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksMirrorSourceVhostUserUnixSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksMirrorSourceVhostUserUnixSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksMirrorSourceVhostUser {
  /**
  * Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dbus Domain#dbus}
  */
  readonly dbus?: DomainDevicesDisksMirrorSourceVhostUserDbus;
  /**
  * Configures an EGD RNG backend that reads entropy from a host character device node.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dev Domain#dev}
  */
  readonly dev?: DomainDevicesDisksMirrorSourceVhostUserDev;
  /**
  * Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file?: DomainDevicesDisksMirrorSourceVhostUserFile;
  /**
  * Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#nmdm Domain#nmdm}
  */
  readonly nmdm?: DomainDevicesDisksMirrorSourceVhostUserNmdm;
  /**
  * When set to true, uses a null character device as the vhost-user backing-store source, discarding all output and providing no input; when false or unset, the null device is not used.
  * 
  * See: <https://libvirt.org/formatdomain.html#null-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#null Domain#null}
  */
  readonly null?: boolean | cdktf.IResolvable;
  /**
  * Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pipe Domain#pipe}
  */
  readonly pipe?: DomainDevicesDisksMirrorSourceVhostUserPipe;
  /**
  * Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pty Domain#pty}
  */
  readonly pty?: DomainDevicesDisksMirrorSourceVhostUserPty;
  /**
  * Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#qemuvd_agent Domain#qemuvd_agent}
  */
  readonly qemuvdAgent?: DomainDevicesDisksMirrorSourceVhostUserQemuvdAgent;
  /**
  * Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#spice_port Domain#spice_port}
  */
  readonly spicePort?: DomainDevicesDisksMirrorSourceVhostUserSpicePort;
  /**
  * When set to true, exposes the vhost-user backing through a SPICE virtio-serial management channel (SpiceVMC); when false or unset, the element is omitted.
  * 
  * See: <https://libvirt.org/formatdomain.html#spice-channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#spice_vmc Domain#spice_vmc}
  */
  readonly spiceVmc?: boolean | cdktf.IResolvable;
  /**
  * When set to true, connects the vhost-user backing to the domain’s standard I/O character device; when false or unset, the StdIO element is omitted.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-interface>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#std_io Domain#std_io}
  */
  readonly stdIo?: boolean | cdktf.IResolvable;
  /**
  * Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tcp Domain#tcp}
  */
  readonly tcp?: DomainDevicesDisksMirrorSourceVhostUserTcp;
  /**
  * Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#udp Domain#udp}
  */
  readonly udp?: DomainDevicesDisksMirrorSourceVhostUserUdp;
  /**
  * Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#unix Domain#unix}
  */
  readonly unix?: DomainDevicesDisksMirrorSourceVhostUserUnix;
  /**
  * Enables use of a vhost-user communication mechanism compatible with a VC-style (versioned capability) endpoint for the disk mirror backing store; when set true the VC element is emitted, when false or null it is omitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vc Domain#vc}
  */
  readonly vc?: boolean | cdktf.IResolvable;
}

export function domainDevicesDisksMirrorSourceVhostUserToTerraform(struct?: DomainDevicesDisksMirrorSourceVhostUser | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dbus: domainDevicesDisksMirrorSourceVhostUserDbusToTerraform(struct!.dbus),
    dev: domainDevicesDisksMirrorSourceVhostUserDevToTerraform(struct!.dev),
    file: domainDevicesDisksMirrorSourceVhostUserFileToTerraform(struct!.file),
    nmdm: domainDevicesDisksMirrorSourceVhostUserNmdmToTerraform(struct!.nmdm),
    null: cdktf.booleanToTerraform(struct!.null),
    pipe: domainDevicesDisksMirrorSourceVhostUserPipeToTerraform(struct!.pipe),
    pty: domainDevicesDisksMirrorSourceVhostUserPtyToTerraform(struct!.pty),
    qemuvd_agent: domainDevicesDisksMirrorSourceVhostUserQemuvdAgentToTerraform(struct!.qemuvdAgent),
    spice_port: domainDevicesDisksMirrorSourceVhostUserSpicePortToTerraform(struct!.spicePort),
    spice_vmc: cdktf.booleanToTerraform(struct!.spiceVmc),
    std_io: cdktf.booleanToTerraform(struct!.stdIo),
    tcp: domainDevicesDisksMirrorSourceVhostUserTcpToTerraform(struct!.tcp),
    udp: domainDevicesDisksMirrorSourceVhostUserUdpToTerraform(struct!.udp),
    unix: domainDevicesDisksMirrorSourceVhostUserUnixToTerraform(struct!.unix),
    vc: cdktf.booleanToTerraform(struct!.vc),
  }
}


export function domainDevicesDisksMirrorSourceVhostUserToHclTerraform(struct?: DomainDevicesDisksMirrorSourceVhostUser | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dbus: {
      value: domainDevicesDisksMirrorSourceVhostUserDbusToHclTerraform(struct!.dbus),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceVhostUserDbus",
    },
    dev: {
      value: domainDevicesDisksMirrorSourceVhostUserDevToHclTerraform(struct!.dev),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceVhostUserDev",
    },
    file: {
      value: domainDevicesDisksMirrorSourceVhostUserFileToHclTerraform(struct!.file),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceVhostUserFile",
    },
    nmdm: {
      value: domainDevicesDisksMirrorSourceVhostUserNmdmToHclTerraform(struct!.nmdm),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceVhostUserNmdm",
    },
    null: {
      value: cdktf.booleanToHclTerraform(struct!.null),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    pipe: {
      value: domainDevicesDisksMirrorSourceVhostUserPipeToHclTerraform(struct!.pipe),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceVhostUserPipe",
    },
    pty: {
      value: domainDevicesDisksMirrorSourceVhostUserPtyToHclTerraform(struct!.pty),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceVhostUserPty",
    },
    qemuvd_agent: {
      value: domainDevicesDisksMirrorSourceVhostUserQemuvdAgentToHclTerraform(struct!.qemuvdAgent),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceVhostUserQemuvdAgent",
    },
    spice_port: {
      value: domainDevicesDisksMirrorSourceVhostUserSpicePortToHclTerraform(struct!.spicePort),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceVhostUserSpicePort",
    },
    spice_vmc: {
      value: cdktf.booleanToHclTerraform(struct!.spiceVmc),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    std_io: {
      value: cdktf.booleanToHclTerraform(struct!.stdIo),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tcp: {
      value: domainDevicesDisksMirrorSourceVhostUserTcpToHclTerraform(struct!.tcp),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceVhostUserTcp",
    },
    udp: {
      value: domainDevicesDisksMirrorSourceVhostUserUdpToHclTerraform(struct!.udp),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceVhostUserUdp",
    },
    unix: {
      value: domainDevicesDisksMirrorSourceVhostUserUnixToHclTerraform(struct!.unix),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceVhostUserUnix",
    },
    vc: {
      value: cdktf.booleanToHclTerraform(struct!.vc),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceVhostUserOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceVhostUser | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dbus?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dbus = this._dbus?.internalValue;
    }
    if (this._dev?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dev = this._dev?.internalValue;
    }
    if (this._file?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file?.internalValue;
    }
    if (this._nmdm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nmdm = this._nmdm?.internalValue;
    }
    if (this._null !== undefined) {
      hasAnyValues = true;
      internalValueResult.null = this._null;
    }
    if (this._pipe?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipe = this._pipe?.internalValue;
    }
    if (this._pty?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pty = this._pty?.internalValue;
    }
    if (this._qemuvdAgent?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.qemuvdAgent = this._qemuvdAgent?.internalValue;
    }
    if (this._spicePort?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spicePort = this._spicePort?.internalValue;
    }
    if (this._spiceVmc !== undefined) {
      hasAnyValues = true;
      internalValueResult.spiceVmc = this._spiceVmc;
    }
    if (this._stdIo !== undefined) {
      hasAnyValues = true;
      internalValueResult.stdIo = this._stdIo;
    }
    if (this._tcp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tcp = this._tcp?.internalValue;
    }
    if (this._udp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.udp = this._udp?.internalValue;
    }
    if (this._unix?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.unix = this._unix?.internalValue;
    }
    if (this._vc !== undefined) {
      hasAnyValues = true;
      internalValueResult.vc = this._vc;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceVhostUser | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dbus.internalValue = undefined;
      this._dev.internalValue = undefined;
      this._file.internalValue = undefined;
      this._nmdm.internalValue = undefined;
      this._null = undefined;
      this._pipe.internalValue = undefined;
      this._pty.internalValue = undefined;
      this._qemuvdAgent.internalValue = undefined;
      this._spicePort.internalValue = undefined;
      this._spiceVmc = undefined;
      this._stdIo = undefined;
      this._tcp.internalValue = undefined;
      this._udp.internalValue = undefined;
      this._unix.internalValue = undefined;
      this._vc = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dbus.internalValue = value.dbus;
      this._dev.internalValue = value.dev;
      this._file.internalValue = value.file;
      this._nmdm.internalValue = value.nmdm;
      this._null = value.null;
      this._pipe.internalValue = value.pipe;
      this._pty.internalValue = value.pty;
      this._qemuvdAgent.internalValue = value.qemuvdAgent;
      this._spicePort.internalValue = value.spicePort;
      this._spiceVmc = value.spiceVmc;
      this._stdIo = value.stdIo;
      this._tcp.internalValue = value.tcp;
      this._udp.internalValue = value.udp;
      this._unix.internalValue = value.unix;
      this._vc = value.vc;
    }
  }

  // dbus - computed: false, optional: true, required: false
  private _dbus = new DomainDevicesDisksMirrorSourceVhostUserDbusOutputReference(this, "dbus");
  public get dbus() {
    return this._dbus;
  }
  public putDbus(value: DomainDevicesDisksMirrorSourceVhostUserDbus) {
    this._dbus.internalValue = value;
  }
  public resetDbus() {
    this._dbus.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dbusInput() {
    return this._dbus.internalValue;
  }

  // dev - computed: false, optional: true, required: false
  private _dev = new DomainDevicesDisksMirrorSourceVhostUserDevOutputReference(this, "dev");
  public get dev() {
    return this._dev;
  }
  public putDev(value: DomainDevicesDisksMirrorSourceVhostUserDev) {
    this._dev.internalValue = value;
  }
  public resetDev() {
    this._dev.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devInput() {
    return this._dev.internalValue;
  }

  // file - computed: false, optional: true, required: false
  private _file = new DomainDevicesDisksMirrorSourceVhostUserFileOutputReference(this, "file");
  public get file() {
    return this._file;
  }
  public putFile(value: DomainDevicesDisksMirrorSourceVhostUserFile) {
    this._file.internalValue = value;
  }
  public resetFile() {
    this._file.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file.internalValue;
  }

  // nmdm - computed: false, optional: true, required: false
  private _nmdm = new DomainDevicesDisksMirrorSourceVhostUserNmdmOutputReference(this, "nmdm");
  public get nmdm() {
    return this._nmdm;
  }
  public putNmdm(value: DomainDevicesDisksMirrorSourceVhostUserNmdm) {
    this._nmdm.internalValue = value;
  }
  public resetNmdm() {
    this._nmdm.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nmdmInput() {
    return this._nmdm.internalValue;
  }

  // null - computed: false, optional: true, required: false
  private _null?: boolean | cdktf.IResolvable; 
  public get null() {
    return this.getBooleanAttribute('null');
  }
  public set null(value: boolean | cdktf.IResolvable) {
    this._null = value;
  }
  public resetNull() {
    this._null = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nullInput() {
    return this._null;
  }

  // pipe - computed: false, optional: true, required: false
  private _pipe = new DomainDevicesDisksMirrorSourceVhostUserPipeOutputReference(this, "pipe");
  public get pipe() {
    return this._pipe;
  }
  public putPipe(value: DomainDevicesDisksMirrorSourceVhostUserPipe) {
    this._pipe.internalValue = value;
  }
  public resetPipe() {
    this._pipe.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipeInput() {
    return this._pipe.internalValue;
  }

  // pty - computed: false, optional: true, required: false
  private _pty = new DomainDevicesDisksMirrorSourceVhostUserPtyOutputReference(this, "pty");
  public get pty() {
    return this._pty;
  }
  public putPty(value: DomainDevicesDisksMirrorSourceVhostUserPty) {
    this._pty.internalValue = value;
  }
  public resetPty() {
    this._pty.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ptyInput() {
    return this._pty.internalValue;
  }

  // qemuvd_agent - computed: false, optional: true, required: false
  private _qemuvdAgent = new DomainDevicesDisksMirrorSourceVhostUserQemuvdAgentOutputReference(this, "qemuvd_agent");
  public get qemuvdAgent() {
    return this._qemuvdAgent;
  }
  public putQemuvdAgent(value: DomainDevicesDisksMirrorSourceVhostUserQemuvdAgent) {
    this._qemuvdAgent.internalValue = value;
  }
  public resetQemuvdAgent() {
    this._qemuvdAgent.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get qemuvdAgentInput() {
    return this._qemuvdAgent.internalValue;
  }

  // spice_port - computed: false, optional: true, required: false
  private _spicePort = new DomainDevicesDisksMirrorSourceVhostUserSpicePortOutputReference(this, "spice_port");
  public get spicePort() {
    return this._spicePort;
  }
  public putSpicePort(value: DomainDevicesDisksMirrorSourceVhostUserSpicePort) {
    this._spicePort.internalValue = value;
  }
  public resetSpicePort() {
    this._spicePort.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spicePortInput() {
    return this._spicePort.internalValue;
  }

  // spice_vmc - computed: false, optional: true, required: false
  private _spiceVmc?: boolean | cdktf.IResolvable; 
  public get spiceVmc() {
    return this.getBooleanAttribute('spice_vmc');
  }
  public set spiceVmc(value: boolean | cdktf.IResolvable) {
    this._spiceVmc = value;
  }
  public resetSpiceVmc() {
    this._spiceVmc = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spiceVmcInput() {
    return this._spiceVmc;
  }

  // std_io - computed: false, optional: true, required: false
  private _stdIo?: boolean | cdktf.IResolvable; 
  public get stdIo() {
    return this.getBooleanAttribute('std_io');
  }
  public set stdIo(value: boolean | cdktf.IResolvable) {
    this._stdIo = value;
  }
  public resetStdIo() {
    this._stdIo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stdIoInput() {
    return this._stdIo;
  }

  // tcp - computed: false, optional: true, required: false
  private _tcp = new DomainDevicesDisksMirrorSourceVhostUserTcpOutputReference(this, "tcp");
  public get tcp() {
    return this._tcp;
  }
  public putTcp(value: DomainDevicesDisksMirrorSourceVhostUserTcp) {
    this._tcp.internalValue = value;
  }
  public resetTcp() {
    this._tcp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tcpInput() {
    return this._tcp.internalValue;
  }

  // udp - computed: false, optional: true, required: false
  private _udp = new DomainDevicesDisksMirrorSourceVhostUserUdpOutputReference(this, "udp");
  public get udp() {
    return this._udp;
  }
  public putUdp(value: DomainDevicesDisksMirrorSourceVhostUserUdp) {
    this._udp.internalValue = value;
  }
  public resetUdp() {
    this._udp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get udpInput() {
    return this._udp.internalValue;
  }

  // unix - computed: false, optional: true, required: false
  private _unix = new DomainDevicesDisksMirrorSourceVhostUserUnixOutputReference(this, "unix");
  public get unix() {
    return this._unix;
  }
  public putUnix(value: DomainDevicesDisksMirrorSourceVhostUserUnix) {
    this._unix.internalValue = value;
  }
  public resetUnix() {
    this._unix.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unixInput() {
    return this._unix.internalValue;
  }

  // vc - computed: false, optional: true, required: false
  private _vc?: boolean | cdktf.IResolvable; 
  public get vc() {
    return this.getBooleanAttribute('vc');
  }
  public set vc(value: boolean | cdktf.IResolvable) {
    this._vc = value;
  }
  public resetVc() {
    this._vc = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vcInput() {
    return this._vc;
  }
}
export interface DomainDevicesDisksMirrorSourceVhostVdpa {
  /**
  * Sets the host vDPA character device path used as the backingStore source for the mirrored disk when using a vhost-vdpa backend; the value is user-provided and must reference an existing device node (for example, /dev/vhost-vdpa0).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dev Domain#dev}
  */
  readonly dev: string;
}

export function domainDevicesDisksMirrorSourceVhostVdpaToTerraform(struct?: DomainDevicesDisksMirrorSourceVhostVdpa | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dev: cdktf.stringToTerraform(struct!.dev),
  }
}


export function domainDevicesDisksMirrorSourceVhostVdpaToHclTerraform(struct?: DomainDevicesDisksMirrorSourceVhostVdpa | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dev: {
      value: cdktf.stringToHclTerraform(struct!.dev),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceVhostVdpaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceVhostVdpa | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dev !== undefined) {
      hasAnyValues = true;
      internalValueResult.dev = this._dev;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceVhostVdpa | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dev = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dev = value.dev;
    }
  }

  // dev - computed: false, optional: false, required: true
  private _dev?: string; 
  public get dev() {
    return this.getStringAttribute('dev');
  }
  public set dev(value: string) {
    this._dev = value;
  }
  // Temporarily expose input value. Use with caution.
  public get devInput() {
    return this._dev;
  }
}
export interface DomainDevicesDisksMirrorSourceVolumeSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksMirrorSourceVolumeSecLabelToTerraform(struct?: DomainDevicesDisksMirrorSourceVolumeSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksMirrorSourceVolumeSecLabelToHclTerraform(struct?: DomainDevicesDisksMirrorSourceVolumeSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceVolumeSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceVolumeSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceVolumeSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksMirrorSourceVolumeSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksMirrorSourceVolumeSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksMirrorSourceVolumeSecLabelOutputReference {
    return new DomainDevicesDisksMirrorSourceVolumeSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksMirrorSourceVolume {
  /**
  * Sets the access mode with which the storage volume is used as the backingStore source (for example, "readOnly" or "readWrite" depending on driver support); the value is user-provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode?: string;
  /**
  * Names the storage pool that contains the backing storage volume used as the mirror backingStore source; must match an existing libvirt storage pool name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pool Domain#pool}
  */
  readonly pool?: string;
  /**
  * Configures an optional security label override applied to the backing storage volume used as the mirror backingStore source.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksMirrorSourceVolumeSecLabel[] | cdktf.IResolvable;
  /**
  * Sets the name of the storage volume within the specified pool that is used as the backingStore source for the mirrored disk.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#volume Domain#volume}
  */
  readonly volume?: string;
}

export function domainDevicesDisksMirrorSourceVolumeToTerraform(struct?: DomainDevicesDisksMirrorSourceVolume | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
    pool: cdktf.stringToTerraform(struct!.pool),
    sec_label: cdktf.listMapper(domainDevicesDisksMirrorSourceVolumeSecLabelToTerraform, false)(struct!.secLabel),
    volume: cdktf.stringToTerraform(struct!.volume),
  }
}


export function domainDevicesDisksMirrorSourceVolumeToHclTerraform(struct?: DomainDevicesDisksMirrorSourceVolume | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pool: {
      value: cdktf.stringToHclTerraform(struct!.pool),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksMirrorSourceVolumeSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksMirrorSourceVolumeSecLabelList",
    },
    volume: {
      value: cdktf.stringToHclTerraform(struct!.volume),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceVolumeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSourceVolume | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._pool !== undefined) {
      hasAnyValues = true;
      internalValueResult.pool = this._pool;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    if (this._volume !== undefined) {
      hasAnyValues = true;
      internalValueResult.volume = this._volume;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSourceVolume | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
      this._pool = undefined;
      this._secLabel.internalValue = undefined;
      this._volume = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
      this._pool = value.pool;
      this._secLabel.internalValue = value.secLabel;
      this._volume = value.volume;
    }
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // pool - computed: false, optional: true, required: false
  private _pool?: string; 
  public get pool() {
    return this.getStringAttribute('pool');
  }
  public set pool(value: string) {
    this._pool = value;
  }
  public resetPool() {
    this._pool = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get poolInput() {
    return this._pool;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksMirrorSourceVolumeSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksMirrorSourceVolumeSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }

  // volume - computed: false, optional: true, required: false
  private _volume?: string; 
  public get volume() {
    return this.getStringAttribute('volume');
  }
  public set volume(value: string) {
    this._volume = value;
  }
  public resetVolume() {
    this._volume = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get volumeInput() {
    return this._volume;
  }
}
export interface DomainDevicesDisksMirrorSource {
  /**
  * Describes a block device used as the source for the mirror backing store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#block Domain#block}
  */
  readonly block?: DomainDevicesDisksMirrorSourceBlock;
  /**
  * Provides optional cookie data associated with the mirror backing store source (for example, auth or session data), with content treated as user-provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#cookies Domain#cookies}
  */
  readonly cookies?: DomainDevicesDisksMirrorSourceCookies;
  /**
  * Configures a data store descriptor for the mirrored backing store, typically used with networked or advanced storage backends that expose format-specific options.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#data_store Domain#data_store}
  */
  readonly dataStore?: DomainDevicesDisksMirrorSourceDataStore;
  /**
  * Configures a directory-based source for the mirrored backing store, pointing to a host directory used by the backing image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dir Domain#dir}
  */
  readonly dir?: DomainDevicesDisksMirrorSourceDir;
  /**
  * Enables disk image encryption configuration for this disk and groups attributes defining the encryption engine, format, and secrets.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#encryption Domain#encryption}
  */
  readonly encryption?: DomainDevicesDisksMirrorSourceEncryption;
  /**
  * Configures a file-based backing store source for the disk mirror, defining how the backing image is accessed from the host filesystem.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file?: DomainDevicesDisksMirrorSourceFile;
  /**
  * Sets the index of this backing store within a backing chain, used when multiple backing layers are present; value is a user-provided non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#index Domain#index}
  */
  readonly index?: number;
  /**
  * Configures a network-based backing store source (such as NBD, iSCSI, or RBD) for the disk mirror, including authentication and host endpoints.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#network Domain#network}
  */
  readonly network?: DomainDevicesDisksMirrorSourceNetwork;
  /**
  * Enables using an NVMe-backed source for the mirrored disk’s backing store; when present, it selects an NVMe device or namespace as the source, with details defined by libvirt/QEMU for NVMe disks.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#nvme Domain#nvme}
  */
  readonly nvme?: DomainDevicesDisksMirrorSourceNvme;
  /**
  * Configures read-ahead behavior for the mirrored disk’s backing-store source, allowing tuning of how much data is pre-fetched from the backend.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#readahead Domain#readahead}
  */
  readonly readahead?: DomainDevicesDisksMirrorSourceReadahead;
  /**
  * Configures SCSI-style reservations or similar persistent reservation management for the mirrored disk’s backing-store source, controlling how access is coordinated across nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reservations Domain#reservations}
  */
  readonly reservations?: DomainDevicesDisksMirrorSourceReservations;
  /**
  * Configures optional slice or segment information for the backing store source (for example, to describe which logical slices of a device are used); content is user-provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#slices Domain#slices}
  */
  readonly slices?: DomainDevicesDisksMirrorSourceSlices;
  /**
  * Enables SSL/TLS parameters for accessing the mirrored backing-store source when it is provided over a secure transport.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#ssl Domain#ssl}
  */
  readonly ssl?: DomainDevicesDisksMirrorSourceSsl;
  /**
  * Specifies how strictly the mirrored backing-store source must be available during domain startup; valid values include "mandatory", "requisite", "optional" (user‑provided string matched by libvirt).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#startup_policy Domain#startup_policy}
  */
  readonly startupPolicy?: string;
  /**
  * Configures a timeout for connecting to or initializing the mirrored backing-store source.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#timeout Domain#timeout}
  */
  readonly timeout?: DomainDevicesDisksMirrorSourceTimeout;
  /**
  * Selects a vhost-user backend as the transport for the mirrored backing-store source, allowing it to be provided via a userspace process.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vhost_user Domain#vhost_user}
  */
  readonly vhostUser?: DomainDevicesDisksMirrorSourceVhostUser;
  /**
  * Selects a vhost-vDPA backend for the disk mirror backing store, allowing acceleration via a vDPA device; additional details are determined by libvirt and device configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vhost_vdpa Domain#vhost_vdpa}
  */
  readonly vhostVdpa?: DomainDevicesDisksMirrorSourceVhostVdpa;
  /**
  * Configures the backingStore source as a libvirt storage volume reference instead of a raw file/block path for the mirrored disk.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#volume Domain#volume}
  */
  readonly volume?: DomainDevicesDisksMirrorSourceVolume;
}

export function domainDevicesDisksMirrorSourceToTerraform(struct?: DomainDevicesDisksMirrorSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    block: domainDevicesDisksMirrorSourceBlockToTerraform(struct!.block),
    cookies: domainDevicesDisksMirrorSourceCookiesToTerraform(struct!.cookies),
    data_store: domainDevicesDisksMirrorSourceDataStoreToTerraform(struct!.dataStore),
    dir: domainDevicesDisksMirrorSourceDirToTerraform(struct!.dir),
    encryption: domainDevicesDisksMirrorSourceEncryptionToTerraform(struct!.encryption),
    file: domainDevicesDisksMirrorSourceFileToTerraform(struct!.file),
    index: cdktf.numberToTerraform(struct!.index),
    network: domainDevicesDisksMirrorSourceNetworkToTerraform(struct!.network),
    nvme: domainDevicesDisksMirrorSourceNvmeToTerraform(struct!.nvme),
    readahead: domainDevicesDisksMirrorSourceReadaheadToTerraform(struct!.readahead),
    reservations: domainDevicesDisksMirrorSourceReservationsToTerraform(struct!.reservations),
    slices: domainDevicesDisksMirrorSourceSlicesToTerraform(struct!.slices),
    ssl: domainDevicesDisksMirrorSourceSslToTerraform(struct!.ssl),
    startup_policy: cdktf.stringToTerraform(struct!.startupPolicy),
    timeout: domainDevicesDisksMirrorSourceTimeoutToTerraform(struct!.timeout),
    vhost_user: domainDevicesDisksMirrorSourceVhostUserToTerraform(struct!.vhostUser),
    vhost_vdpa: domainDevicesDisksMirrorSourceVhostVdpaToTerraform(struct!.vhostVdpa),
    volume: domainDevicesDisksMirrorSourceVolumeToTerraform(struct!.volume),
  }
}


export function domainDevicesDisksMirrorSourceToHclTerraform(struct?: DomainDevicesDisksMirrorSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    block: {
      value: domainDevicesDisksMirrorSourceBlockToHclTerraform(struct!.block),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceBlock",
    },
    cookies: {
      value: domainDevicesDisksMirrorSourceCookiesToHclTerraform(struct!.cookies),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceCookies",
    },
    data_store: {
      value: domainDevicesDisksMirrorSourceDataStoreToHclTerraform(struct!.dataStore),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceDataStore",
    },
    dir: {
      value: domainDevicesDisksMirrorSourceDirToHclTerraform(struct!.dir),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceDir",
    },
    encryption: {
      value: domainDevicesDisksMirrorSourceEncryptionToHclTerraform(struct!.encryption),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceEncryption",
    },
    file: {
      value: domainDevicesDisksMirrorSourceFileToHclTerraform(struct!.file),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceFile",
    },
    index: {
      value: cdktf.numberToHclTerraform(struct!.index),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    network: {
      value: domainDevicesDisksMirrorSourceNetworkToHclTerraform(struct!.network),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceNetwork",
    },
    nvme: {
      value: domainDevicesDisksMirrorSourceNvmeToHclTerraform(struct!.nvme),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceNvme",
    },
    readahead: {
      value: domainDevicesDisksMirrorSourceReadaheadToHclTerraform(struct!.readahead),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceReadahead",
    },
    reservations: {
      value: domainDevicesDisksMirrorSourceReservationsToHclTerraform(struct!.reservations),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceReservations",
    },
    slices: {
      value: domainDevicesDisksMirrorSourceSlicesToHclTerraform(struct!.slices),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceSlices",
    },
    ssl: {
      value: domainDevicesDisksMirrorSourceSslToHclTerraform(struct!.ssl),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceSsl",
    },
    startup_policy: {
      value: cdktf.stringToHclTerraform(struct!.startupPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: domainDevicesDisksMirrorSourceTimeoutToHclTerraform(struct!.timeout),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceTimeout",
    },
    vhost_user: {
      value: domainDevicesDisksMirrorSourceVhostUserToHclTerraform(struct!.vhostUser),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceVhostUser",
    },
    vhost_vdpa: {
      value: domainDevicesDisksMirrorSourceVhostVdpaToHclTerraform(struct!.vhostVdpa),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceVhostVdpa",
    },
    volume: {
      value: domainDevicesDisksMirrorSourceVolumeToHclTerraform(struct!.volume),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSourceVolume",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirrorSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._block?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.block = this._block?.internalValue;
    }
    if (this._cookies?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cookies = this._cookies?.internalValue;
    }
    if (this._dataStore?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dataStore = this._dataStore?.internalValue;
    }
    if (this._dir?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dir = this._dir?.internalValue;
    }
    if (this._encryption?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.encryption = this._encryption?.internalValue;
    }
    if (this._file?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file?.internalValue;
    }
    if (this._index !== undefined) {
      hasAnyValues = true;
      internalValueResult.index = this._index;
    }
    if (this._network?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.network = this._network?.internalValue;
    }
    if (this._nvme?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nvme = this._nvme?.internalValue;
    }
    if (this._readahead?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.readahead = this._readahead?.internalValue;
    }
    if (this._reservations?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.reservations = this._reservations?.internalValue;
    }
    if (this._slices?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.slices = this._slices?.internalValue;
    }
    if (this._ssl?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ssl = this._ssl?.internalValue;
    }
    if (this._startupPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.startupPolicy = this._startupPolicy;
    }
    if (this._timeout?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout?.internalValue;
    }
    if (this._vhostUser?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.vhostUser = this._vhostUser?.internalValue;
    }
    if (this._vhostVdpa?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.vhostVdpa = this._vhostVdpa?.internalValue;
    }
    if (this._volume?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.volume = this._volume?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirrorSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._block.internalValue = undefined;
      this._cookies.internalValue = undefined;
      this._dataStore.internalValue = undefined;
      this._dir.internalValue = undefined;
      this._encryption.internalValue = undefined;
      this._file.internalValue = undefined;
      this._index = undefined;
      this._network.internalValue = undefined;
      this._nvme.internalValue = undefined;
      this._readahead.internalValue = undefined;
      this._reservations.internalValue = undefined;
      this._slices.internalValue = undefined;
      this._ssl.internalValue = undefined;
      this._startupPolicy = undefined;
      this._timeout.internalValue = undefined;
      this._vhostUser.internalValue = undefined;
      this._vhostVdpa.internalValue = undefined;
      this._volume.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._block.internalValue = value.block;
      this._cookies.internalValue = value.cookies;
      this._dataStore.internalValue = value.dataStore;
      this._dir.internalValue = value.dir;
      this._encryption.internalValue = value.encryption;
      this._file.internalValue = value.file;
      this._index = value.index;
      this._network.internalValue = value.network;
      this._nvme.internalValue = value.nvme;
      this._readahead.internalValue = value.readahead;
      this._reservations.internalValue = value.reservations;
      this._slices.internalValue = value.slices;
      this._ssl.internalValue = value.ssl;
      this._startupPolicy = value.startupPolicy;
      this._timeout.internalValue = value.timeout;
      this._vhostUser.internalValue = value.vhostUser;
      this._vhostVdpa.internalValue = value.vhostVdpa;
      this._volume.internalValue = value.volume;
    }
  }

  // block - computed: false, optional: true, required: false
  private _block = new DomainDevicesDisksMirrorSourceBlockOutputReference(this, "block");
  public get block() {
    return this._block;
  }
  public putBlock(value: DomainDevicesDisksMirrorSourceBlock) {
    this._block.internalValue = value;
  }
  public resetBlock() {
    this._block.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get blockInput() {
    return this._block.internalValue;
  }

  // cookies - computed: false, optional: true, required: false
  private _cookies = new DomainDevicesDisksMirrorSourceCookiesOutputReference(this, "cookies");
  public get cookies() {
    return this._cookies;
  }
  public putCookies(value: DomainDevicesDisksMirrorSourceCookies) {
    this._cookies.internalValue = value;
  }
  public resetCookies() {
    this._cookies.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cookiesInput() {
    return this._cookies.internalValue;
  }

  // data_store - computed: false, optional: true, required: false
  private _dataStore = new DomainDevicesDisksMirrorSourceDataStoreOutputReference(this, "data_store");
  public get dataStore() {
    return this._dataStore;
  }
  public putDataStore(value: DomainDevicesDisksMirrorSourceDataStore) {
    this._dataStore.internalValue = value;
  }
  public resetDataStore() {
    this._dataStore.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dataStoreInput() {
    return this._dataStore.internalValue;
  }

  // dir - computed: false, optional: true, required: false
  private _dir = new DomainDevicesDisksMirrorSourceDirOutputReference(this, "dir");
  public get dir() {
    return this._dir;
  }
  public putDir(value: DomainDevicesDisksMirrorSourceDir) {
    this._dir.internalValue = value;
  }
  public resetDir() {
    this._dir.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dirInput() {
    return this._dir.internalValue;
  }

  // encryption - computed: false, optional: true, required: false
  private _encryption = new DomainDevicesDisksMirrorSourceEncryptionOutputReference(this, "encryption");
  public get encryption() {
    return this._encryption;
  }
  public putEncryption(value: DomainDevicesDisksMirrorSourceEncryption) {
    this._encryption.internalValue = value;
  }
  public resetEncryption() {
    this._encryption.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get encryptionInput() {
    return this._encryption.internalValue;
  }

  // file - computed: false, optional: true, required: false
  private _file = new DomainDevicesDisksMirrorSourceFileOutputReference(this, "file");
  public get file() {
    return this._file;
  }
  public putFile(value: DomainDevicesDisksMirrorSourceFile) {
    this._file.internalValue = value;
  }
  public resetFile() {
    this._file.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file.internalValue;
  }

  // index - computed: false, optional: true, required: false
  private _index?: number; 
  public get index() {
    return this.getNumberAttribute('index');
  }
  public set index(value: number) {
    this._index = value;
  }
  public resetIndex() {
    this._index = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get indexInput() {
    return this._index;
  }

  // network - computed: false, optional: true, required: false
  private _network = new DomainDevicesDisksMirrorSourceNetworkOutputReference(this, "network");
  public get network() {
    return this._network;
  }
  public putNetwork(value: DomainDevicesDisksMirrorSourceNetwork) {
    this._network.internalValue = value;
  }
  public resetNetwork() {
    this._network.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkInput() {
    return this._network.internalValue;
  }

  // nvme - computed: false, optional: true, required: false
  private _nvme = new DomainDevicesDisksMirrorSourceNvmeOutputReference(this, "nvme");
  public get nvme() {
    return this._nvme;
  }
  public putNvme(value: DomainDevicesDisksMirrorSourceNvme) {
    this._nvme.internalValue = value;
  }
  public resetNvme() {
    this._nvme.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nvmeInput() {
    return this._nvme.internalValue;
  }

  // readahead - computed: false, optional: true, required: false
  private _readahead = new DomainDevicesDisksMirrorSourceReadaheadOutputReference(this, "readahead");
  public get readahead() {
    return this._readahead;
  }
  public putReadahead(value: DomainDevicesDisksMirrorSourceReadahead) {
    this._readahead.internalValue = value;
  }
  public resetReadahead() {
    this._readahead.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readaheadInput() {
    return this._readahead.internalValue;
  }

  // reservations - computed: false, optional: true, required: false
  private _reservations = new DomainDevicesDisksMirrorSourceReservationsOutputReference(this, "reservations");
  public get reservations() {
    return this._reservations;
  }
  public putReservations(value: DomainDevicesDisksMirrorSourceReservations) {
    this._reservations.internalValue = value;
  }
  public resetReservations() {
    this._reservations.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reservationsInput() {
    return this._reservations.internalValue;
  }

  // slices - computed: false, optional: true, required: false
  private _slices = new DomainDevicesDisksMirrorSourceSlicesOutputReference(this, "slices");
  public get slices() {
    return this._slices;
  }
  public putSlices(value: DomainDevicesDisksMirrorSourceSlices) {
    this._slices.internalValue = value;
  }
  public resetSlices() {
    this._slices.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get slicesInput() {
    return this._slices.internalValue;
  }

  // ssl - computed: false, optional: true, required: false
  private _ssl = new DomainDevicesDisksMirrorSourceSslOutputReference(this, "ssl");
  public get ssl() {
    return this._ssl;
  }
  public putSsl(value: DomainDevicesDisksMirrorSourceSsl) {
    this._ssl.internalValue = value;
  }
  public resetSsl() {
    this._ssl.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sslInput() {
    return this._ssl.internalValue;
  }

  // startup_policy - computed: false, optional: true, required: false
  private _startupPolicy?: string; 
  public get startupPolicy() {
    return this.getStringAttribute('startup_policy');
  }
  public set startupPolicy(value: string) {
    this._startupPolicy = value;
  }
  public resetStartupPolicy() {
    this._startupPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get startupPolicyInput() {
    return this._startupPolicy;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout = new DomainDevicesDisksMirrorSourceTimeoutOutputReference(this, "timeout");
  public get timeout() {
    return this._timeout;
  }
  public putTimeout(value: DomainDevicesDisksMirrorSourceTimeout) {
    this._timeout.internalValue = value;
  }
  public resetTimeout() {
    this._timeout.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout.internalValue;
  }

  // vhost_user - computed: false, optional: true, required: false
  private _vhostUser = new DomainDevicesDisksMirrorSourceVhostUserOutputReference(this, "vhost_user");
  public get vhostUser() {
    return this._vhostUser;
  }
  public putVhostUser(value: DomainDevicesDisksMirrorSourceVhostUser) {
    this._vhostUser.internalValue = value;
  }
  public resetVhostUser() {
    this._vhostUser.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vhostUserInput() {
    return this._vhostUser.internalValue;
  }

  // vhost_vdpa - computed: false, optional: true, required: false
  private _vhostVdpa = new DomainDevicesDisksMirrorSourceVhostVdpaOutputReference(this, "vhost_vdpa");
  public get vhostVdpa() {
    return this._vhostVdpa;
  }
  public putVhostVdpa(value: DomainDevicesDisksMirrorSourceVhostVdpa) {
    this._vhostVdpa.internalValue = value;
  }
  public resetVhostVdpa() {
    this._vhostVdpa.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vhostVdpaInput() {
    return this._vhostVdpa.internalValue;
  }

  // volume - computed: false, optional: true, required: false
  private _volume = new DomainDevicesDisksMirrorSourceVolumeOutputReference(this, "volume");
  public get volume() {
    return this._volume;
  }
  public putVolume(value: DomainDevicesDisksMirrorSourceVolume) {
    this._volume.internalValue = value;
  }
  public resetVolume() {
    this._volume.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get volumeInput() {
    return this._volume.internalValue;
  }
}
export interface DomainDevicesDisksMirror {
  /**
  * Defines the backing store chain for the mirrored disk image, describing one layer of the underlying image stack used by the mirror target.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#backing_store Domain#backing_store}
  */
  readonly backingStore?: DomainDevicesDisksMirrorBackingStore;
  /**
  * Configures the on-disk format settings for the mirrored backing store’s data store, including format type and optional metadata cache tuning.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#format Domain#format}
  */
  readonly format?: DomainDevicesDisksMirrorFormat;
  /**
  * Selects the mirroring job mode, such as whether the mirror should be a persistent replacement or a transient copy; the value is user-provided and must match a libvirt-supported job type.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#job Domain#job}
  */
  readonly job?: string;
  /**
  * Indicates whether the mirror is marked as ready to be switched to or used (typically a yes/no flag as a string, such as "yes" or "no").
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#ready Domain#ready}
  */
  readonly ready?: string;
  /**
  * Defines the data source for the mirror backing store, such as a block device or file path.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#source Domain#source}
  */
  readonly source?: DomainDevicesDisksMirrorSource;
}

export function domainDevicesDisksMirrorToTerraform(struct?: DomainDevicesDisksMirror | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backing_store: domainDevicesDisksMirrorBackingStoreToTerraform(struct!.backingStore),
    format: domainDevicesDisksMirrorFormatToTerraform(struct!.format),
    job: cdktf.stringToTerraform(struct!.job),
    ready: cdktf.stringToTerraform(struct!.ready),
    source: domainDevicesDisksMirrorSourceToTerraform(struct!.source),
  }
}


export function domainDevicesDisksMirrorToHclTerraform(struct?: DomainDevicesDisksMirror | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backing_store: {
      value: domainDevicesDisksMirrorBackingStoreToHclTerraform(struct!.backingStore),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorBackingStore",
    },
    format: {
      value: domainDevicesDisksMirrorFormatToHclTerraform(struct!.format),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorFormat",
    },
    job: {
      value: cdktf.stringToHclTerraform(struct!.job),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ready: {
      value: cdktf.stringToHclTerraform(struct!.ready),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    source: {
      value: domainDevicesDisksMirrorSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirrorSource",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksMirrorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksMirror | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backingStore?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.backingStore = this._backingStore?.internalValue;
    }
    if (this._format?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format?.internalValue;
    }
    if (this._job !== undefined) {
      hasAnyValues = true;
      internalValueResult.job = this._job;
    }
    if (this._ready !== undefined) {
      hasAnyValues = true;
      internalValueResult.ready = this._ready;
    }
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksMirror | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backingStore.internalValue = undefined;
      this._format.internalValue = undefined;
      this._job = undefined;
      this._ready = undefined;
      this._source.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backingStore.internalValue = value.backingStore;
      this._format.internalValue = value.format;
      this._job = value.job;
      this._ready = value.ready;
      this._source.internalValue = value.source;
    }
  }

  // backing_store - computed: false, optional: true, required: false
  private _backingStore = new DomainDevicesDisksMirrorBackingStoreOutputReference(this, "backing_store");
  public get backingStore() {
    return this._backingStore;
  }
  public putBackingStore(value: DomainDevicesDisksMirrorBackingStore) {
    this._backingStore.internalValue = value;
  }
  public resetBackingStore() {
    this._backingStore.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backingStoreInput() {
    return this._backingStore.internalValue;
  }

  // format - computed: false, optional: true, required: false
  private _format = new DomainDevicesDisksMirrorFormatOutputReference(this, "format");
  public get format() {
    return this._format;
  }
  public putFormat(value: DomainDevicesDisksMirrorFormat) {
    this._format.internalValue = value;
  }
  public resetFormat() {
    this._format.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format.internalValue;
  }

  // job - computed: false, optional: true, required: false
  private _job?: string; 
  public get job() {
    return this.getStringAttribute('job');
  }
  public set job(value: string) {
    this._job = value;
  }
  public resetJob() {
    this._job = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jobInput() {
    return this._job;
  }

  // ready - computed: false, optional: true, required: false
  private _ready?: string; 
  public get ready() {
    return this.getStringAttribute('ready');
  }
  public set ready(value: string) {
    this._ready = value;
  }
  public resetReady() {
    this._ready = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readyInput() {
    return this._ready;
  }

  // source - computed: false, optional: true, required: false
  private _source = new DomainDevicesDisksMirrorSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: DomainDevicesDisksMirrorSource) {
    this._source.internalValue = value;
  }
  public resetSource() {
    this._source.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }
}
export interface DomainDevicesDisksSourceBlockSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksSourceBlockSecLabelToTerraform(struct?: DomainDevicesDisksSourceBlockSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksSourceBlockSecLabelToHclTerraform(struct?: DomainDevicesDisksSourceBlockSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceBlockSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksSourceBlockSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceBlockSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksSourceBlockSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksSourceBlockSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksSourceBlockSecLabelOutputReference {
    return new DomainDevicesDisksSourceBlockSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksSourceBlock {
  /**
  * Sets the host block device path used as the mirror backing store source (for example "/dev/sdb1"); the value is user-provided and must reference an existing block device.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dev Domain#dev}
  */
  readonly dev?: string;
  /**
  * Configures an optional security label for the block-device backing store of the mirror, controlling how security drivers label this source.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksSourceBlockSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksSourceBlockToTerraform(struct?: DomainDevicesDisksSourceBlock | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dev: cdktf.stringToTerraform(struct!.dev),
    sec_label: cdktf.listMapper(domainDevicesDisksSourceBlockSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksSourceBlockToHclTerraform(struct?: DomainDevicesDisksSourceBlock | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dev: {
      value: cdktf.stringToHclTerraform(struct!.dev),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksSourceBlockSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksSourceBlockSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceBlockOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceBlock | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dev !== undefined) {
      hasAnyValues = true;
      internalValueResult.dev = this._dev;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceBlock | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dev = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dev = value.dev;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // dev - computed: false, optional: true, required: false
  private _dev?: string; 
  public get dev() {
    return this.getStringAttribute('dev');
  }
  public set dev(value: string) {
    this._dev = value;
  }
  public resetDev() {
    this._dev = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devInput() {
    return this._dev;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksSourceBlockSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksSourceBlockSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksSourceCookiesCookies {
  /**
  * Sets the cookie name for this backing store HTTP cookie; the value is user-provided and must be non-empty (for example, "sessionid").
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
  /**
  * Sets the cookie value for this backing store HTTP cookie; the value is user-provided and must be non-empty (for example, "abc123").
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#value Domain#value}
  */
  readonly value: string;
}

export function domainDevicesDisksSourceCookiesCookiesToTerraform(struct?: DomainDevicesDisksSourceCookiesCookies | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function domainDevicesDisksSourceCookiesCookiesToHclTerraform(struct?: DomainDevicesDisksSourceCookiesCookies | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceCookiesCookiesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksSourceCookiesCookies | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceCookiesCookies | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DomainDevicesDisksSourceCookiesCookiesList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksSourceCookiesCookies[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksSourceCookiesCookiesOutputReference {
    return new DomainDevicesDisksSourceCookiesCookiesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksSourceCookies {
  /**
  * Configures one or more HTTP cookies to be sent when accessing the mirrored backing store over a network protocol that supports cookies (for example, HTTPS or HTTP-based storage).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#cookies Domain#cookies}
  */
  readonly cookies?: DomainDevicesDisksSourceCookiesCookies[] | cdktf.IResolvable;
}

export function domainDevicesDisksSourceCookiesToTerraform(struct?: DomainDevicesDisksSourceCookies | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cookies: cdktf.listMapper(domainDevicesDisksSourceCookiesCookiesToTerraform, false)(struct!.cookies),
  }
}


export function domainDevicesDisksSourceCookiesToHclTerraform(struct?: DomainDevicesDisksSourceCookies | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cookies: {
      value: cdktf.listMapperHcl(domainDevicesDisksSourceCookiesCookiesToHclTerraform, false)(struct!.cookies),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksSourceCookiesCookiesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceCookiesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceCookies | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cookies?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cookies = this._cookies?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceCookies | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cookies.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cookies.internalValue = value.cookies;
    }
  }

  // cookies - computed: false, optional: true, required: false
  private _cookies = new DomainDevicesDisksSourceCookiesCookiesList(this, "cookies", false);
  public get cookies() {
    return this._cookies;
  }
  public putCookies(value: DomainDevicesDisksSourceCookiesCookies[] | cdktf.IResolvable) {
    this._cookies.internalValue = value;
  }
  public resetCookies() {
    this._cookies.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cookiesInput() {
    return this._cookies.internalValue;
  }
}
export interface DomainDevicesDisksSourceDataStoreFormatMetadataCacheMaxSize {
  /**
  * Sets the unit used for the metadata cache maximum size; valid units follow libvirt size units such as "B", "KiB", "MiB", "GiB" and are user-chosen.
  * 
  * See: <https://libvirt.org/formatdomain.html#memory-allocation>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#unit Domain#unit}
  */
  readonly unit?: string;
  /**
  * Sets the numeric value for the metadata cache maximum size in the specified unit; this must be a positive integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#value Domain#value}
  */
  readonly value: number;
}

export function domainDevicesDisksSourceDataStoreFormatMetadataCacheMaxSizeToTerraform(struct?: DomainDevicesDisksSourceDataStoreFormatMetadataCacheMaxSize | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    unit: cdktf.stringToTerraform(struct!.unit),
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function domainDevicesDisksSourceDataStoreFormatMetadataCacheMaxSizeToHclTerraform(struct?: DomainDevicesDisksSourceDataStoreFormatMetadataCacheMaxSize | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    unit: {
      value: cdktf.stringToHclTerraform(struct!.unit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceDataStoreFormatMetadataCacheMaxSizeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceDataStoreFormatMetadataCacheMaxSize | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._unit !== undefined) {
      hasAnyValues = true;
      internalValueResult.unit = this._unit;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceDataStoreFormatMetadataCacheMaxSize | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._unit = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._unit = value.unit;
      this._value = value.value;
    }
  }

  // unit - computed: false, optional: true, required: false
  private _unit?: string; 
  public get unit() {
    return this.getStringAttribute('unit');
  }
  public set unit(value: string) {
    this._unit = value;
  }
  public resetUnit() {
    this._unit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unitInput() {
    return this._unit;
  }

  // value - computed: false, optional: false, required: true
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DomainDevicesDisksSourceDataStoreFormatMetadataCache {
  /**
  * Sets the maximum size of the metadata cache used by the data store format; value and unit together define the limit (for example, 64 MiB).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#max_size Domain#max_size}
  */
  readonly maxSize?: DomainDevicesDisksSourceDataStoreFormatMetadataCacheMaxSize;
}

export function domainDevicesDisksSourceDataStoreFormatMetadataCacheToTerraform(struct?: DomainDevicesDisksSourceDataStoreFormatMetadataCache | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_size: domainDevicesDisksSourceDataStoreFormatMetadataCacheMaxSizeToTerraform(struct!.maxSize),
  }
}


export function domainDevicesDisksSourceDataStoreFormatMetadataCacheToHclTerraform(struct?: DomainDevicesDisksSourceDataStoreFormatMetadataCache | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_size: {
      value: domainDevicesDisksSourceDataStoreFormatMetadataCacheMaxSizeToHclTerraform(struct!.maxSize),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceDataStoreFormatMetadataCacheMaxSize",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceDataStoreFormatMetadataCacheOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceDataStoreFormatMetadataCache | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxSize?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceDataStoreFormatMetadataCache | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxSize.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxSize.internalValue = value.maxSize;
    }
  }

  // max_size - computed: false, optional: true, required: false
  private _maxSize = new DomainDevicesDisksSourceDataStoreFormatMetadataCacheMaxSizeOutputReference(this, "max_size");
  public get maxSize() {
    return this._maxSize;
  }
  public putMaxSize(value: DomainDevicesDisksSourceDataStoreFormatMetadataCacheMaxSize) {
    this._maxSize.internalValue = value;
  }
  public resetMaxSize() {
    this._maxSize.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize.internalValue;
  }
}
export interface DomainDevicesDisksSourceDataStoreFormat {
  /**
  * Configures metadata cache behavior for the mirrored backing store’s data store format (for example, limiting the size of cached metadata).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#metadata_cache Domain#metadata_cache}
  */
  readonly metadataCache?: DomainDevicesDisksSourceDataStoreFormatMetadataCache;
  /**
  * Sets the data store format type for the mirrored backing store (for example, "qcow2" or "raw"); the value is user-provided and must be a valid libvirt disk format name.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type: string;
}

export function domainDevicesDisksSourceDataStoreFormatToTerraform(struct?: DomainDevicesDisksSourceDataStoreFormat | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metadata_cache: domainDevicesDisksSourceDataStoreFormatMetadataCacheToTerraform(struct!.metadataCache),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function domainDevicesDisksSourceDataStoreFormatToHclTerraform(struct?: DomainDevicesDisksSourceDataStoreFormat | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metadata_cache: {
      value: domainDevicesDisksSourceDataStoreFormatMetadataCacheToHclTerraform(struct!.metadataCache),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceDataStoreFormatMetadataCache",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceDataStoreFormatOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceDataStoreFormat | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metadataCache?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadataCache = this._metadataCache?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceDataStoreFormat | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metadataCache.internalValue = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metadataCache.internalValue = value.metadataCache;
      this._type = value.type;
    }
  }

  // metadata_cache - computed: false, optional: true, required: false
  private _metadataCache = new DomainDevicesDisksSourceDataStoreFormatMetadataCacheOutputReference(this, "metadata_cache");
  public get metadataCache() {
    return this._metadataCache;
  }
  public putMetadataCache(value: DomainDevicesDisksSourceDataStoreFormatMetadataCache) {
    this._metadataCache.internalValue = value;
  }
  public resetMetadataCache() {
    this._metadataCache.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataCacheInput() {
    return this._metadataCache.internalValue;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DomainDevicesDisksSourceDataStore {
  /**
  * Configures the on-disk format settings for the mirrored backing store’s data store, including format type and optional metadata cache tuning.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#format Domain#format}
  */
  readonly format?: DomainDevicesDisksSourceDataStoreFormat;
}

export function domainDevicesDisksSourceDataStoreToTerraform(struct?: DomainDevicesDisksSourceDataStore | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    format: domainDevicesDisksSourceDataStoreFormatToTerraform(struct!.format),
  }
}


export function domainDevicesDisksSourceDataStoreToHclTerraform(struct?: DomainDevicesDisksSourceDataStore | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    format: {
      value: domainDevicesDisksSourceDataStoreFormatToHclTerraform(struct!.format),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceDataStoreFormat",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceDataStoreOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceDataStore | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._format?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceDataStore | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._format.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._format.internalValue = value.format;
    }
  }

  // format - computed: false, optional: true, required: false
  private _format = new DomainDevicesDisksSourceDataStoreFormatOutputReference(this, "format");
  public get format() {
    return this._format;
  }
  public putFormat(value: DomainDevicesDisksSourceDataStoreFormat) {
    this._format.internalValue = value;
  }
  public resetFormat() {
    this._format.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format.internalValue;
  }
}
export interface DomainDevicesDisksSourceDir {
  /**
  * Sets the host directory path used as the mirrored backing store source; this must be an absolute path on the host (for example, "/var/lib/libvirt/images").
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dir Domain#dir}
  */
  readonly dir?: string;
}

export function domainDevicesDisksSourceDirToTerraform(struct?: DomainDevicesDisksSourceDir | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dir: cdktf.stringToTerraform(struct!.dir),
  }
}


export function domainDevicesDisksSourceDirToHclTerraform(struct?: DomainDevicesDisksSourceDir | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dir: {
      value: cdktf.stringToHclTerraform(struct!.dir),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceDirOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceDir | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dir !== undefined) {
      hasAnyValues = true;
      internalValueResult.dir = this._dir;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceDir | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dir = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dir = value.dir;
    }
  }

  // dir - computed: false, optional: true, required: false
  private _dir?: string; 
  public get dir() {
    return this.getStringAttribute('dir');
  }
  public set dir(value: string) {
    this._dir = value;
  }
  public resetDir() {
    this._dir = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dirInput() {
    return this._dir;
  }
}
export interface DomainDevicesDisksSourceEncryptionSecrets {
  /**
  * Sets how the referenced secret is identified; typical values are user-provided strings such as "uuid" or "usage" depending on how the secret is looked up.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type?: string;
  /**
  * Sets the libvirt secret usage name when referencing the iSCSI auth secret by usage; the value is a user-provided identifier such as an iSCSI target name.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#usage Domain#usage}
  */
  readonly usage?: string;
}

export function domainDevicesDisksSourceEncryptionSecretsToTerraform(struct?: DomainDevicesDisksSourceEncryptionSecrets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    type: cdktf.stringToTerraform(struct!.type),
    usage: cdktf.stringToTerraform(struct!.usage),
  }
}


export function domainDevicesDisksSourceEncryptionSecretsToHclTerraform(struct?: DomainDevicesDisksSourceEncryptionSecrets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    usage: {
      value: cdktf.stringToHclTerraform(struct!.usage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceEncryptionSecretsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksSourceEncryptionSecrets | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._usage !== undefined) {
      hasAnyValues = true;
      internalValueResult.usage = this._usage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceEncryptionSecrets | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._type = undefined;
      this._usage = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._type = value.type;
      this._usage = value.usage;
    }
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // usage - computed: false, optional: true, required: false
  private _usage?: string; 
  public get usage() {
    return this.getStringAttribute('usage');
  }
  public set usage(value: string) {
    this._usage = value;
  }
  public resetUsage() {
    this._usage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usageInput() {
    return this._usage;
  }

  // uuid - computed: true, optional: false, required: false
  public get uuid() {
    return this.getStringAttribute('uuid');
  }
}

export class DomainDevicesDisksSourceEncryptionSecretsList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksSourceEncryptionSecrets[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksSourceEncryptionSecretsOutputReference {
    return new DomainDevicesDisksSourceEncryptionSecretsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksSourceEncryption {
  /**
  * Sets the encryption engine/provider to use for the disk (user-provided string, e.g. implementation-specific engine name).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#engine Domain#engine}
  */
  readonly engine?: string;
  /**
  * Sets the disk encryption format, such as "luks" or another user-provided scheme supported by libvirt/qemu.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#format Domain#format}
  */
  readonly format?: string;
  /**
  * Defines one or more secret references used to access the encrypted disk, each describing how libvirt locates the secret material.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#secrets Domain#secrets}
  */
  readonly secrets?: DomainDevicesDisksSourceEncryptionSecrets[] | cdktf.IResolvable;
}

export function domainDevicesDisksSourceEncryptionToTerraform(struct?: DomainDevicesDisksSourceEncryption | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    engine: cdktf.stringToTerraform(struct!.engine),
    format: cdktf.stringToTerraform(struct!.format),
    secrets: cdktf.listMapper(domainDevicesDisksSourceEncryptionSecretsToTerraform, false)(struct!.secrets),
  }
}


export function domainDevicesDisksSourceEncryptionToHclTerraform(struct?: DomainDevicesDisksSourceEncryption | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    engine: {
      value: cdktf.stringToHclTerraform(struct!.engine),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secrets: {
      value: cdktf.listMapperHcl(domainDevicesDisksSourceEncryptionSecretsToHclTerraform, false)(struct!.secrets),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksSourceEncryptionSecretsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceEncryptionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceEncryption | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._engine !== undefined) {
      hasAnyValues = true;
      internalValueResult.engine = this._engine;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._secrets?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secrets = this._secrets?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceEncryption | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._engine = undefined;
      this._format = undefined;
      this._secrets.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._engine = value.engine;
      this._format = value.format;
      this._secrets.internalValue = value.secrets;
    }
  }

  // engine - computed: false, optional: true, required: false
  private _engine?: string; 
  public get engine() {
    return this.getStringAttribute('engine');
  }
  public set engine(value: string) {
    this._engine = value;
  }
  public resetEngine() {
    this._engine = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get engineInput() {
    return this._engine;
  }

  // format - computed: false, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // secrets - computed: false, optional: true, required: false
  private _secrets = new DomainDevicesDisksSourceEncryptionSecretsList(this, "secrets", false);
  public get secrets() {
    return this._secrets;
  }
  public putSecrets(value: DomainDevicesDisksSourceEncryptionSecrets[] | cdktf.IResolvable) {
    this._secrets.internalValue = value;
  }
  public resetSecrets() {
    this._secrets.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretsInput() {
    return this._secrets.internalValue;
  }
}
export interface DomainDevicesDisksSourceFileSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksSourceFileSecLabelToTerraform(struct?: DomainDevicesDisksSourceFileSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksSourceFileSecLabelToHclTerraform(struct?: DomainDevicesDisksSourceFileSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceFileSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksSourceFileSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceFileSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksSourceFileSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksSourceFileSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksSourceFileSecLabelOutputReference {
    return new DomainDevicesDisksSourceFileSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksSourceFile {
  /**
  * Sets the name of an fdgroup whose pre-opened file descriptor is used for this backing store instead of opening the file path directly; value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#fd_group Domain#fd_group}
  */
  readonly fdGroup?: string;
  /**
  * Sets the absolute path on the host to the backing file used as the source for this mirrored disk (for example, /var/lib/libvirt/images/base.qcow2).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file?: string;
  /**
  * Configures an explicit security label for the file backing store, overriding default security driver labeling for this file.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksSourceFileSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksSourceFileToTerraform(struct?: DomainDevicesDisksSourceFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fd_group: cdktf.stringToTerraform(struct!.fdGroup),
    file: cdktf.stringToTerraform(struct!.file),
    sec_label: cdktf.listMapper(domainDevicesDisksSourceFileSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksSourceFileToHclTerraform(struct?: DomainDevicesDisksSourceFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fd_group: {
      value: cdktf.stringToHclTerraform(struct!.fdGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    file: {
      value: cdktf.stringToHclTerraform(struct!.file),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksSourceFileSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksSourceFileSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceFileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceFile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fdGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.fdGroup = this._fdGroup;
    }
    if (this._file !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceFile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fdGroup = undefined;
      this._file = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fdGroup = value.fdGroup;
      this._file = value.file;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // fd_group - computed: false, optional: true, required: false
  private _fdGroup?: string; 
  public get fdGroup() {
    return this.getStringAttribute('fd_group');
  }
  public set fdGroup(value: string) {
    this._fdGroup = value;
  }
  public resetFdGroup() {
    this._fdGroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fdGroupInput() {
    return this._fdGroup;
  }

  // file - computed: false, optional: true, required: false
  private _file?: string; 
  public get file() {
    return this.getStringAttribute('file');
  }
  public set file(value: string) {
    this._file = value;
  }
  public resetFile() {
    this._file = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksSourceFileSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksSourceFileSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksSourceNetworkAuthSecret {
  /**
  * Sets how the referenced secret is identified; typical values are user-provided strings such as "uuid" or "usage" depending on how the secret is looked up.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type?: string;
  /**
  * Sets the libvirt secret usage name when referencing the iSCSI auth secret by usage; the value is a user-provided identifier such as an iSCSI target name.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#usage Domain#usage}
  */
  readonly usage?: string;
}

export function domainDevicesDisksSourceNetworkAuthSecretToTerraform(struct?: DomainDevicesDisksSourceNetworkAuthSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    type: cdktf.stringToTerraform(struct!.type),
    usage: cdktf.stringToTerraform(struct!.usage),
  }
}


export function domainDevicesDisksSourceNetworkAuthSecretToHclTerraform(struct?: DomainDevicesDisksSourceNetworkAuthSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    usage: {
      value: cdktf.stringToHclTerraform(struct!.usage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceNetworkAuthSecretOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceNetworkAuthSecret | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._usage !== undefined) {
      hasAnyValues = true;
      internalValueResult.usage = this._usage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceNetworkAuthSecret | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._type = undefined;
      this._usage = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._type = value.type;
      this._usage = value.usage;
    }
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // usage - computed: false, optional: true, required: false
  private _usage?: string; 
  public get usage() {
    return this.getStringAttribute('usage');
  }
  public set usage(value: string) {
    this._usage = value;
  }
  public resetUsage() {
    this._usage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usageInput() {
    return this._usage;
  }

  // uuid - computed: true, optional: false, required: false
  public get uuid() {
    return this.getStringAttribute('uuid');
  }
}
export interface DomainDevicesDisksSourceNetworkAuth {
  /**
  * Configures the libvirt secret object used to hold the iSCSI authentication password for this hostdev; this references an existing libvirt secret, not the clear-text secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#secret Domain#secret}
  */
  readonly secret?: DomainDevicesDisksSourceNetworkAuthSecret;
  /**
  * Sets the CHAP username used when authenticating to the iSCSI target for this SCSI hostdev; the value is user-provided (for example, "chapuser1").
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#username Domain#username}
  */
  readonly username?: string;
}

export function domainDevicesDisksSourceNetworkAuthToTerraform(struct?: DomainDevicesDisksSourceNetworkAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret: domainDevicesDisksSourceNetworkAuthSecretToTerraform(struct!.secret),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function domainDevicesDisksSourceNetworkAuthToHclTerraform(struct?: DomainDevicesDisksSourceNetworkAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret: {
      value: domainDevicesDisksSourceNetworkAuthSecretToHclTerraform(struct!.secret),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceNetworkAuthSecret",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceNetworkAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceNetworkAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secret?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret?.internalValue;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceNetworkAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secret.internalValue = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secret.internalValue = value.secret;
      this._username = value.username;
    }
  }

  // secret - computed: false, optional: true, required: false
  private _secret = new DomainDevicesDisksSourceNetworkAuthSecretOutputReference(this, "secret");
  public get secret() {
    return this._secret;
  }
  public putSecret(value: DomainDevicesDisksSourceNetworkAuthSecret) {
    this._secret.internalValue = value;
  }
  public resetSecret() {
    this._secret.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret.internalValue;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface DomainDevicesDisksSourceNetworkConfig {
  /**
  * Sets the path to the configuration file used for the network backing store connection, such as a Ceph configuration file (/etc/ceph/ceph.conf).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file: string;
}

export function domainDevicesDisksSourceNetworkConfigToTerraform(struct?: DomainDevicesDisksSourceNetworkConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    file: cdktf.stringToTerraform(struct!.file),
  }
}


export function domainDevicesDisksSourceNetworkConfigToHclTerraform(struct?: DomainDevicesDisksSourceNetworkConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    file: {
      value: cdktf.stringToHclTerraform(struct!.file),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceNetworkConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceNetworkConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._file !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceNetworkConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._file = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._file = value.file;
    }
  }

  // file - computed: false, optional: false, required: true
  private _file?: string; 
  public get file() {
    return this.getStringAttribute('file');
  }
  public set file(value: string) {
    this._file = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file;
  }
}
export interface DomainDevicesDisksSourceNetworkHosts {
  /**
  * Sets the hostname or IP address of the iSCSI target portal (for example, "10.0.0.10" or "iscsi.example.com").
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name?: string;
  /**
  * Sets the TCP port of the iSCSI target portal; if omitted, libvirt/driver defaults (commonly 3260) are used.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#port Domain#port}
  */
  readonly port?: string;
  /**
  * Sets a UNIX domain socket path to connect to an iSCSI target via a local socket instead of TCP; value is a user-provided filesystem path.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#socket Domain#socket}
  */
  readonly socket?: string;
  /**
  * Sets the transport type used to reach the iSCSI target portal; valid values are user-provided strings as supported by the environment (for example, "tcp" or "iser").
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#transport Domain#transport}
  */
  readonly transport?: string;
}

export function domainDevicesDisksSourceNetworkHostsToTerraform(struct?: DomainDevicesDisksSourceNetworkHosts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    port: cdktf.stringToTerraform(struct!.port),
    socket: cdktf.stringToTerraform(struct!.socket),
    transport: cdktf.stringToTerraform(struct!.transport),
  }
}


export function domainDevicesDisksSourceNetworkHostsToHclTerraform(struct?: DomainDevicesDisksSourceNetworkHosts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.stringToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    socket: {
      value: cdktf.stringToHclTerraform(struct!.socket),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    transport: {
      value: cdktf.stringToHclTerraform(struct!.transport),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceNetworkHostsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksSourceNetworkHosts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._socket !== undefined) {
      hasAnyValues = true;
      internalValueResult.socket = this._socket;
    }
    if (this._transport !== undefined) {
      hasAnyValues = true;
      internalValueResult.transport = this._transport;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceNetworkHosts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._port = undefined;
      this._socket = undefined;
      this._transport = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._port = value.port;
      this._socket = value.socket;
      this._transport = value.transport;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port - computed: false, optional: true, required: false
  private _port?: string; 
  public get port() {
    return this.getStringAttribute('port');
  }
  public set port(value: string) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // socket - computed: false, optional: true, required: false
  private _socket?: string; 
  public get socket() {
    return this.getStringAttribute('socket');
  }
  public set socket(value: string) {
    this._socket = value;
  }
  public resetSocket() {
    this._socket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketInput() {
    return this._socket;
  }

  // transport - computed: false, optional: true, required: false
  private _transport?: string; 
  public get transport() {
    return this.getStringAttribute('transport');
  }
  public set transport(value: string) {
    this._transport = value;
  }
  public resetTransport() {
    this._transport = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get transportInput() {
    return this._transport;
  }
}

export class DomainDevicesDisksSourceNetworkHostsList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksSourceNetworkHosts[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksSourceNetworkHostsOutputReference {
    return new DomainDevicesDisksSourceNetworkHostsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksSourceNetworkIdentity {
  /**
  * Sets the path to a local agent socket used for external authentication (for example, SASL or SSH agent) when connecting to the network backing store; value is a user-provided Unix socket path.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#agent_sock Domain#agent_sock}
  */
  readonly agentSock?: string;
  /**
  * Sets the group name to use for authentication or access control when connecting to the network backing store; value is user-provided and protocol-specific.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#group Domain#group}
  */
  readonly group?: string;
  /**
  * Sets the path to a private key file used for authenticating to the network backing store (for example, an SSH or TLS key); value is a user-provided filesystem path.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#keyfile Domain#keyfile}
  */
  readonly keyfile?: string;
  /**
  * Sets the user identifier used for authentication to the network backing store; value is user-provided and typically matches a remote account name.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#user Domain#user}
  */
  readonly user?: string;
  /**
  * Sets an explicit username string used for authentication to the network backing store, separate from any other user identity settings; value is user-provided (for example, "backupuser").
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#user_name Domain#user_name}
  */
  readonly userName?: string;
}

export function domainDevicesDisksSourceNetworkIdentityToTerraform(struct?: DomainDevicesDisksSourceNetworkIdentity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    agent_sock: cdktf.stringToTerraform(struct!.agentSock),
    group: cdktf.stringToTerraform(struct!.group),
    keyfile: cdktf.stringToTerraform(struct!.keyfile),
    user: cdktf.stringToTerraform(struct!.user),
    user_name: cdktf.stringToTerraform(struct!.userName),
  }
}


export function domainDevicesDisksSourceNetworkIdentityToHclTerraform(struct?: DomainDevicesDisksSourceNetworkIdentity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    agent_sock: {
      value: cdktf.stringToHclTerraform(struct!.agentSock),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    group: {
      value: cdktf.stringToHclTerraform(struct!.group),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keyfile: {
      value: cdktf.stringToHclTerraform(struct!.keyfile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user: {
      value: cdktf.stringToHclTerraform(struct!.user),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user_name: {
      value: cdktf.stringToHclTerraform(struct!.userName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceNetworkIdentityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceNetworkIdentity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._agentSock !== undefined) {
      hasAnyValues = true;
      internalValueResult.agentSock = this._agentSock;
    }
    if (this._group !== undefined) {
      hasAnyValues = true;
      internalValueResult.group = this._group;
    }
    if (this._keyfile !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyfile = this._keyfile;
    }
    if (this._user !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user;
    }
    if (this._userName !== undefined) {
      hasAnyValues = true;
      internalValueResult.userName = this._userName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceNetworkIdentity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._agentSock = undefined;
      this._group = undefined;
      this._keyfile = undefined;
      this._user = undefined;
      this._userName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._agentSock = value.agentSock;
      this._group = value.group;
      this._keyfile = value.keyfile;
      this._user = value.user;
      this._userName = value.userName;
    }
  }

  // agent_sock - computed: false, optional: true, required: false
  private _agentSock?: string; 
  public get agentSock() {
    return this.getStringAttribute('agent_sock');
  }
  public set agentSock(value: string) {
    this._agentSock = value;
  }
  public resetAgentSock() {
    this._agentSock = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get agentSockInput() {
    return this._agentSock;
  }

  // group - computed: false, optional: true, required: false
  private _group?: string; 
  public get group() {
    return this.getStringAttribute('group');
  }
  public set group(value: string) {
    this._group = value;
  }
  public resetGroup() {
    this._group = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupInput() {
    return this._group;
  }

  // keyfile - computed: false, optional: true, required: false
  private _keyfile?: string; 
  public get keyfile() {
    return this.getStringAttribute('keyfile');
  }
  public set keyfile(value: string) {
    this._keyfile = value;
  }
  public resetKeyfile() {
    this._keyfile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyfileInput() {
    return this._keyfile;
  }

  // user - computed: false, optional: true, required: false
  private _user?: string; 
  public get user() {
    return this.getStringAttribute('user');
  }
  public set user(value: string) {
    this._user = value;
  }
  public resetUser() {
    this._user = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user;
  }

  // user_name - computed: false, optional: true, required: false
  private _userName?: string; 
  public get userName() {
    return this.getStringAttribute('user_name');
  }
  public set userName(value: string) {
    this._userName = value;
  }
  public resetUserName() {
    this._userName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userNameInput() {
    return this._userName;
  }
}
export interface DomainDevicesDisksSourceNetworkInitiatorIqn {
  /**
  * Sets the initiator IQN string used when logging into an iSCSI target backing the mirrored disk; value must be a valid IQN (for example, iqn.2020-01.com.example:host1).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name?: string;
}

export function domainDevicesDisksSourceNetworkInitiatorIqnToTerraform(struct?: DomainDevicesDisksSourceNetworkInitiatorIqn | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function domainDevicesDisksSourceNetworkInitiatorIqnToHclTerraform(struct?: DomainDevicesDisksSourceNetworkInitiatorIqn | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceNetworkInitiatorIqnOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceNetworkInitiatorIqn | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceNetworkInitiatorIqn | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DomainDevicesDisksSourceNetworkInitiator {
  /**
  * Configures the iSCSI initiator IQN block for the mirrored network backing store, defining the initiator name presented to the target.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#iqn Domain#iqn}
  */
  readonly iqn?: DomainDevicesDisksSourceNetworkInitiatorIqn;
}

export function domainDevicesDisksSourceNetworkInitiatorToTerraform(struct?: DomainDevicesDisksSourceNetworkInitiator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    iqn: domainDevicesDisksSourceNetworkInitiatorIqnToTerraform(struct!.iqn),
  }
}


export function domainDevicesDisksSourceNetworkInitiatorToHclTerraform(struct?: DomainDevicesDisksSourceNetworkInitiator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    iqn: {
      value: domainDevicesDisksSourceNetworkInitiatorIqnToHclTerraform(struct!.iqn),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceNetworkInitiatorIqn",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceNetworkInitiatorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceNetworkInitiator | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._iqn?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.iqn = this._iqn?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceNetworkInitiator | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._iqn.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._iqn.internalValue = value.iqn;
    }
  }

  // iqn - computed: false, optional: true, required: false
  private _iqn = new DomainDevicesDisksSourceNetworkInitiatorIqnOutputReference(this, "iqn");
  public get iqn() {
    return this._iqn;
  }
  public putIqn(value: DomainDevicesDisksSourceNetworkInitiatorIqn) {
    this._iqn.internalValue = value;
  }
  public resetIqn() {
    this._iqn.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get iqnInput() {
    return this._iqn.internalValue;
  }
}
export interface DomainDevicesDisksSourceNetworkKnownHosts {
  /**
  * Sets the path to the known-hosts file used to verify the identity of the remote storage host; value is a required user-provided filesystem path (for example, /etc/libvirt/known_hosts).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
}

export function domainDevicesDisksSourceNetworkKnownHostsToTerraform(struct?: DomainDevicesDisksSourceNetworkKnownHosts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function domainDevicesDisksSourceNetworkKnownHostsToHclTerraform(struct?: DomainDevicesDisksSourceNetworkKnownHosts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceNetworkKnownHostsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceNetworkKnownHosts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceNetworkKnownHosts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface DomainDevicesDisksSourceNetworkReconnect {
  /**
  * Sets the reconnection delay (in seconds) before retrying a failed connection to the mirrored network backing store; value is a required user-provided non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#delay Domain#delay}
  */
  readonly delay: string;
}

export function domainDevicesDisksSourceNetworkReconnectToTerraform(struct?: DomainDevicesDisksSourceNetworkReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    delay: cdktf.stringToTerraform(struct!.delay),
  }
}


export function domainDevicesDisksSourceNetworkReconnectToHclTerraform(struct?: DomainDevicesDisksSourceNetworkReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    delay: {
      value: cdktf.stringToHclTerraform(struct!.delay),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceNetworkReconnectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceNetworkReconnect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._delay !== undefined) {
      hasAnyValues = true;
      internalValueResult.delay = this._delay;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceNetworkReconnect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._delay = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._delay = value.delay;
    }
  }

  // delay - computed: false, optional: false, required: true
  private _delay?: string; 
  public get delay() {
    return this.getStringAttribute('delay');
  }
  public set delay(value: string) {
    this._delay = value;
  }
  // Temporarily expose input value. Use with caution.
  public get delayInput() {
    return this._delay;
  }
}
export interface DomainDevicesDisksSourceNetworkSnapshot {
  /**
  * Sets the name of the network snapshot to use as the backing store for the mirrored disk’s network source; value is user-provided and must match an existing snapshot identifier on the storage backend.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
}

export function domainDevicesDisksSourceNetworkSnapshotToTerraform(struct?: DomainDevicesDisksSourceNetworkSnapshot | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function domainDevicesDisksSourceNetworkSnapshotToHclTerraform(struct?: DomainDevicesDisksSourceNetworkSnapshot | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceNetworkSnapshotOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceNetworkSnapshot | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceNetworkSnapshot | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DomainDevicesDisksSourceNetwork {
  /**
  * Configures CHAP authentication parameters for the iSCSI source backing an assigned SCSI host device; include this block only when the target requires authentication.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#auth Domain#auth}
  */
  readonly auth?: DomainDevicesDisksSourceNetworkAuth;
  /**
  * Points to an external configuration source for the network backing store (for example, an RBD or Ceph config file) that libvirt passes to the backend.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#config Domain#config}
  */
  readonly config?: DomainDevicesDisksSourceNetworkConfig;
  /**
  * Declares one or more network endpoints (hosts) for the backing store server, each with its own name/address and possibly additional attributes.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#hosts Domain#hosts}
  */
  readonly hosts?: DomainDevicesDisksSourceNetworkHosts[] | cdktf.IResolvable;
  /**
  * Configures authentication/identity parameters used when accessing the mirrored backing store over a network, such as user, group, keyfile, or agent socket, depending on the protocol.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#identity Domain#identity}
  */
  readonly identity?: DomainDevicesDisksSourceNetworkIdentity;
  /**
  * Configures initiator identity information (typically for iSCSI-like protocols) used when accessing the mirrored network backing store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#initiator Domain#initiator}
  */
  readonly initiator?: DomainDevicesDisksSourceNetworkInitiator;
  /**
  * Enables use of a known-hosts file to validate the remote host’s identity when connecting to the mirrored network backing store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#known_hosts Domain#known_hosts}
  */
  readonly knownHosts?: DomainDevicesDisksSourceNetworkKnownHosts;
  /**
  * Sets a name for the network source of the mirrored backing store, typically used by certain protocols (such as RBD pool or NBD export names); value is user-provided and protocol-specific.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name?: string;
  /**
  * Sets the network storage protocol used for the mirrored backing store; value is user-provided but must be a protocol supported by libvirt for network disks (for example, rbd, sheepdog, gluster, nbd).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#protocol Domain#protocol}
  */
  readonly protocol?: string;
  /**
  * Sets an optional query string or subresource specifier for the network storage URL of the mirrored backing store; value is user-provided and protocol-specific.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#query Domain#query}
  */
  readonly query?: string;
  /**
  * Configures automatic reconnection behavior for the mirrored network backing store after a connection loss.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reconnect Domain#reconnect}
  */
  readonly reconnect?: DomainDevicesDisksSourceNetworkReconnect;
  /**
  * Configures snapshot-related behavior for the network-based mirrored backing store, with semantics depending on the underlying protocol and storage implementation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#snapshot Domain#snapshot}
  */
  readonly snapshot?: DomainDevicesDisksSourceNetworkSnapshot;
  /**
  * Controls whether TLS is used for the mirrored disk’s network backing-store connection; value is user-provided and typically enabled only when the chosen protocol and backend support TLS.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tls Domain#tls}
  */
  readonly tls?: string;
  /**
  * Sets the expected TLS hostname for the mirrored disk’s network backing-store connection, used for certificate verification; value is user-provided and should match the server certificate’s hostname (for example, "storage.example.com").
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tls_hostname Domain#tls_hostname}
  */
  readonly tlsHostname?: string;
}

export function domainDevicesDisksSourceNetworkToTerraform(struct?: DomainDevicesDisksSourceNetwork | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: domainDevicesDisksSourceNetworkAuthToTerraform(struct!.auth),
    config: domainDevicesDisksSourceNetworkConfigToTerraform(struct!.config),
    hosts: cdktf.listMapper(domainDevicesDisksSourceNetworkHostsToTerraform, false)(struct!.hosts),
    identity: domainDevicesDisksSourceNetworkIdentityToTerraform(struct!.identity),
    initiator: domainDevicesDisksSourceNetworkInitiatorToTerraform(struct!.initiator),
    known_hosts: domainDevicesDisksSourceNetworkKnownHostsToTerraform(struct!.knownHosts),
    name: cdktf.stringToTerraform(struct!.name),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    query: cdktf.stringToTerraform(struct!.query),
    reconnect: domainDevicesDisksSourceNetworkReconnectToTerraform(struct!.reconnect),
    snapshot: domainDevicesDisksSourceNetworkSnapshotToTerraform(struct!.snapshot),
    tls: cdktf.stringToTerraform(struct!.tls),
    tls_hostname: cdktf.stringToTerraform(struct!.tlsHostname),
  }
}


export function domainDevicesDisksSourceNetworkToHclTerraform(struct?: DomainDevicesDisksSourceNetwork | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: domainDevicesDisksSourceNetworkAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceNetworkAuth",
    },
    config: {
      value: domainDevicesDisksSourceNetworkConfigToHclTerraform(struct!.config),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceNetworkConfig",
    },
    hosts: {
      value: cdktf.listMapperHcl(domainDevicesDisksSourceNetworkHostsToHclTerraform, false)(struct!.hosts),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksSourceNetworkHostsList",
    },
    identity: {
      value: domainDevicesDisksSourceNetworkIdentityToHclTerraform(struct!.identity),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceNetworkIdentity",
    },
    initiator: {
      value: domainDevicesDisksSourceNetworkInitiatorToHclTerraform(struct!.initiator),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceNetworkInitiator",
    },
    known_hosts: {
      value: domainDevicesDisksSourceNetworkKnownHostsToHclTerraform(struct!.knownHosts),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceNetworkKnownHosts",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    query: {
      value: cdktf.stringToHclTerraform(struct!.query),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reconnect: {
      value: domainDevicesDisksSourceNetworkReconnectToHclTerraform(struct!.reconnect),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceNetworkReconnect",
    },
    snapshot: {
      value: domainDevicesDisksSourceNetworkSnapshotToHclTerraform(struct!.snapshot),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceNetworkSnapshot",
    },
    tls: {
      value: cdktf.stringToHclTerraform(struct!.tls),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_hostname: {
      value: cdktf.stringToHclTerraform(struct!.tlsHostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceNetworkOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceNetwork | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._config?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.config = this._config?.internalValue;
    }
    if (this._hosts?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hosts = this._hosts?.internalValue;
    }
    if (this._identity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.identity = this._identity?.internalValue;
    }
    if (this._initiator?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.initiator = this._initiator?.internalValue;
    }
    if (this._knownHosts?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.knownHosts = this._knownHosts?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._query !== undefined) {
      hasAnyValues = true;
      internalValueResult.query = this._query;
    }
    if (this._reconnect?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.reconnect = this._reconnect?.internalValue;
    }
    if (this._snapshot?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.snapshot = this._snapshot?.internalValue;
    }
    if (this._tls !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls;
    }
    if (this._tlsHostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsHostname = this._tlsHostname;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceNetwork | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._config.internalValue = undefined;
      this._hosts.internalValue = undefined;
      this._identity.internalValue = undefined;
      this._initiator.internalValue = undefined;
      this._knownHosts.internalValue = undefined;
      this._name = undefined;
      this._protocol = undefined;
      this._query = undefined;
      this._reconnect.internalValue = undefined;
      this._snapshot.internalValue = undefined;
      this._tls = undefined;
      this._tlsHostname = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._config.internalValue = value.config;
      this._hosts.internalValue = value.hosts;
      this._identity.internalValue = value.identity;
      this._initiator.internalValue = value.initiator;
      this._knownHosts.internalValue = value.knownHosts;
      this._name = value.name;
      this._protocol = value.protocol;
      this._query = value.query;
      this._reconnect.internalValue = value.reconnect;
      this._snapshot.internalValue = value.snapshot;
      this._tls = value.tls;
      this._tlsHostname = value.tlsHostname;
    }
  }

  // auth - computed: false, optional: true, required: false
  private _auth = new DomainDevicesDisksSourceNetworkAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DomainDevicesDisksSourceNetworkAuth) {
    this._auth.internalValue = value;
  }
  public resetAuth() {
    this._auth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // config - computed: false, optional: true, required: false
  private _config = new DomainDevicesDisksSourceNetworkConfigOutputReference(this, "config");
  public get config() {
    return this._config;
  }
  public putConfig(value: DomainDevicesDisksSourceNetworkConfig) {
    this._config.internalValue = value;
  }
  public resetConfig() {
    this._config.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configInput() {
    return this._config.internalValue;
  }

  // hosts - computed: false, optional: true, required: false
  private _hosts = new DomainDevicesDisksSourceNetworkHostsList(this, "hosts", false);
  public get hosts() {
    return this._hosts;
  }
  public putHosts(value: DomainDevicesDisksSourceNetworkHosts[] | cdktf.IResolvable) {
    this._hosts.internalValue = value;
  }
  public resetHosts() {
    this._hosts.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostsInput() {
    return this._hosts.internalValue;
  }

  // identity - computed: false, optional: true, required: false
  private _identity = new DomainDevicesDisksSourceNetworkIdentityOutputReference(this, "identity");
  public get identity() {
    return this._identity;
  }
  public putIdentity(value: DomainDevicesDisksSourceNetworkIdentity) {
    this._identity.internalValue = value;
  }
  public resetIdentity() {
    this._identity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identityInput() {
    return this._identity.internalValue;
  }

  // initiator - computed: false, optional: true, required: false
  private _initiator = new DomainDevicesDisksSourceNetworkInitiatorOutputReference(this, "initiator");
  public get initiator() {
    return this._initiator;
  }
  public putInitiator(value: DomainDevicesDisksSourceNetworkInitiator) {
    this._initiator.internalValue = value;
  }
  public resetInitiator() {
    this._initiator.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initiatorInput() {
    return this._initiator.internalValue;
  }

  // known_hosts - computed: false, optional: true, required: false
  private _knownHosts = new DomainDevicesDisksSourceNetworkKnownHostsOutputReference(this, "known_hosts");
  public get knownHosts() {
    return this._knownHosts;
  }
  public putKnownHosts(value: DomainDevicesDisksSourceNetworkKnownHosts) {
    this._knownHosts.internalValue = value;
  }
  public resetKnownHosts() {
    this._knownHosts.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get knownHostsInput() {
    return this._knownHosts.internalValue;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // protocol - computed: false, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // query - computed: false, optional: true, required: false
  private _query?: string; 
  public get query() {
    return this.getStringAttribute('query');
  }
  public set query(value: string) {
    this._query = value;
  }
  public resetQuery() {
    this._query = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queryInput() {
    return this._query;
  }

  // reconnect - computed: false, optional: true, required: false
  private _reconnect = new DomainDevicesDisksSourceNetworkReconnectOutputReference(this, "reconnect");
  public get reconnect() {
    return this._reconnect;
  }
  public putReconnect(value: DomainDevicesDisksSourceNetworkReconnect) {
    this._reconnect.internalValue = value;
  }
  public resetReconnect() {
    this._reconnect.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reconnectInput() {
    return this._reconnect.internalValue;
  }

  // snapshot - computed: false, optional: true, required: false
  private _snapshot = new DomainDevicesDisksSourceNetworkSnapshotOutputReference(this, "snapshot");
  public get snapshot() {
    return this._snapshot;
  }
  public putSnapshot(value: DomainDevicesDisksSourceNetworkSnapshot) {
    this._snapshot.internalValue = value;
  }
  public resetSnapshot() {
    this._snapshot.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get snapshotInput() {
    return this._snapshot.internalValue;
  }

  // tls - computed: false, optional: true, required: false
  private _tls?: string; 
  public get tls() {
    return this.getStringAttribute('tls');
  }
  public set tls(value: string) {
    this._tls = value;
  }
  public resetTls() {
    this._tls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls;
  }

  // tls_hostname - computed: false, optional: true, required: false
  private _tlsHostname?: string; 
  public get tlsHostname() {
    return this.getStringAttribute('tls_hostname');
  }
  public set tlsHostname(value: string) {
    this._tlsHostname = value;
  }
  public resetTlsHostname() {
    this._tlsHostname = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsHostnameInput() {
    return this._tlsHostname;
  }
}
export interface DomainDevicesDisksSourceNvme {
}

export function domainDevicesDisksSourceNvmeToTerraform(struct?: DomainDevicesDisksSourceNvme | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function domainDevicesDisksSourceNvmeToHclTerraform(struct?: DomainDevicesDisksSourceNvme | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DomainDevicesDisksSourceNvmeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceNvme | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceNvme | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DomainDevicesDisksSourceReadahead {
  /**
  * Sets the read-ahead size for the mirrored disk’s backing store; value is a user-provided positive integer in bytes (for example, 65536 for 64 KiB).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#size Domain#size}
  */
  readonly size: string;
}

export function domainDevicesDisksSourceReadaheadToTerraform(struct?: DomainDevicesDisksSourceReadahead | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    size: cdktf.stringToTerraform(struct!.size),
  }
}


export function domainDevicesDisksSourceReadaheadToHclTerraform(struct?: DomainDevicesDisksSourceReadahead | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    size: {
      value: cdktf.stringToHclTerraform(struct!.size),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceReadaheadOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceReadahead | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._size !== undefined) {
      hasAnyValues = true;
      internalValueResult.size = this._size;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceReadahead | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._size = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._size = value.size;
    }
  }

  // size - computed: false, optional: false, required: true
  private _size?: string; 
  public get size() {
    return this.getStringAttribute('size');
  }
  public set size(value: string) {
    this._size = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sizeInput() {
    return this._size;
  }
}
export interface DomainDevicesDisksSourceReservationsSourceDbus {
  /**
  * Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#channel Domain#channel}
  */
  readonly channel?: string;
}

export function domainDevicesDisksSourceReservationsSourceDbusToTerraform(struct?: DomainDevicesDisksSourceReservationsSourceDbus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    channel: cdktf.stringToTerraform(struct!.channel),
  }
}


export function domainDevicesDisksSourceReservationsSourceDbusToHclTerraform(struct?: DomainDevicesDisksSourceReservationsSourceDbus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    channel: {
      value: cdktf.stringToHclTerraform(struct!.channel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceReservationsSourceDbusOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceReservationsSourceDbus | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._channel !== undefined) {
      hasAnyValues = true;
      internalValueResult.channel = this._channel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceReservationsSourceDbus | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._channel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._channel = value.channel;
    }
  }

  // channel - computed: false, optional: true, required: false
  private _channel?: string; 
  public get channel() {
    return this.getStringAttribute('channel');
  }
  public set channel(value: string) {
    this._channel = value;
  }
  public resetChannel() {
    this._channel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get channelInput() {
    return this._channel;
  }
}
export interface DomainDevicesDisksSourceReservationsSourceDevSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksSourceReservationsSourceDevSecLabelToTerraform(struct?: DomainDevicesDisksSourceReservationsSourceDevSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksSourceReservationsSourceDevSecLabelToHclTerraform(struct?: DomainDevicesDisksSourceReservationsSourceDevSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceReservationsSourceDevSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksSourceReservationsSourceDevSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceReservationsSourceDevSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksSourceReservationsSourceDevSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksSourceReservationsSourceDevSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksSourceReservationsSourceDevSecLabelOutputReference {
    return new DomainDevicesDisksSourceReservationsSourceDevSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksSourceReservationsSourceDev {
  /**
  * Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksSourceReservationsSourceDevSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksSourceReservationsSourceDevToTerraform(struct?: DomainDevicesDisksSourceReservationsSourceDev | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesDisksSourceReservationsSourceDevSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksSourceReservationsSourceDevToHclTerraform(struct?: DomainDevicesDisksSourceReservationsSourceDev | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksSourceReservationsSourceDevSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksSourceReservationsSourceDevSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceReservationsSourceDevOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceReservationsSourceDev | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceReservationsSourceDev | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksSourceReservationsSourceDevSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksSourceReservationsSourceDevSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksSourceReservationsSourceFileSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksSourceReservationsSourceFileSecLabelToTerraform(struct?: DomainDevicesDisksSourceReservationsSourceFileSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksSourceReservationsSourceFileSecLabelToHclTerraform(struct?: DomainDevicesDisksSourceReservationsSourceFileSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceReservationsSourceFileSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksSourceReservationsSourceFileSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceReservationsSourceFileSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksSourceReservationsSourceFileSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksSourceReservationsSourceFileSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksSourceReservationsSourceFileSecLabelOutputReference {
    return new DomainDevicesDisksSourceReservationsSourceFileSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksSourceReservationsSourceFile {
  /**
  * Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.
  * 
  * See: <https://libvirt.org/formatdomain.html#device-logfile>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#append Domain#append}
  */
  readonly append?: string;
  /**
  * Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksSourceReservationsSourceFileSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksSourceReservationsSourceFileToTerraform(struct?: DomainDevicesDisksSourceReservationsSourceFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.stringToTerraform(struct!.append),
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesDisksSourceReservationsSourceFileSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksSourceReservationsSourceFileToHclTerraform(struct?: DomainDevicesDisksSourceReservationsSourceFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.stringToHclTerraform(struct!.append),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksSourceReservationsSourceFileSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksSourceReservationsSourceFileSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceReservationsSourceFileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceReservationsSourceFile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceReservationsSourceFile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append = value.append;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append?: string; 
  public get append() {
    return this.getStringAttribute('append');
  }
  public set append(value: string) {
    this._append = value;
  }
  public resetAppend() {
    this._append = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append;
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksSourceReservationsSourceFileSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksSourceReservationsSourceFileSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksSourceReservationsSourceNmdm {
  /**
  * Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.
  * 
  * See: <https://libvirt.org/formatdomain.html#nmdm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#master Domain#master}
  */
  readonly master: string;
  /**
  * Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.
  * 
  * See: <https://libvirt.org/formatdomain.html#nmdm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#slave Domain#slave}
  */
  readonly slave: string;
}

export function domainDevicesDisksSourceReservationsSourceNmdmToTerraform(struct?: DomainDevicesDisksSourceReservationsSourceNmdm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    master: cdktf.stringToTerraform(struct!.master),
    slave: cdktf.stringToTerraform(struct!.slave),
  }
}


export function domainDevicesDisksSourceReservationsSourceNmdmToHclTerraform(struct?: DomainDevicesDisksSourceReservationsSourceNmdm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    master: {
      value: cdktf.stringToHclTerraform(struct!.master),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    slave: {
      value: cdktf.stringToHclTerraform(struct!.slave),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceReservationsSourceNmdmOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceReservationsSourceNmdm | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._master !== undefined) {
      hasAnyValues = true;
      internalValueResult.master = this._master;
    }
    if (this._slave !== undefined) {
      hasAnyValues = true;
      internalValueResult.slave = this._slave;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceReservationsSourceNmdm | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._master = undefined;
      this._slave = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._master = value.master;
      this._slave = value.slave;
    }
  }

  // master - computed: false, optional: false, required: true
  private _master?: string; 
  public get master() {
    return this.getStringAttribute('master');
  }
  public set master(value: string) {
    this._master = value;
  }
  // Temporarily expose input value. Use with caution.
  public get masterInput() {
    return this._master;
  }

  // slave - computed: false, optional: false, required: true
  private _slave?: string; 
  public get slave() {
    return this.getStringAttribute('slave');
  }
  public set slave(value: string) {
    this._slave = value;
  }
  // Temporarily expose input value. Use with caution.
  public get slaveInput() {
    return this._slave;
  }
}
export interface DomainDevicesDisksSourceReservationsSourcePipeSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksSourceReservationsSourcePipeSecLabelToTerraform(struct?: DomainDevicesDisksSourceReservationsSourcePipeSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksSourceReservationsSourcePipeSecLabelToHclTerraform(struct?: DomainDevicesDisksSourceReservationsSourcePipeSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceReservationsSourcePipeSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksSourceReservationsSourcePipeSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceReservationsSourcePipeSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksSourceReservationsSourcePipeSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksSourceReservationsSourcePipeSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksSourceReservationsSourcePipeSecLabelOutputReference {
    return new DomainDevicesDisksSourceReservationsSourcePipeSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksSourceReservationsSourcePipe {
  /**
  * Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksSourceReservationsSourcePipeSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksSourceReservationsSourcePipeToTerraform(struct?: DomainDevicesDisksSourceReservationsSourcePipe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesDisksSourceReservationsSourcePipeSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksSourceReservationsSourcePipeToHclTerraform(struct?: DomainDevicesDisksSourceReservationsSourcePipe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksSourceReservationsSourcePipeSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksSourceReservationsSourcePipeSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceReservationsSourcePipeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceReservationsSourcePipe | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceReservationsSourcePipe | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksSourceReservationsSourcePipeSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksSourceReservationsSourcePipeSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksSourceReservationsSourcePtySecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksSourceReservationsSourcePtySecLabelToTerraform(struct?: DomainDevicesDisksSourceReservationsSourcePtySecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksSourceReservationsSourcePtySecLabelToHclTerraform(struct?: DomainDevicesDisksSourceReservationsSourcePtySecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceReservationsSourcePtySecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksSourceReservationsSourcePtySecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceReservationsSourcePtySecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksSourceReservationsSourcePtySecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksSourceReservationsSourcePtySecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksSourceReservationsSourcePtySecLabelOutputReference {
    return new DomainDevicesDisksSourceReservationsSourcePtySecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksSourceReservationsSourcePty {
  /**
  * Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksSourceReservationsSourcePtySecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksSourceReservationsSourcePtyToTerraform(struct?: DomainDevicesDisksSourceReservationsSourcePty | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesDisksSourceReservationsSourcePtySecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksSourceReservationsSourcePtyToHclTerraform(struct?: DomainDevicesDisksSourceReservationsSourcePty | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksSourceReservationsSourcePtySecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksSourceReservationsSourcePtySecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceReservationsSourcePtyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceReservationsSourcePty | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceReservationsSourcePty | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksSourceReservationsSourcePtySecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksSourceReservationsSourcePtySecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksSourceReservationsSourceQemuvdAgentClipBoard {
  /**
  * Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#copy_paste Domain#copy_paste}
  */
  readonly copyPaste: string;
}

export function domainDevicesDisksSourceReservationsSourceQemuvdAgentClipBoardToTerraform(struct?: DomainDevicesDisksSourceReservationsSourceQemuvdAgentClipBoard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    copy_paste: cdktf.stringToTerraform(struct!.copyPaste),
  }
}


export function domainDevicesDisksSourceReservationsSourceQemuvdAgentClipBoardToHclTerraform(struct?: DomainDevicesDisksSourceReservationsSourceQemuvdAgentClipBoard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    copy_paste: {
      value: cdktf.stringToHclTerraform(struct!.copyPaste),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceReservationsSourceQemuvdAgentClipBoardOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceReservationsSourceQemuvdAgentClipBoard | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._copyPaste !== undefined) {
      hasAnyValues = true;
      internalValueResult.copyPaste = this._copyPaste;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceReservationsSourceQemuvdAgentClipBoard | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._copyPaste = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._copyPaste = value.copyPaste;
    }
  }

  // copy_paste - computed: false, optional: false, required: true
  private _copyPaste?: string; 
  public get copyPaste() {
    return this.getStringAttribute('copy_paste');
  }
  public set copyPaste(value: string) {
    this._copyPaste = value;
  }
  // Temporarily expose input value. Use with caution.
  public get copyPasteInput() {
    return this._copyPaste;
  }
}
export interface DomainDevicesDisksSourceReservationsSourceQemuvdAgentMouse {
  /**
  * Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).
  * 
  * See: <https://libvirt.org/formatdomain.html#channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode: string;
}

export function domainDevicesDisksSourceReservationsSourceQemuvdAgentMouseToTerraform(struct?: DomainDevicesDisksSourceReservationsSourceQemuvdAgentMouse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
  }
}


export function domainDevicesDisksSourceReservationsSourceQemuvdAgentMouseToHclTerraform(struct?: DomainDevicesDisksSourceReservationsSourceQemuvdAgentMouse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceReservationsSourceQemuvdAgentMouseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceReservationsSourceQemuvdAgentMouse | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceReservationsSourceQemuvdAgentMouse | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
    }
  }

  // mode - computed: false, optional: false, required: true
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }
}
export interface DomainDevicesDisksSourceReservationsSourceQemuvdAgent {
  /**
  * Configures clipboard-related behavior for the QEMU vdagent–based EGD source, controlling whether clipboard data exchange is allowed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#clip_board Domain#clip_board}
  */
  readonly clipBoard?: DomainDevicesDisksSourceReservationsSourceQemuvdAgentClipBoard;
  /**
  * Configures mouse integration options for the QEMU vdagent–based EGD source, such as how mouse events are handled.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mouse Domain#mouse}
  */
  readonly mouse?: DomainDevicesDisksSourceReservationsSourceQemuvdAgentMouse;
}

export function domainDevicesDisksSourceReservationsSourceQemuvdAgentToTerraform(struct?: DomainDevicesDisksSourceReservationsSourceQemuvdAgent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    clip_board: domainDevicesDisksSourceReservationsSourceQemuvdAgentClipBoardToTerraform(struct!.clipBoard),
    mouse: domainDevicesDisksSourceReservationsSourceQemuvdAgentMouseToTerraform(struct!.mouse),
  }
}


export function domainDevicesDisksSourceReservationsSourceQemuvdAgentToHclTerraform(struct?: DomainDevicesDisksSourceReservationsSourceQemuvdAgent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    clip_board: {
      value: domainDevicesDisksSourceReservationsSourceQemuvdAgentClipBoardToHclTerraform(struct!.clipBoard),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceReservationsSourceQemuvdAgentClipBoard",
    },
    mouse: {
      value: domainDevicesDisksSourceReservationsSourceQemuvdAgentMouseToHclTerraform(struct!.mouse),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceReservationsSourceQemuvdAgentMouse",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceReservationsSourceQemuvdAgentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceReservationsSourceQemuvdAgent | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clipBoard?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clipBoard = this._clipBoard?.internalValue;
    }
    if (this._mouse?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.mouse = this._mouse?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceReservationsSourceQemuvdAgent | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clipBoard.internalValue = undefined;
      this._mouse.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clipBoard.internalValue = value.clipBoard;
      this._mouse.internalValue = value.mouse;
    }
  }

  // clip_board - computed: false, optional: true, required: false
  private _clipBoard = new DomainDevicesDisksSourceReservationsSourceQemuvdAgentClipBoardOutputReference(this, "clip_board");
  public get clipBoard() {
    return this._clipBoard;
  }
  public putClipBoard(value: DomainDevicesDisksSourceReservationsSourceQemuvdAgentClipBoard) {
    this._clipBoard.internalValue = value;
  }
  public resetClipBoard() {
    this._clipBoard.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clipBoardInput() {
    return this._clipBoard.internalValue;
  }

  // mouse - computed: false, optional: true, required: false
  private _mouse = new DomainDevicesDisksSourceReservationsSourceQemuvdAgentMouseOutputReference(this, "mouse");
  public get mouse() {
    return this._mouse;
  }
  public putMouse(value: DomainDevicesDisksSourceReservationsSourceQemuvdAgentMouse) {
    this._mouse.internalValue = value;
  }
  public resetMouse() {
    this._mouse.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mouseInput() {
    return this._mouse.internalValue;
  }
}
export interface DomainDevicesDisksSourceReservationsSourceSpicePort {
  /**
  * Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#channel Domain#channel}
  */
  readonly channel: string;
}

export function domainDevicesDisksSourceReservationsSourceSpicePortToTerraform(struct?: DomainDevicesDisksSourceReservationsSourceSpicePort | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    channel: cdktf.stringToTerraform(struct!.channel),
  }
}


export function domainDevicesDisksSourceReservationsSourceSpicePortToHclTerraform(struct?: DomainDevicesDisksSourceReservationsSourceSpicePort | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    channel: {
      value: cdktf.stringToHclTerraform(struct!.channel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceReservationsSourceSpicePortOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceReservationsSourceSpicePort | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._channel !== undefined) {
      hasAnyValues = true;
      internalValueResult.channel = this._channel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceReservationsSourceSpicePort | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._channel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._channel = value.channel;
    }
  }

  // channel - computed: false, optional: false, required: true
  private _channel?: string; 
  public get channel() {
    return this.getStringAttribute('channel');
  }
  public set channel(value: string) {
    this._channel = value;
  }
  // Temporarily expose input value. Use with caution.
  public get channelInput() {
    return this._channel;
  }
}
export interface DomainDevicesDisksSourceReservationsSourceTcpReconnect {
  /**
  * Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enabled Domain#enabled}
  */
  readonly enabled: string;
  /**
  * Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#timeout Domain#timeout}
  */
  readonly timeout?: number;
}

export function domainDevicesDisksSourceReservationsSourceTcpReconnectToTerraform(struct?: DomainDevicesDisksSourceReservationsSourceTcpReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.stringToTerraform(struct!.enabled),
    timeout: cdktf.numberToTerraform(struct!.timeout),
  }
}


export function domainDevicesDisksSourceReservationsSourceTcpReconnectToHclTerraform(struct?: DomainDevicesDisksSourceReservationsSourceTcpReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.stringToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.numberToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceReservationsSourceTcpReconnectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceReservationsSourceTcpReconnect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceReservationsSourceTcpReconnect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._timeout = value.timeout;
    }
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: string; 
  public get enabled() {
    return this.getStringAttribute('enabled');
  }
  public set enabled(value: string) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: number; 
  public get timeout() {
    return this.getNumberAttribute('timeout');
  }
  public set timeout(value: number) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DomainDevicesDisksSourceReservationsSourceTcp {
  /**
  * Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#host Domain#host}
  */
  readonly host?: string;
  /**
  * Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode?: string;
  /**
  * Enables and configures automatic reconnection behavior for a UNIX socket–based EGD entropy source; the content and attributes are user-provided according to desired policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reconnect Domain#reconnect}
  */
  readonly reconnect?: DomainDevicesDisksSourceReservationsSourceTcpReconnect;
  /**
  * Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#service Domain#service}
  */
  readonly service?: string;
  /**
  * Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tls Domain#tls}
  */
  readonly tls?: string;
}

export function domainDevicesDisksSourceReservationsSourceTcpToTerraform(struct?: DomainDevicesDisksSourceReservationsSourceTcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    mode: cdktf.stringToTerraform(struct!.mode),
    reconnect: domainDevicesDisksSourceReservationsSourceTcpReconnectToTerraform(struct!.reconnect),
    service: cdktf.stringToTerraform(struct!.service),
    tls: cdktf.stringToTerraform(struct!.tls),
  }
}


export function domainDevicesDisksSourceReservationsSourceTcpToHclTerraform(struct?: DomainDevicesDisksSourceReservationsSourceTcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reconnect: {
      value: domainDevicesDisksSourceReservationsSourceTcpReconnectToHclTerraform(struct!.reconnect),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceReservationsSourceTcpReconnect",
    },
    service: {
      value: cdktf.stringToHclTerraform(struct!.service),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: cdktf.stringToHclTerraform(struct!.tls),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceReservationsSourceTcpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceReservationsSourceTcp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._reconnect?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.reconnect = this._reconnect?.internalValue;
    }
    if (this._service !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service;
    }
    if (this._tls !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceReservationsSourceTcp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host = undefined;
      this._mode = undefined;
      this._reconnect.internalValue = undefined;
      this._service = undefined;
      this._tls = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host = value.host;
      this._mode = value.mode;
      this._reconnect.internalValue = value.reconnect;
      this._service = value.service;
      this._tls = value.tls;
    }
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // reconnect - computed: false, optional: true, required: false
  private _reconnect = new DomainDevicesDisksSourceReservationsSourceTcpReconnectOutputReference(this, "reconnect");
  public get reconnect() {
    return this._reconnect;
  }
  public putReconnect(value: DomainDevicesDisksSourceReservationsSourceTcpReconnect) {
    this._reconnect.internalValue = value;
  }
  public resetReconnect() {
    this._reconnect.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reconnectInput() {
    return this._reconnect.internalValue;
  }

  // service - computed: false, optional: true, required: false
  private _service?: string; 
  public get service() {
    return this.getStringAttribute('service');
  }
  public set service(value: string) {
    this._service = value;
  }
  public resetService() {
    this._service = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service;
  }

  // tls - computed: false, optional: true, required: false
  private _tls?: string; 
  public get tls() {
    return this.getStringAttribute('tls');
  }
  public set tls(value: string) {
    this._tls = value;
  }
  public resetTls() {
    this._tls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls;
  }
}
export interface DomainDevicesDisksSourceReservationsSourceUdp {
  /**
  * Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bind_host Domain#bind_host}
  */
  readonly bindHost: string;
  /**
  * Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bind_service Domain#bind_service}
  */
  readonly bindService: string;
  /**
  * Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#connect_host Domain#connect_host}
  */
  readonly connectHost: string;
  /**
  * Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#connect_service Domain#connect_service}
  */
  readonly connectService: string;
}

export function domainDevicesDisksSourceReservationsSourceUdpToTerraform(struct?: DomainDevicesDisksSourceReservationsSourceUdp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_host: cdktf.stringToTerraform(struct!.bindHost),
    bind_service: cdktf.stringToTerraform(struct!.bindService),
    connect_host: cdktf.stringToTerraform(struct!.connectHost),
    connect_service: cdktf.stringToTerraform(struct!.connectService),
  }
}


export function domainDevicesDisksSourceReservationsSourceUdpToHclTerraform(struct?: DomainDevicesDisksSourceReservationsSourceUdp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_host: {
      value: cdktf.stringToHclTerraform(struct!.bindHost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bind_service: {
      value: cdktf.stringToHclTerraform(struct!.bindService),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connect_host: {
      value: cdktf.stringToHclTerraform(struct!.connectHost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connect_service: {
      value: cdktf.stringToHclTerraform(struct!.connectService),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceReservationsSourceUdpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceReservationsSourceUdp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindHost !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindHost = this._bindHost;
    }
    if (this._bindService !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindService = this._bindService;
    }
    if (this._connectHost !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectHost = this._connectHost;
    }
    if (this._connectService !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectService = this._connectService;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceReservationsSourceUdp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bindHost = undefined;
      this._bindService = undefined;
      this._connectHost = undefined;
      this._connectService = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bindHost = value.bindHost;
      this._bindService = value.bindService;
      this._connectHost = value.connectHost;
      this._connectService = value.connectService;
    }
  }

  // bind_host - computed: false, optional: false, required: true
  private _bindHost?: string; 
  public get bindHost() {
    return this.getStringAttribute('bind_host');
  }
  public set bindHost(value: string) {
    this._bindHost = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bindHostInput() {
    return this._bindHost;
  }

  // bind_service - computed: false, optional: false, required: true
  private _bindService?: string; 
  public get bindService() {
    return this.getStringAttribute('bind_service');
  }
  public set bindService(value: string) {
    this._bindService = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bindServiceInput() {
    return this._bindService;
  }

  // connect_host - computed: false, optional: false, required: true
  private _connectHost?: string; 
  public get connectHost() {
    return this.getStringAttribute('connect_host');
  }
  public set connectHost(value: string) {
    this._connectHost = value;
  }
  // Temporarily expose input value. Use with caution.
  public get connectHostInput() {
    return this._connectHost;
  }

  // connect_service - computed: false, optional: false, required: true
  private _connectService?: string; 
  public get connectService() {
    return this.getStringAttribute('connect_service');
  }
  public set connectService(value: string) {
    this._connectService = value;
  }
  // Temporarily expose input value. Use with caution.
  public get connectServiceInput() {
    return this._connectService;
  }
}
export interface DomainDevicesDisksSourceReservationsSourceUnixReconnect {
  /**
  * Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enabled Domain#enabled}
  */
  readonly enabled: string;
  /**
  * Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#timeout Domain#timeout}
  */
  readonly timeout?: number;
}

export function domainDevicesDisksSourceReservationsSourceUnixReconnectToTerraform(struct?: DomainDevicesDisksSourceReservationsSourceUnixReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.stringToTerraform(struct!.enabled),
    timeout: cdktf.numberToTerraform(struct!.timeout),
  }
}


export function domainDevicesDisksSourceReservationsSourceUnixReconnectToHclTerraform(struct?: DomainDevicesDisksSourceReservationsSourceUnixReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.stringToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.numberToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceReservationsSourceUnixReconnectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceReservationsSourceUnixReconnect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceReservationsSourceUnixReconnect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._timeout = value.timeout;
    }
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: string; 
  public get enabled() {
    return this.getStringAttribute('enabled');
  }
  public set enabled(value: string) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: number; 
  public get timeout() {
    return this.getNumberAttribute('timeout');
  }
  public set timeout(value: number) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DomainDevicesDisksSourceReservationsSourceUnixSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksSourceReservationsSourceUnixSecLabelToTerraform(struct?: DomainDevicesDisksSourceReservationsSourceUnixSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksSourceReservationsSourceUnixSecLabelToHclTerraform(struct?: DomainDevicesDisksSourceReservationsSourceUnixSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceReservationsSourceUnixSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksSourceReservationsSourceUnixSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceReservationsSourceUnixSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksSourceReservationsSourceUnixSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksSourceReservationsSourceUnixSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksSourceReservationsSourceUnixSecLabelOutputReference {
    return new DomainDevicesDisksSourceReservationsSourceUnixSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksSourceReservationsSourceUnix {
  /**
  * Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode?: string;
  /**
  * Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path?: string;
  /**
  * Enables and configures automatic reconnection behavior for a UNIX socket–based EGD entropy source; the content and attributes are user-provided according to desired policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reconnect Domain#reconnect}
  */
  readonly reconnect?: DomainDevicesDisksSourceReservationsSourceUnixReconnect;
  /**
  * Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksSourceReservationsSourceUnixSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksSourceReservationsSourceUnixToTerraform(struct?: DomainDevicesDisksSourceReservationsSourceUnix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
    reconnect: domainDevicesDisksSourceReservationsSourceUnixReconnectToTerraform(struct!.reconnect),
    sec_label: cdktf.listMapper(domainDevicesDisksSourceReservationsSourceUnixSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksSourceReservationsSourceUnixToHclTerraform(struct?: DomainDevicesDisksSourceReservationsSourceUnix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reconnect: {
      value: domainDevicesDisksSourceReservationsSourceUnixReconnectToHclTerraform(struct!.reconnect),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceReservationsSourceUnixReconnect",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksSourceReservationsSourceUnixSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksSourceReservationsSourceUnixSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceReservationsSourceUnixOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceReservationsSourceUnix | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._reconnect?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.reconnect = this._reconnect?.internalValue;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceReservationsSourceUnix | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
      this._path = undefined;
      this._reconnect.internalValue = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
      this._path = value.path;
      this._reconnect.internalValue = value.reconnect;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // reconnect - computed: false, optional: true, required: false
  private _reconnect = new DomainDevicesDisksSourceReservationsSourceUnixReconnectOutputReference(this, "reconnect");
  public get reconnect() {
    return this._reconnect;
  }
  public putReconnect(value: DomainDevicesDisksSourceReservationsSourceUnixReconnect) {
    this._reconnect.internalValue = value;
  }
  public resetReconnect() {
    this._reconnect.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reconnectInput() {
    return this._reconnect.internalValue;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksSourceReservationsSourceUnixSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksSourceReservationsSourceUnixSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksSourceReservationsSource {
  /**
  * Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dbus Domain#dbus}
  */
  readonly dbus?: DomainDevicesDisksSourceReservationsSourceDbus;
  /**
  * Configures an EGD RNG backend that reads entropy from a host character device node.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dev Domain#dev}
  */
  readonly dev?: DomainDevicesDisksSourceReservationsSourceDev;
  /**
  * Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file?: DomainDevicesDisksSourceReservationsSourceFile;
  /**
  * Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#nmdm Domain#nmdm}
  */
  readonly nmdm?: DomainDevicesDisksSourceReservationsSourceNmdm;
  /**
  * Enables use of a null character device as the reservation backing source; when this boolean is true, a Null source is emitted and all written data is discarded.
  * 
  * See: <https://libvirt.org/formatdomain.html#null-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#null Domain#null}
  */
  readonly null?: boolean | cdktf.IResolvable;
  /**
  * Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pipe Domain#pipe}
  */
  readonly pipe?: DomainDevicesDisksSourceReservationsSourcePipe;
  /**
  * Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pty Domain#pty}
  */
  readonly pty?: DomainDevicesDisksSourceReservationsSourcePty;
  /**
  * Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#qemuvd_agent Domain#qemuvd_agent}
  */
  readonly qemuvdAgent?: DomainDevicesDisksSourceReservationsSourceQemuvdAgent;
  /**
  * Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#spice_port Domain#spice_port}
  */
  readonly spicePort?: DomainDevicesDisksSourceReservationsSourceSpicePort;
  /**
  * Enables a SPICE VMC (SPICE management channel) backend for this backing-store source; when set true the element is emitted, when false or null it is omitted.
  * 
  * See: <https://libvirt.org/formatdomain.html#spice-channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#spice_vmc Domain#spice_vmc}
  */
  readonly spiceVmc?: boolean | cdktf.IResolvable;
  /**
  * Connects the backing-store source’s character channel to the domain’s standard I/O (stdin/stdout/stderr); when true the element is emitted, when false or null it is omitted.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-interface>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#std_io Domain#std_io}
  */
  readonly stdIo?: boolean | cdktf.IResolvable;
  /**
  * Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tcp Domain#tcp}
  */
  readonly tcp?: DomainDevicesDisksSourceReservationsSourceTcp;
  /**
  * Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#udp Domain#udp}
  */
  readonly udp?: DomainDevicesDisksSourceReservationsSourceUdp;
  /**
  * Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#unix Domain#unix}
  */
  readonly unix?: DomainDevicesDisksSourceReservationsSourceUnix;
  /**
  * Enables use of a VC (virtual cluster or vendor-specific) reservation source when set; since this is presence-based, setting it to true emits the element and false/null omits it.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vc Domain#vc}
  */
  readonly vc?: boolean | cdktf.IResolvable;
}

export function domainDevicesDisksSourceReservationsSourceToTerraform(struct?: DomainDevicesDisksSourceReservationsSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dbus: domainDevicesDisksSourceReservationsSourceDbusToTerraform(struct!.dbus),
    dev: domainDevicesDisksSourceReservationsSourceDevToTerraform(struct!.dev),
    file: domainDevicesDisksSourceReservationsSourceFileToTerraform(struct!.file),
    nmdm: domainDevicesDisksSourceReservationsSourceNmdmToTerraform(struct!.nmdm),
    null: cdktf.booleanToTerraform(struct!.null),
    pipe: domainDevicesDisksSourceReservationsSourcePipeToTerraform(struct!.pipe),
    pty: domainDevicesDisksSourceReservationsSourcePtyToTerraform(struct!.pty),
    qemuvd_agent: domainDevicesDisksSourceReservationsSourceQemuvdAgentToTerraform(struct!.qemuvdAgent),
    spice_port: domainDevicesDisksSourceReservationsSourceSpicePortToTerraform(struct!.spicePort),
    spice_vmc: cdktf.booleanToTerraform(struct!.spiceVmc),
    std_io: cdktf.booleanToTerraform(struct!.stdIo),
    tcp: domainDevicesDisksSourceReservationsSourceTcpToTerraform(struct!.tcp),
    udp: domainDevicesDisksSourceReservationsSourceUdpToTerraform(struct!.udp),
    unix: domainDevicesDisksSourceReservationsSourceUnixToTerraform(struct!.unix),
    vc: cdktf.booleanToTerraform(struct!.vc),
  }
}


export function domainDevicesDisksSourceReservationsSourceToHclTerraform(struct?: DomainDevicesDisksSourceReservationsSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dbus: {
      value: domainDevicesDisksSourceReservationsSourceDbusToHclTerraform(struct!.dbus),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceReservationsSourceDbus",
    },
    dev: {
      value: domainDevicesDisksSourceReservationsSourceDevToHclTerraform(struct!.dev),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceReservationsSourceDev",
    },
    file: {
      value: domainDevicesDisksSourceReservationsSourceFileToHclTerraform(struct!.file),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceReservationsSourceFile",
    },
    nmdm: {
      value: domainDevicesDisksSourceReservationsSourceNmdmToHclTerraform(struct!.nmdm),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceReservationsSourceNmdm",
    },
    null: {
      value: cdktf.booleanToHclTerraform(struct!.null),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    pipe: {
      value: domainDevicesDisksSourceReservationsSourcePipeToHclTerraform(struct!.pipe),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceReservationsSourcePipe",
    },
    pty: {
      value: domainDevicesDisksSourceReservationsSourcePtyToHclTerraform(struct!.pty),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceReservationsSourcePty",
    },
    qemuvd_agent: {
      value: domainDevicesDisksSourceReservationsSourceQemuvdAgentToHclTerraform(struct!.qemuvdAgent),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceReservationsSourceQemuvdAgent",
    },
    spice_port: {
      value: domainDevicesDisksSourceReservationsSourceSpicePortToHclTerraform(struct!.spicePort),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceReservationsSourceSpicePort",
    },
    spice_vmc: {
      value: cdktf.booleanToHclTerraform(struct!.spiceVmc),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    std_io: {
      value: cdktf.booleanToHclTerraform(struct!.stdIo),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tcp: {
      value: domainDevicesDisksSourceReservationsSourceTcpToHclTerraform(struct!.tcp),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceReservationsSourceTcp",
    },
    udp: {
      value: domainDevicesDisksSourceReservationsSourceUdpToHclTerraform(struct!.udp),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceReservationsSourceUdp",
    },
    unix: {
      value: domainDevicesDisksSourceReservationsSourceUnixToHclTerraform(struct!.unix),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceReservationsSourceUnix",
    },
    vc: {
      value: cdktf.booleanToHclTerraform(struct!.vc),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceReservationsSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceReservationsSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dbus?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dbus = this._dbus?.internalValue;
    }
    if (this._dev?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dev = this._dev?.internalValue;
    }
    if (this._file?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file?.internalValue;
    }
    if (this._nmdm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nmdm = this._nmdm?.internalValue;
    }
    if (this._null !== undefined) {
      hasAnyValues = true;
      internalValueResult.null = this._null;
    }
    if (this._pipe?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipe = this._pipe?.internalValue;
    }
    if (this._pty?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pty = this._pty?.internalValue;
    }
    if (this._qemuvdAgent?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.qemuvdAgent = this._qemuvdAgent?.internalValue;
    }
    if (this._spicePort?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spicePort = this._spicePort?.internalValue;
    }
    if (this._spiceVmc !== undefined) {
      hasAnyValues = true;
      internalValueResult.spiceVmc = this._spiceVmc;
    }
    if (this._stdIo !== undefined) {
      hasAnyValues = true;
      internalValueResult.stdIo = this._stdIo;
    }
    if (this._tcp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tcp = this._tcp?.internalValue;
    }
    if (this._udp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.udp = this._udp?.internalValue;
    }
    if (this._unix?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.unix = this._unix?.internalValue;
    }
    if (this._vc !== undefined) {
      hasAnyValues = true;
      internalValueResult.vc = this._vc;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceReservationsSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dbus.internalValue = undefined;
      this._dev.internalValue = undefined;
      this._file.internalValue = undefined;
      this._nmdm.internalValue = undefined;
      this._null = undefined;
      this._pipe.internalValue = undefined;
      this._pty.internalValue = undefined;
      this._qemuvdAgent.internalValue = undefined;
      this._spicePort.internalValue = undefined;
      this._spiceVmc = undefined;
      this._stdIo = undefined;
      this._tcp.internalValue = undefined;
      this._udp.internalValue = undefined;
      this._unix.internalValue = undefined;
      this._vc = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dbus.internalValue = value.dbus;
      this._dev.internalValue = value.dev;
      this._file.internalValue = value.file;
      this._nmdm.internalValue = value.nmdm;
      this._null = value.null;
      this._pipe.internalValue = value.pipe;
      this._pty.internalValue = value.pty;
      this._qemuvdAgent.internalValue = value.qemuvdAgent;
      this._spicePort.internalValue = value.spicePort;
      this._spiceVmc = value.spiceVmc;
      this._stdIo = value.stdIo;
      this._tcp.internalValue = value.tcp;
      this._udp.internalValue = value.udp;
      this._unix.internalValue = value.unix;
      this._vc = value.vc;
    }
  }

  // dbus - computed: false, optional: true, required: false
  private _dbus = new DomainDevicesDisksSourceReservationsSourceDbusOutputReference(this, "dbus");
  public get dbus() {
    return this._dbus;
  }
  public putDbus(value: DomainDevicesDisksSourceReservationsSourceDbus) {
    this._dbus.internalValue = value;
  }
  public resetDbus() {
    this._dbus.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dbusInput() {
    return this._dbus.internalValue;
  }

  // dev - computed: false, optional: true, required: false
  private _dev = new DomainDevicesDisksSourceReservationsSourceDevOutputReference(this, "dev");
  public get dev() {
    return this._dev;
  }
  public putDev(value: DomainDevicesDisksSourceReservationsSourceDev) {
    this._dev.internalValue = value;
  }
  public resetDev() {
    this._dev.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devInput() {
    return this._dev.internalValue;
  }

  // file - computed: false, optional: true, required: false
  private _file = new DomainDevicesDisksSourceReservationsSourceFileOutputReference(this, "file");
  public get file() {
    return this._file;
  }
  public putFile(value: DomainDevicesDisksSourceReservationsSourceFile) {
    this._file.internalValue = value;
  }
  public resetFile() {
    this._file.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file.internalValue;
  }

  // nmdm - computed: false, optional: true, required: false
  private _nmdm = new DomainDevicesDisksSourceReservationsSourceNmdmOutputReference(this, "nmdm");
  public get nmdm() {
    return this._nmdm;
  }
  public putNmdm(value: DomainDevicesDisksSourceReservationsSourceNmdm) {
    this._nmdm.internalValue = value;
  }
  public resetNmdm() {
    this._nmdm.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nmdmInput() {
    return this._nmdm.internalValue;
  }

  // null - computed: false, optional: true, required: false
  private _null?: boolean | cdktf.IResolvable; 
  public get null() {
    return this.getBooleanAttribute('null');
  }
  public set null(value: boolean | cdktf.IResolvable) {
    this._null = value;
  }
  public resetNull() {
    this._null = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nullInput() {
    return this._null;
  }

  // pipe - computed: false, optional: true, required: false
  private _pipe = new DomainDevicesDisksSourceReservationsSourcePipeOutputReference(this, "pipe");
  public get pipe() {
    return this._pipe;
  }
  public putPipe(value: DomainDevicesDisksSourceReservationsSourcePipe) {
    this._pipe.internalValue = value;
  }
  public resetPipe() {
    this._pipe.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipeInput() {
    return this._pipe.internalValue;
  }

  // pty - computed: false, optional: true, required: false
  private _pty = new DomainDevicesDisksSourceReservationsSourcePtyOutputReference(this, "pty");
  public get pty() {
    return this._pty;
  }
  public putPty(value: DomainDevicesDisksSourceReservationsSourcePty) {
    this._pty.internalValue = value;
  }
  public resetPty() {
    this._pty.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ptyInput() {
    return this._pty.internalValue;
  }

  // qemuvd_agent - computed: false, optional: true, required: false
  private _qemuvdAgent = new DomainDevicesDisksSourceReservationsSourceQemuvdAgentOutputReference(this, "qemuvd_agent");
  public get qemuvdAgent() {
    return this._qemuvdAgent;
  }
  public putQemuvdAgent(value: DomainDevicesDisksSourceReservationsSourceQemuvdAgent) {
    this._qemuvdAgent.internalValue = value;
  }
  public resetQemuvdAgent() {
    this._qemuvdAgent.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get qemuvdAgentInput() {
    return this._qemuvdAgent.internalValue;
  }

  // spice_port - computed: false, optional: true, required: false
  private _spicePort = new DomainDevicesDisksSourceReservationsSourceSpicePortOutputReference(this, "spice_port");
  public get spicePort() {
    return this._spicePort;
  }
  public putSpicePort(value: DomainDevicesDisksSourceReservationsSourceSpicePort) {
    this._spicePort.internalValue = value;
  }
  public resetSpicePort() {
    this._spicePort.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spicePortInput() {
    return this._spicePort.internalValue;
  }

  // spice_vmc - computed: false, optional: true, required: false
  private _spiceVmc?: boolean | cdktf.IResolvable; 
  public get spiceVmc() {
    return this.getBooleanAttribute('spice_vmc');
  }
  public set spiceVmc(value: boolean | cdktf.IResolvable) {
    this._spiceVmc = value;
  }
  public resetSpiceVmc() {
    this._spiceVmc = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spiceVmcInput() {
    return this._spiceVmc;
  }

  // std_io - computed: false, optional: true, required: false
  private _stdIo?: boolean | cdktf.IResolvable; 
  public get stdIo() {
    return this.getBooleanAttribute('std_io');
  }
  public set stdIo(value: boolean | cdktf.IResolvable) {
    this._stdIo = value;
  }
  public resetStdIo() {
    this._stdIo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stdIoInput() {
    return this._stdIo;
  }

  // tcp - computed: false, optional: true, required: false
  private _tcp = new DomainDevicesDisksSourceReservationsSourceTcpOutputReference(this, "tcp");
  public get tcp() {
    return this._tcp;
  }
  public putTcp(value: DomainDevicesDisksSourceReservationsSourceTcp) {
    this._tcp.internalValue = value;
  }
  public resetTcp() {
    this._tcp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tcpInput() {
    return this._tcp.internalValue;
  }

  // udp - computed: false, optional: true, required: false
  private _udp = new DomainDevicesDisksSourceReservationsSourceUdpOutputReference(this, "udp");
  public get udp() {
    return this._udp;
  }
  public putUdp(value: DomainDevicesDisksSourceReservationsSourceUdp) {
    this._udp.internalValue = value;
  }
  public resetUdp() {
    this._udp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get udpInput() {
    return this._udp.internalValue;
  }

  // unix - computed: false, optional: true, required: false
  private _unix = new DomainDevicesDisksSourceReservationsSourceUnixOutputReference(this, "unix");
  public get unix() {
    return this._unix;
  }
  public putUnix(value: DomainDevicesDisksSourceReservationsSourceUnix) {
    this._unix.internalValue = value;
  }
  public resetUnix() {
    this._unix.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unixInput() {
    return this._unix.internalValue;
  }

  // vc - computed: false, optional: true, required: false
  private _vc?: boolean | cdktf.IResolvable; 
  public get vc() {
    return this.getBooleanAttribute('vc');
  }
  public set vc(value: boolean | cdktf.IResolvable) {
    this._vc = value;
  }
  public resetVc() {
    this._vc = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vcInput() {
    return this._vc;
  }
}
export interface DomainDevicesDisksSourceReservations {
  /**
  * Controls whether persistent reservations are enabled for the mirrored disk’s backing-store source; value is user-provided and typically expects "yes" or "no" semantics per libvirt.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enabled Domain#enabled}
  */
  readonly enabled?: string;
  /**
  * Indicates whether reservations are managed by libvirt ("yes") or externally ("no"); value is provided as a string and translated to a boolean, with "yes" meaning true and "no" meaning false.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#managed Domain#managed}
  */
  readonly managed?: boolean | cdktf.IResolvable;
  /**
  * Selects the mechanism used to provide reservation control for the mirrored backing-store source, such as a D-Bus service or a device/file endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#source Domain#source}
  */
  readonly source?: DomainDevicesDisksSourceReservationsSource;
}

export function domainDevicesDisksSourceReservationsToTerraform(struct?: DomainDevicesDisksSourceReservations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.stringToTerraform(struct!.enabled),
    managed: cdktf.booleanToTerraform(struct!.managed),
    source: domainDevicesDisksSourceReservationsSourceToTerraform(struct!.source),
  }
}


export function domainDevicesDisksSourceReservationsToHclTerraform(struct?: DomainDevicesDisksSourceReservations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.stringToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    managed: {
      value: cdktf.booleanToHclTerraform(struct!.managed),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    source: {
      value: domainDevicesDisksSourceReservationsSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceReservationsSource",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceReservationsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceReservations | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._managed !== undefined) {
      hasAnyValues = true;
      internalValueResult.managed = this._managed;
    }
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceReservations | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._managed = undefined;
      this._source.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._managed = value.managed;
      this._source.internalValue = value.source;
    }
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: string; 
  public get enabled() {
    return this.getStringAttribute('enabled');
  }
  public set enabled(value: string) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // managed - computed: false, optional: true, required: false
  private _managed?: boolean | cdktf.IResolvable; 
  public get managed() {
    return this.getBooleanAttribute('managed');
  }
  public set managed(value: boolean | cdktf.IResolvable) {
    this._managed = value;
  }
  public resetManaged() {
    this._managed = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get managedInput() {
    return this._managed;
  }

  // source - computed: false, optional: true, required: false
  private _source = new DomainDevicesDisksSourceReservationsSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: DomainDevicesDisksSourceReservationsSource) {
    this._source.internalValue = value;
  }
  public resetSource() {
    this._source.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }
}
export interface DomainDevicesDisksSourceSlicesSlices {
  /**
  * Sets the starting offset (in bytes) of this slice within the underlying backing-store source; must be a non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#offset Domain#offset}
  */
  readonly offset: number;
  /**
  * Sets the size (in bytes) of this slice within the underlying backing-store source; must be a positive integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#size Domain#size}
  */
  readonly size: number;
  /**
  * Specifies the type of slice mapping to use for this range; the value is user‑provided and must match a type supported by the hypervisor (for example, a particular mapping or layout scheme).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type: string;
}

export function domainDevicesDisksSourceSlicesSlicesToTerraform(struct?: DomainDevicesDisksSourceSlicesSlices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    offset: cdktf.numberToTerraform(struct!.offset),
    size: cdktf.numberToTerraform(struct!.size),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function domainDevicesDisksSourceSlicesSlicesToHclTerraform(struct?: DomainDevicesDisksSourceSlicesSlices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    offset: {
      value: cdktf.numberToHclTerraform(struct!.offset),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    size: {
      value: cdktf.numberToHclTerraform(struct!.size),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceSlicesSlicesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksSourceSlicesSlices | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._offset !== undefined) {
      hasAnyValues = true;
      internalValueResult.offset = this._offset;
    }
    if (this._size !== undefined) {
      hasAnyValues = true;
      internalValueResult.size = this._size;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceSlicesSlices | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._offset = undefined;
      this._size = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._offset = value.offset;
      this._size = value.size;
      this._type = value.type;
    }
  }

  // offset - computed: false, optional: false, required: true
  private _offset?: number; 
  public get offset() {
    return this.getNumberAttribute('offset');
  }
  public set offset(value: number) {
    this._offset = value;
  }
  // Temporarily expose input value. Use with caution.
  public get offsetInput() {
    return this._offset;
  }

  // size - computed: false, optional: false, required: true
  private _size?: number; 
  public get size() {
    return this.getNumberAttribute('size');
  }
  public set size(value: number) {
    this._size = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sizeInput() {
    return this._size;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}

export class DomainDevicesDisksSourceSlicesSlicesList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksSourceSlicesSlices[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksSourceSlicesSlicesOutputReference {
    return new DomainDevicesDisksSourceSlicesSlicesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksSourceSlices {
  /**
  * Configures one or more slices of the backing-store source, each describing a contiguous portion of the underlying device or file that is exposed through this mirror backing store.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#slices Domain#slices}
  */
  readonly slices?: DomainDevicesDisksSourceSlicesSlices[] | cdktf.IResolvable;
}

export function domainDevicesDisksSourceSlicesToTerraform(struct?: DomainDevicesDisksSourceSlices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    slices: cdktf.listMapper(domainDevicesDisksSourceSlicesSlicesToTerraform, false)(struct!.slices),
  }
}


export function domainDevicesDisksSourceSlicesToHclTerraform(struct?: DomainDevicesDisksSourceSlices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    slices: {
      value: cdktf.listMapperHcl(domainDevicesDisksSourceSlicesSlicesToHclTerraform, false)(struct!.slices),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksSourceSlicesSlicesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceSlicesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceSlices | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._slices?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.slices = this._slices?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceSlices | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._slices.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._slices.internalValue = value.slices;
    }
  }

  // slices - computed: false, optional: true, required: false
  private _slices = new DomainDevicesDisksSourceSlicesSlicesList(this, "slices", false);
  public get slices() {
    return this._slices;
  }
  public putSlices(value: DomainDevicesDisksSourceSlicesSlices[] | cdktf.IResolvable) {
    this._slices.internalValue = value;
  }
  public resetSlices() {
    this._slices.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get slicesInput() {
    return this._slices.internalValue;
  }
}
export interface DomainDevicesDisksSourceSsl {
  /**
  * Controls certificate verification for SSL/TLS access to the mirrored backing-store source; typical values are "yes" or "no" to enable or disable verification.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#verify Domain#verify}
  */
  readonly verify: string;
}

export function domainDevicesDisksSourceSslToTerraform(struct?: DomainDevicesDisksSourceSsl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    verify: cdktf.stringToTerraform(struct!.verify),
  }
}


export function domainDevicesDisksSourceSslToHclTerraform(struct?: DomainDevicesDisksSourceSsl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    verify: {
      value: cdktf.stringToHclTerraform(struct!.verify),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceSslOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceSsl | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._verify !== undefined) {
      hasAnyValues = true;
      internalValueResult.verify = this._verify;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceSsl | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._verify = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._verify = value.verify;
    }
  }

  // verify - computed: false, optional: false, required: true
  private _verify?: string; 
  public get verify() {
    return this.getStringAttribute('verify');
  }
  public set verify(value: string) {
    this._verify = value;
  }
  // Temporarily expose input value. Use with caution.
  public get verifyInput() {
    return this._verify;
  }
}
export interface DomainDevicesDisksSourceTimeout {
  /**
  * Sets the timeout duration in seconds for accessing the mirrored backing-store source; must be a non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#seconds Domain#seconds}
  */
  readonly seconds: string;
}

export function domainDevicesDisksSourceTimeoutToTerraform(struct?: DomainDevicesDisksSourceTimeout | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    seconds: cdktf.stringToTerraform(struct!.seconds),
  }
}


export function domainDevicesDisksSourceTimeoutToHclTerraform(struct?: DomainDevicesDisksSourceTimeout | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    seconds: {
      value: cdktf.stringToHclTerraform(struct!.seconds),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceTimeoutOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceTimeout | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._seconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.seconds = this._seconds;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceTimeout | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._seconds = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._seconds = value.seconds;
    }
  }

  // seconds - computed: false, optional: false, required: true
  private _seconds?: string; 
  public get seconds() {
    return this.getStringAttribute('seconds');
  }
  public set seconds(value: string) {
    this._seconds = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secondsInput() {
    return this._seconds;
  }
}
export interface DomainDevicesDisksSourceVhostUserDbus {
  /**
  * Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#channel Domain#channel}
  */
  readonly channel?: string;
}

export function domainDevicesDisksSourceVhostUserDbusToTerraform(struct?: DomainDevicesDisksSourceVhostUserDbus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    channel: cdktf.stringToTerraform(struct!.channel),
  }
}


export function domainDevicesDisksSourceVhostUserDbusToHclTerraform(struct?: DomainDevicesDisksSourceVhostUserDbus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    channel: {
      value: cdktf.stringToHclTerraform(struct!.channel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceVhostUserDbusOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceVhostUserDbus | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._channel !== undefined) {
      hasAnyValues = true;
      internalValueResult.channel = this._channel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceVhostUserDbus | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._channel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._channel = value.channel;
    }
  }

  // channel - computed: false, optional: true, required: false
  private _channel?: string; 
  public get channel() {
    return this.getStringAttribute('channel');
  }
  public set channel(value: string) {
    this._channel = value;
  }
  public resetChannel() {
    this._channel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get channelInput() {
    return this._channel;
  }
}
export interface DomainDevicesDisksSourceVhostUserDevSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksSourceVhostUserDevSecLabelToTerraform(struct?: DomainDevicesDisksSourceVhostUserDevSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksSourceVhostUserDevSecLabelToHclTerraform(struct?: DomainDevicesDisksSourceVhostUserDevSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceVhostUserDevSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksSourceVhostUserDevSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceVhostUserDevSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksSourceVhostUserDevSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksSourceVhostUserDevSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksSourceVhostUserDevSecLabelOutputReference {
    return new DomainDevicesDisksSourceVhostUserDevSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksSourceVhostUserDev {
  /**
  * Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksSourceVhostUserDevSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksSourceVhostUserDevToTerraform(struct?: DomainDevicesDisksSourceVhostUserDev | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesDisksSourceVhostUserDevSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksSourceVhostUserDevToHclTerraform(struct?: DomainDevicesDisksSourceVhostUserDev | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksSourceVhostUserDevSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksSourceVhostUserDevSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceVhostUserDevOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceVhostUserDev | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceVhostUserDev | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksSourceVhostUserDevSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksSourceVhostUserDevSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksSourceVhostUserFileSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksSourceVhostUserFileSecLabelToTerraform(struct?: DomainDevicesDisksSourceVhostUserFileSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksSourceVhostUserFileSecLabelToHclTerraform(struct?: DomainDevicesDisksSourceVhostUserFileSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceVhostUserFileSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksSourceVhostUserFileSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceVhostUserFileSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksSourceVhostUserFileSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksSourceVhostUserFileSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksSourceVhostUserFileSecLabelOutputReference {
    return new DomainDevicesDisksSourceVhostUserFileSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksSourceVhostUserFile {
  /**
  * Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.
  * 
  * See: <https://libvirt.org/formatdomain.html#device-logfile>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#append Domain#append}
  */
  readonly append?: string;
  /**
  * Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksSourceVhostUserFileSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksSourceVhostUserFileToTerraform(struct?: DomainDevicesDisksSourceVhostUserFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.stringToTerraform(struct!.append),
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesDisksSourceVhostUserFileSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksSourceVhostUserFileToHclTerraform(struct?: DomainDevicesDisksSourceVhostUserFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.stringToHclTerraform(struct!.append),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksSourceVhostUserFileSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksSourceVhostUserFileSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceVhostUserFileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceVhostUserFile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceVhostUserFile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append = value.append;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append?: string; 
  public get append() {
    return this.getStringAttribute('append');
  }
  public set append(value: string) {
    this._append = value;
  }
  public resetAppend() {
    this._append = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append;
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksSourceVhostUserFileSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksSourceVhostUserFileSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksSourceVhostUserNmdm {
  /**
  * Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.
  * 
  * See: <https://libvirt.org/formatdomain.html#nmdm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#master Domain#master}
  */
  readonly master: string;
  /**
  * Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.
  * 
  * See: <https://libvirt.org/formatdomain.html#nmdm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#slave Domain#slave}
  */
  readonly slave: string;
}

export function domainDevicesDisksSourceVhostUserNmdmToTerraform(struct?: DomainDevicesDisksSourceVhostUserNmdm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    master: cdktf.stringToTerraform(struct!.master),
    slave: cdktf.stringToTerraform(struct!.slave),
  }
}


export function domainDevicesDisksSourceVhostUserNmdmToHclTerraform(struct?: DomainDevicesDisksSourceVhostUserNmdm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    master: {
      value: cdktf.stringToHclTerraform(struct!.master),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    slave: {
      value: cdktf.stringToHclTerraform(struct!.slave),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceVhostUserNmdmOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceVhostUserNmdm | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._master !== undefined) {
      hasAnyValues = true;
      internalValueResult.master = this._master;
    }
    if (this._slave !== undefined) {
      hasAnyValues = true;
      internalValueResult.slave = this._slave;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceVhostUserNmdm | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._master = undefined;
      this._slave = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._master = value.master;
      this._slave = value.slave;
    }
  }

  // master - computed: false, optional: false, required: true
  private _master?: string; 
  public get master() {
    return this.getStringAttribute('master');
  }
  public set master(value: string) {
    this._master = value;
  }
  // Temporarily expose input value. Use with caution.
  public get masterInput() {
    return this._master;
  }

  // slave - computed: false, optional: false, required: true
  private _slave?: string; 
  public get slave() {
    return this.getStringAttribute('slave');
  }
  public set slave(value: string) {
    this._slave = value;
  }
  // Temporarily expose input value. Use with caution.
  public get slaveInput() {
    return this._slave;
  }
}
export interface DomainDevicesDisksSourceVhostUserPipeSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksSourceVhostUserPipeSecLabelToTerraform(struct?: DomainDevicesDisksSourceVhostUserPipeSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksSourceVhostUserPipeSecLabelToHclTerraform(struct?: DomainDevicesDisksSourceVhostUserPipeSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceVhostUserPipeSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksSourceVhostUserPipeSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceVhostUserPipeSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksSourceVhostUserPipeSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksSourceVhostUserPipeSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksSourceVhostUserPipeSecLabelOutputReference {
    return new DomainDevicesDisksSourceVhostUserPipeSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksSourceVhostUserPipe {
  /**
  * Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksSourceVhostUserPipeSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksSourceVhostUserPipeToTerraform(struct?: DomainDevicesDisksSourceVhostUserPipe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesDisksSourceVhostUserPipeSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksSourceVhostUserPipeToHclTerraform(struct?: DomainDevicesDisksSourceVhostUserPipe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksSourceVhostUserPipeSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksSourceVhostUserPipeSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceVhostUserPipeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceVhostUserPipe | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceVhostUserPipe | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksSourceVhostUserPipeSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksSourceVhostUserPipeSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksSourceVhostUserPtySecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksSourceVhostUserPtySecLabelToTerraform(struct?: DomainDevicesDisksSourceVhostUserPtySecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksSourceVhostUserPtySecLabelToHclTerraform(struct?: DomainDevicesDisksSourceVhostUserPtySecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceVhostUserPtySecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksSourceVhostUserPtySecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceVhostUserPtySecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksSourceVhostUserPtySecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksSourceVhostUserPtySecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksSourceVhostUserPtySecLabelOutputReference {
    return new DomainDevicesDisksSourceVhostUserPtySecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksSourceVhostUserPty {
  /**
  * Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksSourceVhostUserPtySecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksSourceVhostUserPtyToTerraform(struct?: DomainDevicesDisksSourceVhostUserPty | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesDisksSourceVhostUserPtySecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksSourceVhostUserPtyToHclTerraform(struct?: DomainDevicesDisksSourceVhostUserPty | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksSourceVhostUserPtySecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksSourceVhostUserPtySecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceVhostUserPtyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceVhostUserPty | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceVhostUserPty | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksSourceVhostUserPtySecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksSourceVhostUserPtySecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksSourceVhostUserQemuvdAgentClipBoard {
  /**
  * Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#copy_paste Domain#copy_paste}
  */
  readonly copyPaste: string;
}

export function domainDevicesDisksSourceVhostUserQemuvdAgentClipBoardToTerraform(struct?: DomainDevicesDisksSourceVhostUserQemuvdAgentClipBoard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    copy_paste: cdktf.stringToTerraform(struct!.copyPaste),
  }
}


export function domainDevicesDisksSourceVhostUserQemuvdAgentClipBoardToHclTerraform(struct?: DomainDevicesDisksSourceVhostUserQemuvdAgentClipBoard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    copy_paste: {
      value: cdktf.stringToHclTerraform(struct!.copyPaste),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceVhostUserQemuvdAgentClipBoardOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceVhostUserQemuvdAgentClipBoard | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._copyPaste !== undefined) {
      hasAnyValues = true;
      internalValueResult.copyPaste = this._copyPaste;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceVhostUserQemuvdAgentClipBoard | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._copyPaste = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._copyPaste = value.copyPaste;
    }
  }

  // copy_paste - computed: false, optional: false, required: true
  private _copyPaste?: string; 
  public get copyPaste() {
    return this.getStringAttribute('copy_paste');
  }
  public set copyPaste(value: string) {
    this._copyPaste = value;
  }
  // Temporarily expose input value. Use with caution.
  public get copyPasteInput() {
    return this._copyPaste;
  }
}
export interface DomainDevicesDisksSourceVhostUserQemuvdAgentMouse {
  /**
  * Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).
  * 
  * See: <https://libvirt.org/formatdomain.html#channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode: string;
}

export function domainDevicesDisksSourceVhostUserQemuvdAgentMouseToTerraform(struct?: DomainDevicesDisksSourceVhostUserQemuvdAgentMouse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
  }
}


export function domainDevicesDisksSourceVhostUserQemuvdAgentMouseToHclTerraform(struct?: DomainDevicesDisksSourceVhostUserQemuvdAgentMouse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceVhostUserQemuvdAgentMouseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceVhostUserQemuvdAgentMouse | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceVhostUserQemuvdAgentMouse | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
    }
  }

  // mode - computed: false, optional: false, required: true
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }
}
export interface DomainDevicesDisksSourceVhostUserQemuvdAgent {
  /**
  * Configures clipboard-related behavior for the QEMU vdagent–based EGD source, controlling whether clipboard data exchange is allowed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#clip_board Domain#clip_board}
  */
  readonly clipBoard?: DomainDevicesDisksSourceVhostUserQemuvdAgentClipBoard;
  /**
  * Configures mouse integration options for the QEMU vdagent–based EGD source, such as how mouse events are handled.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mouse Domain#mouse}
  */
  readonly mouse?: DomainDevicesDisksSourceVhostUserQemuvdAgentMouse;
}

export function domainDevicesDisksSourceVhostUserQemuvdAgentToTerraform(struct?: DomainDevicesDisksSourceVhostUserQemuvdAgent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    clip_board: domainDevicesDisksSourceVhostUserQemuvdAgentClipBoardToTerraform(struct!.clipBoard),
    mouse: domainDevicesDisksSourceVhostUserQemuvdAgentMouseToTerraform(struct!.mouse),
  }
}


export function domainDevicesDisksSourceVhostUserQemuvdAgentToHclTerraform(struct?: DomainDevicesDisksSourceVhostUserQemuvdAgent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    clip_board: {
      value: domainDevicesDisksSourceVhostUserQemuvdAgentClipBoardToHclTerraform(struct!.clipBoard),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceVhostUserQemuvdAgentClipBoard",
    },
    mouse: {
      value: domainDevicesDisksSourceVhostUserQemuvdAgentMouseToHclTerraform(struct!.mouse),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceVhostUserQemuvdAgentMouse",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceVhostUserQemuvdAgentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceVhostUserQemuvdAgent | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clipBoard?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clipBoard = this._clipBoard?.internalValue;
    }
    if (this._mouse?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.mouse = this._mouse?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceVhostUserQemuvdAgent | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clipBoard.internalValue = undefined;
      this._mouse.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clipBoard.internalValue = value.clipBoard;
      this._mouse.internalValue = value.mouse;
    }
  }

  // clip_board - computed: false, optional: true, required: false
  private _clipBoard = new DomainDevicesDisksSourceVhostUserQemuvdAgentClipBoardOutputReference(this, "clip_board");
  public get clipBoard() {
    return this._clipBoard;
  }
  public putClipBoard(value: DomainDevicesDisksSourceVhostUserQemuvdAgentClipBoard) {
    this._clipBoard.internalValue = value;
  }
  public resetClipBoard() {
    this._clipBoard.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clipBoardInput() {
    return this._clipBoard.internalValue;
  }

  // mouse - computed: false, optional: true, required: false
  private _mouse = new DomainDevicesDisksSourceVhostUserQemuvdAgentMouseOutputReference(this, "mouse");
  public get mouse() {
    return this._mouse;
  }
  public putMouse(value: DomainDevicesDisksSourceVhostUserQemuvdAgentMouse) {
    this._mouse.internalValue = value;
  }
  public resetMouse() {
    this._mouse.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mouseInput() {
    return this._mouse.internalValue;
  }
}
export interface DomainDevicesDisksSourceVhostUserSpicePort {
  /**
  * Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#channel Domain#channel}
  */
  readonly channel: string;
}

export function domainDevicesDisksSourceVhostUserSpicePortToTerraform(struct?: DomainDevicesDisksSourceVhostUserSpicePort | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    channel: cdktf.stringToTerraform(struct!.channel),
  }
}


export function domainDevicesDisksSourceVhostUserSpicePortToHclTerraform(struct?: DomainDevicesDisksSourceVhostUserSpicePort | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    channel: {
      value: cdktf.stringToHclTerraform(struct!.channel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceVhostUserSpicePortOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceVhostUserSpicePort | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._channel !== undefined) {
      hasAnyValues = true;
      internalValueResult.channel = this._channel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceVhostUserSpicePort | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._channel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._channel = value.channel;
    }
  }

  // channel - computed: false, optional: false, required: true
  private _channel?: string; 
  public get channel() {
    return this.getStringAttribute('channel');
  }
  public set channel(value: string) {
    this._channel = value;
  }
  // Temporarily expose input value. Use with caution.
  public get channelInput() {
    return this._channel;
  }
}
export interface DomainDevicesDisksSourceVhostUserTcpReconnect {
  /**
  * Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enabled Domain#enabled}
  */
  readonly enabled: string;
  /**
  * Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#timeout Domain#timeout}
  */
  readonly timeout?: number;
}

export function domainDevicesDisksSourceVhostUserTcpReconnectToTerraform(struct?: DomainDevicesDisksSourceVhostUserTcpReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.stringToTerraform(struct!.enabled),
    timeout: cdktf.numberToTerraform(struct!.timeout),
  }
}


export function domainDevicesDisksSourceVhostUserTcpReconnectToHclTerraform(struct?: DomainDevicesDisksSourceVhostUserTcpReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.stringToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.numberToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceVhostUserTcpReconnectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceVhostUserTcpReconnect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceVhostUserTcpReconnect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._timeout = value.timeout;
    }
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: string; 
  public get enabled() {
    return this.getStringAttribute('enabled');
  }
  public set enabled(value: string) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: number; 
  public get timeout() {
    return this.getNumberAttribute('timeout');
  }
  public set timeout(value: number) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DomainDevicesDisksSourceVhostUserTcp {
  /**
  * Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#host Domain#host}
  */
  readonly host?: string;
  /**
  * Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode?: string;
  /**
  * Enables and configures automatic reconnection behavior for a UNIX socket–based EGD entropy source; the content and attributes are user-provided according to desired policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reconnect Domain#reconnect}
  */
  readonly reconnect?: DomainDevicesDisksSourceVhostUserTcpReconnect;
  /**
  * Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#service Domain#service}
  */
  readonly service?: string;
  /**
  * Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tls Domain#tls}
  */
  readonly tls?: string;
}

export function domainDevicesDisksSourceVhostUserTcpToTerraform(struct?: DomainDevicesDisksSourceVhostUserTcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    mode: cdktf.stringToTerraform(struct!.mode),
    reconnect: domainDevicesDisksSourceVhostUserTcpReconnectToTerraform(struct!.reconnect),
    service: cdktf.stringToTerraform(struct!.service),
    tls: cdktf.stringToTerraform(struct!.tls),
  }
}


export function domainDevicesDisksSourceVhostUserTcpToHclTerraform(struct?: DomainDevicesDisksSourceVhostUserTcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reconnect: {
      value: domainDevicesDisksSourceVhostUserTcpReconnectToHclTerraform(struct!.reconnect),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceVhostUserTcpReconnect",
    },
    service: {
      value: cdktf.stringToHclTerraform(struct!.service),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: cdktf.stringToHclTerraform(struct!.tls),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceVhostUserTcpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceVhostUserTcp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._reconnect?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.reconnect = this._reconnect?.internalValue;
    }
    if (this._service !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service;
    }
    if (this._tls !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceVhostUserTcp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host = undefined;
      this._mode = undefined;
      this._reconnect.internalValue = undefined;
      this._service = undefined;
      this._tls = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host = value.host;
      this._mode = value.mode;
      this._reconnect.internalValue = value.reconnect;
      this._service = value.service;
      this._tls = value.tls;
    }
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // reconnect - computed: false, optional: true, required: false
  private _reconnect = new DomainDevicesDisksSourceVhostUserTcpReconnectOutputReference(this, "reconnect");
  public get reconnect() {
    return this._reconnect;
  }
  public putReconnect(value: DomainDevicesDisksSourceVhostUserTcpReconnect) {
    this._reconnect.internalValue = value;
  }
  public resetReconnect() {
    this._reconnect.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reconnectInput() {
    return this._reconnect.internalValue;
  }

  // service - computed: false, optional: true, required: false
  private _service?: string; 
  public get service() {
    return this.getStringAttribute('service');
  }
  public set service(value: string) {
    this._service = value;
  }
  public resetService() {
    this._service = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service;
  }

  // tls - computed: false, optional: true, required: false
  private _tls?: string; 
  public get tls() {
    return this.getStringAttribute('tls');
  }
  public set tls(value: string) {
    this._tls = value;
  }
  public resetTls() {
    this._tls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls;
  }
}
export interface DomainDevicesDisksSourceVhostUserUdp {
  /**
  * Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bind_host Domain#bind_host}
  */
  readonly bindHost: string;
  /**
  * Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bind_service Domain#bind_service}
  */
  readonly bindService: string;
  /**
  * Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#connect_host Domain#connect_host}
  */
  readonly connectHost: string;
  /**
  * Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#connect_service Domain#connect_service}
  */
  readonly connectService: string;
}

export function domainDevicesDisksSourceVhostUserUdpToTerraform(struct?: DomainDevicesDisksSourceVhostUserUdp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_host: cdktf.stringToTerraform(struct!.bindHost),
    bind_service: cdktf.stringToTerraform(struct!.bindService),
    connect_host: cdktf.stringToTerraform(struct!.connectHost),
    connect_service: cdktf.stringToTerraform(struct!.connectService),
  }
}


export function domainDevicesDisksSourceVhostUserUdpToHclTerraform(struct?: DomainDevicesDisksSourceVhostUserUdp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_host: {
      value: cdktf.stringToHclTerraform(struct!.bindHost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bind_service: {
      value: cdktf.stringToHclTerraform(struct!.bindService),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connect_host: {
      value: cdktf.stringToHclTerraform(struct!.connectHost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connect_service: {
      value: cdktf.stringToHclTerraform(struct!.connectService),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceVhostUserUdpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceVhostUserUdp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindHost !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindHost = this._bindHost;
    }
    if (this._bindService !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindService = this._bindService;
    }
    if (this._connectHost !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectHost = this._connectHost;
    }
    if (this._connectService !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectService = this._connectService;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceVhostUserUdp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bindHost = undefined;
      this._bindService = undefined;
      this._connectHost = undefined;
      this._connectService = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bindHost = value.bindHost;
      this._bindService = value.bindService;
      this._connectHost = value.connectHost;
      this._connectService = value.connectService;
    }
  }

  // bind_host - computed: false, optional: false, required: true
  private _bindHost?: string; 
  public get bindHost() {
    return this.getStringAttribute('bind_host');
  }
  public set bindHost(value: string) {
    this._bindHost = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bindHostInput() {
    return this._bindHost;
  }

  // bind_service - computed: false, optional: false, required: true
  private _bindService?: string; 
  public get bindService() {
    return this.getStringAttribute('bind_service');
  }
  public set bindService(value: string) {
    this._bindService = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bindServiceInput() {
    return this._bindService;
  }

  // connect_host - computed: false, optional: false, required: true
  private _connectHost?: string; 
  public get connectHost() {
    return this.getStringAttribute('connect_host');
  }
  public set connectHost(value: string) {
    this._connectHost = value;
  }
  // Temporarily expose input value. Use with caution.
  public get connectHostInput() {
    return this._connectHost;
  }

  // connect_service - computed: false, optional: false, required: true
  private _connectService?: string; 
  public get connectService() {
    return this.getStringAttribute('connect_service');
  }
  public set connectService(value: string) {
    this._connectService = value;
  }
  // Temporarily expose input value. Use with caution.
  public get connectServiceInput() {
    return this._connectService;
  }
}
export interface DomainDevicesDisksSourceVhostUserUnixReconnect {
  /**
  * Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enabled Domain#enabled}
  */
  readonly enabled: string;
  /**
  * Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#timeout Domain#timeout}
  */
  readonly timeout?: number;
}

export function domainDevicesDisksSourceVhostUserUnixReconnectToTerraform(struct?: DomainDevicesDisksSourceVhostUserUnixReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.stringToTerraform(struct!.enabled),
    timeout: cdktf.numberToTerraform(struct!.timeout),
  }
}


export function domainDevicesDisksSourceVhostUserUnixReconnectToHclTerraform(struct?: DomainDevicesDisksSourceVhostUserUnixReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.stringToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.numberToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceVhostUserUnixReconnectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceVhostUserUnixReconnect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceVhostUserUnixReconnect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._timeout = value.timeout;
    }
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: string; 
  public get enabled() {
    return this.getStringAttribute('enabled');
  }
  public set enabled(value: string) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: number; 
  public get timeout() {
    return this.getNumberAttribute('timeout');
  }
  public set timeout(value: number) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DomainDevicesDisksSourceVhostUserUnixSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksSourceVhostUserUnixSecLabelToTerraform(struct?: DomainDevicesDisksSourceVhostUserUnixSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksSourceVhostUserUnixSecLabelToHclTerraform(struct?: DomainDevicesDisksSourceVhostUserUnixSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceVhostUserUnixSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksSourceVhostUserUnixSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceVhostUserUnixSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksSourceVhostUserUnixSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksSourceVhostUserUnixSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksSourceVhostUserUnixSecLabelOutputReference {
    return new DomainDevicesDisksSourceVhostUserUnixSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksSourceVhostUserUnix {
  /**
  * Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode?: string;
  /**
  * Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path?: string;
  /**
  * Enables and configures automatic reconnection behavior for a UNIX socket–based EGD entropy source; the content and attributes are user-provided according to desired policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reconnect Domain#reconnect}
  */
  readonly reconnect?: DomainDevicesDisksSourceVhostUserUnixReconnect;
  /**
  * Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksSourceVhostUserUnixSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesDisksSourceVhostUserUnixToTerraform(struct?: DomainDevicesDisksSourceVhostUserUnix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
    reconnect: domainDevicesDisksSourceVhostUserUnixReconnectToTerraform(struct!.reconnect),
    sec_label: cdktf.listMapper(domainDevicesDisksSourceVhostUserUnixSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesDisksSourceVhostUserUnixToHclTerraform(struct?: DomainDevicesDisksSourceVhostUserUnix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reconnect: {
      value: domainDevicesDisksSourceVhostUserUnixReconnectToHclTerraform(struct!.reconnect),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceVhostUserUnixReconnect",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksSourceVhostUserUnixSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksSourceVhostUserUnixSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceVhostUserUnixOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceVhostUserUnix | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._reconnect?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.reconnect = this._reconnect?.internalValue;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceVhostUserUnix | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
      this._path = undefined;
      this._reconnect.internalValue = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
      this._path = value.path;
      this._reconnect.internalValue = value.reconnect;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // reconnect - computed: false, optional: true, required: false
  private _reconnect = new DomainDevicesDisksSourceVhostUserUnixReconnectOutputReference(this, "reconnect");
  public get reconnect() {
    return this._reconnect;
  }
  public putReconnect(value: DomainDevicesDisksSourceVhostUserUnixReconnect) {
    this._reconnect.internalValue = value;
  }
  public resetReconnect() {
    this._reconnect.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reconnectInput() {
    return this._reconnect.internalValue;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksSourceVhostUserUnixSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksSourceVhostUserUnixSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesDisksSourceVhostUser {
  /**
  * Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dbus Domain#dbus}
  */
  readonly dbus?: DomainDevicesDisksSourceVhostUserDbus;
  /**
  * Configures an EGD RNG backend that reads entropy from a host character device node.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dev Domain#dev}
  */
  readonly dev?: DomainDevicesDisksSourceVhostUserDev;
  /**
  * Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file?: DomainDevicesDisksSourceVhostUserFile;
  /**
  * Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#nmdm Domain#nmdm}
  */
  readonly nmdm?: DomainDevicesDisksSourceVhostUserNmdm;
  /**
  * When set to true, uses a null character device as the vhost-user backing-store source, discarding all output and providing no input; when false or unset, the null device is not used.
  * 
  * See: <https://libvirt.org/formatdomain.html#null-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#null Domain#null}
  */
  readonly null?: boolean | cdktf.IResolvable;
  /**
  * Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pipe Domain#pipe}
  */
  readonly pipe?: DomainDevicesDisksSourceVhostUserPipe;
  /**
  * Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pty Domain#pty}
  */
  readonly pty?: DomainDevicesDisksSourceVhostUserPty;
  /**
  * Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#qemuvd_agent Domain#qemuvd_agent}
  */
  readonly qemuvdAgent?: DomainDevicesDisksSourceVhostUserQemuvdAgent;
  /**
  * Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#spice_port Domain#spice_port}
  */
  readonly spicePort?: DomainDevicesDisksSourceVhostUserSpicePort;
  /**
  * When set to true, exposes the vhost-user backing through a SPICE virtio-serial management channel (SpiceVMC); when false or unset, the element is omitted.
  * 
  * See: <https://libvirt.org/formatdomain.html#spice-channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#spice_vmc Domain#spice_vmc}
  */
  readonly spiceVmc?: boolean | cdktf.IResolvable;
  /**
  * When set to true, connects the vhost-user backing to the domain’s standard I/O character device; when false or unset, the StdIO element is omitted.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-interface>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#std_io Domain#std_io}
  */
  readonly stdIo?: boolean | cdktf.IResolvable;
  /**
  * Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tcp Domain#tcp}
  */
  readonly tcp?: DomainDevicesDisksSourceVhostUserTcp;
  /**
  * Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#udp Domain#udp}
  */
  readonly udp?: DomainDevicesDisksSourceVhostUserUdp;
  /**
  * Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#unix Domain#unix}
  */
  readonly unix?: DomainDevicesDisksSourceVhostUserUnix;
  /**
  * Enables use of a vhost-user communication mechanism compatible with a VC-style (versioned capability) endpoint for the disk mirror backing store; when set true the VC element is emitted, when false or null it is omitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vc Domain#vc}
  */
  readonly vc?: boolean | cdktf.IResolvable;
}

export function domainDevicesDisksSourceVhostUserToTerraform(struct?: DomainDevicesDisksSourceVhostUser | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dbus: domainDevicesDisksSourceVhostUserDbusToTerraform(struct!.dbus),
    dev: domainDevicesDisksSourceVhostUserDevToTerraform(struct!.dev),
    file: domainDevicesDisksSourceVhostUserFileToTerraform(struct!.file),
    nmdm: domainDevicesDisksSourceVhostUserNmdmToTerraform(struct!.nmdm),
    null: cdktf.booleanToTerraform(struct!.null),
    pipe: domainDevicesDisksSourceVhostUserPipeToTerraform(struct!.pipe),
    pty: domainDevicesDisksSourceVhostUserPtyToTerraform(struct!.pty),
    qemuvd_agent: domainDevicesDisksSourceVhostUserQemuvdAgentToTerraform(struct!.qemuvdAgent),
    spice_port: domainDevicesDisksSourceVhostUserSpicePortToTerraform(struct!.spicePort),
    spice_vmc: cdktf.booleanToTerraform(struct!.spiceVmc),
    std_io: cdktf.booleanToTerraform(struct!.stdIo),
    tcp: domainDevicesDisksSourceVhostUserTcpToTerraform(struct!.tcp),
    udp: domainDevicesDisksSourceVhostUserUdpToTerraform(struct!.udp),
    unix: domainDevicesDisksSourceVhostUserUnixToTerraform(struct!.unix),
    vc: cdktf.booleanToTerraform(struct!.vc),
  }
}


export function domainDevicesDisksSourceVhostUserToHclTerraform(struct?: DomainDevicesDisksSourceVhostUser | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dbus: {
      value: domainDevicesDisksSourceVhostUserDbusToHclTerraform(struct!.dbus),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceVhostUserDbus",
    },
    dev: {
      value: domainDevicesDisksSourceVhostUserDevToHclTerraform(struct!.dev),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceVhostUserDev",
    },
    file: {
      value: domainDevicesDisksSourceVhostUserFileToHclTerraform(struct!.file),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceVhostUserFile",
    },
    nmdm: {
      value: domainDevicesDisksSourceVhostUserNmdmToHclTerraform(struct!.nmdm),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceVhostUserNmdm",
    },
    null: {
      value: cdktf.booleanToHclTerraform(struct!.null),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    pipe: {
      value: domainDevicesDisksSourceVhostUserPipeToHclTerraform(struct!.pipe),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceVhostUserPipe",
    },
    pty: {
      value: domainDevicesDisksSourceVhostUserPtyToHclTerraform(struct!.pty),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceVhostUserPty",
    },
    qemuvd_agent: {
      value: domainDevicesDisksSourceVhostUserQemuvdAgentToHclTerraform(struct!.qemuvdAgent),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceVhostUserQemuvdAgent",
    },
    spice_port: {
      value: domainDevicesDisksSourceVhostUserSpicePortToHclTerraform(struct!.spicePort),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceVhostUserSpicePort",
    },
    spice_vmc: {
      value: cdktf.booleanToHclTerraform(struct!.spiceVmc),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    std_io: {
      value: cdktf.booleanToHclTerraform(struct!.stdIo),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tcp: {
      value: domainDevicesDisksSourceVhostUserTcpToHclTerraform(struct!.tcp),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceVhostUserTcp",
    },
    udp: {
      value: domainDevicesDisksSourceVhostUserUdpToHclTerraform(struct!.udp),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceVhostUserUdp",
    },
    unix: {
      value: domainDevicesDisksSourceVhostUserUnixToHclTerraform(struct!.unix),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceVhostUserUnix",
    },
    vc: {
      value: cdktf.booleanToHclTerraform(struct!.vc),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceVhostUserOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceVhostUser | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dbus?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dbus = this._dbus?.internalValue;
    }
    if (this._dev?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dev = this._dev?.internalValue;
    }
    if (this._file?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file?.internalValue;
    }
    if (this._nmdm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nmdm = this._nmdm?.internalValue;
    }
    if (this._null !== undefined) {
      hasAnyValues = true;
      internalValueResult.null = this._null;
    }
    if (this._pipe?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipe = this._pipe?.internalValue;
    }
    if (this._pty?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pty = this._pty?.internalValue;
    }
    if (this._qemuvdAgent?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.qemuvdAgent = this._qemuvdAgent?.internalValue;
    }
    if (this._spicePort?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spicePort = this._spicePort?.internalValue;
    }
    if (this._spiceVmc !== undefined) {
      hasAnyValues = true;
      internalValueResult.spiceVmc = this._spiceVmc;
    }
    if (this._stdIo !== undefined) {
      hasAnyValues = true;
      internalValueResult.stdIo = this._stdIo;
    }
    if (this._tcp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tcp = this._tcp?.internalValue;
    }
    if (this._udp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.udp = this._udp?.internalValue;
    }
    if (this._unix?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.unix = this._unix?.internalValue;
    }
    if (this._vc !== undefined) {
      hasAnyValues = true;
      internalValueResult.vc = this._vc;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceVhostUser | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dbus.internalValue = undefined;
      this._dev.internalValue = undefined;
      this._file.internalValue = undefined;
      this._nmdm.internalValue = undefined;
      this._null = undefined;
      this._pipe.internalValue = undefined;
      this._pty.internalValue = undefined;
      this._qemuvdAgent.internalValue = undefined;
      this._spicePort.internalValue = undefined;
      this._spiceVmc = undefined;
      this._stdIo = undefined;
      this._tcp.internalValue = undefined;
      this._udp.internalValue = undefined;
      this._unix.internalValue = undefined;
      this._vc = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dbus.internalValue = value.dbus;
      this._dev.internalValue = value.dev;
      this._file.internalValue = value.file;
      this._nmdm.internalValue = value.nmdm;
      this._null = value.null;
      this._pipe.internalValue = value.pipe;
      this._pty.internalValue = value.pty;
      this._qemuvdAgent.internalValue = value.qemuvdAgent;
      this._spicePort.internalValue = value.spicePort;
      this._spiceVmc = value.spiceVmc;
      this._stdIo = value.stdIo;
      this._tcp.internalValue = value.tcp;
      this._udp.internalValue = value.udp;
      this._unix.internalValue = value.unix;
      this._vc = value.vc;
    }
  }

  // dbus - computed: false, optional: true, required: false
  private _dbus = new DomainDevicesDisksSourceVhostUserDbusOutputReference(this, "dbus");
  public get dbus() {
    return this._dbus;
  }
  public putDbus(value: DomainDevicesDisksSourceVhostUserDbus) {
    this._dbus.internalValue = value;
  }
  public resetDbus() {
    this._dbus.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dbusInput() {
    return this._dbus.internalValue;
  }

  // dev - computed: false, optional: true, required: false
  private _dev = new DomainDevicesDisksSourceVhostUserDevOutputReference(this, "dev");
  public get dev() {
    return this._dev;
  }
  public putDev(value: DomainDevicesDisksSourceVhostUserDev) {
    this._dev.internalValue = value;
  }
  public resetDev() {
    this._dev.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devInput() {
    return this._dev.internalValue;
  }

  // file - computed: false, optional: true, required: false
  private _file = new DomainDevicesDisksSourceVhostUserFileOutputReference(this, "file");
  public get file() {
    return this._file;
  }
  public putFile(value: DomainDevicesDisksSourceVhostUserFile) {
    this._file.internalValue = value;
  }
  public resetFile() {
    this._file.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file.internalValue;
  }

  // nmdm - computed: false, optional: true, required: false
  private _nmdm = new DomainDevicesDisksSourceVhostUserNmdmOutputReference(this, "nmdm");
  public get nmdm() {
    return this._nmdm;
  }
  public putNmdm(value: DomainDevicesDisksSourceVhostUserNmdm) {
    this._nmdm.internalValue = value;
  }
  public resetNmdm() {
    this._nmdm.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nmdmInput() {
    return this._nmdm.internalValue;
  }

  // null - computed: false, optional: true, required: false
  private _null?: boolean | cdktf.IResolvable; 
  public get null() {
    return this.getBooleanAttribute('null');
  }
  public set null(value: boolean | cdktf.IResolvable) {
    this._null = value;
  }
  public resetNull() {
    this._null = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nullInput() {
    return this._null;
  }

  // pipe - computed: false, optional: true, required: false
  private _pipe = new DomainDevicesDisksSourceVhostUserPipeOutputReference(this, "pipe");
  public get pipe() {
    return this._pipe;
  }
  public putPipe(value: DomainDevicesDisksSourceVhostUserPipe) {
    this._pipe.internalValue = value;
  }
  public resetPipe() {
    this._pipe.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipeInput() {
    return this._pipe.internalValue;
  }

  // pty - computed: false, optional: true, required: false
  private _pty = new DomainDevicesDisksSourceVhostUserPtyOutputReference(this, "pty");
  public get pty() {
    return this._pty;
  }
  public putPty(value: DomainDevicesDisksSourceVhostUserPty) {
    this._pty.internalValue = value;
  }
  public resetPty() {
    this._pty.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ptyInput() {
    return this._pty.internalValue;
  }

  // qemuvd_agent - computed: false, optional: true, required: false
  private _qemuvdAgent = new DomainDevicesDisksSourceVhostUserQemuvdAgentOutputReference(this, "qemuvd_agent");
  public get qemuvdAgent() {
    return this._qemuvdAgent;
  }
  public putQemuvdAgent(value: DomainDevicesDisksSourceVhostUserQemuvdAgent) {
    this._qemuvdAgent.internalValue = value;
  }
  public resetQemuvdAgent() {
    this._qemuvdAgent.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get qemuvdAgentInput() {
    return this._qemuvdAgent.internalValue;
  }

  // spice_port - computed: false, optional: true, required: false
  private _spicePort = new DomainDevicesDisksSourceVhostUserSpicePortOutputReference(this, "spice_port");
  public get spicePort() {
    return this._spicePort;
  }
  public putSpicePort(value: DomainDevicesDisksSourceVhostUserSpicePort) {
    this._spicePort.internalValue = value;
  }
  public resetSpicePort() {
    this._spicePort.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spicePortInput() {
    return this._spicePort.internalValue;
  }

  // spice_vmc - computed: false, optional: true, required: false
  private _spiceVmc?: boolean | cdktf.IResolvable; 
  public get spiceVmc() {
    return this.getBooleanAttribute('spice_vmc');
  }
  public set spiceVmc(value: boolean | cdktf.IResolvable) {
    this._spiceVmc = value;
  }
  public resetSpiceVmc() {
    this._spiceVmc = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spiceVmcInput() {
    return this._spiceVmc;
  }

  // std_io - computed: false, optional: true, required: false
  private _stdIo?: boolean | cdktf.IResolvable; 
  public get stdIo() {
    return this.getBooleanAttribute('std_io');
  }
  public set stdIo(value: boolean | cdktf.IResolvable) {
    this._stdIo = value;
  }
  public resetStdIo() {
    this._stdIo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stdIoInput() {
    return this._stdIo;
  }

  // tcp - computed: false, optional: true, required: false
  private _tcp = new DomainDevicesDisksSourceVhostUserTcpOutputReference(this, "tcp");
  public get tcp() {
    return this._tcp;
  }
  public putTcp(value: DomainDevicesDisksSourceVhostUserTcp) {
    this._tcp.internalValue = value;
  }
  public resetTcp() {
    this._tcp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tcpInput() {
    return this._tcp.internalValue;
  }

  // udp - computed: false, optional: true, required: false
  private _udp = new DomainDevicesDisksSourceVhostUserUdpOutputReference(this, "udp");
  public get udp() {
    return this._udp;
  }
  public putUdp(value: DomainDevicesDisksSourceVhostUserUdp) {
    this._udp.internalValue = value;
  }
  public resetUdp() {
    this._udp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get udpInput() {
    return this._udp.internalValue;
  }

  // unix - computed: false, optional: true, required: false
  private _unix = new DomainDevicesDisksSourceVhostUserUnixOutputReference(this, "unix");
  public get unix() {
    return this._unix;
  }
  public putUnix(value: DomainDevicesDisksSourceVhostUserUnix) {
    this._unix.internalValue = value;
  }
  public resetUnix() {
    this._unix.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unixInput() {
    return this._unix.internalValue;
  }

  // vc - computed: false, optional: true, required: false
  private _vc?: boolean | cdktf.IResolvable; 
  public get vc() {
    return this.getBooleanAttribute('vc');
  }
  public set vc(value: boolean | cdktf.IResolvable) {
    this._vc = value;
  }
  public resetVc() {
    this._vc = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vcInput() {
    return this._vc;
  }
}
export interface DomainDevicesDisksSourceVhostVdpa {
  /**
  * Sets the host vDPA character device path used as the backingStore source for the mirrored disk when using a vhost-vdpa backend; the value is user-provided and must reference an existing device node (for example, /dev/vhost-vdpa0).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dev Domain#dev}
  */
  readonly dev: string;
}

export function domainDevicesDisksSourceVhostVdpaToTerraform(struct?: DomainDevicesDisksSourceVhostVdpa | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dev: cdktf.stringToTerraform(struct!.dev),
  }
}


export function domainDevicesDisksSourceVhostVdpaToHclTerraform(struct?: DomainDevicesDisksSourceVhostVdpa | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dev: {
      value: cdktf.stringToHclTerraform(struct!.dev),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceVhostVdpaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceVhostVdpa | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dev !== undefined) {
      hasAnyValues = true;
      internalValueResult.dev = this._dev;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceVhostVdpa | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dev = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dev = value.dev;
    }
  }

  // dev - computed: false, optional: false, required: true
  private _dev?: string; 
  public get dev() {
    return this.getStringAttribute('dev');
  }
  public set dev(value: string) {
    this._dev = value;
  }
  // Temporarily expose input value. Use with caution.
  public get devInput() {
    return this._dev;
  }
}
export interface DomainDevicesDisksSourceVolumeSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesDisksSourceVolumeSecLabelToTerraform(struct?: DomainDevicesDisksSourceVolumeSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesDisksSourceVolumeSecLabelToHclTerraform(struct?: DomainDevicesDisksSourceVolumeSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceVolumeSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksSourceVolumeSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceVolumeSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesDisksSourceVolumeSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksSourceVolumeSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksSourceVolumeSecLabelOutputReference {
    return new DomainDevicesDisksSourceVolumeSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksSourceVolume {
  /**
  * Sets the access mode with which the storage volume is used as the backingStore source (for example, "readOnly" or "readWrite" depending on driver support); the value is user-provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode?: string;
  /**
  * Names the storage pool that contains the backing storage volume used as the mirror backingStore source; must match an existing libvirt storage pool name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pool Domain#pool}
  */
  readonly pool?: string;
  /**
  * Configures an optional security label override applied to the backing storage volume used as the mirror backingStore source.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesDisksSourceVolumeSecLabel[] | cdktf.IResolvable;
  /**
  * Sets the name of the storage volume within the specified pool that is used as the backingStore source for the mirrored disk.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#volume Domain#volume}
  */
  readonly volume?: string;
}

export function domainDevicesDisksSourceVolumeToTerraform(struct?: DomainDevicesDisksSourceVolume | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
    pool: cdktf.stringToTerraform(struct!.pool),
    sec_label: cdktf.listMapper(domainDevicesDisksSourceVolumeSecLabelToTerraform, false)(struct!.secLabel),
    volume: cdktf.stringToTerraform(struct!.volume),
  }
}


export function domainDevicesDisksSourceVolumeToHclTerraform(struct?: DomainDevicesDisksSourceVolume | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pool: {
      value: cdktf.stringToHclTerraform(struct!.pool),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesDisksSourceVolumeSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksSourceVolumeSecLabelList",
    },
    volume: {
      value: cdktf.stringToHclTerraform(struct!.volume),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceVolumeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSourceVolume | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._pool !== undefined) {
      hasAnyValues = true;
      internalValueResult.pool = this._pool;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    if (this._volume !== undefined) {
      hasAnyValues = true;
      internalValueResult.volume = this._volume;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSourceVolume | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
      this._pool = undefined;
      this._secLabel.internalValue = undefined;
      this._volume = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
      this._pool = value.pool;
      this._secLabel.internalValue = value.secLabel;
      this._volume = value.volume;
    }
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // pool - computed: false, optional: true, required: false
  private _pool?: string; 
  public get pool() {
    return this.getStringAttribute('pool');
  }
  public set pool(value: string) {
    this._pool = value;
  }
  public resetPool() {
    this._pool = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get poolInput() {
    return this._pool;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesDisksSourceVolumeSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesDisksSourceVolumeSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }

  // volume - computed: false, optional: true, required: false
  private _volume?: string; 
  public get volume() {
    return this.getStringAttribute('volume');
  }
  public set volume(value: string) {
    this._volume = value;
  }
  public resetVolume() {
    this._volume = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get volumeInput() {
    return this._volume;
  }
}
export interface DomainDevicesDisksSource {
  /**
  * Describes a block device used as the source for the mirror backing store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#block Domain#block}
  */
  readonly block?: DomainDevicesDisksSourceBlock;
  /**
  * Provides optional cookie data associated with the mirror backing store source (for example, auth or session data), with content treated as user-provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#cookies Domain#cookies}
  */
  readonly cookies?: DomainDevicesDisksSourceCookies;
  /**
  * Configures a data store descriptor for the mirrored backing store, typically used with networked or advanced storage backends that expose format-specific options.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#data_store Domain#data_store}
  */
  readonly dataStore?: DomainDevicesDisksSourceDataStore;
  /**
  * Configures a directory-based source for the mirrored backing store, pointing to a host directory used by the backing image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dir Domain#dir}
  */
  readonly dir?: DomainDevicesDisksSourceDir;
  /**
  * Enables disk image encryption configuration for this disk and groups attributes defining the encryption engine, format, and secrets.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#encryption Domain#encryption}
  */
  readonly encryption?: DomainDevicesDisksSourceEncryption;
  /**
  * Configures a file-based backing store source for the disk mirror, defining how the backing image is accessed from the host filesystem.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file?: DomainDevicesDisksSourceFile;
  /**
  * Sets the index of this backing store within a backing chain, used when multiple backing layers are present; value is a user-provided non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#index Domain#index}
  */
  readonly index?: number;
  /**
  * Configures a network-based backing store source (such as NBD, iSCSI, or RBD) for the disk mirror, including authentication and host endpoints.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#network Domain#network}
  */
  readonly network?: DomainDevicesDisksSourceNetwork;
  /**
  * Enables using an NVMe-backed source for the mirrored disk’s backing store; when present, it selects an NVMe device or namespace as the source, with details defined by libvirt/QEMU for NVMe disks.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#nvme Domain#nvme}
  */
  readonly nvme?: DomainDevicesDisksSourceNvme;
  /**
  * Configures read-ahead behavior for the mirrored disk’s backing-store source, allowing tuning of how much data is pre-fetched from the backend.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#readahead Domain#readahead}
  */
  readonly readahead?: DomainDevicesDisksSourceReadahead;
  /**
  * Configures SCSI-style reservations or similar persistent reservation management for the mirrored disk’s backing-store source, controlling how access is coordinated across nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reservations Domain#reservations}
  */
  readonly reservations?: DomainDevicesDisksSourceReservations;
  /**
  * Configures optional slice or segment information for the backing store source (for example, to describe which logical slices of a device are used); content is user-provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#slices Domain#slices}
  */
  readonly slices?: DomainDevicesDisksSourceSlices;
  /**
  * Enables SSL/TLS parameters for accessing the mirrored backing-store source when it is provided over a secure transport.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#ssl Domain#ssl}
  */
  readonly ssl?: DomainDevicesDisksSourceSsl;
  /**
  * Specifies how strictly the mirrored backing-store source must be available during domain startup; valid values include "mandatory", "requisite", "optional" (user‑provided string matched by libvirt).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#startup_policy Domain#startup_policy}
  */
  readonly startupPolicy?: string;
  /**
  * Configures a timeout for connecting to or initializing the mirrored backing-store source.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#timeout Domain#timeout}
  */
  readonly timeout?: DomainDevicesDisksSourceTimeout;
  /**
  * Selects a vhost-user backend as the transport for the mirrored backing-store source, allowing it to be provided via a userspace process.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vhost_user Domain#vhost_user}
  */
  readonly vhostUser?: DomainDevicesDisksSourceVhostUser;
  /**
  * Selects a vhost-vDPA backend for the disk mirror backing store, allowing acceleration via a vDPA device; additional details are determined by libvirt and device configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vhost_vdpa Domain#vhost_vdpa}
  */
  readonly vhostVdpa?: DomainDevicesDisksSourceVhostVdpa;
  /**
  * Configures the backingStore source as a libvirt storage volume reference instead of a raw file/block path for the mirrored disk.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#volume Domain#volume}
  */
  readonly volume?: DomainDevicesDisksSourceVolume;
}

export function domainDevicesDisksSourceToTerraform(struct?: DomainDevicesDisksSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    block: domainDevicesDisksSourceBlockToTerraform(struct!.block),
    cookies: domainDevicesDisksSourceCookiesToTerraform(struct!.cookies),
    data_store: domainDevicesDisksSourceDataStoreToTerraform(struct!.dataStore),
    dir: domainDevicesDisksSourceDirToTerraform(struct!.dir),
    encryption: domainDevicesDisksSourceEncryptionToTerraform(struct!.encryption),
    file: domainDevicesDisksSourceFileToTerraform(struct!.file),
    index: cdktf.numberToTerraform(struct!.index),
    network: domainDevicesDisksSourceNetworkToTerraform(struct!.network),
    nvme: domainDevicesDisksSourceNvmeToTerraform(struct!.nvme),
    readahead: domainDevicesDisksSourceReadaheadToTerraform(struct!.readahead),
    reservations: domainDevicesDisksSourceReservationsToTerraform(struct!.reservations),
    slices: domainDevicesDisksSourceSlicesToTerraform(struct!.slices),
    ssl: domainDevicesDisksSourceSslToTerraform(struct!.ssl),
    startup_policy: cdktf.stringToTerraform(struct!.startupPolicy),
    timeout: domainDevicesDisksSourceTimeoutToTerraform(struct!.timeout),
    vhost_user: domainDevicesDisksSourceVhostUserToTerraform(struct!.vhostUser),
    vhost_vdpa: domainDevicesDisksSourceVhostVdpaToTerraform(struct!.vhostVdpa),
    volume: domainDevicesDisksSourceVolumeToTerraform(struct!.volume),
  }
}


export function domainDevicesDisksSourceToHclTerraform(struct?: DomainDevicesDisksSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    block: {
      value: domainDevicesDisksSourceBlockToHclTerraform(struct!.block),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceBlock",
    },
    cookies: {
      value: domainDevicesDisksSourceCookiesToHclTerraform(struct!.cookies),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceCookies",
    },
    data_store: {
      value: domainDevicesDisksSourceDataStoreToHclTerraform(struct!.dataStore),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceDataStore",
    },
    dir: {
      value: domainDevicesDisksSourceDirToHclTerraform(struct!.dir),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceDir",
    },
    encryption: {
      value: domainDevicesDisksSourceEncryptionToHclTerraform(struct!.encryption),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceEncryption",
    },
    file: {
      value: domainDevicesDisksSourceFileToHclTerraform(struct!.file),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceFile",
    },
    index: {
      value: cdktf.numberToHclTerraform(struct!.index),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    network: {
      value: domainDevicesDisksSourceNetworkToHclTerraform(struct!.network),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceNetwork",
    },
    nvme: {
      value: domainDevicesDisksSourceNvmeToHclTerraform(struct!.nvme),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceNvme",
    },
    readahead: {
      value: domainDevicesDisksSourceReadaheadToHclTerraform(struct!.readahead),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceReadahead",
    },
    reservations: {
      value: domainDevicesDisksSourceReservationsToHclTerraform(struct!.reservations),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceReservations",
    },
    slices: {
      value: domainDevicesDisksSourceSlicesToHclTerraform(struct!.slices),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceSlices",
    },
    ssl: {
      value: domainDevicesDisksSourceSslToHclTerraform(struct!.ssl),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceSsl",
    },
    startup_policy: {
      value: cdktf.stringToHclTerraform(struct!.startupPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: domainDevicesDisksSourceTimeoutToHclTerraform(struct!.timeout),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceTimeout",
    },
    vhost_user: {
      value: domainDevicesDisksSourceVhostUserToHclTerraform(struct!.vhostUser),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceVhostUser",
    },
    vhost_vdpa: {
      value: domainDevicesDisksSourceVhostVdpaToHclTerraform(struct!.vhostVdpa),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceVhostVdpa",
    },
    volume: {
      value: domainDevicesDisksSourceVolumeToHclTerraform(struct!.volume),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSourceVolume",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._block?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.block = this._block?.internalValue;
    }
    if (this._cookies?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cookies = this._cookies?.internalValue;
    }
    if (this._dataStore?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dataStore = this._dataStore?.internalValue;
    }
    if (this._dir?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dir = this._dir?.internalValue;
    }
    if (this._encryption?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.encryption = this._encryption?.internalValue;
    }
    if (this._file?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file?.internalValue;
    }
    if (this._index !== undefined) {
      hasAnyValues = true;
      internalValueResult.index = this._index;
    }
    if (this._network?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.network = this._network?.internalValue;
    }
    if (this._nvme?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nvme = this._nvme?.internalValue;
    }
    if (this._readahead?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.readahead = this._readahead?.internalValue;
    }
    if (this._reservations?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.reservations = this._reservations?.internalValue;
    }
    if (this._slices?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.slices = this._slices?.internalValue;
    }
    if (this._ssl?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ssl = this._ssl?.internalValue;
    }
    if (this._startupPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.startupPolicy = this._startupPolicy;
    }
    if (this._timeout?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout?.internalValue;
    }
    if (this._vhostUser?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.vhostUser = this._vhostUser?.internalValue;
    }
    if (this._vhostVdpa?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.vhostVdpa = this._vhostVdpa?.internalValue;
    }
    if (this._volume?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.volume = this._volume?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._block.internalValue = undefined;
      this._cookies.internalValue = undefined;
      this._dataStore.internalValue = undefined;
      this._dir.internalValue = undefined;
      this._encryption.internalValue = undefined;
      this._file.internalValue = undefined;
      this._index = undefined;
      this._network.internalValue = undefined;
      this._nvme.internalValue = undefined;
      this._readahead.internalValue = undefined;
      this._reservations.internalValue = undefined;
      this._slices.internalValue = undefined;
      this._ssl.internalValue = undefined;
      this._startupPolicy = undefined;
      this._timeout.internalValue = undefined;
      this._vhostUser.internalValue = undefined;
      this._vhostVdpa.internalValue = undefined;
      this._volume.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._block.internalValue = value.block;
      this._cookies.internalValue = value.cookies;
      this._dataStore.internalValue = value.dataStore;
      this._dir.internalValue = value.dir;
      this._encryption.internalValue = value.encryption;
      this._file.internalValue = value.file;
      this._index = value.index;
      this._network.internalValue = value.network;
      this._nvme.internalValue = value.nvme;
      this._readahead.internalValue = value.readahead;
      this._reservations.internalValue = value.reservations;
      this._slices.internalValue = value.slices;
      this._ssl.internalValue = value.ssl;
      this._startupPolicy = value.startupPolicy;
      this._timeout.internalValue = value.timeout;
      this._vhostUser.internalValue = value.vhostUser;
      this._vhostVdpa.internalValue = value.vhostVdpa;
      this._volume.internalValue = value.volume;
    }
  }

  // block - computed: false, optional: true, required: false
  private _block = new DomainDevicesDisksSourceBlockOutputReference(this, "block");
  public get block() {
    return this._block;
  }
  public putBlock(value: DomainDevicesDisksSourceBlock) {
    this._block.internalValue = value;
  }
  public resetBlock() {
    this._block.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get blockInput() {
    return this._block.internalValue;
  }

  // cookies - computed: false, optional: true, required: false
  private _cookies = new DomainDevicesDisksSourceCookiesOutputReference(this, "cookies");
  public get cookies() {
    return this._cookies;
  }
  public putCookies(value: DomainDevicesDisksSourceCookies) {
    this._cookies.internalValue = value;
  }
  public resetCookies() {
    this._cookies.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cookiesInput() {
    return this._cookies.internalValue;
  }

  // data_store - computed: false, optional: true, required: false
  private _dataStore = new DomainDevicesDisksSourceDataStoreOutputReference(this, "data_store");
  public get dataStore() {
    return this._dataStore;
  }
  public putDataStore(value: DomainDevicesDisksSourceDataStore) {
    this._dataStore.internalValue = value;
  }
  public resetDataStore() {
    this._dataStore.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dataStoreInput() {
    return this._dataStore.internalValue;
  }

  // dir - computed: false, optional: true, required: false
  private _dir = new DomainDevicesDisksSourceDirOutputReference(this, "dir");
  public get dir() {
    return this._dir;
  }
  public putDir(value: DomainDevicesDisksSourceDir) {
    this._dir.internalValue = value;
  }
  public resetDir() {
    this._dir.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dirInput() {
    return this._dir.internalValue;
  }

  // encryption - computed: false, optional: true, required: false
  private _encryption = new DomainDevicesDisksSourceEncryptionOutputReference(this, "encryption");
  public get encryption() {
    return this._encryption;
  }
  public putEncryption(value: DomainDevicesDisksSourceEncryption) {
    this._encryption.internalValue = value;
  }
  public resetEncryption() {
    this._encryption.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get encryptionInput() {
    return this._encryption.internalValue;
  }

  // file - computed: false, optional: true, required: false
  private _file = new DomainDevicesDisksSourceFileOutputReference(this, "file");
  public get file() {
    return this._file;
  }
  public putFile(value: DomainDevicesDisksSourceFile) {
    this._file.internalValue = value;
  }
  public resetFile() {
    this._file.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file.internalValue;
  }

  // index - computed: false, optional: true, required: false
  private _index?: number; 
  public get index() {
    return this.getNumberAttribute('index');
  }
  public set index(value: number) {
    this._index = value;
  }
  public resetIndex() {
    this._index = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get indexInput() {
    return this._index;
  }

  // network - computed: false, optional: true, required: false
  private _network = new DomainDevicesDisksSourceNetworkOutputReference(this, "network");
  public get network() {
    return this._network;
  }
  public putNetwork(value: DomainDevicesDisksSourceNetwork) {
    this._network.internalValue = value;
  }
  public resetNetwork() {
    this._network.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkInput() {
    return this._network.internalValue;
  }

  // nvme - computed: false, optional: true, required: false
  private _nvme = new DomainDevicesDisksSourceNvmeOutputReference(this, "nvme");
  public get nvme() {
    return this._nvme;
  }
  public putNvme(value: DomainDevicesDisksSourceNvme) {
    this._nvme.internalValue = value;
  }
  public resetNvme() {
    this._nvme.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nvmeInput() {
    return this._nvme.internalValue;
  }

  // readahead - computed: false, optional: true, required: false
  private _readahead = new DomainDevicesDisksSourceReadaheadOutputReference(this, "readahead");
  public get readahead() {
    return this._readahead;
  }
  public putReadahead(value: DomainDevicesDisksSourceReadahead) {
    this._readahead.internalValue = value;
  }
  public resetReadahead() {
    this._readahead.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readaheadInput() {
    return this._readahead.internalValue;
  }

  // reservations - computed: false, optional: true, required: false
  private _reservations = new DomainDevicesDisksSourceReservationsOutputReference(this, "reservations");
  public get reservations() {
    return this._reservations;
  }
  public putReservations(value: DomainDevicesDisksSourceReservations) {
    this._reservations.internalValue = value;
  }
  public resetReservations() {
    this._reservations.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reservationsInput() {
    return this._reservations.internalValue;
  }

  // slices - computed: false, optional: true, required: false
  private _slices = new DomainDevicesDisksSourceSlicesOutputReference(this, "slices");
  public get slices() {
    return this._slices;
  }
  public putSlices(value: DomainDevicesDisksSourceSlices) {
    this._slices.internalValue = value;
  }
  public resetSlices() {
    this._slices.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get slicesInput() {
    return this._slices.internalValue;
  }

  // ssl - computed: false, optional: true, required: false
  private _ssl = new DomainDevicesDisksSourceSslOutputReference(this, "ssl");
  public get ssl() {
    return this._ssl;
  }
  public putSsl(value: DomainDevicesDisksSourceSsl) {
    this._ssl.internalValue = value;
  }
  public resetSsl() {
    this._ssl.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sslInput() {
    return this._ssl.internalValue;
  }

  // startup_policy - computed: false, optional: true, required: false
  private _startupPolicy?: string; 
  public get startupPolicy() {
    return this.getStringAttribute('startup_policy');
  }
  public set startupPolicy(value: string) {
    this._startupPolicy = value;
  }
  public resetStartupPolicy() {
    this._startupPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get startupPolicyInput() {
    return this._startupPolicy;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout = new DomainDevicesDisksSourceTimeoutOutputReference(this, "timeout");
  public get timeout() {
    return this._timeout;
  }
  public putTimeout(value: DomainDevicesDisksSourceTimeout) {
    this._timeout.internalValue = value;
  }
  public resetTimeout() {
    this._timeout.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout.internalValue;
  }

  // vhost_user - computed: false, optional: true, required: false
  private _vhostUser = new DomainDevicesDisksSourceVhostUserOutputReference(this, "vhost_user");
  public get vhostUser() {
    return this._vhostUser;
  }
  public putVhostUser(value: DomainDevicesDisksSourceVhostUser) {
    this._vhostUser.internalValue = value;
  }
  public resetVhostUser() {
    this._vhostUser.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vhostUserInput() {
    return this._vhostUser.internalValue;
  }

  // vhost_vdpa - computed: false, optional: true, required: false
  private _vhostVdpa = new DomainDevicesDisksSourceVhostVdpaOutputReference(this, "vhost_vdpa");
  public get vhostVdpa() {
    return this._vhostVdpa;
  }
  public putVhostVdpa(value: DomainDevicesDisksSourceVhostVdpa) {
    this._vhostVdpa.internalValue = value;
  }
  public resetVhostVdpa() {
    this._vhostVdpa.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vhostVdpaInput() {
    return this._vhostVdpa.internalValue;
  }

  // volume - computed: false, optional: true, required: false
  private _volume = new DomainDevicesDisksSourceVolumeOutputReference(this, "volume");
  public get volume() {
    return this._volume;
  }
  public putVolume(value: DomainDevicesDisksSourceVolume) {
    this._volume.internalValue = value;
  }
  public resetVolume() {
    this._volume.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get volumeInput() {
    return this._volume.internalValue;
  }
}
export interface DomainDevicesDisksTarget {
  /**
  * Sets the guest bus type this disk is attached to, such as "ide", "sata", "scsi", "virtio", "usb", or "xen".
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bus Domain#bus}
  */
  readonly bus?: string;
  /**
  * Sets the guest device name exposed by this disk on the chosen bus (for example "vda", "sda", or "hda").
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dev Domain#dev}
  */
  readonly dev?: string;
  /**
  * Sets whether the guest can treat this disk as removable media; accepts "on" or "off" when supported by the bus/model.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#removable Domain#removable}
  */
  readonly removable?: string;
  /**
  * Sets the simulated disk rotation rate in revolutions per minute (RPM), typically "1" for SSDs or a realistic integer like "7200" for HDDs.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#rotation_rate Domain#rotation_rate}
  */
  readonly rotationRate?: number;
  /**
  * Sets the current tray state for tray-capable devices (e.g. CD-ROM), accepting "open" or "closed".
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tray Domain#tray}
  */
  readonly tray?: string;
}

export function domainDevicesDisksTargetToTerraform(struct?: DomainDevicesDisksTarget | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bus: cdktf.stringToTerraform(struct!.bus),
    dev: cdktf.stringToTerraform(struct!.dev),
    removable: cdktf.stringToTerraform(struct!.removable),
    rotation_rate: cdktf.numberToTerraform(struct!.rotationRate),
    tray: cdktf.stringToTerraform(struct!.tray),
  }
}


export function domainDevicesDisksTargetToHclTerraform(struct?: DomainDevicesDisksTarget | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bus: {
      value: cdktf.stringToHclTerraform(struct!.bus),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dev: {
      value: cdktf.stringToHclTerraform(struct!.dev),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    removable: {
      value: cdktf.stringToHclTerraform(struct!.removable),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    rotation_rate: {
      value: cdktf.numberToHclTerraform(struct!.rotationRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    tray: {
      value: cdktf.stringToHclTerraform(struct!.tray),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksTargetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksTarget | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bus !== undefined) {
      hasAnyValues = true;
      internalValueResult.bus = this._bus;
    }
    if (this._dev !== undefined) {
      hasAnyValues = true;
      internalValueResult.dev = this._dev;
    }
    if (this._removable !== undefined) {
      hasAnyValues = true;
      internalValueResult.removable = this._removable;
    }
    if (this._rotationRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.rotationRate = this._rotationRate;
    }
    if (this._tray !== undefined) {
      hasAnyValues = true;
      internalValueResult.tray = this._tray;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksTarget | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bus = undefined;
      this._dev = undefined;
      this._removable = undefined;
      this._rotationRate = undefined;
      this._tray = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bus = value.bus;
      this._dev = value.dev;
      this._removable = value.removable;
      this._rotationRate = value.rotationRate;
      this._tray = value.tray;
    }
  }

  // bus - computed: false, optional: true, required: false
  private _bus?: string; 
  public get bus() {
    return this.getStringAttribute('bus');
  }
  public set bus(value: string) {
    this._bus = value;
  }
  public resetBus() {
    this._bus = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get busInput() {
    return this._bus;
  }

  // dev - computed: false, optional: true, required: false
  private _dev?: string; 
  public get dev() {
    return this.getStringAttribute('dev');
  }
  public set dev(value: string) {
    this._dev = value;
  }
  public resetDev() {
    this._dev = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devInput() {
    return this._dev;
  }

  // removable - computed: false, optional: true, required: false
  private _removable?: string; 
  public get removable() {
    return this.getStringAttribute('removable');
  }
  public set removable(value: string) {
    this._removable = value;
  }
  public resetRemovable() {
    this._removable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removableInput() {
    return this._removable;
  }

  // rotation_rate - computed: false, optional: true, required: false
  private _rotationRate?: number; 
  public get rotationRate() {
    return this.getNumberAttribute('rotation_rate');
  }
  public set rotationRate(value: number) {
    this._rotationRate = value;
  }
  public resetRotationRate() {
    this._rotationRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rotationRateInput() {
    return this._rotationRate;
  }

  // tray - computed: false, optional: true, required: false
  private _tray?: string; 
  public get tray() {
    return this.getStringAttribute('tray');
  }
  public set tray(value: string) {
    this._tray = value;
  }
  public resetTray() {
    this._tray = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get trayInput() {
    return this._tray;
  }
}
export interface DomainDevicesDisksThrottleFiltersThrottleFilter {
  /**
  * Sets the name of the throttle group that this disk’s throttle filter should attach to; must match an existing group defined under domain throttlegroups.
  * 
  * See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#group Domain#group}
  */
  readonly group: string;
}

export function domainDevicesDisksThrottleFiltersThrottleFilterToTerraform(struct?: DomainDevicesDisksThrottleFiltersThrottleFilter | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    group: cdktf.stringToTerraform(struct!.group),
  }
}


export function domainDevicesDisksThrottleFiltersThrottleFilterToHclTerraform(struct?: DomainDevicesDisksThrottleFiltersThrottleFilter | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    group: {
      value: cdktf.stringToHclTerraform(struct!.group),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksThrottleFiltersThrottleFilterOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisksThrottleFiltersThrottleFilter | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._group !== undefined) {
      hasAnyValues = true;
      internalValueResult.group = this._group;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksThrottleFiltersThrottleFilter | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._group = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._group = value.group;
    }
  }

  // group - computed: false, optional: false, required: true
  private _group?: string; 
  public get group() {
    return this.getStringAttribute('group');
  }
  public set group(value: string) {
    this._group = value;
  }
  // Temporarily expose input value. Use with caution.
  public get groupInput() {
    return this._group;
  }
}

export class DomainDevicesDisksThrottleFiltersThrottleFilterList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisksThrottleFiltersThrottleFilter[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksThrottleFiltersThrottleFilterOutputReference {
    return new DomainDevicesDisksThrottleFiltersThrottleFilterOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesDisksThrottleFilters {
  /**
  * Declares a single throttle filter element referencing a named throttle group to control this disk’s I/O limits.
  * 
  * See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#throttle_filter Domain#throttle_filter}
  */
  readonly throttleFilter?: DomainDevicesDisksThrottleFiltersThrottleFilter[] | cdktf.IResolvable;
}

export function domainDevicesDisksThrottleFiltersToTerraform(struct?: DomainDevicesDisksThrottleFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    throttle_filter: cdktf.listMapper(domainDevicesDisksThrottleFiltersThrottleFilterToTerraform, false)(struct!.throttleFilter),
  }
}


export function domainDevicesDisksThrottleFiltersToHclTerraform(struct?: DomainDevicesDisksThrottleFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    throttle_filter: {
      value: cdktf.listMapperHcl(domainDevicesDisksThrottleFiltersThrottleFilterToHclTerraform, false)(struct!.throttleFilter),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksThrottleFiltersThrottleFilterList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksThrottleFiltersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksThrottleFilters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._throttleFilter?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.throttleFilter = this._throttleFilter?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksThrottleFilters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._throttleFilter.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._throttleFilter.internalValue = value.throttleFilter;
    }
  }

  // throttle_filter - computed: false, optional: true, required: false
  private _throttleFilter = new DomainDevicesDisksThrottleFiltersThrottleFilterList(this, "throttle_filter", false);
  public get throttleFilter() {
    return this._throttleFilter;
  }
  public putThrottleFilter(value: DomainDevicesDisksThrottleFiltersThrottleFilter[] | cdktf.IResolvable) {
    this._throttleFilter.internalValue = value;
  }
  public resetThrottleFilter() {
    this._throttleFilter.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get throttleFilterInput() {
    return this._throttleFilter.internalValue;
  }
}
export interface DomainDevicesDisksTransient {
  /**
  * Sets whether a transient disk is allowed to share its backing image with other guests; accepts "yes" or "no".
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#share_backing Domain#share_backing}
  */
  readonly shareBacking?: string;
}

export function domainDevicesDisksTransientToTerraform(struct?: DomainDevicesDisksTransient | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    share_backing: cdktf.stringToTerraform(struct!.shareBacking),
  }
}


export function domainDevicesDisksTransientToHclTerraform(struct?: DomainDevicesDisksTransient | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    share_backing: {
      value: cdktf.stringToHclTerraform(struct!.shareBacking),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksTransientOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesDisksTransient | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._shareBacking !== undefined) {
      hasAnyValues = true;
      internalValueResult.shareBacking = this._shareBacking;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisksTransient | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._shareBacking = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._shareBacking = value.shareBacking;
    }
  }

  // share_backing - computed: false, optional: true, required: false
  private _shareBacking?: string; 
  public get shareBacking() {
    return this.getStringAttribute('share_backing');
  }
  public set shareBacking(value: string) {
    this._shareBacking = value;
  }
  public resetShareBacking() {
    this._shareBacking = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shareBackingInput() {
    return this._shareBacking;
  }
}
export interface DomainDevicesDisks {
  /**
  * Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#acpi Domain#acpi}
  */
  readonly acpi?: DomainDevicesDisksAcpi;
  /**
  * Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: DomainDevicesDisksAddress;
  /**
  * Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#alias Domain#alias}
  */
  readonly alias?: DomainDevicesDisksAlias;
  /**
  * Configures CHAP authentication parameters for the iSCSI source backing an assigned SCSI host device; include this block only when the target requires authentication.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#auth Domain#auth}
  */
  readonly auth?: DomainDevicesDisksAuth;
  /**
  * Attaches the interface’s network backend to a separate driver/backend domain instead of the main host, enabling driver-domain networking setups.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#backend_domain Domain#backend_domain}
  */
  readonly backendDomain?: DomainDevicesDisksBackendDomain;
  /**
  * Defines the backing store chain for the mirrored disk image, describing one layer of the underlying image stack used by the mirror target.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#backing_store Domain#backing_store}
  */
  readonly backingStore?: DomainDevicesDisksBackingStore;
  /**
  * Configures per-disk block I/O characteristics such as logical/physical sector sizes and discard granularity as presented to the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#block_io Domain#block_io}
  */
  readonly blockIo?: DomainDevicesDisksBlockIo;
  /**
  * Enables boot-order control for this redirected device, allowing it to participate in the device boot sequence.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#boot Domain#boot}
  */
  readonly boot?: DomainDevicesDisksBoot;
  /**
  * Selects the high-level device type for this disk, typically "disk", "cdrom", "floppy", or "lun"; the value is user-provided and must be a valid libvirt disk device type.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#device Domain#device}
  */
  readonly device?: string;
  /**
  * Configures driver-specific options for this disk, such as the hypervisor driver name, cache mode, discard behavior, or I/O bus features.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#driver Domain#driver}
  */
  readonly driver?: DomainDevicesDisksDriver;
  /**
  * Enables disk image encryption configuration for this disk and groups attributes defining the encryption engine, format, and secrets.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#encryption Domain#encryption}
  */
  readonly encryption?: DomainDevicesDisksEncryption;
  /**
  * Configures the legacy CHS (cylinders/heads/sectors) geometry that the guest sees for this disk, typically for compatibility with older guests or tools.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#geometry Domain#geometry}
  */
  readonly geometry?: DomainDevicesDisksGeometry;
  /**
  * Configures per-disk block I/O throttling parameters (bandwidth and IOPS limits, and optional burst limits) for this disk device; omit this block to leave disk I/O unthrottled.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#io_tune Domain#io_tune}
  */
  readonly ioTune?: DomainDevicesDisksIoTune;
  /**
  * Configures an online block device mirror for the disk, defining the target image and its properties used during block copy or active commit operations.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mirror Domain#mirror}
  */
  readonly mirror?: DomainDevicesDisksMirror;
  /**
  * Specifies the emulated disk device model (e.g. "virtio", "scsi", "ide") or a driver-specific model string passed to the hypervisor.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Sets an optional user-provided product identifier string for the disk device, exposed to the guest similar to a SCSI product field.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#product Domain#product}
  */
  readonly product?: string;
  /**
  * Enables or disables raw I/O access for the disk device when supported by the driver; typically a "yes"/"no" style flag, value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#raw_io Domain#raw_io}
  */
  readonly rawIo?: string;
  /**
  * Controls whether the disk is exposed as read-only to the guest; when set to true the <readonly> element is emitted, and when false or unset the disk is writable.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#read_only Domain#read_only}
  */
  readonly readOnly?: boolean | cdktf.IResolvable;
  /**
  * Sets the user-provided serial number reported to the guest for this disk device (for example, to match a physical disk's serial).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#serial Domain#serial}
  */
  readonly serial?: string;
  /**
  * Sets the SCSI generic I/O behavior for the disk using a user-provided value accepted by libvirt (e.g. modes controlling filtered vs unfiltered SG_IO).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sgio Domain#sgio}
  */
  readonly sgio?: string;
  /**
  * Controls whether the disk is marked as shareable between multiple guests; when set to true the <shareable> element is emitted, otherwise it is omitted.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#shareable Domain#shareable}
  */
  readonly shareable?: boolean | cdktf.IResolvable;
  /**
  * Sets the disk snapshot behavior policy with a user-provided string value supported by libvirt (for example, controlling how the disk participates in domain snapshots).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#snapshot Domain#snapshot}
  */
  readonly snapshot?: string;
  /**
  * Defines the data source for the mirror backing store, such as a block device or file path.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#source Domain#source}
  */
  readonly source?: DomainDevicesDisksSource;
  /**
  * Configures the guest-visible block device target for this disk, including bus type, device name, and related attributes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#target Domain#target}
  */
  readonly target?: DomainDevicesDisksTarget;
  /**
  * Groups one or more disk throttle filter references used to apply shared throttling policies via throttle groups.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#throttle_filters Domain#throttle_filters}
  */
  readonly throttleFilters?: DomainDevicesDisksThrottleFilters;
  /**
  * Marks this disk as transient, meaning it is not persisted in domain configuration and exists only for the lifetime of the running guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#transient Domain#transient}
  */
  readonly transient?: DomainDevicesDisksTransient;
  /**
  * Sets the vendor identification string reported by this disk to the guest; value is user-provided (commonly up to 8 ASCII characters).
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vendor Domain#vendor}
  */
  readonly vendor?: string;
  /**
  * Sets the world wide name (WWN) reported for this disk, typically as a 16-hex-digit string (for example "500123456789abcd").
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#wwn Domain#wwn}
  */
  readonly wwn?: string;
}

export function domainDevicesDisksToTerraform(struct?: DomainDevicesDisks | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    acpi: domainDevicesDisksAcpiToTerraform(struct!.acpi),
    address: domainDevicesDisksAddressToTerraform(struct!.address),
    alias: domainDevicesDisksAliasToTerraform(struct!.alias),
    auth: domainDevicesDisksAuthToTerraform(struct!.auth),
    backend_domain: domainDevicesDisksBackendDomainToTerraform(struct!.backendDomain),
    backing_store: domainDevicesDisksBackingStoreToTerraform(struct!.backingStore),
    block_io: domainDevicesDisksBlockIoToTerraform(struct!.blockIo),
    boot: domainDevicesDisksBootToTerraform(struct!.boot),
    device: cdktf.stringToTerraform(struct!.device),
    driver: domainDevicesDisksDriverToTerraform(struct!.driver),
    encryption: domainDevicesDisksEncryptionToTerraform(struct!.encryption),
    geometry: domainDevicesDisksGeometryToTerraform(struct!.geometry),
    io_tune: domainDevicesDisksIoTuneToTerraform(struct!.ioTune),
    mirror: domainDevicesDisksMirrorToTerraform(struct!.mirror),
    model: cdktf.stringToTerraform(struct!.model),
    product: cdktf.stringToTerraform(struct!.product),
    raw_io: cdktf.stringToTerraform(struct!.rawIo),
    read_only: cdktf.booleanToTerraform(struct!.readOnly),
    serial: cdktf.stringToTerraform(struct!.serial),
    sgio: cdktf.stringToTerraform(struct!.sgio),
    shareable: cdktf.booleanToTerraform(struct!.shareable),
    snapshot: cdktf.stringToTerraform(struct!.snapshot),
    source: domainDevicesDisksSourceToTerraform(struct!.source),
    target: domainDevicesDisksTargetToTerraform(struct!.target),
    throttle_filters: domainDevicesDisksThrottleFiltersToTerraform(struct!.throttleFilters),
    transient: domainDevicesDisksTransientToTerraform(struct!.transient),
    vendor: cdktf.stringToTerraform(struct!.vendor),
    wwn: cdktf.stringToTerraform(struct!.wwn),
  }
}


export function domainDevicesDisksToHclTerraform(struct?: DomainDevicesDisks | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    acpi: {
      value: domainDevicesDisksAcpiToHclTerraform(struct!.acpi),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksAcpi",
    },
    address: {
      value: domainDevicesDisksAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksAddress",
    },
    alias: {
      value: domainDevicesDisksAliasToHclTerraform(struct!.alias),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksAlias",
    },
    auth: {
      value: domainDevicesDisksAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksAuth",
    },
    backend_domain: {
      value: domainDevicesDisksBackendDomainToHclTerraform(struct!.backendDomain),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackendDomain",
    },
    backing_store: {
      value: domainDevicesDisksBackingStoreToHclTerraform(struct!.backingStore),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBackingStore",
    },
    block_io: {
      value: domainDevicesDisksBlockIoToHclTerraform(struct!.blockIo),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBlockIo",
    },
    boot: {
      value: domainDevicesDisksBootToHclTerraform(struct!.boot),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksBoot",
    },
    device: {
      value: cdktf.stringToHclTerraform(struct!.device),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    driver: {
      value: domainDevicesDisksDriverToHclTerraform(struct!.driver),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksDriver",
    },
    encryption: {
      value: domainDevicesDisksEncryptionToHclTerraform(struct!.encryption),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksEncryption",
    },
    geometry: {
      value: domainDevicesDisksGeometryToHclTerraform(struct!.geometry),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksGeometry",
    },
    io_tune: {
      value: domainDevicesDisksIoTuneToHclTerraform(struct!.ioTune),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksIoTune",
    },
    mirror: {
      value: domainDevicesDisksMirrorToHclTerraform(struct!.mirror),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksMirror",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    product: {
      value: cdktf.stringToHclTerraform(struct!.product),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    raw_io: {
      value: cdktf.stringToHclTerraform(struct!.rawIo),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    read_only: {
      value: cdktf.booleanToHclTerraform(struct!.readOnly),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    serial: {
      value: cdktf.stringToHclTerraform(struct!.serial),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sgio: {
      value: cdktf.stringToHclTerraform(struct!.sgio),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    shareable: {
      value: cdktf.booleanToHclTerraform(struct!.shareable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    snapshot: {
      value: cdktf.stringToHclTerraform(struct!.snapshot),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    source: {
      value: domainDevicesDisksSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksSource",
    },
    target: {
      value: domainDevicesDisksTargetToHclTerraform(struct!.target),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksTarget",
    },
    throttle_filters: {
      value: domainDevicesDisksThrottleFiltersToHclTerraform(struct!.throttleFilters),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksThrottleFilters",
    },
    transient: {
      value: domainDevicesDisksTransientToHclTerraform(struct!.transient),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesDisksTransient",
    },
    vendor: {
      value: cdktf.stringToHclTerraform(struct!.vendor),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    wwn: {
      value: cdktf.stringToHclTerraform(struct!.wwn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesDisksOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesDisks | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._acpi?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.acpi = this._acpi?.internalValue;
    }
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._alias?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.alias = this._alias?.internalValue;
    }
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._backendDomain?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.backendDomain = this._backendDomain?.internalValue;
    }
    if (this._backingStore?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.backingStore = this._backingStore?.internalValue;
    }
    if (this._blockIo?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.blockIo = this._blockIo?.internalValue;
    }
    if (this._boot?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.boot = this._boot?.internalValue;
    }
    if (this._device !== undefined) {
      hasAnyValues = true;
      internalValueResult.device = this._device;
    }
    if (this._driver?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.driver = this._driver?.internalValue;
    }
    if (this._encryption?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.encryption = this._encryption?.internalValue;
    }
    if (this._geometry?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.geometry = this._geometry?.internalValue;
    }
    if (this._ioTune?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ioTune = this._ioTune?.internalValue;
    }
    if (this._mirror?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.mirror = this._mirror?.internalValue;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._product !== undefined) {
      hasAnyValues = true;
      internalValueResult.product = this._product;
    }
    if (this._rawIo !== undefined) {
      hasAnyValues = true;
      internalValueResult.rawIo = this._rawIo;
    }
    if (this._readOnly !== undefined) {
      hasAnyValues = true;
      internalValueResult.readOnly = this._readOnly;
    }
    if (this._serial !== undefined) {
      hasAnyValues = true;
      internalValueResult.serial = this._serial;
    }
    if (this._sgio !== undefined) {
      hasAnyValues = true;
      internalValueResult.sgio = this._sgio;
    }
    if (this._shareable !== undefined) {
      hasAnyValues = true;
      internalValueResult.shareable = this._shareable;
    }
    if (this._snapshot !== undefined) {
      hasAnyValues = true;
      internalValueResult.snapshot = this._snapshot;
    }
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    if (this._target?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.target = this._target?.internalValue;
    }
    if (this._throttleFilters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.throttleFilters = this._throttleFilters?.internalValue;
    }
    if (this._transient?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.transient = this._transient?.internalValue;
    }
    if (this._vendor !== undefined) {
      hasAnyValues = true;
      internalValueResult.vendor = this._vendor;
    }
    if (this._wwn !== undefined) {
      hasAnyValues = true;
      internalValueResult.wwn = this._wwn;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesDisks | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._acpi.internalValue = undefined;
      this._address.internalValue = undefined;
      this._alias.internalValue = undefined;
      this._auth.internalValue = undefined;
      this._backendDomain.internalValue = undefined;
      this._backingStore.internalValue = undefined;
      this._blockIo.internalValue = undefined;
      this._boot.internalValue = undefined;
      this._device = undefined;
      this._driver.internalValue = undefined;
      this._encryption.internalValue = undefined;
      this._geometry.internalValue = undefined;
      this._ioTune.internalValue = undefined;
      this._mirror.internalValue = undefined;
      this._model = undefined;
      this._product = undefined;
      this._rawIo = undefined;
      this._readOnly = undefined;
      this._serial = undefined;
      this._sgio = undefined;
      this._shareable = undefined;
      this._snapshot = undefined;
      this._source.internalValue = undefined;
      this._target.internalValue = undefined;
      this._throttleFilters.internalValue = undefined;
      this._transient.internalValue = undefined;
      this._vendor = undefined;
      this._wwn = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._acpi.internalValue = value.acpi;
      this._address.internalValue = value.address;
      this._alias.internalValue = value.alias;
      this._auth.internalValue = value.auth;
      this._backendDomain.internalValue = value.backendDomain;
      this._backingStore.internalValue = value.backingStore;
      this._blockIo.internalValue = value.blockIo;
      this._boot.internalValue = value.boot;
      this._device = value.device;
      this._driver.internalValue = value.driver;
      this._encryption.internalValue = value.encryption;
      this._geometry.internalValue = value.geometry;
      this._ioTune.internalValue = value.ioTune;
      this._mirror.internalValue = value.mirror;
      this._model = value.model;
      this._product = value.product;
      this._rawIo = value.rawIo;
      this._readOnly = value.readOnly;
      this._serial = value.serial;
      this._sgio = value.sgio;
      this._shareable = value.shareable;
      this._snapshot = value.snapshot;
      this._source.internalValue = value.source;
      this._target.internalValue = value.target;
      this._throttleFilters.internalValue = value.throttleFilters;
      this._transient.internalValue = value.transient;
      this._vendor = value.vendor;
      this._wwn = value.wwn;
    }
  }

  // acpi - computed: false, optional: true, required: false
  private _acpi = new DomainDevicesDisksAcpiOutputReference(this, "acpi");
  public get acpi() {
    return this._acpi;
  }
  public putAcpi(value: DomainDevicesDisksAcpi) {
    this._acpi.internalValue = value;
  }
  public resetAcpi() {
    this._acpi.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get acpiInput() {
    return this._acpi.internalValue;
  }

  // address - computed: false, optional: true, required: false
  private _address = new DomainDevicesDisksAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DomainDevicesDisksAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // alias - computed: false, optional: true, required: false
  private _alias = new DomainDevicesDisksAliasOutputReference(this, "alias");
  public get alias() {
    return this._alias;
  }
  public putAlias(value: DomainDevicesDisksAlias) {
    this._alias.internalValue = value;
  }
  public resetAlias() {
    this._alias.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aliasInput() {
    return this._alias.internalValue;
  }

  // auth - computed: false, optional: true, required: false
  private _auth = new DomainDevicesDisksAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DomainDevicesDisksAuth) {
    this._auth.internalValue = value;
  }
  public resetAuth() {
    this._auth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // backend_domain - computed: false, optional: true, required: false
  private _backendDomain = new DomainDevicesDisksBackendDomainOutputReference(this, "backend_domain");
  public get backendDomain() {
    return this._backendDomain;
  }
  public putBackendDomain(value: DomainDevicesDisksBackendDomain) {
    this._backendDomain.internalValue = value;
  }
  public resetBackendDomain() {
    this._backendDomain.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backendDomainInput() {
    return this._backendDomain.internalValue;
  }

  // backing_store - computed: false, optional: true, required: false
  private _backingStore = new DomainDevicesDisksBackingStoreOutputReference(this, "backing_store");
  public get backingStore() {
    return this._backingStore;
  }
  public putBackingStore(value: DomainDevicesDisksBackingStore) {
    this._backingStore.internalValue = value;
  }
  public resetBackingStore() {
    this._backingStore.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backingStoreInput() {
    return this._backingStore.internalValue;
  }

  // block_io - computed: false, optional: true, required: false
  private _blockIo = new DomainDevicesDisksBlockIoOutputReference(this, "block_io");
  public get blockIo() {
    return this._blockIo;
  }
  public putBlockIo(value: DomainDevicesDisksBlockIo) {
    this._blockIo.internalValue = value;
  }
  public resetBlockIo() {
    this._blockIo.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get blockIoInput() {
    return this._blockIo.internalValue;
  }

  // boot - computed: false, optional: true, required: false
  private _boot = new DomainDevicesDisksBootOutputReference(this, "boot");
  public get boot() {
    return this._boot;
  }
  public putBoot(value: DomainDevicesDisksBoot) {
    this._boot.internalValue = value;
  }
  public resetBoot() {
    this._boot.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bootInput() {
    return this._boot.internalValue;
  }

  // device - computed: false, optional: true, required: false
  private _device?: string; 
  public get device() {
    return this.getStringAttribute('device');
  }
  public set device(value: string) {
    this._device = value;
  }
  public resetDevice() {
    this._device = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deviceInput() {
    return this._device;
  }

  // driver - computed: false, optional: true, required: false
  private _driver = new DomainDevicesDisksDriverOutputReference(this, "driver");
  public get driver() {
    return this._driver;
  }
  public putDriver(value: DomainDevicesDisksDriver) {
    this._driver.internalValue = value;
  }
  public resetDriver() {
    this._driver.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get driverInput() {
    return this._driver.internalValue;
  }

  // encryption - computed: false, optional: true, required: false
  private _encryption = new DomainDevicesDisksEncryptionOutputReference(this, "encryption");
  public get encryption() {
    return this._encryption;
  }
  public putEncryption(value: DomainDevicesDisksEncryption) {
    this._encryption.internalValue = value;
  }
  public resetEncryption() {
    this._encryption.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get encryptionInput() {
    return this._encryption.internalValue;
  }

  // geometry - computed: false, optional: true, required: false
  private _geometry = new DomainDevicesDisksGeometryOutputReference(this, "geometry");
  public get geometry() {
    return this._geometry;
  }
  public putGeometry(value: DomainDevicesDisksGeometry) {
    this._geometry.internalValue = value;
  }
  public resetGeometry() {
    this._geometry.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get geometryInput() {
    return this._geometry.internalValue;
  }

  // io_tune - computed: false, optional: true, required: false
  private _ioTune = new DomainDevicesDisksIoTuneOutputReference(this, "io_tune");
  public get ioTune() {
    return this._ioTune;
  }
  public putIoTune(value: DomainDevicesDisksIoTune) {
    this._ioTune.internalValue = value;
  }
  public resetIoTune() {
    this._ioTune.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ioTuneInput() {
    return this._ioTune.internalValue;
  }

  // mirror - computed: false, optional: true, required: false
  private _mirror = new DomainDevicesDisksMirrorOutputReference(this, "mirror");
  public get mirror() {
    return this._mirror;
  }
  public putMirror(value: DomainDevicesDisksMirror) {
    this._mirror.internalValue = value;
  }
  public resetMirror() {
    this._mirror.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mirrorInput() {
    return this._mirror.internalValue;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // product - computed: false, optional: true, required: false
  private _product?: string; 
  public get product() {
    return this.getStringAttribute('product');
  }
  public set product(value: string) {
    this._product = value;
  }
  public resetProduct() {
    this._product = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get productInput() {
    return this._product;
  }

  // raw_io - computed: false, optional: true, required: false
  private _rawIo?: string; 
  public get rawIo() {
    return this.getStringAttribute('raw_io');
  }
  public set rawIo(value: string) {
    this._rawIo = value;
  }
  public resetRawIo() {
    this._rawIo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rawIoInput() {
    return this._rawIo;
  }

  // read_only - computed: false, optional: true, required: false
  private _readOnly?: boolean | cdktf.IResolvable; 
  public get readOnly() {
    return this.getBooleanAttribute('read_only');
  }
  public set readOnly(value: boolean | cdktf.IResolvable) {
    this._readOnly = value;
  }
  public resetReadOnly() {
    this._readOnly = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readOnlyInput() {
    return this._readOnly;
  }

  // serial - computed: false, optional: true, required: false
  private _serial?: string; 
  public get serial() {
    return this.getStringAttribute('serial');
  }
  public set serial(value: string) {
    this._serial = value;
  }
  public resetSerial() {
    this._serial = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serialInput() {
    return this._serial;
  }

  // sgio - computed: false, optional: true, required: false
  private _sgio?: string; 
  public get sgio() {
    return this.getStringAttribute('sgio');
  }
  public set sgio(value: string) {
    this._sgio = value;
  }
  public resetSgio() {
    this._sgio = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sgioInput() {
    return this._sgio;
  }

  // shareable - computed: false, optional: true, required: false
  private _shareable?: boolean | cdktf.IResolvable; 
  public get shareable() {
    return this.getBooleanAttribute('shareable');
  }
  public set shareable(value: boolean | cdktf.IResolvable) {
    this._shareable = value;
  }
  public resetShareable() {
    this._shareable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shareableInput() {
    return this._shareable;
  }

  // snapshot - computed: false, optional: true, required: false
  private _snapshot?: string; 
  public get snapshot() {
    return this.getStringAttribute('snapshot');
  }
  public set snapshot(value: string) {
    this._snapshot = value;
  }
  public resetSnapshot() {
    this._snapshot = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get snapshotInput() {
    return this._snapshot;
  }

  // source - computed: false, optional: true, required: false
  private _source = new DomainDevicesDisksSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: DomainDevicesDisksSource) {
    this._source.internalValue = value;
  }
  public resetSource() {
    this._source.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }

  // target - computed: false, optional: true, required: false
  private _target = new DomainDevicesDisksTargetOutputReference(this, "target");
  public get target() {
    return this._target;
  }
  public putTarget(value: DomainDevicesDisksTarget) {
    this._target.internalValue = value;
  }
  public resetTarget() {
    this._target.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetInput() {
    return this._target.internalValue;
  }

  // throttle_filters - computed: false, optional: true, required: false
  private _throttleFilters = new DomainDevicesDisksThrottleFiltersOutputReference(this, "throttle_filters");
  public get throttleFilters() {
    return this._throttleFilters;
  }
  public putThrottleFilters(value: DomainDevicesDisksThrottleFilters) {
    this._throttleFilters.internalValue = value;
  }
  public resetThrottleFilters() {
    this._throttleFilters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get throttleFiltersInput() {
    return this._throttleFilters.internalValue;
  }

  // transient - computed: false, optional: true, required: false
  private _transient = new DomainDevicesDisksTransientOutputReference(this, "transient");
  public get transient() {
    return this._transient;
  }
  public putTransient(value: DomainDevicesDisksTransient) {
    this._transient.internalValue = value;
  }
  public resetTransient() {
    this._transient.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get transientInput() {
    return this._transient.internalValue;
  }

  // vendor - computed: false, optional: true, required: false
  private _vendor?: string; 
  public get vendor() {
    return this.getStringAttribute('vendor');
  }
  public set vendor(value: string) {
    this._vendor = value;
  }
  public resetVendor() {
    this._vendor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vendorInput() {
    return this._vendor;
  }

  // wwn - computed: false, optional: true, required: false
  private _wwn?: string; 
  public get wwn() {
    return this.getStringAttribute('wwn');
  }
  public set wwn(value: string) {
    this._wwn = value;
  }
  public resetWwn() {
    this._wwn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get wwnInput() {
    return this._wwn;
  }
}

export class DomainDevicesDisksList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesDisks[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesDisksOutputReference {
    return new DomainDevicesDisksOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
