import * as cdktf from 'cdktf';
import { DomainDevicesSerialsSourceTcpReconnect,
domainDevicesSerialsSourceTcpReconnectToTerraform,
domainDevicesSerialsSourceTcpReconnectToHclTerraform,
DomainDevicesSerialsSourceTcpReconnectOutputReference,
DomainDevicesSerialsSourceDbus,
domainDevicesSerialsSourceDbusToTerraform,
domainDevicesSerialsSourceDbusToHclTerraform,
DomainDevicesSerialsSourceDbusOutputReference,
DomainDevicesSerialsSourceDev,
domainDevicesSerialsSourceDevToTerraform,
domainDevicesSerialsSourceDevToHclTerraform,
DomainDevicesSerialsSourceDevOutputReference,
DomainDevicesSerialsSourceFile,
domainDevicesSerialsSourceFileToTerraform,
domainDevicesSerialsSourceFileToHclTerraform,
DomainDevicesSerialsSourceFileOutputReference,
DomainDevicesSerialsSourceNmdm,
domainDevicesSerialsSourceNmdmToTerraform,
domainDevicesSerialsSourceNmdmToHclTerraform,
DomainDevicesSerialsSourceNmdmOutputReference,
DomainDevicesSerialsSourcePipe,
domainDevicesSerialsSourcePipeToTerraform,
domainDevicesSerialsSourcePipeToHclTerraform,
DomainDevicesSerialsSourcePipeOutputReference,
DomainDevicesSerialsSourcePty,
domainDevicesSerialsSourcePtyToTerraform,
domainDevicesSerialsSourcePtyToHclTerraform,
DomainDevicesSerialsSourcePtyOutputReference,
DomainDevicesSerialsSourceQemuvdAgent,
domainDevicesSerialsSourceQemuvdAgentToTerraform,
domainDevicesSerialsSourceQemuvdAgentToHclTerraform,
DomainDevicesSerialsSourceQemuvdAgentOutputReference,
DomainDevicesSerialsSourceSpicePort,
domainDevicesSerialsSourceSpicePortToTerraform,
domainDevicesSerialsSourceSpicePortToHclTerraform,
DomainDevicesSerialsSourceSpicePortOutputReference,
DomainDevicesSerialsAcpi,
domainDevicesSerialsAcpiToTerraform,
domainDevicesSerialsAcpiToHclTerraform,
DomainDevicesSerialsAcpiOutputReference,
DomainDevicesSerialsAddress,
domainDevicesSerialsAddressToTerraform,
domainDevicesSerialsAddressToHclTerraform,
DomainDevicesSerialsAddressOutputReference,
DomainDevicesSerialsAlias,
domainDevicesSerialsAliasToTerraform,
domainDevicesSerialsAliasToHclTerraform,
DomainDevicesSerialsAliasOutputReference,
DomainDevicesSerialsLog,
domainDevicesSerialsLogToTerraform,
domainDevicesSerialsLogToHclTerraform,
DomainDevicesSerialsLogOutputReference,
DomainDevicesSerialsProtocol,
domainDevicesSerialsProtocolToTerraform,
domainDevicesSerialsProtocolToHclTerraform,
DomainDevicesSerialsProtocolOutputReference,
DomainDevicesInterfaces,
domainDevicesInterfacesToTerraform,
domainDevicesInterfacesToHclTerraform,
DomainDevicesInterfacesList,
DomainDevicesIommu,
domainDevicesIommuToTerraform,
domainDevicesIommuToHclTerraform,
DomainDevicesIommuOutputReference,
DomainDevicesLeases,
domainDevicesLeasesToTerraform,
domainDevicesLeasesToHclTerraform,
DomainDevicesLeasesList,
DomainDevicesMemBalloon,
domainDevicesMemBalloonToTerraform,
domainDevicesMemBalloonToHclTerraform,
DomainDevicesMemBalloonOutputReference,
DomainDevicesMemorydevs,
domainDevicesMemorydevsToTerraform,
domainDevicesMemorydevsToHclTerraform,
DomainDevicesMemorydevsList,
DomainDevicesNvram,
domainDevicesNvramToTerraform,
domainDevicesNvramToHclTerraform,
DomainDevicesNvramOutputReference,
DomainDevicesPanics,
domainDevicesPanicsToTerraform,
domainDevicesPanicsToHclTerraform,
DomainDevicesPanicsList,
DomainDevicesParallels,
domainDevicesParallelsToTerraform,
domainDevicesParallelsToHclTerraform,
DomainDevicesParallelsList,
DomainDevicesPstore,
domainDevicesPstoreToTerraform,
domainDevicesPstoreToHclTerraform,
DomainDevicesPstoreOutputReference,
DomainDevicesRedirDevs,
domainDevicesRedirDevsToTerraform,
domainDevicesRedirDevsToHclTerraform,
DomainDevicesRedirDevsList,
DomainDevicesRedirFilters,
domainDevicesRedirFiltersToTerraform,
domainDevicesRedirFiltersToHclTerraform,
DomainDevicesRedirFiltersList,
DomainDevicesRngs,
domainDevicesRngsToTerraform,
domainDevicesRngsToHclTerraform,
DomainDevicesRngsList } from './structs1600'
import { DomainDevicesAudios,
domainDevicesAudiosToTerraform,
domainDevicesAudiosToHclTerraform,
DomainDevicesAudiosList,
DomainDevicesChannels,
domainDevicesChannelsToTerraform,
domainDevicesChannelsToHclTerraform,
DomainDevicesChannelsList,
DomainDevicesConsoles,
domainDevicesConsolesToTerraform,
domainDevicesConsolesToHclTerraform,
DomainDevicesConsolesList,
DomainDevicesControllers,
domainDevicesControllersToTerraform,
domainDevicesControllersToHclTerraform,
DomainDevicesControllersList,
DomainDevicesCrypto,
domainDevicesCryptoToTerraform,
domainDevicesCryptoToHclTerraform,
DomainDevicesCryptoList } from './structs0'
import { DomainDevicesDisks,
domainDevicesDisksToTerraform,
domainDevicesDisksToHclTerraform,
DomainDevicesDisksList } from './structs800'
import { DomainDevicesFilesystems,
domainDevicesFilesystemsToTerraform,
domainDevicesFilesystemsToHclTerraform,
DomainDevicesFilesystemsList,
DomainDevicesGraphics,
domainDevicesGraphicsToTerraform,
domainDevicesGraphicsToHclTerraform,
DomainDevicesGraphicsList,
DomainDevicesHostdevs,
domainDevicesHostdevsToTerraform,
domainDevicesHostdevsToHclTerraform,
DomainDevicesHostdevsList,
DomainDevicesHubs,
domainDevicesHubsToTerraform,
domainDevicesHubsToHclTerraform,
DomainDevicesHubsList,
DomainDevicesInputs,
domainDevicesInputsToTerraform,
domainDevicesInputsToHclTerraform,
DomainDevicesInputsList } from './structs1200'
export interface DomainDevicesSerialsSourceTcp {
  /**
  * Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#host Domain#host}
  */
  readonly host?: string;
  /**
  * Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode?: string;
  /**
  * Enables and configures automatic reconnection behavior for a UNIX socket–based EGD entropy source; the content and attributes are user-provided according to desired policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reconnect Domain#reconnect}
  */
  readonly reconnect?: DomainDevicesSerialsSourceTcpReconnect;
  /**
  * Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#service Domain#service}
  */
  readonly service?: string;
  /**
  * Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tls Domain#tls}
  */
  readonly tls?: string;
}

export function domainDevicesSerialsSourceTcpToTerraform(struct?: DomainDevicesSerialsSourceTcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    mode: cdktf.stringToTerraform(struct!.mode),
    reconnect: domainDevicesSerialsSourceTcpReconnectToTerraform(struct!.reconnect),
    service: cdktf.stringToTerraform(struct!.service),
    tls: cdktf.stringToTerraform(struct!.tls),
  }
}


export function domainDevicesSerialsSourceTcpToHclTerraform(struct?: DomainDevicesSerialsSourceTcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reconnect: {
      value: domainDevicesSerialsSourceTcpReconnectToHclTerraform(struct!.reconnect),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSerialsSourceTcpReconnect",
    },
    service: {
      value: cdktf.stringToHclTerraform(struct!.service),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: cdktf.stringToHclTerraform(struct!.tls),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesSerialsSourceTcpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesSerialsSourceTcp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._reconnect?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.reconnect = this._reconnect?.internalValue;
    }
    if (this._service !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service;
    }
    if (this._tls !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesSerialsSourceTcp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host = undefined;
      this._mode = undefined;
      this._reconnect.internalValue = undefined;
      this._service = undefined;
      this._tls = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host = value.host;
      this._mode = value.mode;
      this._reconnect.internalValue = value.reconnect;
      this._service = value.service;
      this._tls = value.tls;
    }
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // reconnect - computed: false, optional: true, required: false
  private _reconnect = new DomainDevicesSerialsSourceTcpReconnectOutputReference(this, "reconnect");
  public get reconnect() {
    return this._reconnect;
  }
  public putReconnect(value: DomainDevicesSerialsSourceTcpReconnect) {
    this._reconnect.internalValue = value;
  }
  public resetReconnect() {
    this._reconnect.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reconnectInput() {
    return this._reconnect.internalValue;
  }

  // service - computed: false, optional: true, required: false
  private _service?: string; 
  public get service() {
    return this.getStringAttribute('service');
  }
  public set service(value: string) {
    this._service = value;
  }
  public resetService() {
    this._service = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service;
  }

  // tls - computed: false, optional: true, required: false
  private _tls?: string; 
  public get tls() {
    return this.getStringAttribute('tls');
  }
  public set tls(value: string) {
    this._tls = value;
  }
  public resetTls() {
    this._tls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls;
  }
}
export interface DomainDevicesSerialsSourceUdp {
  /**
  * Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bind_host Domain#bind_host}
  */
  readonly bindHost: string;
  /**
  * Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bind_service Domain#bind_service}
  */
  readonly bindService: string;
  /**
  * Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#connect_host Domain#connect_host}
  */
  readonly connectHost: string;
  /**
  * Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#connect_service Domain#connect_service}
  */
  readonly connectService: string;
}

export function domainDevicesSerialsSourceUdpToTerraform(struct?: DomainDevicesSerialsSourceUdp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_host: cdktf.stringToTerraform(struct!.bindHost),
    bind_service: cdktf.stringToTerraform(struct!.bindService),
    connect_host: cdktf.stringToTerraform(struct!.connectHost),
    connect_service: cdktf.stringToTerraform(struct!.connectService),
  }
}


export function domainDevicesSerialsSourceUdpToHclTerraform(struct?: DomainDevicesSerialsSourceUdp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_host: {
      value: cdktf.stringToHclTerraform(struct!.bindHost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bind_service: {
      value: cdktf.stringToHclTerraform(struct!.bindService),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connect_host: {
      value: cdktf.stringToHclTerraform(struct!.connectHost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connect_service: {
      value: cdktf.stringToHclTerraform(struct!.connectService),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesSerialsSourceUdpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesSerialsSourceUdp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindHost !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindHost = this._bindHost;
    }
    if (this._bindService !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindService = this._bindService;
    }
    if (this._connectHost !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectHost = this._connectHost;
    }
    if (this._connectService !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectService = this._connectService;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesSerialsSourceUdp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bindHost = undefined;
      this._bindService = undefined;
      this._connectHost = undefined;
      this._connectService = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bindHost = value.bindHost;
      this._bindService = value.bindService;
      this._connectHost = value.connectHost;
      this._connectService = value.connectService;
    }
  }

  // bind_host - computed: false, optional: false, required: true
  private _bindHost?: string; 
  public get bindHost() {
    return this.getStringAttribute('bind_host');
  }
  public set bindHost(value: string) {
    this._bindHost = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bindHostInput() {
    return this._bindHost;
  }

  // bind_service - computed: false, optional: false, required: true
  private _bindService?: string; 
  public get bindService() {
    return this.getStringAttribute('bind_service');
  }
  public set bindService(value: string) {
    this._bindService = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bindServiceInput() {
    return this._bindService;
  }

  // connect_host - computed: false, optional: false, required: true
  private _connectHost?: string; 
  public get connectHost() {
    return this.getStringAttribute('connect_host');
  }
  public set connectHost(value: string) {
    this._connectHost = value;
  }
  // Temporarily expose input value. Use with caution.
  public get connectHostInput() {
    return this._connectHost;
  }

  // connect_service - computed: false, optional: false, required: true
  private _connectService?: string; 
  public get connectService() {
    return this.getStringAttribute('connect_service');
  }
  public set connectService(value: string) {
    this._connectService = value;
  }
  // Temporarily expose input value. Use with caution.
  public get connectServiceInput() {
    return this._connectService;
  }
}
export interface DomainDevicesSerialsSourceUnixReconnect {
  /**
  * Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enabled Domain#enabled}
  */
  readonly enabled: string;
  /**
  * Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#timeout Domain#timeout}
  */
  readonly timeout?: number;
}

export function domainDevicesSerialsSourceUnixReconnectToTerraform(struct?: DomainDevicesSerialsSourceUnixReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.stringToTerraform(struct!.enabled),
    timeout: cdktf.numberToTerraform(struct!.timeout),
  }
}


export function domainDevicesSerialsSourceUnixReconnectToHclTerraform(struct?: DomainDevicesSerialsSourceUnixReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.stringToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.numberToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesSerialsSourceUnixReconnectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesSerialsSourceUnixReconnect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesSerialsSourceUnixReconnect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._timeout = value.timeout;
    }
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: string; 
  public get enabled() {
    return this.getStringAttribute('enabled');
  }
  public set enabled(value: string) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: number; 
  public get timeout() {
    return this.getNumberAttribute('timeout');
  }
  public set timeout(value: number) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DomainDevicesSerialsSourceUnixSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesSerialsSourceUnixSecLabelToTerraform(struct?: DomainDevicesSerialsSourceUnixSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesSerialsSourceUnixSecLabelToHclTerraform(struct?: DomainDevicesSerialsSourceUnixSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesSerialsSourceUnixSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesSerialsSourceUnixSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesSerialsSourceUnixSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesSerialsSourceUnixSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesSerialsSourceUnixSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesSerialsSourceUnixSecLabelOutputReference {
    return new DomainDevicesSerialsSourceUnixSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesSerialsSourceUnix {
  /**
  * Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode?: string;
  /**
  * Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path?: string;
  /**
  * Enables and configures automatic reconnection behavior for a UNIX socket–based EGD entropy source; the content and attributes are user-provided according to desired policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reconnect Domain#reconnect}
  */
  readonly reconnect?: DomainDevicesSerialsSourceUnixReconnect;
  /**
  * Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesSerialsSourceUnixSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesSerialsSourceUnixToTerraform(struct?: DomainDevicesSerialsSourceUnix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
    reconnect: domainDevicesSerialsSourceUnixReconnectToTerraform(struct!.reconnect),
    sec_label: cdktf.listMapper(domainDevicesSerialsSourceUnixSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesSerialsSourceUnixToHclTerraform(struct?: DomainDevicesSerialsSourceUnix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reconnect: {
      value: domainDevicesSerialsSourceUnixReconnectToHclTerraform(struct!.reconnect),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSerialsSourceUnixReconnect",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesSerialsSourceUnixSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesSerialsSourceUnixSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesSerialsSourceUnixOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesSerialsSourceUnix | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._reconnect?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.reconnect = this._reconnect?.internalValue;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesSerialsSourceUnix | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
      this._path = undefined;
      this._reconnect.internalValue = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
      this._path = value.path;
      this._reconnect.internalValue = value.reconnect;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // reconnect - computed: false, optional: true, required: false
  private _reconnect = new DomainDevicesSerialsSourceUnixReconnectOutputReference(this, "reconnect");
  public get reconnect() {
    return this._reconnect;
  }
  public putReconnect(value: DomainDevicesSerialsSourceUnixReconnect) {
    this._reconnect.internalValue = value;
  }
  public resetReconnect() {
    this._reconnect.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reconnectInput() {
    return this._reconnect.internalValue;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesSerialsSourceUnixSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesSerialsSourceUnixSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesSerialsSource {
  /**
  * Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dbus Domain#dbus}
  */
  readonly dbus?: DomainDevicesSerialsSourceDbus;
  /**
  * Configures an EGD RNG backend that reads entropy from a host character device node.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dev Domain#dev}
  */
  readonly dev?: DomainDevicesSerialsSourceDev;
  /**
  * Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file?: DomainDevicesSerialsSourceFile;
  /**
  * Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#nmdm Domain#nmdm}
  */
  readonly nmdm?: DomainDevicesSerialsSourceNmdm;
  /**
  * Enables use of a null backend for the EGD RNG source, discarding all data written and providing no entropy; when this boolean is true the <Null> source is emitted, and when false or unset it is omitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#null Domain#null}
  */
  readonly null?: boolean | cdktf.IResolvable;
  /**
  * Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pipe Domain#pipe}
  */
  readonly pipe?: DomainDevicesSerialsSourcePipe;
  /**
  * Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pty Domain#pty}
  */
  readonly pty?: DomainDevicesSerialsSourcePty;
  /**
  * Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#qemuvd_agent Domain#qemuvd_agent}
  */
  readonly qemuvdAgent?: DomainDevicesSerialsSourceQemuvdAgent;
  /**
  * Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#spice_port Domain#spice_port}
  */
  readonly spicePort?: DomainDevicesSerialsSourceSpicePort;
  /**
  * Enables using a SPICE virtio serial management channel (spicevmc) as the entropy source for the EGD RNG backend when set to true; when false or unset, the element is omitted.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#spice_vmc Domain#spice_vmc}
  */
  readonly spiceVmc?: boolean | cdktf.IResolvable;
  /**
  * Enables using the QEMU process standard I/O stream as the entropy source for the EGD RNG backend when set to true; when false or unset, the element is omitted.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#std_io Domain#std_io}
  */
  readonly stdIo?: boolean | cdktf.IResolvable;
  /**
  * Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tcp Domain#tcp}
  */
  readonly tcp?: DomainDevicesSerialsSourceTcp;
  /**
  * Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#udp Domain#udp}
  */
  readonly udp?: DomainDevicesSerialsSourceUdp;
  /**
  * Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#unix Domain#unix}
  */
  readonly unix?: DomainDevicesSerialsSourceUnix;
  /**
  * Enables use of a virtual console device as the entropy source for the EGD RNG backend when set (presence-only element; omitting it disables this source).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vc Domain#vc}
  */
  readonly vc?: boolean | cdktf.IResolvable;
}

export function domainDevicesSerialsSourceToTerraform(struct?: DomainDevicesSerialsSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dbus: domainDevicesSerialsSourceDbusToTerraform(struct!.dbus),
    dev: domainDevicesSerialsSourceDevToTerraform(struct!.dev),
    file: domainDevicesSerialsSourceFileToTerraform(struct!.file),
    nmdm: domainDevicesSerialsSourceNmdmToTerraform(struct!.nmdm),
    null: cdktf.booleanToTerraform(struct!.null),
    pipe: domainDevicesSerialsSourcePipeToTerraform(struct!.pipe),
    pty: domainDevicesSerialsSourcePtyToTerraform(struct!.pty),
    qemuvd_agent: domainDevicesSerialsSourceQemuvdAgentToTerraform(struct!.qemuvdAgent),
    spice_port: domainDevicesSerialsSourceSpicePortToTerraform(struct!.spicePort),
    spice_vmc: cdktf.booleanToTerraform(struct!.spiceVmc),
    std_io: cdktf.booleanToTerraform(struct!.stdIo),
    tcp: domainDevicesSerialsSourceTcpToTerraform(struct!.tcp),
    udp: domainDevicesSerialsSourceUdpToTerraform(struct!.udp),
    unix: domainDevicesSerialsSourceUnixToTerraform(struct!.unix),
    vc: cdktf.booleanToTerraform(struct!.vc),
  }
}


export function domainDevicesSerialsSourceToHclTerraform(struct?: DomainDevicesSerialsSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dbus: {
      value: domainDevicesSerialsSourceDbusToHclTerraform(struct!.dbus),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSerialsSourceDbus",
    },
    dev: {
      value: domainDevicesSerialsSourceDevToHclTerraform(struct!.dev),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSerialsSourceDev",
    },
    file: {
      value: domainDevicesSerialsSourceFileToHclTerraform(struct!.file),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSerialsSourceFile",
    },
    nmdm: {
      value: domainDevicesSerialsSourceNmdmToHclTerraform(struct!.nmdm),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSerialsSourceNmdm",
    },
    null: {
      value: cdktf.booleanToHclTerraform(struct!.null),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    pipe: {
      value: domainDevicesSerialsSourcePipeToHclTerraform(struct!.pipe),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSerialsSourcePipe",
    },
    pty: {
      value: domainDevicesSerialsSourcePtyToHclTerraform(struct!.pty),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSerialsSourcePty",
    },
    qemuvd_agent: {
      value: domainDevicesSerialsSourceQemuvdAgentToHclTerraform(struct!.qemuvdAgent),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSerialsSourceQemuvdAgent",
    },
    spice_port: {
      value: domainDevicesSerialsSourceSpicePortToHclTerraform(struct!.spicePort),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSerialsSourceSpicePort",
    },
    spice_vmc: {
      value: cdktf.booleanToHclTerraform(struct!.spiceVmc),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    std_io: {
      value: cdktf.booleanToHclTerraform(struct!.stdIo),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tcp: {
      value: domainDevicesSerialsSourceTcpToHclTerraform(struct!.tcp),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSerialsSourceTcp",
    },
    udp: {
      value: domainDevicesSerialsSourceUdpToHclTerraform(struct!.udp),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSerialsSourceUdp",
    },
    unix: {
      value: domainDevicesSerialsSourceUnixToHclTerraform(struct!.unix),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSerialsSourceUnix",
    },
    vc: {
      value: cdktf.booleanToHclTerraform(struct!.vc),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesSerialsSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesSerialsSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dbus?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dbus = this._dbus?.internalValue;
    }
    if (this._dev?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dev = this._dev?.internalValue;
    }
    if (this._file?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file?.internalValue;
    }
    if (this._nmdm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nmdm = this._nmdm?.internalValue;
    }
    if (this._null !== undefined) {
      hasAnyValues = true;
      internalValueResult.null = this._null;
    }
    if (this._pipe?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipe = this._pipe?.internalValue;
    }
    if (this._pty?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pty = this._pty?.internalValue;
    }
    if (this._qemuvdAgent?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.qemuvdAgent = this._qemuvdAgent?.internalValue;
    }
    if (this._spicePort?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spicePort = this._spicePort?.internalValue;
    }
    if (this._spiceVmc !== undefined) {
      hasAnyValues = true;
      internalValueResult.spiceVmc = this._spiceVmc;
    }
    if (this._stdIo !== undefined) {
      hasAnyValues = true;
      internalValueResult.stdIo = this._stdIo;
    }
    if (this._tcp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tcp = this._tcp?.internalValue;
    }
    if (this._udp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.udp = this._udp?.internalValue;
    }
    if (this._unix?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.unix = this._unix?.internalValue;
    }
    if (this._vc !== undefined) {
      hasAnyValues = true;
      internalValueResult.vc = this._vc;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesSerialsSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dbus.internalValue = undefined;
      this._dev.internalValue = undefined;
      this._file.internalValue = undefined;
      this._nmdm.internalValue = undefined;
      this._null = undefined;
      this._pipe.internalValue = undefined;
      this._pty.internalValue = undefined;
      this._qemuvdAgent.internalValue = undefined;
      this._spicePort.internalValue = undefined;
      this._spiceVmc = undefined;
      this._stdIo = undefined;
      this._tcp.internalValue = undefined;
      this._udp.internalValue = undefined;
      this._unix.internalValue = undefined;
      this._vc = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dbus.internalValue = value.dbus;
      this._dev.internalValue = value.dev;
      this._file.internalValue = value.file;
      this._nmdm.internalValue = value.nmdm;
      this._null = value.null;
      this._pipe.internalValue = value.pipe;
      this._pty.internalValue = value.pty;
      this._qemuvdAgent.internalValue = value.qemuvdAgent;
      this._spicePort.internalValue = value.spicePort;
      this._spiceVmc = value.spiceVmc;
      this._stdIo = value.stdIo;
      this._tcp.internalValue = value.tcp;
      this._udp.internalValue = value.udp;
      this._unix.internalValue = value.unix;
      this._vc = value.vc;
    }
  }

  // dbus - computed: false, optional: true, required: false
  private _dbus = new DomainDevicesSerialsSourceDbusOutputReference(this, "dbus");
  public get dbus() {
    return this._dbus;
  }
  public putDbus(value: DomainDevicesSerialsSourceDbus) {
    this._dbus.internalValue = value;
  }
  public resetDbus() {
    this._dbus.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dbusInput() {
    return this._dbus.internalValue;
  }

  // dev - computed: false, optional: true, required: false
  private _dev = new DomainDevicesSerialsSourceDevOutputReference(this, "dev");
  public get dev() {
    return this._dev;
  }
  public putDev(value: DomainDevicesSerialsSourceDev) {
    this._dev.internalValue = value;
  }
  public resetDev() {
    this._dev.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devInput() {
    return this._dev.internalValue;
  }

  // file - computed: false, optional: true, required: false
  private _file = new DomainDevicesSerialsSourceFileOutputReference(this, "file");
  public get file() {
    return this._file;
  }
  public putFile(value: DomainDevicesSerialsSourceFile) {
    this._file.internalValue = value;
  }
  public resetFile() {
    this._file.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file.internalValue;
  }

  // nmdm - computed: false, optional: true, required: false
  private _nmdm = new DomainDevicesSerialsSourceNmdmOutputReference(this, "nmdm");
  public get nmdm() {
    return this._nmdm;
  }
  public putNmdm(value: DomainDevicesSerialsSourceNmdm) {
    this._nmdm.internalValue = value;
  }
  public resetNmdm() {
    this._nmdm.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nmdmInput() {
    return this._nmdm.internalValue;
  }

  // null - computed: false, optional: true, required: false
  private _null?: boolean | cdktf.IResolvable; 
  public get null() {
    return this.getBooleanAttribute('null');
  }
  public set null(value: boolean | cdktf.IResolvable) {
    this._null = value;
  }
  public resetNull() {
    this._null = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nullInput() {
    return this._null;
  }

  // pipe - computed: false, optional: true, required: false
  private _pipe = new DomainDevicesSerialsSourcePipeOutputReference(this, "pipe");
  public get pipe() {
    return this._pipe;
  }
  public putPipe(value: DomainDevicesSerialsSourcePipe) {
    this._pipe.internalValue = value;
  }
  public resetPipe() {
    this._pipe.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipeInput() {
    return this._pipe.internalValue;
  }

  // pty - computed: false, optional: true, required: false
  private _pty = new DomainDevicesSerialsSourcePtyOutputReference(this, "pty");
  public get pty() {
    return this._pty;
  }
  public putPty(value: DomainDevicesSerialsSourcePty) {
    this._pty.internalValue = value;
  }
  public resetPty() {
    this._pty.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ptyInput() {
    return this._pty.internalValue;
  }

  // qemuvd_agent - computed: false, optional: true, required: false
  private _qemuvdAgent = new DomainDevicesSerialsSourceQemuvdAgentOutputReference(this, "qemuvd_agent");
  public get qemuvdAgent() {
    return this._qemuvdAgent;
  }
  public putQemuvdAgent(value: DomainDevicesSerialsSourceQemuvdAgent) {
    this._qemuvdAgent.internalValue = value;
  }
  public resetQemuvdAgent() {
    this._qemuvdAgent.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get qemuvdAgentInput() {
    return this._qemuvdAgent.internalValue;
  }

  // spice_port - computed: false, optional: true, required: false
  private _spicePort = new DomainDevicesSerialsSourceSpicePortOutputReference(this, "spice_port");
  public get spicePort() {
    return this._spicePort;
  }
  public putSpicePort(value: DomainDevicesSerialsSourceSpicePort) {
    this._spicePort.internalValue = value;
  }
  public resetSpicePort() {
    this._spicePort.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spicePortInput() {
    return this._spicePort.internalValue;
  }

  // spice_vmc - computed: false, optional: true, required: false
  private _spiceVmc?: boolean | cdktf.IResolvable; 
  public get spiceVmc() {
    return this.getBooleanAttribute('spice_vmc');
  }
  public set spiceVmc(value: boolean | cdktf.IResolvable) {
    this._spiceVmc = value;
  }
  public resetSpiceVmc() {
    this._spiceVmc = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spiceVmcInput() {
    return this._spiceVmc;
  }

  // std_io - computed: false, optional: true, required: false
  private _stdIo?: boolean | cdktf.IResolvable; 
  public get stdIo() {
    return this.getBooleanAttribute('std_io');
  }
  public set stdIo(value: boolean | cdktf.IResolvable) {
    this._stdIo = value;
  }
  public resetStdIo() {
    this._stdIo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stdIoInput() {
    return this._stdIo;
  }

  // tcp - computed: false, optional: true, required: false
  private _tcp = new DomainDevicesSerialsSourceTcpOutputReference(this, "tcp");
  public get tcp() {
    return this._tcp;
  }
  public putTcp(value: DomainDevicesSerialsSourceTcp) {
    this._tcp.internalValue = value;
  }
  public resetTcp() {
    this._tcp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tcpInput() {
    return this._tcp.internalValue;
  }

  // udp - computed: false, optional: true, required: false
  private _udp = new DomainDevicesSerialsSourceUdpOutputReference(this, "udp");
  public get udp() {
    return this._udp;
  }
  public putUdp(value: DomainDevicesSerialsSourceUdp) {
    this._udp.internalValue = value;
  }
  public resetUdp() {
    this._udp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get udpInput() {
    return this._udp.internalValue;
  }

  // unix - computed: false, optional: true, required: false
  private _unix = new DomainDevicesSerialsSourceUnixOutputReference(this, "unix");
  public get unix() {
    return this._unix;
  }
  public putUnix(value: DomainDevicesSerialsSourceUnix) {
    this._unix.internalValue = value;
  }
  public resetUnix() {
    this._unix.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unixInput() {
    return this._unix.internalValue;
  }

  // vc - computed: false, optional: true, required: false
  private _vc?: boolean | cdktf.IResolvable; 
  public get vc() {
    return this.getBooleanAttribute('vc');
  }
  public set vc(value: boolean | cdktf.IResolvable) {
    this._vc = value;
  }
  public resetVc() {
    this._vc = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vcInput() {
    return this._vc;
  }
}
export interface DomainDevicesSerialsTargetModel {
  /**
  * Sets the serial controller model name (user-provided string, e.g. "isa-serial" or "pci-serial"), as accepted by the underlying hypervisor.
  * 
  * See: <https://libvirt.org/formatdomain.html#serial-port>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name?: string;
}

export function domainDevicesSerialsTargetModelToTerraform(struct?: DomainDevicesSerialsTargetModel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function domainDevicesSerialsTargetModelToHclTerraform(struct?: DomainDevicesSerialsTargetModel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesSerialsTargetModelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesSerialsTargetModel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesSerialsTargetModel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DomainDevicesSerialsTarget {
  /**
  * Configures the hardware model of the serial port target, allowing selection of different emulated serial controller types where supported.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: DomainDevicesSerialsTargetModel;
  /**
  * Sets the guest-visible serial port number starting from 0; typically 0–3 depending on how many serial ports the guest OS supports.
  * 
  * See: <https://libvirt.org/formatdomain.html#serial-port>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#port Domain#port}
  */
  readonly port?: number;
  /**
  * Selects the type of serial controller for this target; valid values include "isa-serial", "pci-serial", "usb-serial", "spapr-vty", "sclp-serial", "sclplmconsole", and "system-serial".
  * 
  * See: <https://libvirt.org/formatdomain.html#serial-port>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type?: string;
}

export function domainDevicesSerialsTargetToTerraform(struct?: DomainDevicesSerialsTarget | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    model: domainDevicesSerialsTargetModelToTerraform(struct!.model),
    port: cdktf.numberToTerraform(struct!.port),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function domainDevicesSerialsTargetToHclTerraform(struct?: DomainDevicesSerialsTarget | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    model: {
      value: domainDevicesSerialsTargetModelToHclTerraform(struct!.model),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSerialsTargetModel",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesSerialsTargetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesSerialsTarget | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._model?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model?.internalValue;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesSerialsTarget | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._model.internalValue = undefined;
      this._port = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._model.internalValue = value.model;
      this._port = value.port;
      this._type = value.type;
    }
  }

  // model - computed: false, optional: true, required: false
  private _model = new DomainDevicesSerialsTargetModelOutputReference(this, "model");
  public get model() {
    return this._model;
  }
  public putModel(value: DomainDevicesSerialsTargetModel) {
    this._model.internalValue = value;
  }
  public resetModel() {
    this._model.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model.internalValue;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DomainDevicesSerials {
  /**
  * Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#acpi Domain#acpi}
  */
  readonly acpi?: DomainDevicesSerialsAcpi;
  /**
  * Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: DomainDevicesSerialsAddress;
  /**
  * Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#alias Domain#alias}
  */
  readonly alias?: DomainDevicesSerialsAlias;
  /**
  * Enables logging of data sent through the channel to a host file and configures how that logging behaves.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#log Domain#log}
  */
  readonly log?: DomainDevicesSerialsLog;
  /**
  * Configures the transport protocol used by the EGD backend connection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#protocol Domain#protocol}
  */
  readonly protocol?: DomainDevicesSerialsProtocol;
  /**
  * Defines the source endpoint for the EGD backend, such as a socket path or network address, depending on the chosen protocol.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#source Domain#source}
  */
  readonly source?: DomainDevicesSerialsSource;
  /**
  * Configures the guest-visible target of the serial device, such as the port number and, where applicable, the subtype (for example, "isa-serial" port 0).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#target Domain#target}
  */
  readonly target?: DomainDevicesSerialsTarget;
}

export function domainDevicesSerialsToTerraform(struct?: DomainDevicesSerials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    acpi: domainDevicesSerialsAcpiToTerraform(struct!.acpi),
    address: domainDevicesSerialsAddressToTerraform(struct!.address),
    alias: domainDevicesSerialsAliasToTerraform(struct!.alias),
    log: domainDevicesSerialsLogToTerraform(struct!.log),
    protocol: domainDevicesSerialsProtocolToTerraform(struct!.protocol),
    source: domainDevicesSerialsSourceToTerraform(struct!.source),
    target: domainDevicesSerialsTargetToTerraform(struct!.target),
  }
}


export function domainDevicesSerialsToHclTerraform(struct?: DomainDevicesSerials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    acpi: {
      value: domainDevicesSerialsAcpiToHclTerraform(struct!.acpi),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSerialsAcpi",
    },
    address: {
      value: domainDevicesSerialsAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSerialsAddress",
    },
    alias: {
      value: domainDevicesSerialsAliasToHclTerraform(struct!.alias),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSerialsAlias",
    },
    log: {
      value: domainDevicesSerialsLogToHclTerraform(struct!.log),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSerialsLog",
    },
    protocol: {
      value: domainDevicesSerialsProtocolToHclTerraform(struct!.protocol),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSerialsProtocol",
    },
    source: {
      value: domainDevicesSerialsSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSerialsSource",
    },
    target: {
      value: domainDevicesSerialsTargetToHclTerraform(struct!.target),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSerialsTarget",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesSerialsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesSerials | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._acpi?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.acpi = this._acpi?.internalValue;
    }
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._alias?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.alias = this._alias?.internalValue;
    }
    if (this._log?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.log = this._log?.internalValue;
    }
    if (this._protocol?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol?.internalValue;
    }
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    if (this._target?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.target = this._target?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesSerials | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._acpi.internalValue = undefined;
      this._address.internalValue = undefined;
      this._alias.internalValue = undefined;
      this._log.internalValue = undefined;
      this._protocol.internalValue = undefined;
      this._source.internalValue = undefined;
      this._target.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._acpi.internalValue = value.acpi;
      this._address.internalValue = value.address;
      this._alias.internalValue = value.alias;
      this._log.internalValue = value.log;
      this._protocol.internalValue = value.protocol;
      this._source.internalValue = value.source;
      this._target.internalValue = value.target;
    }
  }

  // acpi - computed: false, optional: true, required: false
  private _acpi = new DomainDevicesSerialsAcpiOutputReference(this, "acpi");
  public get acpi() {
    return this._acpi;
  }
  public putAcpi(value: DomainDevicesSerialsAcpi) {
    this._acpi.internalValue = value;
  }
  public resetAcpi() {
    this._acpi.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get acpiInput() {
    return this._acpi.internalValue;
  }

  // address - computed: false, optional: true, required: false
  private _address = new DomainDevicesSerialsAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DomainDevicesSerialsAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // alias - computed: false, optional: true, required: false
  private _alias = new DomainDevicesSerialsAliasOutputReference(this, "alias");
  public get alias() {
    return this._alias;
  }
  public putAlias(value: DomainDevicesSerialsAlias) {
    this._alias.internalValue = value;
  }
  public resetAlias() {
    this._alias.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aliasInput() {
    return this._alias.internalValue;
  }

  // log - computed: false, optional: true, required: false
  private _log = new DomainDevicesSerialsLogOutputReference(this, "log");
  public get log() {
    return this._log;
  }
  public putLog(value: DomainDevicesSerialsLog) {
    this._log.internalValue = value;
  }
  public resetLog() {
    this._log.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logInput() {
    return this._log.internalValue;
  }

  // protocol - computed: false, optional: true, required: false
  private _protocol = new DomainDevicesSerialsProtocolOutputReference(this, "protocol");
  public get protocol() {
    return this._protocol;
  }
  public putProtocol(value: DomainDevicesSerialsProtocol) {
    this._protocol.internalValue = value;
  }
  public resetProtocol() {
    this._protocol.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol.internalValue;
  }

  // source - computed: false, optional: true, required: false
  private _source = new DomainDevicesSerialsSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: DomainDevicesSerialsSource) {
    this._source.internalValue = value;
  }
  public resetSource() {
    this._source.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }

  // target - computed: false, optional: true, required: false
  private _target = new DomainDevicesSerialsTargetOutputReference(this, "target");
  public get target() {
    return this._target;
  }
  public putTarget(value: DomainDevicesSerialsTarget) {
    this._target.internalValue = value;
  }
  public resetTarget() {
    this._target.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetInput() {
    return this._target.internalValue;
  }
}

export class DomainDevicesSerialsList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesSerials[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesSerialsOutputReference {
    return new DomainDevicesSerialsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesShmemsAcpi {
  /**
  * Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#pstore>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#index Domain#index}
  */
  readonly index?: number;
}

export function domainDevicesShmemsAcpiToTerraform(struct?: DomainDevicesShmemsAcpi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    index: cdktf.numberToTerraform(struct!.index),
  }
}


export function domainDevicesShmemsAcpiToHclTerraform(struct?: DomainDevicesShmemsAcpi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    index: {
      value: cdktf.numberToHclTerraform(struct!.index),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesShmemsAcpiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesShmemsAcpi | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._index !== undefined) {
      hasAnyValues = true;
      internalValueResult.index = this._index;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesShmemsAcpi | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._index = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._index = value.index;
    }
  }

  // index - computed: false, optional: true, required: false
  private _index?: number; 
  public get index() {
    return this.getNumberAttribute('index');
  }
  public set index(value: number) {
    this._index = value;
  }
  public resetIndex() {
    this._index = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get indexInput() {
    return this._index;
  }
}
export interface DomainDevicesShmemsAddress {
}

export function domainDevicesShmemsAddressToTerraform(struct?: DomainDevicesShmemsAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function domainDevicesShmemsAddressToHclTerraform(struct?: DomainDevicesShmemsAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DomainDevicesShmemsAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesShmemsAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesShmemsAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DomainDevicesShmemsAlias {
  /**
  * Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
}

export function domainDevicesShmemsAliasToTerraform(struct?: DomainDevicesShmemsAlias | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function domainDevicesShmemsAliasToHclTerraform(struct?: DomainDevicesShmemsAlias | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesShmemsAliasOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesShmemsAlias | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesShmemsAlias | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DomainDevicesShmemsModel {
  /**
  * Sets the shared memory model type; valid values include "ivshmem-plain" and "ivshmem-doorbell" as supported by QEMU.
  * 
  * See: <https://libvirt.org/formatdomain.html#shared-memory-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type: string;
}

export function domainDevicesShmemsModelToTerraform(struct?: DomainDevicesShmemsModel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function domainDevicesShmemsModelToHclTerraform(struct?: DomainDevicesShmemsModel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesShmemsModelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesShmemsModel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesShmemsModel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._type = value.type;
    }
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DomainDevicesShmemsMsi {
  /**
  * Toggles MSI support for the shared memory device; accepts "on"/"off" (or "yes"/"no") as a string flag depending on driver support.
  * 
  * See: <https://libvirt.org/formatdomain.html#shared-memory-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enabled Domain#enabled}
  */
  readonly enabled?: string;
  /**
  * Enables or disables ioeventfd usage for MSI signaling; value is a string yes/no-style flag interpreted by the hypervisor.
  * 
  * See: <https://libvirt.org/formatdomain.html#shared-memory-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#io_event_fd Domain#io_event_fd}
  */
  readonly ioEventFd?: string;
  /**
  * Sets the number of MSI vectors (interrupts) allocated for this shared memory device as a positive integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#shared-memory-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vectors Domain#vectors}
  */
  readonly vectors?: number;
}

export function domainDevicesShmemsMsiToTerraform(struct?: DomainDevicesShmemsMsi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.stringToTerraform(struct!.enabled),
    io_event_fd: cdktf.stringToTerraform(struct!.ioEventFd),
    vectors: cdktf.numberToTerraform(struct!.vectors),
  }
}


export function domainDevicesShmemsMsiToHclTerraform(struct?: DomainDevicesShmemsMsi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.stringToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    io_event_fd: {
      value: cdktf.stringToHclTerraform(struct!.ioEventFd),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    vectors: {
      value: cdktf.numberToHclTerraform(struct!.vectors),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesShmemsMsiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesShmemsMsi | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._ioEventFd !== undefined) {
      hasAnyValues = true;
      internalValueResult.ioEventFd = this._ioEventFd;
    }
    if (this._vectors !== undefined) {
      hasAnyValues = true;
      internalValueResult.vectors = this._vectors;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesShmemsMsi | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._ioEventFd = undefined;
      this._vectors = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._ioEventFd = value.ioEventFd;
      this._vectors = value.vectors;
    }
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: string; 
  public get enabled() {
    return this.getStringAttribute('enabled');
  }
  public set enabled(value: string) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // io_event_fd - computed: false, optional: true, required: false
  private _ioEventFd?: string; 
  public get ioEventFd() {
    return this.getStringAttribute('io_event_fd');
  }
  public set ioEventFd(value: string) {
    this._ioEventFd = value;
  }
  public resetIoEventFd() {
    this._ioEventFd = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ioEventFdInput() {
    return this._ioEventFd;
  }

  // vectors - computed: false, optional: true, required: false
  private _vectors?: number; 
  public get vectors() {
    return this.getNumberAttribute('vectors');
  }
  public set vectors(value: number) {
    this._vectors = value;
  }
  public resetVectors() {
    this._vectors = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vectorsInput() {
    return this._vectors;
  }
}
export interface DomainDevicesShmemsServer {
  /**
  * Sets the filesystem path used by the shmem server (for example, a memory-backend or socket path) as a user-provided string.
  * 
  * See: <https://libvirt.org/formatdomain.html#shared-memory-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path?: string;
}

export function domainDevicesShmemsServerToTerraform(struct?: DomainDevicesShmemsServer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function domainDevicesShmemsServerToHclTerraform(struct?: DomainDevicesShmemsServer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesShmemsServerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesShmemsServer | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesShmemsServer | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
    }
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface DomainDevicesShmems {
  /**
  * Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#acpi Domain#acpi}
  */
  readonly acpi?: DomainDevicesShmemsAcpi;
  /**
  * Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: DomainDevicesShmemsAddress;
  /**
  * Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#alias Domain#alias}
  */
  readonly alias?: DomainDevicesShmemsAlias;
  /**
  * Selects which shmem device model to use (e.g. "ivshmem-plain" or "ivshmem-doorbell") depending on the desired feature set.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: DomainDevicesShmemsModel;
  /**
  * Enables and configures MSI interrupt support for the shared memory device to signal events using MSI/MSI-X.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#msi Domain#msi}
  */
  readonly msi?: DomainDevicesShmemsMsi;
  /**
  * Specifies the logical name of the shared memory region; this must be unique across shmem devices and is used to match peers.
  * 
  * See: <https://libvirt.org/formatdomain.html#shared-memory-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
  /**
  * Sets the device role in the shared memory configuration, typically "guest" or "host" style roles depending on model; value is user-provided according to hypervisor support.
  * 
  * See: <https://libvirt.org/formatdomain.html#shared-memory-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#role Domain#role}
  */
  readonly role?: string;
  /**
  * Configures this shared memory device as a server endpoint, providing details about how the backing memory is hosted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#server Domain#server}
  */
  readonly server?: DomainDevicesShmemsServer;
  /**
  * Sets the shared memory region size; the value is user-provided and interpreted together with `size_unit` (for example, `1024` with unit `KiB`).
  * 
  * See: <https://libvirt.org/formatdomain.html#shared-memory-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#size Domain#size}
  */
  readonly size?: number;
  /**
  * Sets the unit for the shared memory size (for example `B`, `KiB`, `MiB`, `GiB`); if omitted, libvirt applies its own default unit.
  * 
  * See: <https://libvirt.org/formatdomain.html#shared-memory-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#size_unit Domain#size_unit}
  */
  readonly sizeUnit?: string;
}

export function domainDevicesShmemsToTerraform(struct?: DomainDevicesShmems | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    acpi: domainDevicesShmemsAcpiToTerraform(struct!.acpi),
    address: domainDevicesShmemsAddressToTerraform(struct!.address),
    alias: domainDevicesShmemsAliasToTerraform(struct!.alias),
    model: domainDevicesShmemsModelToTerraform(struct!.model),
    msi: domainDevicesShmemsMsiToTerraform(struct!.msi),
    name: cdktf.stringToTerraform(struct!.name),
    role: cdktf.stringToTerraform(struct!.role),
    server: domainDevicesShmemsServerToTerraform(struct!.server),
    size: cdktf.numberToTerraform(struct!.size),
    size_unit: cdktf.stringToTerraform(struct!.sizeUnit),
  }
}


export function domainDevicesShmemsToHclTerraform(struct?: DomainDevicesShmems | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    acpi: {
      value: domainDevicesShmemsAcpiToHclTerraform(struct!.acpi),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesShmemsAcpi",
    },
    address: {
      value: domainDevicesShmemsAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesShmemsAddress",
    },
    alias: {
      value: domainDevicesShmemsAliasToHclTerraform(struct!.alias),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesShmemsAlias",
    },
    model: {
      value: domainDevicesShmemsModelToHclTerraform(struct!.model),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesShmemsModel",
    },
    msi: {
      value: domainDevicesShmemsMsiToHclTerraform(struct!.msi),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesShmemsMsi",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role: {
      value: cdktf.stringToHclTerraform(struct!.role),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server: {
      value: domainDevicesShmemsServerToHclTerraform(struct!.server),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesShmemsServer",
    },
    size: {
      value: cdktf.numberToHclTerraform(struct!.size),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    size_unit: {
      value: cdktf.stringToHclTerraform(struct!.sizeUnit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesShmemsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesShmems | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._acpi?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.acpi = this._acpi?.internalValue;
    }
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._alias?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.alias = this._alias?.internalValue;
    }
    if (this._model?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model?.internalValue;
    }
    if (this._msi?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.msi = this._msi?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._role !== undefined) {
      hasAnyValues = true;
      internalValueResult.role = this._role;
    }
    if (this._server?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.server = this._server?.internalValue;
    }
    if (this._size !== undefined) {
      hasAnyValues = true;
      internalValueResult.size = this._size;
    }
    if (this._sizeUnit !== undefined) {
      hasAnyValues = true;
      internalValueResult.sizeUnit = this._sizeUnit;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesShmems | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._acpi.internalValue = undefined;
      this._address.internalValue = undefined;
      this._alias.internalValue = undefined;
      this._model.internalValue = undefined;
      this._msi.internalValue = undefined;
      this._name = undefined;
      this._role = undefined;
      this._server.internalValue = undefined;
      this._size = undefined;
      this._sizeUnit = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._acpi.internalValue = value.acpi;
      this._address.internalValue = value.address;
      this._alias.internalValue = value.alias;
      this._model.internalValue = value.model;
      this._msi.internalValue = value.msi;
      this._name = value.name;
      this._role = value.role;
      this._server.internalValue = value.server;
      this._size = value.size;
      this._sizeUnit = value.sizeUnit;
    }
  }

  // acpi - computed: false, optional: true, required: false
  private _acpi = new DomainDevicesShmemsAcpiOutputReference(this, "acpi");
  public get acpi() {
    return this._acpi;
  }
  public putAcpi(value: DomainDevicesShmemsAcpi) {
    this._acpi.internalValue = value;
  }
  public resetAcpi() {
    this._acpi.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get acpiInput() {
    return this._acpi.internalValue;
  }

  // address - computed: false, optional: true, required: false
  private _address = new DomainDevicesShmemsAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DomainDevicesShmemsAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // alias - computed: false, optional: true, required: false
  private _alias = new DomainDevicesShmemsAliasOutputReference(this, "alias");
  public get alias() {
    return this._alias;
  }
  public putAlias(value: DomainDevicesShmemsAlias) {
    this._alias.internalValue = value;
  }
  public resetAlias() {
    this._alias.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aliasInput() {
    return this._alias.internalValue;
  }

  // model - computed: false, optional: true, required: false
  private _model = new DomainDevicesShmemsModelOutputReference(this, "model");
  public get model() {
    return this._model;
  }
  public putModel(value: DomainDevicesShmemsModel) {
    this._model.internalValue = value;
  }
  public resetModel() {
    this._model.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model.internalValue;
  }

  // msi - computed: false, optional: true, required: false
  private _msi = new DomainDevicesShmemsMsiOutputReference(this, "msi");
  public get msi() {
    return this._msi;
  }
  public putMsi(value: DomainDevicesShmemsMsi) {
    this._msi.internalValue = value;
  }
  public resetMsi() {
    this._msi.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get msiInput() {
    return this._msi.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // role - computed: false, optional: true, required: false
  private _role?: string; 
  public get role() {
    return this.getStringAttribute('role');
  }
  public set role(value: string) {
    this._role = value;
  }
  public resetRole() {
    this._role = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleInput() {
    return this._role;
  }

  // server - computed: false, optional: true, required: false
  private _server = new DomainDevicesShmemsServerOutputReference(this, "server");
  public get server() {
    return this._server;
  }
  public putServer(value: DomainDevicesShmemsServer) {
    this._server.internalValue = value;
  }
  public resetServer() {
    this._server.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverInput() {
    return this._server.internalValue;
  }

  // size - computed: false, optional: true, required: false
  private _size?: number; 
  public get size() {
    return this.getNumberAttribute('size');
  }
  public set size(value: number) {
    this._size = value;
  }
  public resetSize() {
    this._size = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sizeInput() {
    return this._size;
  }

  // size_unit - computed: false, optional: true, required: false
  private _sizeUnit?: string; 
  public get sizeUnit() {
    return this.getStringAttribute('size_unit');
  }
  public set sizeUnit(value: string) {
    this._sizeUnit = value;
  }
  public resetSizeUnit() {
    this._sizeUnit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sizeUnitInput() {
    return this._sizeUnit;
  }
}

export class DomainDevicesShmemsList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesShmems[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesShmemsOutputReference {
    return new DomainDevicesShmemsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesSmartcardsAcpi {
  /**
  * Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#pstore>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#index Domain#index}
  */
  readonly index?: number;
}

export function domainDevicesSmartcardsAcpiToTerraform(struct?: DomainDevicesSmartcardsAcpi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    index: cdktf.numberToTerraform(struct!.index),
  }
}


export function domainDevicesSmartcardsAcpiToHclTerraform(struct?: DomainDevicesSmartcardsAcpi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    index: {
      value: cdktf.numberToHclTerraform(struct!.index),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesSmartcardsAcpiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesSmartcardsAcpi | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._index !== undefined) {
      hasAnyValues = true;
      internalValueResult.index = this._index;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesSmartcardsAcpi | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._index = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._index = value.index;
    }
  }

  // index - computed: false, optional: true, required: false
  private _index?: number; 
  public get index() {
    return this.getNumberAttribute('index');
  }
  public set index(value: number) {
    this._index = value;
  }
  public resetIndex() {
    this._index = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get indexInput() {
    return this._index;
  }
}
export interface DomainDevicesSmartcardsAddress {
}

export function domainDevicesSmartcardsAddressToTerraform(struct?: DomainDevicesSmartcardsAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function domainDevicesSmartcardsAddressToHclTerraform(struct?: DomainDevicesSmartcardsAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DomainDevicesSmartcardsAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesSmartcardsAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesSmartcardsAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DomainDevicesSmartcardsAlias {
  /**
  * Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
}

export function domainDevicesSmartcardsAliasToTerraform(struct?: DomainDevicesSmartcardsAlias | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function domainDevicesSmartcardsAliasToHclTerraform(struct?: DomainDevicesSmartcardsAlias | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesSmartcardsAliasOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesSmartcardsAlias | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesSmartcardsAlias | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DomainDevicesSmartcardsHostCerts {
  /**
  * Sets the path to a certificate file included in the host-certificates smartcard configuration; value is a user-provided filesystem path.
  * 
  * See: <https://libvirt.org/formatdomain.html#smartcard-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file: string;
}

export function domainDevicesSmartcardsHostCertsToTerraform(struct?: DomainDevicesSmartcardsHostCerts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    file: cdktf.stringToTerraform(struct!.file),
  }
}


export function domainDevicesSmartcardsHostCertsToHclTerraform(struct?: DomainDevicesSmartcardsHostCerts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    file: {
      value: cdktf.stringToHclTerraform(struct!.file),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesSmartcardsHostCertsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesSmartcardsHostCerts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._file !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesSmartcardsHostCerts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._file = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._file = value.file;
    }
  }

  // file - computed: false, optional: false, required: true
  private _file?: string; 
  public get file() {
    return this.getStringAttribute('file');
  }
  public set file(value: string) {
    this._file = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file;
  }
}

export class DomainDevicesSmartcardsHostCertsList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesSmartcardsHostCerts[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesSmartcardsHostCertsOutputReference {
    return new DomainDevicesSmartcardsHostCertsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesSmartcardsPassthroughDbus {
  /**
  * Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#channel Domain#channel}
  */
  readonly channel?: string;
}

export function domainDevicesSmartcardsPassthroughDbusToTerraform(struct?: DomainDevicesSmartcardsPassthroughDbus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    channel: cdktf.stringToTerraform(struct!.channel),
  }
}


export function domainDevicesSmartcardsPassthroughDbusToHclTerraform(struct?: DomainDevicesSmartcardsPassthroughDbus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    channel: {
      value: cdktf.stringToHclTerraform(struct!.channel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesSmartcardsPassthroughDbusOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesSmartcardsPassthroughDbus | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._channel !== undefined) {
      hasAnyValues = true;
      internalValueResult.channel = this._channel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesSmartcardsPassthroughDbus | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._channel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._channel = value.channel;
    }
  }

  // channel - computed: false, optional: true, required: false
  private _channel?: string; 
  public get channel() {
    return this.getStringAttribute('channel');
  }
  public set channel(value: string) {
    this._channel = value;
  }
  public resetChannel() {
    this._channel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get channelInput() {
    return this._channel;
  }
}
export interface DomainDevicesSmartcardsPassthroughDevSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesSmartcardsPassthroughDevSecLabelToTerraform(struct?: DomainDevicesSmartcardsPassthroughDevSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesSmartcardsPassthroughDevSecLabelToHclTerraform(struct?: DomainDevicesSmartcardsPassthroughDevSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesSmartcardsPassthroughDevSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesSmartcardsPassthroughDevSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesSmartcardsPassthroughDevSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesSmartcardsPassthroughDevSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesSmartcardsPassthroughDevSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesSmartcardsPassthroughDevSecLabelOutputReference {
    return new DomainDevicesSmartcardsPassthroughDevSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesSmartcardsPassthroughDev {
  /**
  * Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesSmartcardsPassthroughDevSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesSmartcardsPassthroughDevToTerraform(struct?: DomainDevicesSmartcardsPassthroughDev | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesSmartcardsPassthroughDevSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesSmartcardsPassthroughDevToHclTerraform(struct?: DomainDevicesSmartcardsPassthroughDev | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesSmartcardsPassthroughDevSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesSmartcardsPassthroughDevSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesSmartcardsPassthroughDevOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesSmartcardsPassthroughDev | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesSmartcardsPassthroughDev | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesSmartcardsPassthroughDevSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesSmartcardsPassthroughDevSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesSmartcardsPassthroughFileSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesSmartcardsPassthroughFileSecLabelToTerraform(struct?: DomainDevicesSmartcardsPassthroughFileSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesSmartcardsPassthroughFileSecLabelToHclTerraform(struct?: DomainDevicesSmartcardsPassthroughFileSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesSmartcardsPassthroughFileSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesSmartcardsPassthroughFileSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesSmartcardsPassthroughFileSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesSmartcardsPassthroughFileSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesSmartcardsPassthroughFileSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesSmartcardsPassthroughFileSecLabelOutputReference {
    return new DomainDevicesSmartcardsPassthroughFileSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesSmartcardsPassthroughFile {
  /**
  * Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.
  * 
  * See: <https://libvirt.org/formatdomain.html#device-logfile>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#append Domain#append}
  */
  readonly append?: string;
  /**
  * Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesSmartcardsPassthroughFileSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesSmartcardsPassthroughFileToTerraform(struct?: DomainDevicesSmartcardsPassthroughFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.stringToTerraform(struct!.append),
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesSmartcardsPassthroughFileSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesSmartcardsPassthroughFileToHclTerraform(struct?: DomainDevicesSmartcardsPassthroughFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.stringToHclTerraform(struct!.append),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesSmartcardsPassthroughFileSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesSmartcardsPassthroughFileSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesSmartcardsPassthroughFileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesSmartcardsPassthroughFile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesSmartcardsPassthroughFile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append = value.append;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append?: string; 
  public get append() {
    return this.getStringAttribute('append');
  }
  public set append(value: string) {
    this._append = value;
  }
  public resetAppend() {
    this._append = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append;
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesSmartcardsPassthroughFileSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesSmartcardsPassthroughFileSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesSmartcardsPassthroughNmdm {
  /**
  * Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.
  * 
  * See: <https://libvirt.org/formatdomain.html#nmdm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#master Domain#master}
  */
  readonly master: string;
  /**
  * Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.
  * 
  * See: <https://libvirt.org/formatdomain.html#nmdm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#slave Domain#slave}
  */
  readonly slave: string;
}

export function domainDevicesSmartcardsPassthroughNmdmToTerraform(struct?: DomainDevicesSmartcardsPassthroughNmdm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    master: cdktf.stringToTerraform(struct!.master),
    slave: cdktf.stringToTerraform(struct!.slave),
  }
}


export function domainDevicesSmartcardsPassthroughNmdmToHclTerraform(struct?: DomainDevicesSmartcardsPassthroughNmdm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    master: {
      value: cdktf.stringToHclTerraform(struct!.master),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    slave: {
      value: cdktf.stringToHclTerraform(struct!.slave),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesSmartcardsPassthroughNmdmOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesSmartcardsPassthroughNmdm | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._master !== undefined) {
      hasAnyValues = true;
      internalValueResult.master = this._master;
    }
    if (this._slave !== undefined) {
      hasAnyValues = true;
      internalValueResult.slave = this._slave;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesSmartcardsPassthroughNmdm | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._master = undefined;
      this._slave = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._master = value.master;
      this._slave = value.slave;
    }
  }

  // master - computed: false, optional: false, required: true
  private _master?: string; 
  public get master() {
    return this.getStringAttribute('master');
  }
  public set master(value: string) {
    this._master = value;
  }
  // Temporarily expose input value. Use with caution.
  public get masterInput() {
    return this._master;
  }

  // slave - computed: false, optional: false, required: true
  private _slave?: string; 
  public get slave() {
    return this.getStringAttribute('slave');
  }
  public set slave(value: string) {
    this._slave = value;
  }
  // Temporarily expose input value. Use with caution.
  public get slaveInput() {
    return this._slave;
  }
}
export interface DomainDevicesSmartcardsPassthroughPipeSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesSmartcardsPassthroughPipeSecLabelToTerraform(struct?: DomainDevicesSmartcardsPassthroughPipeSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesSmartcardsPassthroughPipeSecLabelToHclTerraform(struct?: DomainDevicesSmartcardsPassthroughPipeSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesSmartcardsPassthroughPipeSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesSmartcardsPassthroughPipeSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesSmartcardsPassthroughPipeSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesSmartcardsPassthroughPipeSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesSmartcardsPassthroughPipeSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesSmartcardsPassthroughPipeSecLabelOutputReference {
    return new DomainDevicesSmartcardsPassthroughPipeSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesSmartcardsPassthroughPipe {
  /**
  * Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesSmartcardsPassthroughPipeSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesSmartcardsPassthroughPipeToTerraform(struct?: DomainDevicesSmartcardsPassthroughPipe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesSmartcardsPassthroughPipeSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesSmartcardsPassthroughPipeToHclTerraform(struct?: DomainDevicesSmartcardsPassthroughPipe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesSmartcardsPassthroughPipeSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesSmartcardsPassthroughPipeSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesSmartcardsPassthroughPipeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesSmartcardsPassthroughPipe | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesSmartcardsPassthroughPipe | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesSmartcardsPassthroughPipeSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesSmartcardsPassthroughPipeSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesSmartcardsPassthroughPtySecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesSmartcardsPassthroughPtySecLabelToTerraform(struct?: DomainDevicesSmartcardsPassthroughPtySecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesSmartcardsPassthroughPtySecLabelToHclTerraform(struct?: DomainDevicesSmartcardsPassthroughPtySecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesSmartcardsPassthroughPtySecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesSmartcardsPassthroughPtySecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesSmartcardsPassthroughPtySecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesSmartcardsPassthroughPtySecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesSmartcardsPassthroughPtySecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesSmartcardsPassthroughPtySecLabelOutputReference {
    return new DomainDevicesSmartcardsPassthroughPtySecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesSmartcardsPassthroughPty {
  /**
  * Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesSmartcardsPassthroughPtySecLabel[] | cdktf.IResolvable;
}

export function domainDevicesSmartcardsPassthroughPtyToTerraform(struct?: DomainDevicesSmartcardsPassthroughPty | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesSmartcardsPassthroughPtySecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesSmartcardsPassthroughPtyToHclTerraform(struct?: DomainDevicesSmartcardsPassthroughPty | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesSmartcardsPassthroughPtySecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesSmartcardsPassthroughPtySecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesSmartcardsPassthroughPtyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesSmartcardsPassthroughPty | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesSmartcardsPassthroughPty | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesSmartcardsPassthroughPtySecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesSmartcardsPassthroughPtySecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesSmartcardsPassthroughQemuvdAgentClipBoard {
  /**
  * Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#copy_paste Domain#copy_paste}
  */
  readonly copyPaste: string;
}

export function domainDevicesSmartcardsPassthroughQemuvdAgentClipBoardToTerraform(struct?: DomainDevicesSmartcardsPassthroughQemuvdAgentClipBoard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    copy_paste: cdktf.stringToTerraform(struct!.copyPaste),
  }
}


export function domainDevicesSmartcardsPassthroughQemuvdAgentClipBoardToHclTerraform(struct?: DomainDevicesSmartcardsPassthroughQemuvdAgentClipBoard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    copy_paste: {
      value: cdktf.stringToHclTerraform(struct!.copyPaste),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesSmartcardsPassthroughQemuvdAgentClipBoardOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesSmartcardsPassthroughQemuvdAgentClipBoard | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._copyPaste !== undefined) {
      hasAnyValues = true;
      internalValueResult.copyPaste = this._copyPaste;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesSmartcardsPassthroughQemuvdAgentClipBoard | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._copyPaste = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._copyPaste = value.copyPaste;
    }
  }

  // copy_paste - computed: false, optional: false, required: true
  private _copyPaste?: string; 
  public get copyPaste() {
    return this.getStringAttribute('copy_paste');
  }
  public set copyPaste(value: string) {
    this._copyPaste = value;
  }
  // Temporarily expose input value. Use with caution.
  public get copyPasteInput() {
    return this._copyPaste;
  }
}
export interface DomainDevicesSmartcardsPassthroughQemuvdAgentMouse {
  /**
  * Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).
  * 
  * See: <https://libvirt.org/formatdomain.html#channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode: string;
}

export function domainDevicesSmartcardsPassthroughQemuvdAgentMouseToTerraform(struct?: DomainDevicesSmartcardsPassthroughQemuvdAgentMouse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
  }
}


export function domainDevicesSmartcardsPassthroughQemuvdAgentMouseToHclTerraform(struct?: DomainDevicesSmartcardsPassthroughQemuvdAgentMouse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesSmartcardsPassthroughQemuvdAgentMouseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesSmartcardsPassthroughQemuvdAgentMouse | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesSmartcardsPassthroughQemuvdAgentMouse | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
    }
  }

  // mode - computed: false, optional: false, required: true
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }
}
export interface DomainDevicesSmartcardsPassthroughQemuvdAgent {
  /**
  * Configures clipboard-related behavior for the QEMU vdagent–based EGD source, controlling whether clipboard data exchange is allowed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#clip_board Domain#clip_board}
  */
  readonly clipBoard?: DomainDevicesSmartcardsPassthroughQemuvdAgentClipBoard;
  /**
  * Configures mouse integration options for the QEMU vdagent–based EGD source, such as how mouse events are handled.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mouse Domain#mouse}
  */
  readonly mouse?: DomainDevicesSmartcardsPassthroughQemuvdAgentMouse;
}

export function domainDevicesSmartcardsPassthroughQemuvdAgentToTerraform(struct?: DomainDevicesSmartcardsPassthroughQemuvdAgent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    clip_board: domainDevicesSmartcardsPassthroughQemuvdAgentClipBoardToTerraform(struct!.clipBoard),
    mouse: domainDevicesSmartcardsPassthroughQemuvdAgentMouseToTerraform(struct!.mouse),
  }
}


export function domainDevicesSmartcardsPassthroughQemuvdAgentToHclTerraform(struct?: DomainDevicesSmartcardsPassthroughQemuvdAgent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    clip_board: {
      value: domainDevicesSmartcardsPassthroughQemuvdAgentClipBoardToHclTerraform(struct!.clipBoard),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSmartcardsPassthroughQemuvdAgentClipBoard",
    },
    mouse: {
      value: domainDevicesSmartcardsPassthroughQemuvdAgentMouseToHclTerraform(struct!.mouse),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSmartcardsPassthroughQemuvdAgentMouse",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesSmartcardsPassthroughQemuvdAgentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesSmartcardsPassthroughQemuvdAgent | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clipBoard?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clipBoard = this._clipBoard?.internalValue;
    }
    if (this._mouse?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.mouse = this._mouse?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesSmartcardsPassthroughQemuvdAgent | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clipBoard.internalValue = undefined;
      this._mouse.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clipBoard.internalValue = value.clipBoard;
      this._mouse.internalValue = value.mouse;
    }
  }

  // clip_board - computed: false, optional: true, required: false
  private _clipBoard = new DomainDevicesSmartcardsPassthroughQemuvdAgentClipBoardOutputReference(this, "clip_board");
  public get clipBoard() {
    return this._clipBoard;
  }
  public putClipBoard(value: DomainDevicesSmartcardsPassthroughQemuvdAgentClipBoard) {
    this._clipBoard.internalValue = value;
  }
  public resetClipBoard() {
    this._clipBoard.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clipBoardInput() {
    return this._clipBoard.internalValue;
  }

  // mouse - computed: false, optional: true, required: false
  private _mouse = new DomainDevicesSmartcardsPassthroughQemuvdAgentMouseOutputReference(this, "mouse");
  public get mouse() {
    return this._mouse;
  }
  public putMouse(value: DomainDevicesSmartcardsPassthroughQemuvdAgentMouse) {
    this._mouse.internalValue = value;
  }
  public resetMouse() {
    this._mouse.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mouseInput() {
    return this._mouse.internalValue;
  }
}
export interface DomainDevicesSmartcardsPassthroughSpicePort {
  /**
  * Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#channel Domain#channel}
  */
  readonly channel: string;
}

export function domainDevicesSmartcardsPassthroughSpicePortToTerraform(struct?: DomainDevicesSmartcardsPassthroughSpicePort | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    channel: cdktf.stringToTerraform(struct!.channel),
  }
}


export function domainDevicesSmartcardsPassthroughSpicePortToHclTerraform(struct?: DomainDevicesSmartcardsPassthroughSpicePort | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    channel: {
      value: cdktf.stringToHclTerraform(struct!.channel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesSmartcardsPassthroughSpicePortOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesSmartcardsPassthroughSpicePort | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._channel !== undefined) {
      hasAnyValues = true;
      internalValueResult.channel = this._channel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesSmartcardsPassthroughSpicePort | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._channel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._channel = value.channel;
    }
  }

  // channel - computed: false, optional: false, required: true
  private _channel?: string; 
  public get channel() {
    return this.getStringAttribute('channel');
  }
  public set channel(value: string) {
    this._channel = value;
  }
  // Temporarily expose input value. Use with caution.
  public get channelInput() {
    return this._channel;
  }
}
export interface DomainDevicesSmartcardsPassthroughTcpReconnect {
  /**
  * Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enabled Domain#enabled}
  */
  readonly enabled: string;
  /**
  * Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#timeout Domain#timeout}
  */
  readonly timeout?: number;
}

export function domainDevicesSmartcardsPassthroughTcpReconnectToTerraform(struct?: DomainDevicesSmartcardsPassthroughTcpReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.stringToTerraform(struct!.enabled),
    timeout: cdktf.numberToTerraform(struct!.timeout),
  }
}


export function domainDevicesSmartcardsPassthroughTcpReconnectToHclTerraform(struct?: DomainDevicesSmartcardsPassthroughTcpReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.stringToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.numberToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesSmartcardsPassthroughTcpReconnectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesSmartcardsPassthroughTcpReconnect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesSmartcardsPassthroughTcpReconnect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._timeout = value.timeout;
    }
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: string; 
  public get enabled() {
    return this.getStringAttribute('enabled');
  }
  public set enabled(value: string) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: number; 
  public get timeout() {
    return this.getNumberAttribute('timeout');
  }
  public set timeout(value: number) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DomainDevicesSmartcardsPassthroughTcp {
  /**
  * Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#host Domain#host}
  */
  readonly host?: string;
  /**
  * Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode?: string;
  /**
  * Enables and configures automatic reconnection behavior for a UNIX socket–based EGD entropy source; the content and attributes are user-provided according to desired policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reconnect Domain#reconnect}
  */
  readonly reconnect?: DomainDevicesSmartcardsPassthroughTcpReconnect;
  /**
  * Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#service Domain#service}
  */
  readonly service?: string;
  /**
  * Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tls Domain#tls}
  */
  readonly tls?: string;
}

export function domainDevicesSmartcardsPassthroughTcpToTerraform(struct?: DomainDevicesSmartcardsPassthroughTcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    mode: cdktf.stringToTerraform(struct!.mode),
    reconnect: domainDevicesSmartcardsPassthroughTcpReconnectToTerraform(struct!.reconnect),
    service: cdktf.stringToTerraform(struct!.service),
    tls: cdktf.stringToTerraform(struct!.tls),
  }
}


export function domainDevicesSmartcardsPassthroughTcpToHclTerraform(struct?: DomainDevicesSmartcardsPassthroughTcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reconnect: {
      value: domainDevicesSmartcardsPassthroughTcpReconnectToHclTerraform(struct!.reconnect),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSmartcardsPassthroughTcpReconnect",
    },
    service: {
      value: cdktf.stringToHclTerraform(struct!.service),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: cdktf.stringToHclTerraform(struct!.tls),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesSmartcardsPassthroughTcpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesSmartcardsPassthroughTcp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._reconnect?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.reconnect = this._reconnect?.internalValue;
    }
    if (this._service !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service;
    }
    if (this._tls !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesSmartcardsPassthroughTcp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host = undefined;
      this._mode = undefined;
      this._reconnect.internalValue = undefined;
      this._service = undefined;
      this._tls = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host = value.host;
      this._mode = value.mode;
      this._reconnect.internalValue = value.reconnect;
      this._service = value.service;
      this._tls = value.tls;
    }
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // reconnect - computed: false, optional: true, required: false
  private _reconnect = new DomainDevicesSmartcardsPassthroughTcpReconnectOutputReference(this, "reconnect");
  public get reconnect() {
    return this._reconnect;
  }
  public putReconnect(value: DomainDevicesSmartcardsPassthroughTcpReconnect) {
    this._reconnect.internalValue = value;
  }
  public resetReconnect() {
    this._reconnect.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reconnectInput() {
    return this._reconnect.internalValue;
  }

  // service - computed: false, optional: true, required: false
  private _service?: string; 
  public get service() {
    return this.getStringAttribute('service');
  }
  public set service(value: string) {
    this._service = value;
  }
  public resetService() {
    this._service = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service;
  }

  // tls - computed: false, optional: true, required: false
  private _tls?: string; 
  public get tls() {
    return this.getStringAttribute('tls');
  }
  public set tls(value: string) {
    this._tls = value;
  }
  public resetTls() {
    this._tls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls;
  }
}
export interface DomainDevicesSmartcardsPassthroughUdp {
  /**
  * Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bind_host Domain#bind_host}
  */
  readonly bindHost: string;
  /**
  * Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bind_service Domain#bind_service}
  */
  readonly bindService: string;
  /**
  * Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#connect_host Domain#connect_host}
  */
  readonly connectHost: string;
  /**
  * Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#connect_service Domain#connect_service}
  */
  readonly connectService: string;
}

export function domainDevicesSmartcardsPassthroughUdpToTerraform(struct?: DomainDevicesSmartcardsPassthroughUdp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_host: cdktf.stringToTerraform(struct!.bindHost),
    bind_service: cdktf.stringToTerraform(struct!.bindService),
    connect_host: cdktf.stringToTerraform(struct!.connectHost),
    connect_service: cdktf.stringToTerraform(struct!.connectService),
  }
}


export function domainDevicesSmartcardsPassthroughUdpToHclTerraform(struct?: DomainDevicesSmartcardsPassthroughUdp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_host: {
      value: cdktf.stringToHclTerraform(struct!.bindHost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bind_service: {
      value: cdktf.stringToHclTerraform(struct!.bindService),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connect_host: {
      value: cdktf.stringToHclTerraform(struct!.connectHost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connect_service: {
      value: cdktf.stringToHclTerraform(struct!.connectService),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesSmartcardsPassthroughUdpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesSmartcardsPassthroughUdp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindHost !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindHost = this._bindHost;
    }
    if (this._bindService !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindService = this._bindService;
    }
    if (this._connectHost !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectHost = this._connectHost;
    }
    if (this._connectService !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectService = this._connectService;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesSmartcardsPassthroughUdp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bindHost = undefined;
      this._bindService = undefined;
      this._connectHost = undefined;
      this._connectService = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bindHost = value.bindHost;
      this._bindService = value.bindService;
      this._connectHost = value.connectHost;
      this._connectService = value.connectService;
    }
  }

  // bind_host - computed: false, optional: false, required: true
  private _bindHost?: string; 
  public get bindHost() {
    return this.getStringAttribute('bind_host');
  }
  public set bindHost(value: string) {
    this._bindHost = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bindHostInput() {
    return this._bindHost;
  }

  // bind_service - computed: false, optional: false, required: true
  private _bindService?: string; 
  public get bindService() {
    return this.getStringAttribute('bind_service');
  }
  public set bindService(value: string) {
    this._bindService = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bindServiceInput() {
    return this._bindService;
  }

  // connect_host - computed: false, optional: false, required: true
  private _connectHost?: string; 
  public get connectHost() {
    return this.getStringAttribute('connect_host');
  }
  public set connectHost(value: string) {
    this._connectHost = value;
  }
  // Temporarily expose input value. Use with caution.
  public get connectHostInput() {
    return this._connectHost;
  }

  // connect_service - computed: false, optional: false, required: true
  private _connectService?: string; 
  public get connectService() {
    return this.getStringAttribute('connect_service');
  }
  public set connectService(value: string) {
    this._connectService = value;
  }
  // Temporarily expose input value. Use with caution.
  public get connectServiceInput() {
    return this._connectService;
  }
}
export interface DomainDevicesSmartcardsPassthroughUnixReconnect {
  /**
  * Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enabled Domain#enabled}
  */
  readonly enabled: string;
  /**
  * Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#timeout Domain#timeout}
  */
  readonly timeout?: number;
}

export function domainDevicesSmartcardsPassthroughUnixReconnectToTerraform(struct?: DomainDevicesSmartcardsPassthroughUnixReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.stringToTerraform(struct!.enabled),
    timeout: cdktf.numberToTerraform(struct!.timeout),
  }
}


export function domainDevicesSmartcardsPassthroughUnixReconnectToHclTerraform(struct?: DomainDevicesSmartcardsPassthroughUnixReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.stringToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.numberToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesSmartcardsPassthroughUnixReconnectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesSmartcardsPassthroughUnixReconnect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesSmartcardsPassthroughUnixReconnect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._timeout = value.timeout;
    }
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: string; 
  public get enabled() {
    return this.getStringAttribute('enabled');
  }
  public set enabled(value: string) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: number; 
  public get timeout() {
    return this.getNumberAttribute('timeout');
  }
  public set timeout(value: number) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DomainDevicesSmartcardsPassthroughUnixSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesSmartcardsPassthroughUnixSecLabelToTerraform(struct?: DomainDevicesSmartcardsPassthroughUnixSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesSmartcardsPassthroughUnixSecLabelToHclTerraform(struct?: DomainDevicesSmartcardsPassthroughUnixSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesSmartcardsPassthroughUnixSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesSmartcardsPassthroughUnixSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesSmartcardsPassthroughUnixSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesSmartcardsPassthroughUnixSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesSmartcardsPassthroughUnixSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesSmartcardsPassthroughUnixSecLabelOutputReference {
    return new DomainDevicesSmartcardsPassthroughUnixSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesSmartcardsPassthroughUnix {
  /**
  * Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode?: string;
  /**
  * Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path?: string;
  /**
  * Enables and configures automatic reconnection behavior for a UNIX socket–based EGD entropy source; the content and attributes are user-provided according to desired policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reconnect Domain#reconnect}
  */
  readonly reconnect?: DomainDevicesSmartcardsPassthroughUnixReconnect;
  /**
  * Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesSmartcardsPassthroughUnixSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesSmartcardsPassthroughUnixToTerraform(struct?: DomainDevicesSmartcardsPassthroughUnix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
    reconnect: domainDevicesSmartcardsPassthroughUnixReconnectToTerraform(struct!.reconnect),
    sec_label: cdktf.listMapper(domainDevicesSmartcardsPassthroughUnixSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesSmartcardsPassthroughUnixToHclTerraform(struct?: DomainDevicesSmartcardsPassthroughUnix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reconnect: {
      value: domainDevicesSmartcardsPassthroughUnixReconnectToHclTerraform(struct!.reconnect),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSmartcardsPassthroughUnixReconnect",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesSmartcardsPassthroughUnixSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesSmartcardsPassthroughUnixSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesSmartcardsPassthroughUnixOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesSmartcardsPassthroughUnix | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._reconnect?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.reconnect = this._reconnect?.internalValue;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesSmartcardsPassthroughUnix | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
      this._path = undefined;
      this._reconnect.internalValue = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
      this._path = value.path;
      this._reconnect.internalValue = value.reconnect;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // reconnect - computed: false, optional: true, required: false
  private _reconnect = new DomainDevicesSmartcardsPassthroughUnixReconnectOutputReference(this, "reconnect");
  public get reconnect() {
    return this._reconnect;
  }
  public putReconnect(value: DomainDevicesSmartcardsPassthroughUnixReconnect) {
    this._reconnect.internalValue = value;
  }
  public resetReconnect() {
    this._reconnect.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reconnectInput() {
    return this._reconnect.internalValue;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesSmartcardsPassthroughUnixSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesSmartcardsPassthroughUnixSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesSmartcardsPassthrough {
  /**
  * Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dbus Domain#dbus}
  */
  readonly dbus?: DomainDevicesSmartcardsPassthroughDbus;
  /**
  * Configures an EGD RNG backend that reads entropy from a host character device node.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dev Domain#dev}
  */
  readonly dev?: DomainDevicesSmartcardsPassthroughDev;
  /**
  * Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file?: DomainDevicesSmartcardsPassthroughFile;
  /**
  * Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#nmdm Domain#nmdm}
  */
  readonly nmdm?: DomainDevicesSmartcardsPassthroughNmdm;
  /**
  * Enables use of a null backend for the EGD RNG source, discarding all data written and providing no entropy; when this boolean is true the <Null> source is emitted, and when false or unset it is omitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#null Domain#null}
  */
  readonly null?: boolean | cdktf.IResolvable;
  /**
  * Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pipe Domain#pipe}
  */
  readonly pipe?: DomainDevicesSmartcardsPassthroughPipe;
  /**
  * Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pty Domain#pty}
  */
  readonly pty?: DomainDevicesSmartcardsPassthroughPty;
  /**
  * Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#qemuvd_agent Domain#qemuvd_agent}
  */
  readonly qemuvdAgent?: DomainDevicesSmartcardsPassthroughQemuvdAgent;
  /**
  * Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#spice_port Domain#spice_port}
  */
  readonly spicePort?: DomainDevicesSmartcardsPassthroughSpicePort;
  /**
  * Enables using a SPICE virtio serial management channel (spicevmc) as the entropy source for the EGD RNG backend when set to true; when false or unset, the element is omitted.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#spice_vmc Domain#spice_vmc}
  */
  readonly spiceVmc?: boolean | cdktf.IResolvable;
  /**
  * Enables using the QEMU process standard I/O stream as the entropy source for the EGD RNG backend when set to true; when false or unset, the element is omitted.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#std_io Domain#std_io}
  */
  readonly stdIo?: boolean | cdktf.IResolvable;
  /**
  * Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tcp Domain#tcp}
  */
  readonly tcp?: DomainDevicesSmartcardsPassthroughTcp;
  /**
  * Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#udp Domain#udp}
  */
  readonly udp?: DomainDevicesSmartcardsPassthroughUdp;
  /**
  * Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#unix Domain#unix}
  */
  readonly unix?: DomainDevicesSmartcardsPassthroughUnix;
  /**
  * Enables use of a virtual console device as the entropy source for the EGD RNG backend when set (presence-only element; omitting it disables this source).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vc Domain#vc}
  */
  readonly vc?: boolean | cdktf.IResolvable;
}

export function domainDevicesSmartcardsPassthroughToTerraform(struct?: DomainDevicesSmartcardsPassthrough | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dbus: domainDevicesSmartcardsPassthroughDbusToTerraform(struct!.dbus),
    dev: domainDevicesSmartcardsPassthroughDevToTerraform(struct!.dev),
    file: domainDevicesSmartcardsPassthroughFileToTerraform(struct!.file),
    nmdm: domainDevicesSmartcardsPassthroughNmdmToTerraform(struct!.nmdm),
    null: cdktf.booleanToTerraform(struct!.null),
    pipe: domainDevicesSmartcardsPassthroughPipeToTerraform(struct!.pipe),
    pty: domainDevicesSmartcardsPassthroughPtyToTerraform(struct!.pty),
    qemuvd_agent: domainDevicesSmartcardsPassthroughQemuvdAgentToTerraform(struct!.qemuvdAgent),
    spice_port: domainDevicesSmartcardsPassthroughSpicePortToTerraform(struct!.spicePort),
    spice_vmc: cdktf.booleanToTerraform(struct!.spiceVmc),
    std_io: cdktf.booleanToTerraform(struct!.stdIo),
    tcp: domainDevicesSmartcardsPassthroughTcpToTerraform(struct!.tcp),
    udp: domainDevicesSmartcardsPassthroughUdpToTerraform(struct!.udp),
    unix: domainDevicesSmartcardsPassthroughUnixToTerraform(struct!.unix),
    vc: cdktf.booleanToTerraform(struct!.vc),
  }
}


export function domainDevicesSmartcardsPassthroughToHclTerraform(struct?: DomainDevicesSmartcardsPassthrough | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dbus: {
      value: domainDevicesSmartcardsPassthroughDbusToHclTerraform(struct!.dbus),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSmartcardsPassthroughDbus",
    },
    dev: {
      value: domainDevicesSmartcardsPassthroughDevToHclTerraform(struct!.dev),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSmartcardsPassthroughDev",
    },
    file: {
      value: domainDevicesSmartcardsPassthroughFileToHclTerraform(struct!.file),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSmartcardsPassthroughFile",
    },
    nmdm: {
      value: domainDevicesSmartcardsPassthroughNmdmToHclTerraform(struct!.nmdm),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSmartcardsPassthroughNmdm",
    },
    null: {
      value: cdktf.booleanToHclTerraform(struct!.null),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    pipe: {
      value: domainDevicesSmartcardsPassthroughPipeToHclTerraform(struct!.pipe),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSmartcardsPassthroughPipe",
    },
    pty: {
      value: domainDevicesSmartcardsPassthroughPtyToHclTerraform(struct!.pty),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSmartcardsPassthroughPty",
    },
    qemuvd_agent: {
      value: domainDevicesSmartcardsPassthroughQemuvdAgentToHclTerraform(struct!.qemuvdAgent),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSmartcardsPassthroughQemuvdAgent",
    },
    spice_port: {
      value: domainDevicesSmartcardsPassthroughSpicePortToHclTerraform(struct!.spicePort),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSmartcardsPassthroughSpicePort",
    },
    spice_vmc: {
      value: cdktf.booleanToHclTerraform(struct!.spiceVmc),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    std_io: {
      value: cdktf.booleanToHclTerraform(struct!.stdIo),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tcp: {
      value: domainDevicesSmartcardsPassthroughTcpToHclTerraform(struct!.tcp),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSmartcardsPassthroughTcp",
    },
    udp: {
      value: domainDevicesSmartcardsPassthroughUdpToHclTerraform(struct!.udp),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSmartcardsPassthroughUdp",
    },
    unix: {
      value: domainDevicesSmartcardsPassthroughUnixToHclTerraform(struct!.unix),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSmartcardsPassthroughUnix",
    },
    vc: {
      value: cdktf.booleanToHclTerraform(struct!.vc),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesSmartcardsPassthroughOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesSmartcardsPassthrough | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dbus?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dbus = this._dbus?.internalValue;
    }
    if (this._dev?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dev = this._dev?.internalValue;
    }
    if (this._file?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file?.internalValue;
    }
    if (this._nmdm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nmdm = this._nmdm?.internalValue;
    }
    if (this._null !== undefined) {
      hasAnyValues = true;
      internalValueResult.null = this._null;
    }
    if (this._pipe?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipe = this._pipe?.internalValue;
    }
    if (this._pty?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pty = this._pty?.internalValue;
    }
    if (this._qemuvdAgent?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.qemuvdAgent = this._qemuvdAgent?.internalValue;
    }
    if (this._spicePort?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spicePort = this._spicePort?.internalValue;
    }
    if (this._spiceVmc !== undefined) {
      hasAnyValues = true;
      internalValueResult.spiceVmc = this._spiceVmc;
    }
    if (this._stdIo !== undefined) {
      hasAnyValues = true;
      internalValueResult.stdIo = this._stdIo;
    }
    if (this._tcp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tcp = this._tcp?.internalValue;
    }
    if (this._udp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.udp = this._udp?.internalValue;
    }
    if (this._unix?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.unix = this._unix?.internalValue;
    }
    if (this._vc !== undefined) {
      hasAnyValues = true;
      internalValueResult.vc = this._vc;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesSmartcardsPassthrough | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dbus.internalValue = undefined;
      this._dev.internalValue = undefined;
      this._file.internalValue = undefined;
      this._nmdm.internalValue = undefined;
      this._null = undefined;
      this._pipe.internalValue = undefined;
      this._pty.internalValue = undefined;
      this._qemuvdAgent.internalValue = undefined;
      this._spicePort.internalValue = undefined;
      this._spiceVmc = undefined;
      this._stdIo = undefined;
      this._tcp.internalValue = undefined;
      this._udp.internalValue = undefined;
      this._unix.internalValue = undefined;
      this._vc = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dbus.internalValue = value.dbus;
      this._dev.internalValue = value.dev;
      this._file.internalValue = value.file;
      this._nmdm.internalValue = value.nmdm;
      this._null = value.null;
      this._pipe.internalValue = value.pipe;
      this._pty.internalValue = value.pty;
      this._qemuvdAgent.internalValue = value.qemuvdAgent;
      this._spicePort.internalValue = value.spicePort;
      this._spiceVmc = value.spiceVmc;
      this._stdIo = value.stdIo;
      this._tcp.internalValue = value.tcp;
      this._udp.internalValue = value.udp;
      this._unix.internalValue = value.unix;
      this._vc = value.vc;
    }
  }

  // dbus - computed: false, optional: true, required: false
  private _dbus = new DomainDevicesSmartcardsPassthroughDbusOutputReference(this, "dbus");
  public get dbus() {
    return this._dbus;
  }
  public putDbus(value: DomainDevicesSmartcardsPassthroughDbus) {
    this._dbus.internalValue = value;
  }
  public resetDbus() {
    this._dbus.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dbusInput() {
    return this._dbus.internalValue;
  }

  // dev - computed: false, optional: true, required: false
  private _dev = new DomainDevicesSmartcardsPassthroughDevOutputReference(this, "dev");
  public get dev() {
    return this._dev;
  }
  public putDev(value: DomainDevicesSmartcardsPassthroughDev) {
    this._dev.internalValue = value;
  }
  public resetDev() {
    this._dev.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devInput() {
    return this._dev.internalValue;
  }

  // file - computed: false, optional: true, required: false
  private _file = new DomainDevicesSmartcardsPassthroughFileOutputReference(this, "file");
  public get file() {
    return this._file;
  }
  public putFile(value: DomainDevicesSmartcardsPassthroughFile) {
    this._file.internalValue = value;
  }
  public resetFile() {
    this._file.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file.internalValue;
  }

  // nmdm - computed: false, optional: true, required: false
  private _nmdm = new DomainDevicesSmartcardsPassthroughNmdmOutputReference(this, "nmdm");
  public get nmdm() {
    return this._nmdm;
  }
  public putNmdm(value: DomainDevicesSmartcardsPassthroughNmdm) {
    this._nmdm.internalValue = value;
  }
  public resetNmdm() {
    this._nmdm.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nmdmInput() {
    return this._nmdm.internalValue;
  }

  // null - computed: false, optional: true, required: false
  private _null?: boolean | cdktf.IResolvable; 
  public get null() {
    return this.getBooleanAttribute('null');
  }
  public set null(value: boolean | cdktf.IResolvable) {
    this._null = value;
  }
  public resetNull() {
    this._null = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nullInput() {
    return this._null;
  }

  // pipe - computed: false, optional: true, required: false
  private _pipe = new DomainDevicesSmartcardsPassthroughPipeOutputReference(this, "pipe");
  public get pipe() {
    return this._pipe;
  }
  public putPipe(value: DomainDevicesSmartcardsPassthroughPipe) {
    this._pipe.internalValue = value;
  }
  public resetPipe() {
    this._pipe.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipeInput() {
    return this._pipe.internalValue;
  }

  // pty - computed: false, optional: true, required: false
  private _pty = new DomainDevicesSmartcardsPassthroughPtyOutputReference(this, "pty");
  public get pty() {
    return this._pty;
  }
  public putPty(value: DomainDevicesSmartcardsPassthroughPty) {
    this._pty.internalValue = value;
  }
  public resetPty() {
    this._pty.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ptyInput() {
    return this._pty.internalValue;
  }

  // qemuvd_agent - computed: false, optional: true, required: false
  private _qemuvdAgent = new DomainDevicesSmartcardsPassthroughQemuvdAgentOutputReference(this, "qemuvd_agent");
  public get qemuvdAgent() {
    return this._qemuvdAgent;
  }
  public putQemuvdAgent(value: DomainDevicesSmartcardsPassthroughQemuvdAgent) {
    this._qemuvdAgent.internalValue = value;
  }
  public resetQemuvdAgent() {
    this._qemuvdAgent.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get qemuvdAgentInput() {
    return this._qemuvdAgent.internalValue;
  }

  // spice_port - computed: false, optional: true, required: false
  private _spicePort = new DomainDevicesSmartcardsPassthroughSpicePortOutputReference(this, "spice_port");
  public get spicePort() {
    return this._spicePort;
  }
  public putSpicePort(value: DomainDevicesSmartcardsPassthroughSpicePort) {
    this._spicePort.internalValue = value;
  }
  public resetSpicePort() {
    this._spicePort.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spicePortInput() {
    return this._spicePort.internalValue;
  }

  // spice_vmc - computed: false, optional: true, required: false
  private _spiceVmc?: boolean | cdktf.IResolvable; 
  public get spiceVmc() {
    return this.getBooleanAttribute('spice_vmc');
  }
  public set spiceVmc(value: boolean | cdktf.IResolvable) {
    this._spiceVmc = value;
  }
  public resetSpiceVmc() {
    this._spiceVmc = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spiceVmcInput() {
    return this._spiceVmc;
  }

  // std_io - computed: false, optional: true, required: false
  private _stdIo?: boolean | cdktf.IResolvable; 
  public get stdIo() {
    return this.getBooleanAttribute('std_io');
  }
  public set stdIo(value: boolean | cdktf.IResolvable) {
    this._stdIo = value;
  }
  public resetStdIo() {
    this._stdIo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stdIoInput() {
    return this._stdIo;
  }

  // tcp - computed: false, optional: true, required: false
  private _tcp = new DomainDevicesSmartcardsPassthroughTcpOutputReference(this, "tcp");
  public get tcp() {
    return this._tcp;
  }
  public putTcp(value: DomainDevicesSmartcardsPassthroughTcp) {
    this._tcp.internalValue = value;
  }
  public resetTcp() {
    this._tcp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tcpInput() {
    return this._tcp.internalValue;
  }

  // udp - computed: false, optional: true, required: false
  private _udp = new DomainDevicesSmartcardsPassthroughUdpOutputReference(this, "udp");
  public get udp() {
    return this._udp;
  }
  public putUdp(value: DomainDevicesSmartcardsPassthroughUdp) {
    this._udp.internalValue = value;
  }
  public resetUdp() {
    this._udp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get udpInput() {
    return this._udp.internalValue;
  }

  // unix - computed: false, optional: true, required: false
  private _unix = new DomainDevicesSmartcardsPassthroughUnixOutputReference(this, "unix");
  public get unix() {
    return this._unix;
  }
  public putUnix(value: DomainDevicesSmartcardsPassthroughUnix) {
    this._unix.internalValue = value;
  }
  public resetUnix() {
    this._unix.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unixInput() {
    return this._unix.internalValue;
  }

  // vc - computed: false, optional: true, required: false
  private _vc?: boolean | cdktf.IResolvable; 
  public get vc() {
    return this.getBooleanAttribute('vc');
  }
  public set vc(value: boolean | cdktf.IResolvable) {
    this._vc = value;
  }
  public resetVc() {
    this._vc = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vcInput() {
    return this._vc;
  }
}
export interface DomainDevicesSmartcardsProtocol {
  /**
  * Sets the EGD transport type, such as "tcp" or "unix"; value is a user-provided string supported by the hypervisor.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type: string;
}

export function domainDevicesSmartcardsProtocolToTerraform(struct?: DomainDevicesSmartcardsProtocol | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function domainDevicesSmartcardsProtocolToHclTerraform(struct?: DomainDevicesSmartcardsProtocol | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesSmartcardsProtocolOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesSmartcardsProtocol | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesSmartcardsProtocol | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._type = value.type;
    }
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DomainDevicesSmartcards {
  /**
  * Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#acpi Domain#acpi}
  */
  readonly acpi?: DomainDevicesSmartcardsAcpi;
  /**
  * Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: DomainDevicesSmartcardsAddress;
  /**
  * Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#alias Domain#alias}
  */
  readonly alias?: DomainDevicesSmartcardsAlias;
  /**
  * Sets the NSS database directory used for the smartcard’s certificate store; value is a user-provided path such as `/etc/pki/nssdb`.
  * 
  * See: <https://libvirt.org/formatdomain.html#smartcard-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#database Domain#database}
  */
  readonly database?: string;
  /**
  * Enables the host-certificates smartcard mode when set (element is present), so the guest uses certificates from the host’s smartcard database.
  * 
  * See: <https://libvirt.org/formatdomain.html#smartcard-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#host Domain#host}
  */
  readonly host?: boolean | cdktf.IResolvable;
  /**
  * Lists one or more certificate files that should be exposed to the guest when using host-certificates smartcard mode.
  * 
  * See: <https://libvirt.org/formatdomain.html#smartcard-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#host_certs Domain#host_certs}
  */
  readonly hostCerts?: DomainDevicesSmartcardsHostCerts[] | cdktf.IResolvable;
  /**
  * Defines the source endpoint for the EGD backend, such as a socket path or network address, depending on the chosen protocol.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#passthrough Domain#passthrough}
  */
  readonly passthrough?: DomainDevicesSmartcardsPassthrough;
  /**
  * Configures the transport protocol used by the EGD backend connection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#protocol Domain#protocol}
  */
  readonly protocol?: DomainDevicesSmartcardsProtocol;
}

export function domainDevicesSmartcardsToTerraform(struct?: DomainDevicesSmartcards | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    acpi: domainDevicesSmartcardsAcpiToTerraform(struct!.acpi),
    address: domainDevicesSmartcardsAddressToTerraform(struct!.address),
    alias: domainDevicesSmartcardsAliasToTerraform(struct!.alias),
    database: cdktf.stringToTerraform(struct!.database),
    host: cdktf.booleanToTerraform(struct!.host),
    host_certs: cdktf.listMapper(domainDevicesSmartcardsHostCertsToTerraform, false)(struct!.hostCerts),
    passthrough: domainDevicesSmartcardsPassthroughToTerraform(struct!.passthrough),
    protocol: domainDevicesSmartcardsProtocolToTerraform(struct!.protocol),
  }
}


export function domainDevicesSmartcardsToHclTerraform(struct?: DomainDevicesSmartcards | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    acpi: {
      value: domainDevicesSmartcardsAcpiToHclTerraform(struct!.acpi),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSmartcardsAcpi",
    },
    address: {
      value: domainDevicesSmartcardsAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSmartcardsAddress",
    },
    alias: {
      value: domainDevicesSmartcardsAliasToHclTerraform(struct!.alias),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSmartcardsAlias",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.booleanToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    host_certs: {
      value: cdktf.listMapperHcl(domainDevicesSmartcardsHostCertsToHclTerraform, false)(struct!.hostCerts),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesSmartcardsHostCertsList",
    },
    passthrough: {
      value: domainDevicesSmartcardsPassthroughToHclTerraform(struct!.passthrough),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSmartcardsPassthrough",
    },
    protocol: {
      value: domainDevicesSmartcardsProtocolToHclTerraform(struct!.protocol),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSmartcardsProtocol",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesSmartcardsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesSmartcards | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._acpi?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.acpi = this._acpi?.internalValue;
    }
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._alias?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.alias = this._alias?.internalValue;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._hostCerts?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostCerts = this._hostCerts?.internalValue;
    }
    if (this._passthrough?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.passthrough = this._passthrough?.internalValue;
    }
    if (this._protocol?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesSmartcards | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._acpi.internalValue = undefined;
      this._address.internalValue = undefined;
      this._alias.internalValue = undefined;
      this._database = undefined;
      this._host = undefined;
      this._hostCerts.internalValue = undefined;
      this._passthrough.internalValue = undefined;
      this._protocol.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._acpi.internalValue = value.acpi;
      this._address.internalValue = value.address;
      this._alias.internalValue = value.alias;
      this._database = value.database;
      this._host = value.host;
      this._hostCerts.internalValue = value.hostCerts;
      this._passthrough.internalValue = value.passthrough;
      this._protocol.internalValue = value.protocol;
    }
  }

  // acpi - computed: false, optional: true, required: false
  private _acpi = new DomainDevicesSmartcardsAcpiOutputReference(this, "acpi");
  public get acpi() {
    return this._acpi;
  }
  public putAcpi(value: DomainDevicesSmartcardsAcpi) {
    this._acpi.internalValue = value;
  }
  public resetAcpi() {
    this._acpi.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get acpiInput() {
    return this._acpi.internalValue;
  }

  // address - computed: false, optional: true, required: false
  private _address = new DomainDevicesSmartcardsAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DomainDevicesSmartcardsAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // alias - computed: false, optional: true, required: false
  private _alias = new DomainDevicesSmartcardsAliasOutputReference(this, "alias");
  public get alias() {
    return this._alias;
  }
  public putAlias(value: DomainDevicesSmartcardsAlias) {
    this._alias.internalValue = value;
  }
  public resetAlias() {
    this._alias.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aliasInput() {
    return this._alias.internalValue;
  }

  // database - computed: false, optional: true, required: false
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  public resetDatabase() {
    this._database = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // host - computed: false, optional: true, required: false
  private _host?: boolean | cdktf.IResolvable; 
  public get host() {
    return this.getBooleanAttribute('host');
  }
  public set host(value: boolean | cdktf.IResolvable) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // host_certs - computed: false, optional: true, required: false
  private _hostCerts = new DomainDevicesSmartcardsHostCertsList(this, "host_certs", false);
  public get hostCerts() {
    return this._hostCerts;
  }
  public putHostCerts(value: DomainDevicesSmartcardsHostCerts[] | cdktf.IResolvable) {
    this._hostCerts.internalValue = value;
  }
  public resetHostCerts() {
    this._hostCerts.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostCertsInput() {
    return this._hostCerts.internalValue;
  }

  // passthrough - computed: false, optional: true, required: false
  private _passthrough = new DomainDevicesSmartcardsPassthroughOutputReference(this, "passthrough");
  public get passthrough() {
    return this._passthrough;
  }
  public putPassthrough(value: DomainDevicesSmartcardsPassthrough) {
    this._passthrough.internalValue = value;
  }
  public resetPassthrough() {
    this._passthrough.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passthroughInput() {
    return this._passthrough.internalValue;
  }

  // protocol - computed: false, optional: true, required: false
  private _protocol = new DomainDevicesSmartcardsProtocolOutputReference(this, "protocol");
  public get protocol() {
    return this._protocol;
  }
  public putProtocol(value: DomainDevicesSmartcardsProtocol) {
    this._protocol.internalValue = value;
  }
  public resetProtocol() {
    this._protocol.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol.internalValue;
  }
}

export class DomainDevicesSmartcardsList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesSmartcards[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesSmartcardsOutputReference {
    return new DomainDevicesSmartcardsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesSoundsAcpi {
  /**
  * Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#pstore>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#index Domain#index}
  */
  readonly index?: number;
}

export function domainDevicesSoundsAcpiToTerraform(struct?: DomainDevicesSoundsAcpi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    index: cdktf.numberToTerraform(struct!.index),
  }
}


export function domainDevicesSoundsAcpiToHclTerraform(struct?: DomainDevicesSoundsAcpi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    index: {
      value: cdktf.numberToHclTerraform(struct!.index),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesSoundsAcpiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesSoundsAcpi | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._index !== undefined) {
      hasAnyValues = true;
      internalValueResult.index = this._index;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesSoundsAcpi | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._index = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._index = value.index;
    }
  }

  // index - computed: false, optional: true, required: false
  private _index?: number; 
  public get index() {
    return this.getNumberAttribute('index');
  }
  public set index(value: number) {
    this._index = value;
  }
  public resetIndex() {
    this._index = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get indexInput() {
    return this._index;
  }
}
export interface DomainDevicesSoundsAddress {
}

export function domainDevicesSoundsAddressToTerraform(struct?: DomainDevicesSoundsAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function domainDevicesSoundsAddressToHclTerraform(struct?: DomainDevicesSoundsAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DomainDevicesSoundsAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesSoundsAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesSoundsAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DomainDevicesSoundsAlias {
  /**
  * Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
}

export function domainDevicesSoundsAliasToTerraform(struct?: DomainDevicesSoundsAlias | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function domainDevicesSoundsAliasToHclTerraform(struct?: DomainDevicesSoundsAlias | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesSoundsAliasOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesSoundsAlias | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesSoundsAlias | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DomainDevicesSoundsAudio {
}

export function domainDevicesSoundsAudioToTerraform(struct?: DomainDevicesSoundsAudio | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function domainDevicesSoundsAudioToHclTerraform(struct?: DomainDevicesSoundsAudio | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DomainDevicesSoundsAudioOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesSoundsAudio | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesSoundsAudio | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }

  // id - computed: true, optional: false, required: false
  public get id() {
    return this.getNumberAttribute('id');
  }
}
export interface DomainDevicesSoundsCodec {
  /**
  * Sets the audio codec type used by the sound device (for example, a specific codec profile or format string supported by the chosen sound model).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type: string;
}

export function domainDevicesSoundsCodecToTerraform(struct?: DomainDevicesSoundsCodec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function domainDevicesSoundsCodecToHclTerraform(struct?: DomainDevicesSoundsCodec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesSoundsCodecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesSoundsCodec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesSoundsCodec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._type = value.type;
    }
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}

export class DomainDevicesSoundsCodecList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesSoundsCodec[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesSoundsCodecOutputReference {
    return new DomainDevicesSoundsCodecOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesSoundsDriver {
  /**
  * Enables or disables Address Translation Service (ATS) support for a virtio-based sound device; value is typically "on" or "off".
  * 
  * See: <https://libvirt.org/formatdomain.html#virtio-related-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#ats Domain#ats}
  */
  readonly ats?: string;
  /**
  * Enables or disables use of the emulated IOMMU for the virtio-based sound device; value is typically "on" or "off".
  * 
  * See: <https://libvirt.org/formatdomain.html#virtio-related-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#iommu Domain#iommu}
  */
  readonly iommu?: string;
  /**
  * Enables or disables packed virtqueue format for a virtio-based sound device to potentially improve performance; value is typically "on" or "off".
  * 
  * See: <https://libvirt.org/formatdomain.html#virtio-related-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#packed Domain#packed}
  */
  readonly packed?: string;
  /**
  * Enables or disables allocation of a separate page per virtqueue for the virtio-based sound device; value is typically "on" or "off".
  * 
  * See: <https://libvirt.org/formatdomain.html#virtio-related-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#page_per_vq Domain#page_per_vq}
  */
  readonly pagePerVq?: string;
}

export function domainDevicesSoundsDriverToTerraform(struct?: DomainDevicesSoundsDriver | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ats: cdktf.stringToTerraform(struct!.ats),
    iommu: cdktf.stringToTerraform(struct!.iommu),
    packed: cdktf.stringToTerraform(struct!.packed),
    page_per_vq: cdktf.stringToTerraform(struct!.pagePerVq),
  }
}


export function domainDevicesSoundsDriverToHclTerraform(struct?: DomainDevicesSoundsDriver | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ats: {
      value: cdktf.stringToHclTerraform(struct!.ats),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    iommu: {
      value: cdktf.stringToHclTerraform(struct!.iommu),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    packed: {
      value: cdktf.stringToHclTerraform(struct!.packed),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    page_per_vq: {
      value: cdktf.stringToHclTerraform(struct!.pagePerVq),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesSoundsDriverOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesSoundsDriver | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ats !== undefined) {
      hasAnyValues = true;
      internalValueResult.ats = this._ats;
    }
    if (this._iommu !== undefined) {
      hasAnyValues = true;
      internalValueResult.iommu = this._iommu;
    }
    if (this._packed !== undefined) {
      hasAnyValues = true;
      internalValueResult.packed = this._packed;
    }
    if (this._pagePerVq !== undefined) {
      hasAnyValues = true;
      internalValueResult.pagePerVq = this._pagePerVq;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesSoundsDriver | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ats = undefined;
      this._iommu = undefined;
      this._packed = undefined;
      this._pagePerVq = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ats = value.ats;
      this._iommu = value.iommu;
      this._packed = value.packed;
      this._pagePerVq = value.pagePerVq;
    }
  }

  // ats - computed: false, optional: true, required: false
  private _ats?: string; 
  public get ats() {
    return this.getStringAttribute('ats');
  }
  public set ats(value: string) {
    this._ats = value;
  }
  public resetAts() {
    this._ats = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get atsInput() {
    return this._ats;
  }

  // iommu - computed: false, optional: true, required: false
  private _iommu?: string; 
  public get iommu() {
    return this.getStringAttribute('iommu');
  }
  public set iommu(value: string) {
    this._iommu = value;
  }
  public resetIommu() {
    this._iommu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get iommuInput() {
    return this._iommu;
  }

  // packed - computed: false, optional: true, required: false
  private _packed?: string; 
  public get packed() {
    return this.getStringAttribute('packed');
  }
  public set packed(value: string) {
    this._packed = value;
  }
  public resetPacked() {
    this._packed = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get packedInput() {
    return this._packed;
  }

  // page_per_vq - computed: false, optional: true, required: false
  private _pagePerVq?: string; 
  public get pagePerVq() {
    return this.getStringAttribute('page_per_vq');
  }
  public set pagePerVq(value: string) {
    this._pagePerVq = value;
  }
  public resetPagePerVq() {
    this._pagePerVq = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pagePerVqInput() {
    return this._pagePerVq;
  }
}
export interface DomainDevicesSounds {
  /**
  * Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#acpi Domain#acpi}
  */
  readonly acpi?: DomainDevicesSoundsAcpi;
  /**
  * Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: DomainDevicesSoundsAddress;
  /**
  * Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#alias Domain#alias}
  */
  readonly alias?: DomainDevicesSoundsAlias;
  /**
  * Associates the sound device with a specific host audio backend instance (by ID) when multiple audio backends are defined.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#audio Domain#audio}
  */
  readonly audio?: DomainDevicesSoundsAudio;
  /**
  * Configures the audio codec parameters for the sound device; contents and allowed values depend on the selected model and hypervisor support.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#codec Domain#codec}
  */
  readonly codec?: DomainDevicesSoundsCodec[] | cdktf.IResolvable;
  /**
  * Configures virtio transport–related driver options for virtio-based sound devices.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#driver Domain#driver}
  */
  readonly driver?: DomainDevicesSoundsDriver;
  /**
  * Sets the emulated sound card model presented to the guest; valid values include "ac97", "es1370", "sb16", "ich6", "ich7", "ich9", "pcspk", and "virtio".
  * 
  * See: <https://libvirt.org/formatdomain.html#sound-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model: string;
  /**
  * Sets whether the emulated sound device exposes multichannel audio support; accepts a boolean-like value (for example, "on"/"off" or "yes"/"no") as supported by the chosen sound model and hypervisor.
  * 
  * See: <https://libvirt.org/formatdomain.html#sound-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#multi_channel Domain#multi_channel}
  */
  readonly multiChannel?: string;
  /**
  * Sets the maximum number of simultaneous audio streams the sound device can handle; value is user-provided and must be a non-negative integer supported by the selected sound model.
  * 
  * See: <https://libvirt.org/formatdomain.html#sound-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#streams Domain#streams}
  */
  readonly streams?: number;
}

export function domainDevicesSoundsToTerraform(struct?: DomainDevicesSounds | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    acpi: domainDevicesSoundsAcpiToTerraform(struct!.acpi),
    address: domainDevicesSoundsAddressToTerraform(struct!.address),
    alias: domainDevicesSoundsAliasToTerraform(struct!.alias),
    audio: domainDevicesSoundsAudioToTerraform(struct!.audio),
    codec: cdktf.listMapper(domainDevicesSoundsCodecToTerraform, false)(struct!.codec),
    driver: domainDevicesSoundsDriverToTerraform(struct!.driver),
    model: cdktf.stringToTerraform(struct!.model),
    multi_channel: cdktf.stringToTerraform(struct!.multiChannel),
    streams: cdktf.numberToTerraform(struct!.streams),
  }
}


export function domainDevicesSoundsToHclTerraform(struct?: DomainDevicesSounds | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    acpi: {
      value: domainDevicesSoundsAcpiToHclTerraform(struct!.acpi),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSoundsAcpi",
    },
    address: {
      value: domainDevicesSoundsAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSoundsAddress",
    },
    alias: {
      value: domainDevicesSoundsAliasToHclTerraform(struct!.alias),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSoundsAlias",
    },
    audio: {
      value: domainDevicesSoundsAudioToHclTerraform(struct!.audio),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSoundsAudio",
    },
    codec: {
      value: cdktf.listMapperHcl(domainDevicesSoundsCodecToHclTerraform, false)(struct!.codec),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesSoundsCodecList",
    },
    driver: {
      value: domainDevicesSoundsDriverToHclTerraform(struct!.driver),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesSoundsDriver",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    multi_channel: {
      value: cdktf.stringToHclTerraform(struct!.multiChannel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streams: {
      value: cdktf.numberToHclTerraform(struct!.streams),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesSoundsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesSounds | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._acpi?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.acpi = this._acpi?.internalValue;
    }
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._alias?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.alias = this._alias?.internalValue;
    }
    if (this._audio?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.audio = this._audio?.internalValue;
    }
    if (this._codec?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.codec = this._codec?.internalValue;
    }
    if (this._driver?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.driver = this._driver?.internalValue;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._multiChannel !== undefined) {
      hasAnyValues = true;
      internalValueResult.multiChannel = this._multiChannel;
    }
    if (this._streams !== undefined) {
      hasAnyValues = true;
      internalValueResult.streams = this._streams;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesSounds | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._acpi.internalValue = undefined;
      this._address.internalValue = undefined;
      this._alias.internalValue = undefined;
      this._audio.internalValue = undefined;
      this._codec.internalValue = undefined;
      this._driver.internalValue = undefined;
      this._model = undefined;
      this._multiChannel = undefined;
      this._streams = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._acpi.internalValue = value.acpi;
      this._address.internalValue = value.address;
      this._alias.internalValue = value.alias;
      this._audio.internalValue = value.audio;
      this._codec.internalValue = value.codec;
      this._driver.internalValue = value.driver;
      this._model = value.model;
      this._multiChannel = value.multiChannel;
      this._streams = value.streams;
    }
  }

  // acpi - computed: false, optional: true, required: false
  private _acpi = new DomainDevicesSoundsAcpiOutputReference(this, "acpi");
  public get acpi() {
    return this._acpi;
  }
  public putAcpi(value: DomainDevicesSoundsAcpi) {
    this._acpi.internalValue = value;
  }
  public resetAcpi() {
    this._acpi.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get acpiInput() {
    return this._acpi.internalValue;
  }

  // address - computed: false, optional: true, required: false
  private _address = new DomainDevicesSoundsAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DomainDevicesSoundsAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // alias - computed: false, optional: true, required: false
  private _alias = new DomainDevicesSoundsAliasOutputReference(this, "alias");
  public get alias() {
    return this._alias;
  }
  public putAlias(value: DomainDevicesSoundsAlias) {
    this._alias.internalValue = value;
  }
  public resetAlias() {
    this._alias.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aliasInput() {
    return this._alias.internalValue;
  }

  // audio - computed: false, optional: true, required: false
  private _audio = new DomainDevicesSoundsAudioOutputReference(this, "audio");
  public get audio() {
    return this._audio;
  }
  public putAudio(value: DomainDevicesSoundsAudio) {
    this._audio.internalValue = value;
  }
  public resetAudio() {
    this._audio.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get audioInput() {
    return this._audio.internalValue;
  }

  // codec - computed: false, optional: true, required: false
  private _codec = new DomainDevicesSoundsCodecList(this, "codec", false);
  public get codec() {
    return this._codec;
  }
  public putCodec(value: DomainDevicesSoundsCodec[] | cdktf.IResolvable) {
    this._codec.internalValue = value;
  }
  public resetCodec() {
    this._codec.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get codecInput() {
    return this._codec.internalValue;
  }

  // driver - computed: false, optional: true, required: false
  private _driver = new DomainDevicesSoundsDriverOutputReference(this, "driver");
  public get driver() {
    return this._driver;
  }
  public putDriver(value: DomainDevicesSoundsDriver) {
    this._driver.internalValue = value;
  }
  public resetDriver() {
    this._driver.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get driverInput() {
    return this._driver.internalValue;
  }

  // model - computed: false, optional: false, required: true
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // multi_channel - computed: false, optional: true, required: false
  private _multiChannel?: string; 
  public get multiChannel() {
    return this.getStringAttribute('multi_channel');
  }
  public set multiChannel(value: string) {
    this._multiChannel = value;
  }
  public resetMultiChannel() {
    this._multiChannel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get multiChannelInput() {
    return this._multiChannel;
  }

  // streams - computed: false, optional: true, required: false
  private _streams?: number; 
  public get streams() {
    return this.getNumberAttribute('streams');
  }
  public set streams(value: number) {
    this._streams = value;
  }
  public resetStreams() {
    this._streams = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamsInput() {
    return this._streams;
  }
}

export class DomainDevicesSoundsList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesSounds[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesSoundsOutputReference {
    return new DomainDevicesSoundsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesTpmsAcpi {
  /**
  * Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#pstore>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#index Domain#index}
  */
  readonly index?: number;
}

export function domainDevicesTpmsAcpiToTerraform(struct?: DomainDevicesTpmsAcpi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    index: cdktf.numberToTerraform(struct!.index),
  }
}


export function domainDevicesTpmsAcpiToHclTerraform(struct?: DomainDevicesTpmsAcpi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    index: {
      value: cdktf.numberToHclTerraform(struct!.index),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesTpmsAcpiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesTpmsAcpi | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._index !== undefined) {
      hasAnyValues = true;
      internalValueResult.index = this._index;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesTpmsAcpi | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._index = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._index = value.index;
    }
  }

  // index - computed: false, optional: true, required: false
  private _index?: number; 
  public get index() {
    return this.getNumberAttribute('index');
  }
  public set index(value: number) {
    this._index = value;
  }
  public resetIndex() {
    this._index = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get indexInput() {
    return this._index;
  }
}
export interface DomainDevicesTpmsAddress {
}

export function domainDevicesTpmsAddressToTerraform(struct?: DomainDevicesTpmsAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function domainDevicesTpmsAddressToHclTerraform(struct?: DomainDevicesTpmsAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DomainDevicesTpmsAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesTpmsAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesTpmsAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DomainDevicesTpmsAlias {
  /**
  * Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
}

export function domainDevicesTpmsAliasToTerraform(struct?: DomainDevicesTpmsAlias | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function domainDevicesTpmsAliasToHclTerraform(struct?: DomainDevicesTpmsAlias | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesTpmsAliasOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesTpmsAlias | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesTpmsAlias | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DomainDevicesTpmsBackendEmulatorActivePcrBanks {
  /**
  * Presence-only flag that enables a SHA‑1 PCR bank in the emulated TPM when set to true; omitting or setting false leaves it disabled.
  * 
  * See: <https://libvirt.org/formatdomain.html#tpm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sha1 Domain#sha1}
  */
  readonly sha1?: boolean | cdktf.IResolvable;
  /**
  * Presence-only flag that enables a SHA‑256 PCR bank in the emulated TPM when set to true; omitting or setting false leaves it disabled.
  * 
  * See: <https://libvirt.org/formatdomain.html#tpm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sha256 Domain#sha256}
  */
  readonly sha256?: boolean | cdktf.IResolvable;
  /**
  * Presence-only flag that enables a SHA‑384 PCR bank in the emulated TPM when set to true; omitting or setting false leaves it disabled.
  * 
  * See: <https://libvirt.org/formatdomain.html#tpm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sha384 Domain#sha384}
  */
  readonly sha384?: boolean | cdktf.IResolvable;
  /**
  * Presence-only flag that enables a SHA‑512 PCR bank in the emulated TPM when set to true; omitting or setting false leaves it disabled.
  * 
  * See: <https://libvirt.org/formatdomain.html#tpm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sha512 Domain#sha512}
  */
  readonly sha512?: boolean | cdktf.IResolvable;
}

export function domainDevicesTpmsBackendEmulatorActivePcrBanksToTerraform(struct?: DomainDevicesTpmsBackendEmulatorActivePcrBanks | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    sha1: cdktf.booleanToTerraform(struct!.sha1),
    sha256: cdktf.booleanToTerraform(struct!.sha256),
    sha384: cdktf.booleanToTerraform(struct!.sha384),
    sha512: cdktf.booleanToTerraform(struct!.sha512),
  }
}


export function domainDevicesTpmsBackendEmulatorActivePcrBanksToHclTerraform(struct?: DomainDevicesTpmsBackendEmulatorActivePcrBanks | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    sha1: {
      value: cdktf.booleanToHclTerraform(struct!.sha1),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    sha256: {
      value: cdktf.booleanToHclTerraform(struct!.sha256),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    sha384: {
      value: cdktf.booleanToHclTerraform(struct!.sha384),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    sha512: {
      value: cdktf.booleanToHclTerraform(struct!.sha512),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesTpmsBackendEmulatorActivePcrBanksOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesTpmsBackendEmulatorActivePcrBanks | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._sha1 !== undefined) {
      hasAnyValues = true;
      internalValueResult.sha1 = this._sha1;
    }
    if (this._sha256 !== undefined) {
      hasAnyValues = true;
      internalValueResult.sha256 = this._sha256;
    }
    if (this._sha384 !== undefined) {
      hasAnyValues = true;
      internalValueResult.sha384 = this._sha384;
    }
    if (this._sha512 !== undefined) {
      hasAnyValues = true;
      internalValueResult.sha512 = this._sha512;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesTpmsBackendEmulatorActivePcrBanks | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._sha1 = undefined;
      this._sha256 = undefined;
      this._sha384 = undefined;
      this._sha512 = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._sha1 = value.sha1;
      this._sha256 = value.sha256;
      this._sha384 = value.sha384;
      this._sha512 = value.sha512;
    }
  }

  // sha1 - computed: false, optional: true, required: false
  private _sha1?: boolean | cdktf.IResolvable; 
  public get sha1() {
    return this.getBooleanAttribute('sha1');
  }
  public set sha1(value: boolean | cdktf.IResolvable) {
    this._sha1 = value;
  }
  public resetSha1() {
    this._sha1 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sha1Input() {
    return this._sha1;
  }

  // sha256 - computed: false, optional: true, required: false
  private _sha256?: boolean | cdktf.IResolvable; 
  public get sha256() {
    return this.getBooleanAttribute('sha256');
  }
  public set sha256(value: boolean | cdktf.IResolvable) {
    this._sha256 = value;
  }
  public resetSha256() {
    this._sha256 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sha256Input() {
    return this._sha256;
  }

  // sha384 - computed: false, optional: true, required: false
  private _sha384?: boolean | cdktf.IResolvable; 
  public get sha384() {
    return this.getBooleanAttribute('sha384');
  }
  public set sha384(value: boolean | cdktf.IResolvable) {
    this._sha384 = value;
  }
  public resetSha384() {
    this._sha384 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sha384Input() {
    return this._sha384;
  }

  // sha512 - computed: false, optional: true, required: false
  private _sha512?: boolean | cdktf.IResolvable; 
  public get sha512() {
    return this.getBooleanAttribute('sha512');
  }
  public set sha512(value: boolean | cdktf.IResolvable) {
    this._sha512 = value;
  }
  public resetSha512() {
    this._sha512 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sha512Input() {
    return this._sha512;
  }
}
export interface DomainDevicesTpmsBackendEmulatorEncryption {
  /**
  * Specifies the identifier of the libvirt secret used to encrypt the emulated TPM’s persistent state; value is user-provided and must match a defined secret.
  * 
  * See: <https://libvirt.org/formatdomain.html#tpm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#secret Domain#secret}
  */
  readonly secret: string;
}

export function domainDevicesTpmsBackendEmulatorEncryptionToTerraform(struct?: DomainDevicesTpmsBackendEmulatorEncryption | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret: cdktf.stringToTerraform(struct!.secret),
  }
}


export function domainDevicesTpmsBackendEmulatorEncryptionToHclTerraform(struct?: DomainDevicesTpmsBackendEmulatorEncryption | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret: {
      value: cdktf.stringToHclTerraform(struct!.secret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesTpmsBackendEmulatorEncryptionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesTpmsBackendEmulatorEncryption | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secret !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesTpmsBackendEmulatorEncryption | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secret = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secret = value.secret;
    }
  }

  // secret - computed: false, optional: false, required: true
  private _secret?: string; 
  public get secret() {
    return this.getStringAttribute('secret');
  }
  public set secret(value: string) {
    this._secret = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret;
  }
}
export interface DomainDevicesTpmsBackendEmulatorProfile {
  /**
  * Sets the name of the swtpm emulator profile to apply, selecting a specific preconfigured TPM profile; the value is user-provided (for example, "qemu").
  * 
  * See: <https://libvirt.org/formatdomain.html#tpm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name?: string;
  /**
  * Sets whether disabled PCR banks are removed from the TPM profile presented to the guest; accepts "yes" or "no".
  * 
  * See: <https://libvirt.org/formatdomain.html#tpm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#remove_disabled Domain#remove_disabled}
  */
  readonly removeDisabled?: string;
  /**
  * Sets an optional identifier of the profile source for the TPM emulator profile (for example, a configuration database or profile namespace); the value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#tpm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#source Domain#source}
  */
  readonly source?: string;
}

export function domainDevicesTpmsBackendEmulatorProfileToTerraform(struct?: DomainDevicesTpmsBackendEmulatorProfile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    remove_disabled: cdktf.stringToTerraform(struct!.removeDisabled),
    source: cdktf.stringToTerraform(struct!.source),
  }
}


export function domainDevicesTpmsBackendEmulatorProfileToHclTerraform(struct?: DomainDevicesTpmsBackendEmulatorProfile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    remove_disabled: {
      value: cdktf.stringToHclTerraform(struct!.removeDisabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    source: {
      value: cdktf.stringToHclTerraform(struct!.source),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesTpmsBackendEmulatorProfileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesTpmsBackendEmulatorProfile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._removeDisabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeDisabled = this._removeDisabled;
    }
    if (this._source !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesTpmsBackendEmulatorProfile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._removeDisabled = undefined;
      this._source = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._removeDisabled = value.removeDisabled;
      this._source = value.source;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // remove_disabled - computed: false, optional: true, required: false
  private _removeDisabled?: string; 
  public get removeDisabled() {
    return this.getStringAttribute('remove_disabled');
  }
  public set removeDisabled(value: string) {
    this._removeDisabled = value;
  }
  public resetRemoveDisabled() {
    this._removeDisabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeDisabledInput() {
    return this._removeDisabled;
  }

  // source - computed: false, optional: true, required: false
  private _source?: string; 
  public get source() {
    return this.getStringAttribute('source');
  }
  public set source(value: string) {
    this._source = value;
  }
  public resetSource() {
    this._source = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source;
  }
}
export interface DomainDevicesTpmsBackendEmulatorSourceDir {
  /**
  * Sets the host directory path used by the TPM emulator to store its state; the value is a host filesystem path (for example, "/var/lib/swtpm/localstate").
  * 
  * See: <https://libvirt.org/formatdomain.html#tpm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path?: string;
}

export function domainDevicesTpmsBackendEmulatorSourceDirToTerraform(struct?: DomainDevicesTpmsBackendEmulatorSourceDir | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function domainDevicesTpmsBackendEmulatorSourceDirToHclTerraform(struct?: DomainDevicesTpmsBackendEmulatorSourceDir | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesTpmsBackendEmulatorSourceDirOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesTpmsBackendEmulatorSourceDir | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesTpmsBackendEmulatorSourceDir | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
    }
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface DomainDevicesTpmsBackendEmulatorSourceFile {
  /**
  * Sets the host file path used by the TPM emulator to persist its state; the value is a host filesystem path (for example, "/var/lib/swtpm/state.tpm").
  * 
  * See: <https://libvirt.org/formatdomain.html#tpm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path?: string;
}

export function domainDevicesTpmsBackendEmulatorSourceFileToTerraform(struct?: DomainDevicesTpmsBackendEmulatorSourceFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function domainDevicesTpmsBackendEmulatorSourceFileToHclTerraform(struct?: DomainDevicesTpmsBackendEmulatorSourceFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesTpmsBackendEmulatorSourceFileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesTpmsBackendEmulatorSourceFile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesTpmsBackendEmulatorSourceFile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
    }
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface DomainDevicesTpmsBackendEmulatorSource {
  /**
  * Selects a directory-based backend for TPM emulator state and metadata storage.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dir Domain#dir}
  */
  readonly dir?: DomainDevicesTpmsBackendEmulatorSourceDir;
  /**
  * Selects a file-based backend for TPM emulator state, pointing directly at a state file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file?: DomainDevicesTpmsBackendEmulatorSourceFile;
}

export function domainDevicesTpmsBackendEmulatorSourceToTerraform(struct?: DomainDevicesTpmsBackendEmulatorSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dir: domainDevicesTpmsBackendEmulatorSourceDirToTerraform(struct!.dir),
    file: domainDevicesTpmsBackendEmulatorSourceFileToTerraform(struct!.file),
  }
}


export function domainDevicesTpmsBackendEmulatorSourceToHclTerraform(struct?: DomainDevicesTpmsBackendEmulatorSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dir: {
      value: domainDevicesTpmsBackendEmulatorSourceDirToHclTerraform(struct!.dir),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesTpmsBackendEmulatorSourceDir",
    },
    file: {
      value: domainDevicesTpmsBackendEmulatorSourceFileToHclTerraform(struct!.file),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesTpmsBackendEmulatorSourceFile",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesTpmsBackendEmulatorSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesTpmsBackendEmulatorSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dir?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dir = this._dir?.internalValue;
    }
    if (this._file?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesTpmsBackendEmulatorSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dir.internalValue = undefined;
      this._file.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dir.internalValue = value.dir;
      this._file.internalValue = value.file;
    }
  }

  // dir - computed: false, optional: true, required: false
  private _dir = new DomainDevicesTpmsBackendEmulatorSourceDirOutputReference(this, "dir");
  public get dir() {
    return this._dir;
  }
  public putDir(value: DomainDevicesTpmsBackendEmulatorSourceDir) {
    this._dir.internalValue = value;
  }
  public resetDir() {
    this._dir.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dirInput() {
    return this._dir.internalValue;
  }

  // file - computed: false, optional: true, required: false
  private _file = new DomainDevicesTpmsBackendEmulatorSourceFileOutputReference(this, "file");
  public get file() {
    return this._file;
  }
  public putFile(value: DomainDevicesTpmsBackendEmulatorSourceFile) {
    this._file.internalValue = value;
  }
  public resetFile() {
    this._file.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file.internalValue;
  }
}
export interface DomainDevicesTpmsBackendEmulator {
  /**
  * Defines which PCR banks are active in the emulated TPM backend by enabling specific hash algorithms as child elements.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#active_pcr_banks Domain#active_pcr_banks}
  */
  readonly activePcrBanks?: DomainDevicesTpmsBackendEmulatorActivePcrBanks;
  /**
  * Enables or configures debug output for the emulated TPM backend; accepts a backend-specific value such as a boolean-like flag or debug level.
  * 
  * See: <https://libvirt.org/formatdomain.html#tpm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#debug Domain#debug}
  */
  readonly debug?: number;
  /**
  * Enables encrypted state storage for the emulated TPM and points to the secret that protects the TPM state at rest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#encryption Domain#encryption}
  */
  readonly encryption?: DomainDevicesTpmsBackendEmulatorEncryption;
  /**
  * Controls whether the emulated TPM keeps its state persistently across guest reboots; accepts a boolean-like value (for example, "yes"/"no").
  * 
  * See: <https://libvirt.org/formatdomain.html#tpm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#persistent_state Domain#persistent_state}
  */
  readonly persistentState?: string;
  /**
  * Selects the TPM profile or version used by the emulator (for example, "1.2" or "2.0"), with allowed values depending on the emulator implementation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#profile Domain#profile}
  */
  readonly profile?: DomainDevicesTpmsBackendEmulatorProfile;
  /**
  * Configures the source location for the TPM emulator state, using either a directory or file sub-block.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#source Domain#source}
  */
  readonly source?: DomainDevicesTpmsBackendEmulatorSource;
  /**
  * Sets the TPM version that the emulator exposes to the guest; valid values are "1.2" or "2.0".
  * 
  * See: <https://libvirt.org/formatdomain.html#tpm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#version Domain#version}
  */
  readonly version?: string;
}

export function domainDevicesTpmsBackendEmulatorToTerraform(struct?: DomainDevicesTpmsBackendEmulator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    active_pcr_banks: domainDevicesTpmsBackendEmulatorActivePcrBanksToTerraform(struct!.activePcrBanks),
    debug: cdktf.numberToTerraform(struct!.debug),
    encryption: domainDevicesTpmsBackendEmulatorEncryptionToTerraform(struct!.encryption),
    persistent_state: cdktf.stringToTerraform(struct!.persistentState),
    profile: domainDevicesTpmsBackendEmulatorProfileToTerraform(struct!.profile),
    source: domainDevicesTpmsBackendEmulatorSourceToTerraform(struct!.source),
    version: cdktf.stringToTerraform(struct!.version),
  }
}


export function domainDevicesTpmsBackendEmulatorToHclTerraform(struct?: DomainDevicesTpmsBackendEmulator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    active_pcr_banks: {
      value: domainDevicesTpmsBackendEmulatorActivePcrBanksToHclTerraform(struct!.activePcrBanks),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesTpmsBackendEmulatorActivePcrBanks",
    },
    debug: {
      value: cdktf.numberToHclTerraform(struct!.debug),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    encryption: {
      value: domainDevicesTpmsBackendEmulatorEncryptionToHclTerraform(struct!.encryption),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesTpmsBackendEmulatorEncryption",
    },
    persistent_state: {
      value: cdktf.stringToHclTerraform(struct!.persistentState),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    profile: {
      value: domainDevicesTpmsBackendEmulatorProfileToHclTerraform(struct!.profile),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesTpmsBackendEmulatorProfile",
    },
    source: {
      value: domainDevicesTpmsBackendEmulatorSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesTpmsBackendEmulatorSource",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesTpmsBackendEmulatorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesTpmsBackendEmulator | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._activePcrBanks?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.activePcrBanks = this._activePcrBanks?.internalValue;
    }
    if (this._debug !== undefined) {
      hasAnyValues = true;
      internalValueResult.debug = this._debug;
    }
    if (this._encryption?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.encryption = this._encryption?.internalValue;
    }
    if (this._persistentState !== undefined) {
      hasAnyValues = true;
      internalValueResult.persistentState = this._persistentState;
    }
    if (this._profile?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.profile = this._profile?.internalValue;
    }
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesTpmsBackendEmulator | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._activePcrBanks.internalValue = undefined;
      this._debug = undefined;
      this._encryption.internalValue = undefined;
      this._persistentState = undefined;
      this._profile.internalValue = undefined;
      this._source.internalValue = undefined;
      this._version = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._activePcrBanks.internalValue = value.activePcrBanks;
      this._debug = value.debug;
      this._encryption.internalValue = value.encryption;
      this._persistentState = value.persistentState;
      this._profile.internalValue = value.profile;
      this._source.internalValue = value.source;
      this._version = value.version;
    }
  }

  // active_pcr_banks - computed: false, optional: true, required: false
  private _activePcrBanks = new DomainDevicesTpmsBackendEmulatorActivePcrBanksOutputReference(this, "active_pcr_banks");
  public get activePcrBanks() {
    return this._activePcrBanks;
  }
  public putActivePcrBanks(value: DomainDevicesTpmsBackendEmulatorActivePcrBanks) {
    this._activePcrBanks.internalValue = value;
  }
  public resetActivePcrBanks() {
    this._activePcrBanks.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get activePcrBanksInput() {
    return this._activePcrBanks.internalValue;
  }

  // debug - computed: false, optional: true, required: false
  private _debug?: number; 
  public get debug() {
    return this.getNumberAttribute('debug');
  }
  public set debug(value: number) {
    this._debug = value;
  }
  public resetDebug() {
    this._debug = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get debugInput() {
    return this._debug;
  }

  // encryption - computed: false, optional: true, required: false
  private _encryption = new DomainDevicesTpmsBackendEmulatorEncryptionOutputReference(this, "encryption");
  public get encryption() {
    return this._encryption;
  }
  public putEncryption(value: DomainDevicesTpmsBackendEmulatorEncryption) {
    this._encryption.internalValue = value;
  }
  public resetEncryption() {
    this._encryption.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get encryptionInput() {
    return this._encryption.internalValue;
  }

  // persistent_state - computed: false, optional: true, required: false
  private _persistentState?: string; 
  public get persistentState() {
    return this.getStringAttribute('persistent_state');
  }
  public set persistentState(value: string) {
    this._persistentState = value;
  }
  public resetPersistentState() {
    this._persistentState = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get persistentStateInput() {
    return this._persistentState;
  }

  // profile - computed: false, optional: true, required: false
  private _profile = new DomainDevicesTpmsBackendEmulatorProfileOutputReference(this, "profile");
  public get profile() {
    return this._profile;
  }
  public putProfile(value: DomainDevicesTpmsBackendEmulatorProfile) {
    this._profile.internalValue = value;
  }
  public resetProfile() {
    this._profile.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get profileInput() {
    return this._profile.internalValue;
  }

  // source - computed: false, optional: true, required: false
  private _source = new DomainDevicesTpmsBackendEmulatorSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: DomainDevicesTpmsBackendEmulatorSource) {
    this._source.internalValue = value;
  }
  public resetSource() {
    this._source.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }

  // version - computed: false, optional: true, required: false
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }
}
export interface DomainDevicesTpmsBackendExternalSourceDbus {
  /**
  * Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#channel Domain#channel}
  */
  readonly channel?: string;
}

export function domainDevicesTpmsBackendExternalSourceDbusToTerraform(struct?: DomainDevicesTpmsBackendExternalSourceDbus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    channel: cdktf.stringToTerraform(struct!.channel),
  }
}


export function domainDevicesTpmsBackendExternalSourceDbusToHclTerraform(struct?: DomainDevicesTpmsBackendExternalSourceDbus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    channel: {
      value: cdktf.stringToHclTerraform(struct!.channel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesTpmsBackendExternalSourceDbusOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesTpmsBackendExternalSourceDbus | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._channel !== undefined) {
      hasAnyValues = true;
      internalValueResult.channel = this._channel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesTpmsBackendExternalSourceDbus | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._channel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._channel = value.channel;
    }
  }

  // channel - computed: false, optional: true, required: false
  private _channel?: string; 
  public get channel() {
    return this.getStringAttribute('channel');
  }
  public set channel(value: string) {
    this._channel = value;
  }
  public resetChannel() {
    this._channel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get channelInput() {
    return this._channel;
  }
}
export interface DomainDevicesTpmsBackendExternalSourceDevSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesTpmsBackendExternalSourceDevSecLabelToTerraform(struct?: DomainDevicesTpmsBackendExternalSourceDevSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesTpmsBackendExternalSourceDevSecLabelToHclTerraform(struct?: DomainDevicesTpmsBackendExternalSourceDevSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesTpmsBackendExternalSourceDevSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesTpmsBackendExternalSourceDevSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesTpmsBackendExternalSourceDevSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesTpmsBackendExternalSourceDevSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesTpmsBackendExternalSourceDevSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesTpmsBackendExternalSourceDevSecLabelOutputReference {
    return new DomainDevicesTpmsBackendExternalSourceDevSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesTpmsBackendExternalSourceDev {
  /**
  * Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesTpmsBackendExternalSourceDevSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesTpmsBackendExternalSourceDevToTerraform(struct?: DomainDevicesTpmsBackendExternalSourceDev | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesTpmsBackendExternalSourceDevSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesTpmsBackendExternalSourceDevToHclTerraform(struct?: DomainDevicesTpmsBackendExternalSourceDev | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesTpmsBackendExternalSourceDevSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesTpmsBackendExternalSourceDevSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesTpmsBackendExternalSourceDevOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesTpmsBackendExternalSourceDev | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesTpmsBackendExternalSourceDev | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesTpmsBackendExternalSourceDevSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesTpmsBackendExternalSourceDevSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesTpmsBackendExternalSourceFileSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesTpmsBackendExternalSourceFileSecLabelToTerraform(struct?: DomainDevicesTpmsBackendExternalSourceFileSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesTpmsBackendExternalSourceFileSecLabelToHclTerraform(struct?: DomainDevicesTpmsBackendExternalSourceFileSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesTpmsBackendExternalSourceFileSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesTpmsBackendExternalSourceFileSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesTpmsBackendExternalSourceFileSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesTpmsBackendExternalSourceFileSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesTpmsBackendExternalSourceFileSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesTpmsBackendExternalSourceFileSecLabelOutputReference {
    return new DomainDevicesTpmsBackendExternalSourceFileSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesTpmsBackendExternalSourceFile {
  /**
  * Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.
  * 
  * See: <https://libvirt.org/formatdomain.html#device-logfile>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#append Domain#append}
  */
  readonly append?: string;
  /**
  * Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesTpmsBackendExternalSourceFileSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesTpmsBackendExternalSourceFileToTerraform(struct?: DomainDevicesTpmsBackendExternalSourceFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.stringToTerraform(struct!.append),
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesTpmsBackendExternalSourceFileSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesTpmsBackendExternalSourceFileToHclTerraform(struct?: DomainDevicesTpmsBackendExternalSourceFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.stringToHclTerraform(struct!.append),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesTpmsBackendExternalSourceFileSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesTpmsBackendExternalSourceFileSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesTpmsBackendExternalSourceFileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesTpmsBackendExternalSourceFile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesTpmsBackendExternalSourceFile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append = value.append;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append?: string; 
  public get append() {
    return this.getStringAttribute('append');
  }
  public set append(value: string) {
    this._append = value;
  }
  public resetAppend() {
    this._append = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append;
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesTpmsBackendExternalSourceFileSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesTpmsBackendExternalSourceFileSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesTpmsBackendExternalSourceNmdm {
  /**
  * Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.
  * 
  * See: <https://libvirt.org/formatdomain.html#nmdm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#master Domain#master}
  */
  readonly master: string;
  /**
  * Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.
  * 
  * See: <https://libvirt.org/formatdomain.html#nmdm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#slave Domain#slave}
  */
  readonly slave: string;
}

export function domainDevicesTpmsBackendExternalSourceNmdmToTerraform(struct?: DomainDevicesTpmsBackendExternalSourceNmdm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    master: cdktf.stringToTerraform(struct!.master),
    slave: cdktf.stringToTerraform(struct!.slave),
  }
}


export function domainDevicesTpmsBackendExternalSourceNmdmToHclTerraform(struct?: DomainDevicesTpmsBackendExternalSourceNmdm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    master: {
      value: cdktf.stringToHclTerraform(struct!.master),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    slave: {
      value: cdktf.stringToHclTerraform(struct!.slave),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesTpmsBackendExternalSourceNmdmOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesTpmsBackendExternalSourceNmdm | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._master !== undefined) {
      hasAnyValues = true;
      internalValueResult.master = this._master;
    }
    if (this._slave !== undefined) {
      hasAnyValues = true;
      internalValueResult.slave = this._slave;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesTpmsBackendExternalSourceNmdm | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._master = undefined;
      this._slave = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._master = value.master;
      this._slave = value.slave;
    }
  }

  // master - computed: false, optional: false, required: true
  private _master?: string; 
  public get master() {
    return this.getStringAttribute('master');
  }
  public set master(value: string) {
    this._master = value;
  }
  // Temporarily expose input value. Use with caution.
  public get masterInput() {
    return this._master;
  }

  // slave - computed: false, optional: false, required: true
  private _slave?: string; 
  public get slave() {
    return this.getStringAttribute('slave');
  }
  public set slave(value: string) {
    this._slave = value;
  }
  // Temporarily expose input value. Use with caution.
  public get slaveInput() {
    return this._slave;
  }
}
export interface DomainDevicesTpmsBackendExternalSourcePipeSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesTpmsBackendExternalSourcePipeSecLabelToTerraform(struct?: DomainDevicesTpmsBackendExternalSourcePipeSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesTpmsBackendExternalSourcePipeSecLabelToHclTerraform(struct?: DomainDevicesTpmsBackendExternalSourcePipeSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesTpmsBackendExternalSourcePipeSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesTpmsBackendExternalSourcePipeSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesTpmsBackendExternalSourcePipeSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesTpmsBackendExternalSourcePipeSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesTpmsBackendExternalSourcePipeSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesTpmsBackendExternalSourcePipeSecLabelOutputReference {
    return new DomainDevicesTpmsBackendExternalSourcePipeSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesTpmsBackendExternalSourcePipe {
  /**
  * Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesTpmsBackendExternalSourcePipeSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesTpmsBackendExternalSourcePipeToTerraform(struct?: DomainDevicesTpmsBackendExternalSourcePipe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesTpmsBackendExternalSourcePipeSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesTpmsBackendExternalSourcePipeToHclTerraform(struct?: DomainDevicesTpmsBackendExternalSourcePipe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesTpmsBackendExternalSourcePipeSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesTpmsBackendExternalSourcePipeSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesTpmsBackendExternalSourcePipeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesTpmsBackendExternalSourcePipe | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesTpmsBackendExternalSourcePipe | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesTpmsBackendExternalSourcePipeSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesTpmsBackendExternalSourcePipeSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesTpmsBackendExternalSourcePtySecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesTpmsBackendExternalSourcePtySecLabelToTerraform(struct?: DomainDevicesTpmsBackendExternalSourcePtySecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesTpmsBackendExternalSourcePtySecLabelToHclTerraform(struct?: DomainDevicesTpmsBackendExternalSourcePtySecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesTpmsBackendExternalSourcePtySecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesTpmsBackendExternalSourcePtySecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesTpmsBackendExternalSourcePtySecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesTpmsBackendExternalSourcePtySecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesTpmsBackendExternalSourcePtySecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesTpmsBackendExternalSourcePtySecLabelOutputReference {
    return new DomainDevicesTpmsBackendExternalSourcePtySecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesTpmsBackendExternalSourcePty {
  /**
  * Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
  /**
  * Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesTpmsBackendExternalSourcePtySecLabel[] | cdktf.IResolvable;
}

export function domainDevicesTpmsBackendExternalSourcePtyToTerraform(struct?: DomainDevicesTpmsBackendExternalSourcePty | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    sec_label: cdktf.listMapper(domainDevicesTpmsBackendExternalSourcePtySecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesTpmsBackendExternalSourcePtyToHclTerraform(struct?: DomainDevicesTpmsBackendExternalSourcePty | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesTpmsBackendExternalSourcePtySecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesTpmsBackendExternalSourcePtySecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesTpmsBackendExternalSourcePtyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesTpmsBackendExternalSourcePty | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesTpmsBackendExternalSourcePty | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesTpmsBackendExternalSourcePtySecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesTpmsBackendExternalSourcePtySecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesTpmsBackendExternalSourceQemuvdAgentClipBoard {
  /**
  * Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#copy_paste Domain#copy_paste}
  */
  readonly copyPaste: string;
}

export function domainDevicesTpmsBackendExternalSourceQemuvdAgentClipBoardToTerraform(struct?: DomainDevicesTpmsBackendExternalSourceQemuvdAgentClipBoard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    copy_paste: cdktf.stringToTerraform(struct!.copyPaste),
  }
}


export function domainDevicesTpmsBackendExternalSourceQemuvdAgentClipBoardToHclTerraform(struct?: DomainDevicesTpmsBackendExternalSourceQemuvdAgentClipBoard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    copy_paste: {
      value: cdktf.stringToHclTerraform(struct!.copyPaste),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesTpmsBackendExternalSourceQemuvdAgentClipBoardOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesTpmsBackendExternalSourceQemuvdAgentClipBoard | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._copyPaste !== undefined) {
      hasAnyValues = true;
      internalValueResult.copyPaste = this._copyPaste;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesTpmsBackendExternalSourceQemuvdAgentClipBoard | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._copyPaste = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._copyPaste = value.copyPaste;
    }
  }

  // copy_paste - computed: false, optional: false, required: true
  private _copyPaste?: string; 
  public get copyPaste() {
    return this.getStringAttribute('copy_paste');
  }
  public set copyPaste(value: string) {
    this._copyPaste = value;
  }
  // Temporarily expose input value. Use with caution.
  public get copyPasteInput() {
    return this._copyPaste;
  }
}
export interface DomainDevicesTpmsBackendExternalSourceQemuvdAgentMouse {
  /**
  * Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).
  * 
  * See: <https://libvirt.org/formatdomain.html#channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode: string;
}

export function domainDevicesTpmsBackendExternalSourceQemuvdAgentMouseToTerraform(struct?: DomainDevicesTpmsBackendExternalSourceQemuvdAgentMouse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
  }
}


export function domainDevicesTpmsBackendExternalSourceQemuvdAgentMouseToHclTerraform(struct?: DomainDevicesTpmsBackendExternalSourceQemuvdAgentMouse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesTpmsBackendExternalSourceQemuvdAgentMouseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesTpmsBackendExternalSourceQemuvdAgentMouse | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesTpmsBackendExternalSourceQemuvdAgentMouse | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
    }
  }

  // mode - computed: false, optional: false, required: true
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }
}
export interface DomainDevicesTpmsBackendExternalSourceQemuvdAgent {
  /**
  * Configures clipboard-related behavior for the QEMU vdagent–based EGD source, controlling whether clipboard data exchange is allowed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#clip_board Domain#clip_board}
  */
  readonly clipBoard?: DomainDevicesTpmsBackendExternalSourceQemuvdAgentClipBoard;
  /**
  * Configures mouse integration options for the QEMU vdagent–based EGD source, such as how mouse events are handled.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mouse Domain#mouse}
  */
  readonly mouse?: DomainDevicesTpmsBackendExternalSourceQemuvdAgentMouse;
}

export function domainDevicesTpmsBackendExternalSourceQemuvdAgentToTerraform(struct?: DomainDevicesTpmsBackendExternalSourceQemuvdAgent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    clip_board: domainDevicesTpmsBackendExternalSourceQemuvdAgentClipBoardToTerraform(struct!.clipBoard),
    mouse: domainDevicesTpmsBackendExternalSourceQemuvdAgentMouseToTerraform(struct!.mouse),
  }
}


export function domainDevicesTpmsBackendExternalSourceQemuvdAgentToHclTerraform(struct?: DomainDevicesTpmsBackendExternalSourceQemuvdAgent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    clip_board: {
      value: domainDevicesTpmsBackendExternalSourceQemuvdAgentClipBoardToHclTerraform(struct!.clipBoard),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesTpmsBackendExternalSourceQemuvdAgentClipBoard",
    },
    mouse: {
      value: domainDevicesTpmsBackendExternalSourceQemuvdAgentMouseToHclTerraform(struct!.mouse),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesTpmsBackendExternalSourceQemuvdAgentMouse",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesTpmsBackendExternalSourceQemuvdAgentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesTpmsBackendExternalSourceQemuvdAgent | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clipBoard?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clipBoard = this._clipBoard?.internalValue;
    }
    if (this._mouse?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.mouse = this._mouse?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesTpmsBackendExternalSourceQemuvdAgent | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clipBoard.internalValue = undefined;
      this._mouse.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clipBoard.internalValue = value.clipBoard;
      this._mouse.internalValue = value.mouse;
    }
  }

  // clip_board - computed: false, optional: true, required: false
  private _clipBoard = new DomainDevicesTpmsBackendExternalSourceQemuvdAgentClipBoardOutputReference(this, "clip_board");
  public get clipBoard() {
    return this._clipBoard;
  }
  public putClipBoard(value: DomainDevicesTpmsBackendExternalSourceQemuvdAgentClipBoard) {
    this._clipBoard.internalValue = value;
  }
  public resetClipBoard() {
    this._clipBoard.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clipBoardInput() {
    return this._clipBoard.internalValue;
  }

  // mouse - computed: false, optional: true, required: false
  private _mouse = new DomainDevicesTpmsBackendExternalSourceQemuvdAgentMouseOutputReference(this, "mouse");
  public get mouse() {
    return this._mouse;
  }
  public putMouse(value: DomainDevicesTpmsBackendExternalSourceQemuvdAgentMouse) {
    this._mouse.internalValue = value;
  }
  public resetMouse() {
    this._mouse.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mouseInput() {
    return this._mouse.internalValue;
  }
}
export interface DomainDevicesTpmsBackendExternalSourceSpicePort {
  /**
  * Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#channel Domain#channel}
  */
  readonly channel: string;
}

export function domainDevicesTpmsBackendExternalSourceSpicePortToTerraform(struct?: DomainDevicesTpmsBackendExternalSourceSpicePort | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    channel: cdktf.stringToTerraform(struct!.channel),
  }
}


export function domainDevicesTpmsBackendExternalSourceSpicePortToHclTerraform(struct?: DomainDevicesTpmsBackendExternalSourceSpicePort | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    channel: {
      value: cdktf.stringToHclTerraform(struct!.channel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesTpmsBackendExternalSourceSpicePortOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesTpmsBackendExternalSourceSpicePort | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._channel !== undefined) {
      hasAnyValues = true;
      internalValueResult.channel = this._channel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesTpmsBackendExternalSourceSpicePort | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._channel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._channel = value.channel;
    }
  }

  // channel - computed: false, optional: false, required: true
  private _channel?: string; 
  public get channel() {
    return this.getStringAttribute('channel');
  }
  public set channel(value: string) {
    this._channel = value;
  }
  // Temporarily expose input value. Use with caution.
  public get channelInput() {
    return this._channel;
  }
}
export interface DomainDevicesTpmsBackendExternalSourceTcpReconnect {
  /**
  * Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enabled Domain#enabled}
  */
  readonly enabled: string;
  /**
  * Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#timeout Domain#timeout}
  */
  readonly timeout?: number;
}

export function domainDevicesTpmsBackendExternalSourceTcpReconnectToTerraform(struct?: DomainDevicesTpmsBackendExternalSourceTcpReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.stringToTerraform(struct!.enabled),
    timeout: cdktf.numberToTerraform(struct!.timeout),
  }
}


export function domainDevicesTpmsBackendExternalSourceTcpReconnectToHclTerraform(struct?: DomainDevicesTpmsBackendExternalSourceTcpReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.stringToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.numberToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesTpmsBackendExternalSourceTcpReconnectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesTpmsBackendExternalSourceTcpReconnect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesTpmsBackendExternalSourceTcpReconnect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._timeout = value.timeout;
    }
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: string; 
  public get enabled() {
    return this.getStringAttribute('enabled');
  }
  public set enabled(value: string) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: number; 
  public get timeout() {
    return this.getNumberAttribute('timeout');
  }
  public set timeout(value: number) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DomainDevicesTpmsBackendExternalSourceTcp {
  /**
  * Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#host Domain#host}
  */
  readonly host?: string;
  /**
  * Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode?: string;
  /**
  * Enables and configures automatic reconnection behavior for a UNIX socket–based EGD entropy source; the content and attributes are user-provided according to desired policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reconnect Domain#reconnect}
  */
  readonly reconnect?: DomainDevicesTpmsBackendExternalSourceTcpReconnect;
  /**
  * Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#service Domain#service}
  */
  readonly service?: string;
  /**
  * Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tls Domain#tls}
  */
  readonly tls?: string;
}

export function domainDevicesTpmsBackendExternalSourceTcpToTerraform(struct?: DomainDevicesTpmsBackendExternalSourceTcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    mode: cdktf.stringToTerraform(struct!.mode),
    reconnect: domainDevicesTpmsBackendExternalSourceTcpReconnectToTerraform(struct!.reconnect),
    service: cdktf.stringToTerraform(struct!.service),
    tls: cdktf.stringToTerraform(struct!.tls),
  }
}


export function domainDevicesTpmsBackendExternalSourceTcpToHclTerraform(struct?: DomainDevicesTpmsBackendExternalSourceTcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reconnect: {
      value: domainDevicesTpmsBackendExternalSourceTcpReconnectToHclTerraform(struct!.reconnect),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesTpmsBackendExternalSourceTcpReconnect",
    },
    service: {
      value: cdktf.stringToHclTerraform(struct!.service),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: cdktf.stringToHclTerraform(struct!.tls),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesTpmsBackendExternalSourceTcpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesTpmsBackendExternalSourceTcp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._reconnect?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.reconnect = this._reconnect?.internalValue;
    }
    if (this._service !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service;
    }
    if (this._tls !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesTpmsBackendExternalSourceTcp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host = undefined;
      this._mode = undefined;
      this._reconnect.internalValue = undefined;
      this._service = undefined;
      this._tls = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host = value.host;
      this._mode = value.mode;
      this._reconnect.internalValue = value.reconnect;
      this._service = value.service;
      this._tls = value.tls;
    }
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // reconnect - computed: false, optional: true, required: false
  private _reconnect = new DomainDevicesTpmsBackendExternalSourceTcpReconnectOutputReference(this, "reconnect");
  public get reconnect() {
    return this._reconnect;
  }
  public putReconnect(value: DomainDevicesTpmsBackendExternalSourceTcpReconnect) {
    this._reconnect.internalValue = value;
  }
  public resetReconnect() {
    this._reconnect.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reconnectInput() {
    return this._reconnect.internalValue;
  }

  // service - computed: false, optional: true, required: false
  private _service?: string; 
  public get service() {
    return this.getStringAttribute('service');
  }
  public set service(value: string) {
    this._service = value;
  }
  public resetService() {
    this._service = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service;
  }

  // tls - computed: false, optional: true, required: false
  private _tls?: string; 
  public get tls() {
    return this.getStringAttribute('tls');
  }
  public set tls(value: string) {
    this._tls = value;
  }
  public resetTls() {
    this._tls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls;
  }
}
export interface DomainDevicesTpmsBackendExternalSourceUdp {
  /**
  * Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bind_host Domain#bind_host}
  */
  readonly bindHost: string;
  /**
  * Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#bind_service Domain#bind_service}
  */
  readonly bindService: string;
  /**
  * Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#connect_host Domain#connect_host}
  */
  readonly connectHost: string;
  /**
  * Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#connect_service Domain#connect_service}
  */
  readonly connectService: string;
}

export function domainDevicesTpmsBackendExternalSourceUdpToTerraform(struct?: DomainDevicesTpmsBackendExternalSourceUdp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_host: cdktf.stringToTerraform(struct!.bindHost),
    bind_service: cdktf.stringToTerraform(struct!.bindService),
    connect_host: cdktf.stringToTerraform(struct!.connectHost),
    connect_service: cdktf.stringToTerraform(struct!.connectService),
  }
}


export function domainDevicesTpmsBackendExternalSourceUdpToHclTerraform(struct?: DomainDevicesTpmsBackendExternalSourceUdp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_host: {
      value: cdktf.stringToHclTerraform(struct!.bindHost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bind_service: {
      value: cdktf.stringToHclTerraform(struct!.bindService),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connect_host: {
      value: cdktf.stringToHclTerraform(struct!.connectHost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connect_service: {
      value: cdktf.stringToHclTerraform(struct!.connectService),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesTpmsBackendExternalSourceUdpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesTpmsBackendExternalSourceUdp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindHost !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindHost = this._bindHost;
    }
    if (this._bindService !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindService = this._bindService;
    }
    if (this._connectHost !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectHost = this._connectHost;
    }
    if (this._connectService !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectService = this._connectService;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesTpmsBackendExternalSourceUdp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bindHost = undefined;
      this._bindService = undefined;
      this._connectHost = undefined;
      this._connectService = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bindHost = value.bindHost;
      this._bindService = value.bindService;
      this._connectHost = value.connectHost;
      this._connectService = value.connectService;
    }
  }

  // bind_host - computed: false, optional: false, required: true
  private _bindHost?: string; 
  public get bindHost() {
    return this.getStringAttribute('bind_host');
  }
  public set bindHost(value: string) {
    this._bindHost = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bindHostInput() {
    return this._bindHost;
  }

  // bind_service - computed: false, optional: false, required: true
  private _bindService?: string; 
  public get bindService() {
    return this.getStringAttribute('bind_service');
  }
  public set bindService(value: string) {
    this._bindService = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bindServiceInput() {
    return this._bindService;
  }

  // connect_host - computed: false, optional: false, required: true
  private _connectHost?: string; 
  public get connectHost() {
    return this.getStringAttribute('connect_host');
  }
  public set connectHost(value: string) {
    this._connectHost = value;
  }
  // Temporarily expose input value. Use with caution.
  public get connectHostInput() {
    return this._connectHost;
  }

  // connect_service - computed: false, optional: false, required: true
  private _connectService?: string; 
  public get connectService() {
    return this.getStringAttribute('connect_service');
  }
  public set connectService(value: string) {
    this._connectService = value;
  }
  // Temporarily expose input value. Use with caution.
  public get connectServiceInput() {
    return this._connectService;
  }
}
export interface DomainDevicesTpmsBackendExternalSourceUnixReconnect {
  /**
  * Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enabled Domain#enabled}
  */
  readonly enabled: string;
  /**
  * Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a non‑negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#timeout Domain#timeout}
  */
  readonly timeout?: number;
}

export function domainDevicesTpmsBackendExternalSourceUnixReconnectToTerraform(struct?: DomainDevicesTpmsBackendExternalSourceUnixReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.stringToTerraform(struct!.enabled),
    timeout: cdktf.numberToTerraform(struct!.timeout),
  }
}


export function domainDevicesTpmsBackendExternalSourceUnixReconnectToHclTerraform(struct?: DomainDevicesTpmsBackendExternalSourceUnixReconnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.stringToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.numberToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesTpmsBackendExternalSourceUnixReconnectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesTpmsBackendExternalSourceUnixReconnect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesTpmsBackendExternalSourceUnixReconnect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._timeout = value.timeout;
    }
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: string; 
  public get enabled() {
    return this.getStringAttribute('enabled');
  }
  public set enabled(value: string) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: number; 
  public get timeout() {
    return this.getNumberAttribute('timeout');
  }
  public set timeout(value: number) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DomainDevicesTpmsBackendExternalSourceUnixSecLabel {
  /**
  * Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label Domain#label}
  */
  readonly label?: string;
  /**
  * Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#label_skip Domain#label_skip}
  */
  readonly labelSkip?: string;
  /**
  * Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
  /**
  * Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relabel Domain#relabel}
  */
  readonly relabel?: string;
}

export function domainDevicesTpmsBackendExternalSourceUnixSecLabelToTerraform(struct?: DomainDevicesTpmsBackendExternalSourceUnixSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    label_skip: cdktf.stringToTerraform(struct!.labelSkip),
    model: cdktf.stringToTerraform(struct!.model),
    relabel: cdktf.stringToTerraform(struct!.relabel),
  }
}


export function domainDevicesTpmsBackendExternalSourceUnixSecLabelToHclTerraform(struct?: DomainDevicesTpmsBackendExternalSourceUnixSecLabel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_skip: {
      value: cdktf.stringToHclTerraform(struct!.labelSkip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabel: {
      value: cdktf.stringToHclTerraform(struct!.relabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesTpmsBackendExternalSourceUnixSecLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesTpmsBackendExternalSourceUnixSecLabel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._labelSkip !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSkip = this._labelSkip;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._relabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabel = this._relabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesTpmsBackendExternalSourceUnixSecLabel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._labelSkip = undefined;
      this._model = undefined;
      this._relabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._labelSkip = value.labelSkip;
      this._model = value.model;
      this._relabel = value.relabel;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // label_skip - computed: false, optional: true, required: false
  private _labelSkip?: string; 
  public get labelSkip() {
    return this.getStringAttribute('label_skip');
  }
  public set labelSkip(value: string) {
    this._labelSkip = value;
  }
  public resetLabelSkip() {
    this._labelSkip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSkipInput() {
    return this._labelSkip;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // relabel - computed: false, optional: true, required: false
  private _relabel?: string; 
  public get relabel() {
    return this.getStringAttribute('relabel');
  }
  public set relabel(value: string) {
    this._relabel = value;
  }
  public resetRelabel() {
    this._relabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelInput() {
    return this._relabel;
  }
}

export class DomainDevicesTpmsBackendExternalSourceUnixSecLabelList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesTpmsBackendExternalSourceUnixSecLabel[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesTpmsBackendExternalSourceUnixSecLabelOutputReference {
    return new DomainDevicesTpmsBackendExternalSourceUnixSecLabelOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesTpmsBackendExternalSourceUnix {
  /**
  * Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode?: string;
  /**
  * Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path?: string;
  /**
  * Enables and configures automatic reconnection behavior for a UNIX socket–based EGD entropy source; the content and attributes are user-provided according to desired policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reconnect Domain#reconnect}
  */
  readonly reconnect?: DomainDevicesTpmsBackendExternalSourceUnixReconnect;
  /**
  * Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.
  * 
  * See: <https://libvirt.org/formatdomain.html#security-label>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sec_label Domain#sec_label}
  */
  readonly secLabel?: DomainDevicesTpmsBackendExternalSourceUnixSecLabel[] | cdktf.IResolvable;
}

export function domainDevicesTpmsBackendExternalSourceUnixToTerraform(struct?: DomainDevicesTpmsBackendExternalSourceUnix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
    reconnect: domainDevicesTpmsBackendExternalSourceUnixReconnectToTerraform(struct!.reconnect),
    sec_label: cdktf.listMapper(domainDevicesTpmsBackendExternalSourceUnixSecLabelToTerraform, false)(struct!.secLabel),
  }
}


export function domainDevicesTpmsBackendExternalSourceUnixToHclTerraform(struct?: DomainDevicesTpmsBackendExternalSourceUnix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reconnect: {
      value: domainDevicesTpmsBackendExternalSourceUnixReconnectToHclTerraform(struct!.reconnect),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesTpmsBackendExternalSourceUnixReconnect",
    },
    sec_label: {
      value: cdktf.listMapperHcl(domainDevicesTpmsBackendExternalSourceUnixSecLabelToHclTerraform, false)(struct!.secLabel),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesTpmsBackendExternalSourceUnixSecLabelList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesTpmsBackendExternalSourceUnixOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesTpmsBackendExternalSourceUnix | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._reconnect?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.reconnect = this._reconnect?.internalValue;
    }
    if (this._secLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secLabel = this._secLabel?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesTpmsBackendExternalSourceUnix | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
      this._path = undefined;
      this._reconnect.internalValue = undefined;
      this._secLabel.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
      this._path = value.path;
      this._reconnect.internalValue = value.reconnect;
      this._secLabel.internalValue = value.secLabel;
    }
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // reconnect - computed: false, optional: true, required: false
  private _reconnect = new DomainDevicesTpmsBackendExternalSourceUnixReconnectOutputReference(this, "reconnect");
  public get reconnect() {
    return this._reconnect;
  }
  public putReconnect(value: DomainDevicesTpmsBackendExternalSourceUnixReconnect) {
    this._reconnect.internalValue = value;
  }
  public resetReconnect() {
    this._reconnect.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reconnectInput() {
    return this._reconnect.internalValue;
  }

  // sec_label - computed: false, optional: true, required: false
  private _secLabel = new DomainDevicesTpmsBackendExternalSourceUnixSecLabelList(this, "sec_label", false);
  public get secLabel() {
    return this._secLabel;
  }
  public putSecLabel(value: DomainDevicesTpmsBackendExternalSourceUnixSecLabel[] | cdktf.IResolvable) {
    this._secLabel.internalValue = value;
  }
  public resetSecLabel() {
    this._secLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secLabelInput() {
    return this._secLabel.internalValue;
  }
}
export interface DomainDevicesTpmsBackendExternalSource {
  /**
  * Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dbus Domain#dbus}
  */
  readonly dbus?: DomainDevicesTpmsBackendExternalSourceDbus;
  /**
  * Configures an EGD RNG backend that reads entropy from a host character device node.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dev Domain#dev}
  */
  readonly dev?: DomainDevicesTpmsBackendExternalSourceDev;
  /**
  * Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#file Domain#file}
  */
  readonly file?: DomainDevicesTpmsBackendExternalSourceFile;
  /**
  * Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#nmdm Domain#nmdm}
  */
  readonly nmdm?: DomainDevicesTpmsBackendExternalSourceNmdm;
  /**
  * Enables use of a null character device as the external TPM backend source; when set (true), the TPM device discards all output and never provides input.
  * 
  * See: <https://libvirt.org/formatdomain.html#null-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#null Domain#null}
  */
  readonly null?: boolean | cdktf.IResolvable;
  /**
  * Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pipe Domain#pipe}
  */
  readonly pipe?: DomainDevicesTpmsBackendExternalSourcePipe;
  /**
  * Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pty Domain#pty}
  */
  readonly pty?: DomainDevicesTpmsBackendExternalSourcePty;
  /**
  * Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#qemuvd_agent Domain#qemuvd_agent}
  */
  readonly qemuvdAgent?: DomainDevicesTpmsBackendExternalSourceQemuvdAgent;
  /**
  * Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#spice_port Domain#spice_port}
  */
  readonly spicePort?: DomainDevicesTpmsBackendExternalSourceSpicePort;
  /**
  * When true, enables a SPICE VMC (virtio‑serial SPICE management) channel as the backend connection for the external TPM; omitting or setting false leaves this source disabled.
  * 
  * See: <https://libvirt.org/formatdomain.html#spice-channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#spice_vmc Domain#spice_vmc}
  */
  readonly spiceVmc?: boolean | cdktf.IResolvable;
  /**
  * When true, connects the external TPM emulator to the domain via the QEMU standard input/output streams instead of a separate device; omitting or setting false disables this source.
  * 
  * See: <https://libvirt.org/formatdomain.html#tpm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#std_io Domain#std_io}
  */
  readonly stdIo?: boolean | cdktf.IResolvable;
  /**
  * Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tcp Domain#tcp}
  */
  readonly tcp?: DomainDevicesTpmsBackendExternalSourceTcp;
  /**
  * Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#udp Domain#udp}
  */
  readonly udp?: DomainDevicesTpmsBackendExternalSourceUdp;
  /**
  * Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#unix Domain#unix}
  */
  readonly unix?: DomainDevicesTpmsBackendExternalSourceUnix;
  /**
  * Enables use of a TPM backend source type "VC" for the external TPM device; setting this boolean to true emits the <VC/> element, while false or null omits it.
  * 
  * See: <https://libvirt.org/formatdomain.html#tpm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vc Domain#vc}
  */
  readonly vc?: boolean | cdktf.IResolvable;
}

export function domainDevicesTpmsBackendExternalSourceToTerraform(struct?: DomainDevicesTpmsBackendExternalSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dbus: domainDevicesTpmsBackendExternalSourceDbusToTerraform(struct!.dbus),
    dev: domainDevicesTpmsBackendExternalSourceDevToTerraform(struct!.dev),
    file: domainDevicesTpmsBackendExternalSourceFileToTerraform(struct!.file),
    nmdm: domainDevicesTpmsBackendExternalSourceNmdmToTerraform(struct!.nmdm),
    null: cdktf.booleanToTerraform(struct!.null),
    pipe: domainDevicesTpmsBackendExternalSourcePipeToTerraform(struct!.pipe),
    pty: domainDevicesTpmsBackendExternalSourcePtyToTerraform(struct!.pty),
    qemuvd_agent: domainDevicesTpmsBackendExternalSourceQemuvdAgentToTerraform(struct!.qemuvdAgent),
    spice_port: domainDevicesTpmsBackendExternalSourceSpicePortToTerraform(struct!.spicePort),
    spice_vmc: cdktf.booleanToTerraform(struct!.spiceVmc),
    std_io: cdktf.booleanToTerraform(struct!.stdIo),
    tcp: domainDevicesTpmsBackendExternalSourceTcpToTerraform(struct!.tcp),
    udp: domainDevicesTpmsBackendExternalSourceUdpToTerraform(struct!.udp),
    unix: domainDevicesTpmsBackendExternalSourceUnixToTerraform(struct!.unix),
    vc: cdktf.booleanToTerraform(struct!.vc),
  }
}


export function domainDevicesTpmsBackendExternalSourceToHclTerraform(struct?: DomainDevicesTpmsBackendExternalSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dbus: {
      value: domainDevicesTpmsBackendExternalSourceDbusToHclTerraform(struct!.dbus),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesTpmsBackendExternalSourceDbus",
    },
    dev: {
      value: domainDevicesTpmsBackendExternalSourceDevToHclTerraform(struct!.dev),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesTpmsBackendExternalSourceDev",
    },
    file: {
      value: domainDevicesTpmsBackendExternalSourceFileToHclTerraform(struct!.file),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesTpmsBackendExternalSourceFile",
    },
    nmdm: {
      value: domainDevicesTpmsBackendExternalSourceNmdmToHclTerraform(struct!.nmdm),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesTpmsBackendExternalSourceNmdm",
    },
    null: {
      value: cdktf.booleanToHclTerraform(struct!.null),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    pipe: {
      value: domainDevicesTpmsBackendExternalSourcePipeToHclTerraform(struct!.pipe),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesTpmsBackendExternalSourcePipe",
    },
    pty: {
      value: domainDevicesTpmsBackendExternalSourcePtyToHclTerraform(struct!.pty),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesTpmsBackendExternalSourcePty",
    },
    qemuvd_agent: {
      value: domainDevicesTpmsBackendExternalSourceQemuvdAgentToHclTerraform(struct!.qemuvdAgent),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesTpmsBackendExternalSourceQemuvdAgent",
    },
    spice_port: {
      value: domainDevicesTpmsBackendExternalSourceSpicePortToHclTerraform(struct!.spicePort),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesTpmsBackendExternalSourceSpicePort",
    },
    spice_vmc: {
      value: cdktf.booleanToHclTerraform(struct!.spiceVmc),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    std_io: {
      value: cdktf.booleanToHclTerraform(struct!.stdIo),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tcp: {
      value: domainDevicesTpmsBackendExternalSourceTcpToHclTerraform(struct!.tcp),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesTpmsBackendExternalSourceTcp",
    },
    udp: {
      value: domainDevicesTpmsBackendExternalSourceUdpToHclTerraform(struct!.udp),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesTpmsBackendExternalSourceUdp",
    },
    unix: {
      value: domainDevicesTpmsBackendExternalSourceUnixToHclTerraform(struct!.unix),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesTpmsBackendExternalSourceUnix",
    },
    vc: {
      value: cdktf.booleanToHclTerraform(struct!.vc),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesTpmsBackendExternalSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesTpmsBackendExternalSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dbus?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dbus = this._dbus?.internalValue;
    }
    if (this._dev?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dev = this._dev?.internalValue;
    }
    if (this._file?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file?.internalValue;
    }
    if (this._nmdm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nmdm = this._nmdm?.internalValue;
    }
    if (this._null !== undefined) {
      hasAnyValues = true;
      internalValueResult.null = this._null;
    }
    if (this._pipe?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipe = this._pipe?.internalValue;
    }
    if (this._pty?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pty = this._pty?.internalValue;
    }
    if (this._qemuvdAgent?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.qemuvdAgent = this._qemuvdAgent?.internalValue;
    }
    if (this._spicePort?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spicePort = this._spicePort?.internalValue;
    }
    if (this._spiceVmc !== undefined) {
      hasAnyValues = true;
      internalValueResult.spiceVmc = this._spiceVmc;
    }
    if (this._stdIo !== undefined) {
      hasAnyValues = true;
      internalValueResult.stdIo = this._stdIo;
    }
    if (this._tcp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tcp = this._tcp?.internalValue;
    }
    if (this._udp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.udp = this._udp?.internalValue;
    }
    if (this._unix?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.unix = this._unix?.internalValue;
    }
    if (this._vc !== undefined) {
      hasAnyValues = true;
      internalValueResult.vc = this._vc;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesTpmsBackendExternalSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dbus.internalValue = undefined;
      this._dev.internalValue = undefined;
      this._file.internalValue = undefined;
      this._nmdm.internalValue = undefined;
      this._null = undefined;
      this._pipe.internalValue = undefined;
      this._pty.internalValue = undefined;
      this._qemuvdAgent.internalValue = undefined;
      this._spicePort.internalValue = undefined;
      this._spiceVmc = undefined;
      this._stdIo = undefined;
      this._tcp.internalValue = undefined;
      this._udp.internalValue = undefined;
      this._unix.internalValue = undefined;
      this._vc = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dbus.internalValue = value.dbus;
      this._dev.internalValue = value.dev;
      this._file.internalValue = value.file;
      this._nmdm.internalValue = value.nmdm;
      this._null = value.null;
      this._pipe.internalValue = value.pipe;
      this._pty.internalValue = value.pty;
      this._qemuvdAgent.internalValue = value.qemuvdAgent;
      this._spicePort.internalValue = value.spicePort;
      this._spiceVmc = value.spiceVmc;
      this._stdIo = value.stdIo;
      this._tcp.internalValue = value.tcp;
      this._udp.internalValue = value.udp;
      this._unix.internalValue = value.unix;
      this._vc = value.vc;
    }
  }

  // dbus - computed: false, optional: true, required: false
  private _dbus = new DomainDevicesTpmsBackendExternalSourceDbusOutputReference(this, "dbus");
  public get dbus() {
    return this._dbus;
  }
  public putDbus(value: DomainDevicesTpmsBackendExternalSourceDbus) {
    this._dbus.internalValue = value;
  }
  public resetDbus() {
    this._dbus.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dbusInput() {
    return this._dbus.internalValue;
  }

  // dev - computed: false, optional: true, required: false
  private _dev = new DomainDevicesTpmsBackendExternalSourceDevOutputReference(this, "dev");
  public get dev() {
    return this._dev;
  }
  public putDev(value: DomainDevicesTpmsBackendExternalSourceDev) {
    this._dev.internalValue = value;
  }
  public resetDev() {
    this._dev.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devInput() {
    return this._dev.internalValue;
  }

  // file - computed: false, optional: true, required: false
  private _file = new DomainDevicesTpmsBackendExternalSourceFileOutputReference(this, "file");
  public get file() {
    return this._file;
  }
  public putFile(value: DomainDevicesTpmsBackendExternalSourceFile) {
    this._file.internalValue = value;
  }
  public resetFile() {
    this._file.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file.internalValue;
  }

  // nmdm - computed: false, optional: true, required: false
  private _nmdm = new DomainDevicesTpmsBackendExternalSourceNmdmOutputReference(this, "nmdm");
  public get nmdm() {
    return this._nmdm;
  }
  public putNmdm(value: DomainDevicesTpmsBackendExternalSourceNmdm) {
    this._nmdm.internalValue = value;
  }
  public resetNmdm() {
    this._nmdm.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nmdmInput() {
    return this._nmdm.internalValue;
  }

  // null - computed: false, optional: true, required: false
  private _null?: boolean | cdktf.IResolvable; 
  public get null() {
    return this.getBooleanAttribute('null');
  }
  public set null(value: boolean | cdktf.IResolvable) {
    this._null = value;
  }
  public resetNull() {
    this._null = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nullInput() {
    return this._null;
  }

  // pipe - computed: false, optional: true, required: false
  private _pipe = new DomainDevicesTpmsBackendExternalSourcePipeOutputReference(this, "pipe");
  public get pipe() {
    return this._pipe;
  }
  public putPipe(value: DomainDevicesTpmsBackendExternalSourcePipe) {
    this._pipe.internalValue = value;
  }
  public resetPipe() {
    this._pipe.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipeInput() {
    return this._pipe.internalValue;
  }

  // pty - computed: false, optional: true, required: false
  private _pty = new DomainDevicesTpmsBackendExternalSourcePtyOutputReference(this, "pty");
  public get pty() {
    return this._pty;
  }
  public putPty(value: DomainDevicesTpmsBackendExternalSourcePty) {
    this._pty.internalValue = value;
  }
  public resetPty() {
    this._pty.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ptyInput() {
    return this._pty.internalValue;
  }

  // qemuvd_agent - computed: false, optional: true, required: false
  private _qemuvdAgent = new DomainDevicesTpmsBackendExternalSourceQemuvdAgentOutputReference(this, "qemuvd_agent");
  public get qemuvdAgent() {
    return this._qemuvdAgent;
  }
  public putQemuvdAgent(value: DomainDevicesTpmsBackendExternalSourceQemuvdAgent) {
    this._qemuvdAgent.internalValue = value;
  }
  public resetQemuvdAgent() {
    this._qemuvdAgent.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get qemuvdAgentInput() {
    return this._qemuvdAgent.internalValue;
  }

  // spice_port - computed: false, optional: true, required: false
  private _spicePort = new DomainDevicesTpmsBackendExternalSourceSpicePortOutputReference(this, "spice_port");
  public get spicePort() {
    return this._spicePort;
  }
  public putSpicePort(value: DomainDevicesTpmsBackendExternalSourceSpicePort) {
    this._spicePort.internalValue = value;
  }
  public resetSpicePort() {
    this._spicePort.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spicePortInput() {
    return this._spicePort.internalValue;
  }

  // spice_vmc - computed: false, optional: true, required: false
  private _spiceVmc?: boolean | cdktf.IResolvable; 
  public get spiceVmc() {
    return this.getBooleanAttribute('spice_vmc');
  }
  public set spiceVmc(value: boolean | cdktf.IResolvable) {
    this._spiceVmc = value;
  }
  public resetSpiceVmc() {
    this._spiceVmc = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spiceVmcInput() {
    return this._spiceVmc;
  }

  // std_io - computed: false, optional: true, required: false
  private _stdIo?: boolean | cdktf.IResolvable; 
  public get stdIo() {
    return this.getBooleanAttribute('std_io');
  }
  public set stdIo(value: boolean | cdktf.IResolvable) {
    this._stdIo = value;
  }
  public resetStdIo() {
    this._stdIo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stdIoInput() {
    return this._stdIo;
  }

  // tcp - computed: false, optional: true, required: false
  private _tcp = new DomainDevicesTpmsBackendExternalSourceTcpOutputReference(this, "tcp");
  public get tcp() {
    return this._tcp;
  }
  public putTcp(value: DomainDevicesTpmsBackendExternalSourceTcp) {
    this._tcp.internalValue = value;
  }
  public resetTcp() {
    this._tcp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tcpInput() {
    return this._tcp.internalValue;
  }

  // udp - computed: false, optional: true, required: false
  private _udp = new DomainDevicesTpmsBackendExternalSourceUdpOutputReference(this, "udp");
  public get udp() {
    return this._udp;
  }
  public putUdp(value: DomainDevicesTpmsBackendExternalSourceUdp) {
    this._udp.internalValue = value;
  }
  public resetUdp() {
    this._udp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get udpInput() {
    return this._udp.internalValue;
  }

  // unix - computed: false, optional: true, required: false
  private _unix = new DomainDevicesTpmsBackendExternalSourceUnixOutputReference(this, "unix");
  public get unix() {
    return this._unix;
  }
  public putUnix(value: DomainDevicesTpmsBackendExternalSourceUnix) {
    this._unix.internalValue = value;
  }
  public resetUnix() {
    this._unix.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unixInput() {
    return this._unix.internalValue;
  }

  // vc - computed: false, optional: true, required: false
  private _vc?: boolean | cdktf.IResolvable; 
  public get vc() {
    return this.getBooleanAttribute('vc');
  }
  public set vc(value: boolean | cdktf.IResolvable) {
    this._vc = value;
  }
  public resetVc() {
    this._vc = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vcInput() {
    return this._vc;
  }
}
export interface DomainDevicesTpmsBackendExternal {
  /**
  * Configures how the external TPM backend is reached, via either a D-Bus service or a character device.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#source Domain#source}
  */
  readonly source?: DomainDevicesTpmsBackendExternalSource;
}

export function domainDevicesTpmsBackendExternalToTerraform(struct?: DomainDevicesTpmsBackendExternal | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    source: domainDevicesTpmsBackendExternalSourceToTerraform(struct!.source),
  }
}


export function domainDevicesTpmsBackendExternalToHclTerraform(struct?: DomainDevicesTpmsBackendExternal | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    source: {
      value: domainDevicesTpmsBackendExternalSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesTpmsBackendExternalSource",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesTpmsBackendExternalOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesTpmsBackendExternal | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesTpmsBackendExternal | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._source.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._source.internalValue = value.source;
    }
  }

  // source - computed: false, optional: true, required: false
  private _source = new DomainDevicesTpmsBackendExternalSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: DomainDevicesTpmsBackendExternalSource) {
    this._source.internalValue = value;
  }
  public resetSource() {
    this._source.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }
}
export interface DomainDevicesTpmsBackendPassthroughDevice {
  /**
  * Sets the path of the host TPM device node for a passthrough TPM backend (for example `/dev/tpm0`); the value is user‑provided and required when passthrough is used.
  * 
  * See: <https://libvirt.org/formatdomain.html#tpm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#path Domain#path}
  */
  readonly path: string;
}

export function domainDevicesTpmsBackendPassthroughDeviceToTerraform(struct?: DomainDevicesTpmsBackendPassthroughDevice | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function domainDevicesTpmsBackendPassthroughDeviceToHclTerraform(struct?: DomainDevicesTpmsBackendPassthroughDevice | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesTpmsBackendPassthroughDeviceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesTpmsBackendPassthroughDevice | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesTpmsBackendPassthroughDevice | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface DomainDevicesTpmsBackendPassthrough {
  /**
  * Sets the host character or TPM device used by the passthrough TPM backend; the device element groups attributes describing the host TPM node.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#device Domain#device}
  */
  readonly device?: DomainDevicesTpmsBackendPassthroughDevice;
}

export function domainDevicesTpmsBackendPassthroughToTerraform(struct?: DomainDevicesTpmsBackendPassthrough | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    device: domainDevicesTpmsBackendPassthroughDeviceToTerraform(struct!.device),
  }
}


export function domainDevicesTpmsBackendPassthroughToHclTerraform(struct?: DomainDevicesTpmsBackendPassthrough | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    device: {
      value: domainDevicesTpmsBackendPassthroughDeviceToHclTerraform(struct!.device),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesTpmsBackendPassthroughDevice",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesTpmsBackendPassthroughOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesTpmsBackendPassthrough | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._device?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.device = this._device?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesTpmsBackendPassthrough | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._device.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._device.internalValue = value.device;
    }
  }

  // device - computed: false, optional: true, required: false
  private _device = new DomainDevicesTpmsBackendPassthroughDeviceOutputReference(this, "device");
  public get device() {
    return this._device;
  }
  public putDevice(value: DomainDevicesTpmsBackendPassthroughDevice) {
    this._device.internalValue = value;
  }
  public resetDevice() {
    this._device.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deviceInput() {
    return this._device.internalValue;
  }
}
export interface DomainDevicesTpmsBackend {
  /**
  * Configures a software-emulated TPM backend (such as swtpm), including its PCR banks, persistence, encryption, and debug behavior.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#emulator Domain#emulator}
  */
  readonly emulator?: DomainDevicesTpmsBackendEmulator;
  /**
  * Selects an external TPM backend, where libvirt connects the guest to an already running TPM service rather than spawning an emulator.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#external Domain#external}
  */
  readonly external?: DomainDevicesTpmsBackendExternal;
  /**
  * Configures a TPM backend of type `passthrough`, which exposes a host TPM device directly to the guest instead of using an emulator.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#passthrough Domain#passthrough}
  */
  readonly passthrough?: DomainDevicesTpmsBackendPassthrough;
}

export function domainDevicesTpmsBackendToTerraform(struct?: DomainDevicesTpmsBackend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    emulator: domainDevicesTpmsBackendEmulatorToTerraform(struct!.emulator),
    external: domainDevicesTpmsBackendExternalToTerraform(struct!.external),
    passthrough: domainDevicesTpmsBackendPassthroughToTerraform(struct!.passthrough),
  }
}


export function domainDevicesTpmsBackendToHclTerraform(struct?: DomainDevicesTpmsBackend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    emulator: {
      value: domainDevicesTpmsBackendEmulatorToHclTerraform(struct!.emulator),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesTpmsBackendEmulator",
    },
    external: {
      value: domainDevicesTpmsBackendExternalToHclTerraform(struct!.external),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesTpmsBackendExternal",
    },
    passthrough: {
      value: domainDevicesTpmsBackendPassthroughToHclTerraform(struct!.passthrough),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesTpmsBackendPassthrough",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesTpmsBackendOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesTpmsBackend | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._emulator?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.emulator = this._emulator?.internalValue;
    }
    if (this._external?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.external = this._external?.internalValue;
    }
    if (this._passthrough?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.passthrough = this._passthrough?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesTpmsBackend | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._emulator.internalValue = undefined;
      this._external.internalValue = undefined;
      this._passthrough.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._emulator.internalValue = value.emulator;
      this._external.internalValue = value.external;
      this._passthrough.internalValue = value.passthrough;
    }
  }

  // emulator - computed: false, optional: true, required: false
  private _emulator = new DomainDevicesTpmsBackendEmulatorOutputReference(this, "emulator");
  public get emulator() {
    return this._emulator;
  }
  public putEmulator(value: DomainDevicesTpmsBackendEmulator) {
    this._emulator.internalValue = value;
  }
  public resetEmulator() {
    this._emulator.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get emulatorInput() {
    return this._emulator.internalValue;
  }

  // external - computed: false, optional: true, required: false
  private _external = new DomainDevicesTpmsBackendExternalOutputReference(this, "external");
  public get external() {
    return this._external;
  }
  public putExternal(value: DomainDevicesTpmsBackendExternal) {
    this._external.internalValue = value;
  }
  public resetExternal() {
    this._external.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalInput() {
    return this._external.internalValue;
  }

  // passthrough - computed: false, optional: true, required: false
  private _passthrough = new DomainDevicesTpmsBackendPassthroughOutputReference(this, "passthrough");
  public get passthrough() {
    return this._passthrough;
  }
  public putPassthrough(value: DomainDevicesTpmsBackendPassthrough) {
    this._passthrough.internalValue = value;
  }
  public resetPassthrough() {
    this._passthrough.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passthroughInput() {
    return this._passthrough.internalValue;
  }
}
export interface DomainDevicesTpms {
  /**
  * Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#acpi Domain#acpi}
  */
  readonly acpi?: DomainDevicesTpmsAcpi;
  /**
  * Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: DomainDevicesTpmsAddress;
  /**
  * Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#alias Domain#alias}
  */
  readonly alias?: DomainDevicesTpmsAlias;
  /**
  * Selects and configures the TPM backend type used by the guest (for example, emulator vs passthrough) and its backend-specific options.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#backend Domain#backend}
  */
  readonly backend?: DomainDevicesTpmsBackend;
  /**
  * Sets the TPM device model exposed to the guest, such as `tpm-tis`, `tpm-crb`, or `tpm-spapr`; the exact allowed values depend on the guest architecture and QEMU support.
  * 
  * See: <https://libvirt.org/formatdomain.html#tpm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
}

export function domainDevicesTpmsToTerraform(struct?: DomainDevicesTpms | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    acpi: domainDevicesTpmsAcpiToTerraform(struct!.acpi),
    address: domainDevicesTpmsAddressToTerraform(struct!.address),
    alias: domainDevicesTpmsAliasToTerraform(struct!.alias),
    backend: domainDevicesTpmsBackendToTerraform(struct!.backend),
    model: cdktf.stringToTerraform(struct!.model),
  }
}


export function domainDevicesTpmsToHclTerraform(struct?: DomainDevicesTpms | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    acpi: {
      value: domainDevicesTpmsAcpiToHclTerraform(struct!.acpi),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesTpmsAcpi",
    },
    address: {
      value: domainDevicesTpmsAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesTpmsAddress",
    },
    alias: {
      value: domainDevicesTpmsAliasToHclTerraform(struct!.alias),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesTpmsAlias",
    },
    backend: {
      value: domainDevicesTpmsBackendToHclTerraform(struct!.backend),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesTpmsBackend",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesTpmsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesTpms | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._acpi?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.acpi = this._acpi?.internalValue;
    }
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._alias?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.alias = this._alias?.internalValue;
    }
    if (this._backend?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.backend = this._backend?.internalValue;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesTpms | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._acpi.internalValue = undefined;
      this._address.internalValue = undefined;
      this._alias.internalValue = undefined;
      this._backend.internalValue = undefined;
      this._model = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._acpi.internalValue = value.acpi;
      this._address.internalValue = value.address;
      this._alias.internalValue = value.alias;
      this._backend.internalValue = value.backend;
      this._model = value.model;
    }
  }

  // acpi - computed: false, optional: true, required: false
  private _acpi = new DomainDevicesTpmsAcpiOutputReference(this, "acpi");
  public get acpi() {
    return this._acpi;
  }
  public putAcpi(value: DomainDevicesTpmsAcpi) {
    this._acpi.internalValue = value;
  }
  public resetAcpi() {
    this._acpi.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get acpiInput() {
    return this._acpi.internalValue;
  }

  // address - computed: false, optional: true, required: false
  private _address = new DomainDevicesTpmsAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DomainDevicesTpmsAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // alias - computed: false, optional: true, required: false
  private _alias = new DomainDevicesTpmsAliasOutputReference(this, "alias");
  public get alias() {
    return this._alias;
  }
  public putAlias(value: DomainDevicesTpmsAlias) {
    this._alias.internalValue = value;
  }
  public resetAlias() {
    this._alias.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aliasInput() {
    return this._alias.internalValue;
  }

  // backend - computed: false, optional: true, required: false
  private _backend = new DomainDevicesTpmsBackendOutputReference(this, "backend");
  public get backend() {
    return this._backend;
  }
  public putBackend(value: DomainDevicesTpmsBackend) {
    this._backend.internalValue = value;
  }
  public resetBackend() {
    this._backend.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backendInput() {
    return this._backend.internalValue;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }
}

export class DomainDevicesTpmsList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesTpms[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesTpmsOutputReference {
    return new DomainDevicesTpmsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesVideosAcpi {
  /**
  * Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#pstore>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#index Domain#index}
  */
  readonly index?: number;
}

export function domainDevicesVideosAcpiToTerraform(struct?: DomainDevicesVideosAcpi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    index: cdktf.numberToTerraform(struct!.index),
  }
}


export function domainDevicesVideosAcpiToHclTerraform(struct?: DomainDevicesVideosAcpi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    index: {
      value: cdktf.numberToHclTerraform(struct!.index),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesVideosAcpiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesVideosAcpi | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._index !== undefined) {
      hasAnyValues = true;
      internalValueResult.index = this._index;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesVideosAcpi | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._index = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._index = value.index;
    }
  }

  // index - computed: false, optional: true, required: false
  private _index?: number; 
  public get index() {
    return this.getNumberAttribute('index');
  }
  public set index(value: number) {
    this._index = value;
  }
  public resetIndex() {
    this._index = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get indexInput() {
    return this._index;
  }
}
export interface DomainDevicesVideosAddress {
}

export function domainDevicesVideosAddressToTerraform(struct?: DomainDevicesVideosAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function domainDevicesVideosAddressToHclTerraform(struct?: DomainDevicesVideosAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DomainDevicesVideosAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesVideosAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesVideosAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DomainDevicesVideosAlias {
  /**
  * Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
}

export function domainDevicesVideosAliasToTerraform(struct?: DomainDevicesVideosAlias | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function domainDevicesVideosAliasToHclTerraform(struct?: DomainDevicesVideosAlias | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesVideosAliasOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesVideosAlias | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesVideosAlias | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DomainDevicesVideosDriver {
  /**
  * Controls the virtio Address Translation Service (ATS) feature for the video device when using an emulated IOMMU; values are typically `on` or `off`.
  * 
  * See: <https://libvirt.org/formatdomain.html#virtio-related-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#ats Domain#ats}
  */
  readonly ats?: string;
  /**
  * Enables or disables the use of an emulated IOMMU for the video device; values are typically `on` or `off` and require a matching IOMMU device configuration.
  * 
  * See: <https://libvirt.org/formatdomain.html#virtio-related-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#iommu Domain#iommu}
  */
  readonly iommu?: string;
  /**
  * Sets a driver name or variant for the video device; the value is user‑provided and specific to the selected video model and hypervisor support.
  * 
  * See: <https://libvirt.org/formatdomain.html#video-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name?: string;
  /**
  * Controls whether the virtio device uses packed virtqueue format instead of split queues; values are typically `on` or `off`.
  * 
  * See: <https://libvirt.org/formatdomain.html#virtio-related-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#packed Domain#packed}
  */
  readonly packed?: string;
  /**
  * Controls whether each virtqueue of the device gets its own memory page (page-per-vq optimization); values are typically `on` or `off`.
  * 
  * See: <https://libvirt.org/formatdomain.html#virtio-related-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#page_per_vq Domain#page_per_vq}
  */
  readonly pagePerVq?: string;
  /**
  * Sets the VGA configuration policy for the video device via the `vgaconf` option (for example `on`, `off`, or `io`), controlling legacy VGA behavior; the exact accepted values are hypervisor-specific.
  * 
  * See: <https://libvirt.org/formatdomain.html#video-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vga_conf Domain#vga_conf}
  */
  readonly vgaConf?: string;
}

export function domainDevicesVideosDriverToTerraform(struct?: DomainDevicesVideosDriver | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ats: cdktf.stringToTerraform(struct!.ats),
    iommu: cdktf.stringToTerraform(struct!.iommu),
    name: cdktf.stringToTerraform(struct!.name),
    packed: cdktf.stringToTerraform(struct!.packed),
    page_per_vq: cdktf.stringToTerraform(struct!.pagePerVq),
    vga_conf: cdktf.stringToTerraform(struct!.vgaConf),
  }
}


export function domainDevicesVideosDriverToHclTerraform(struct?: DomainDevicesVideosDriver | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ats: {
      value: cdktf.stringToHclTerraform(struct!.ats),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    iommu: {
      value: cdktf.stringToHclTerraform(struct!.iommu),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    packed: {
      value: cdktf.stringToHclTerraform(struct!.packed),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    page_per_vq: {
      value: cdktf.stringToHclTerraform(struct!.pagePerVq),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    vga_conf: {
      value: cdktf.stringToHclTerraform(struct!.vgaConf),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesVideosDriverOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesVideosDriver | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ats !== undefined) {
      hasAnyValues = true;
      internalValueResult.ats = this._ats;
    }
    if (this._iommu !== undefined) {
      hasAnyValues = true;
      internalValueResult.iommu = this._iommu;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._packed !== undefined) {
      hasAnyValues = true;
      internalValueResult.packed = this._packed;
    }
    if (this._pagePerVq !== undefined) {
      hasAnyValues = true;
      internalValueResult.pagePerVq = this._pagePerVq;
    }
    if (this._vgaConf !== undefined) {
      hasAnyValues = true;
      internalValueResult.vgaConf = this._vgaConf;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesVideosDriver | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ats = undefined;
      this._iommu = undefined;
      this._name = undefined;
      this._packed = undefined;
      this._pagePerVq = undefined;
      this._vgaConf = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ats = value.ats;
      this._iommu = value.iommu;
      this._name = value.name;
      this._packed = value.packed;
      this._pagePerVq = value.pagePerVq;
      this._vgaConf = value.vgaConf;
    }
  }

  // ats - computed: false, optional: true, required: false
  private _ats?: string; 
  public get ats() {
    return this.getStringAttribute('ats');
  }
  public set ats(value: string) {
    this._ats = value;
  }
  public resetAts() {
    this._ats = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get atsInput() {
    return this._ats;
  }

  // iommu - computed: false, optional: true, required: false
  private _iommu?: string; 
  public get iommu() {
    return this.getStringAttribute('iommu');
  }
  public set iommu(value: string) {
    this._iommu = value;
  }
  public resetIommu() {
    this._iommu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get iommuInput() {
    return this._iommu;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // packed - computed: false, optional: true, required: false
  private _packed?: string; 
  public get packed() {
    return this.getStringAttribute('packed');
  }
  public set packed(value: string) {
    this._packed = value;
  }
  public resetPacked() {
    this._packed = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get packedInput() {
    return this._packed;
  }

  // page_per_vq - computed: false, optional: true, required: false
  private _pagePerVq?: string; 
  public get pagePerVq() {
    return this.getStringAttribute('page_per_vq');
  }
  public set pagePerVq(value: string) {
    this._pagePerVq = value;
  }
  public resetPagePerVq() {
    this._pagePerVq = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pagePerVqInput() {
    return this._pagePerVq;
  }

  // vga_conf - computed: false, optional: true, required: false
  private _vgaConf?: string; 
  public get vgaConf() {
    return this.getStringAttribute('vga_conf');
  }
  public set vgaConf(value: string) {
    this._vgaConf = value;
  }
  public resetVgaConf() {
    this._vgaConf = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vgaConfInput() {
    return this._vgaConf;
  }
}
export interface DomainDevicesVideosModelAccel {
  /**
  * Enables or disables 2D acceleration for the video device model; values are typically `yes`/`no` or `on`/`off` depending on libvirt version.
  * 
  * See: <https://libvirt.org/formatdomain.html#video-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#accel2d Domain#accel2d}
  */
  readonly accel2D?: string;
  /**
  * Configures whether 3D acceleration is enabled for the video device model; accepts the string values "on" or "off".
  * 
  * See: <https://libvirt.org/formatdomain.html#video-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#accel3d Domain#accel3d}
  */
  readonly accel3D?: string;
  /**
  * Sets the render node path used for hardware-accelerated rendering by the video device (for example "/dev/dri/renderD128"); the value is user-provided.
  * 
  * See: <https://libvirt.org/formatdomain.html#video-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#render_node Domain#render_node}
  */
  readonly renderNode?: string;
}

export function domainDevicesVideosModelAccelToTerraform(struct?: DomainDevicesVideosModelAccel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    accel2d: cdktf.stringToTerraform(struct!.accel2D),
    accel3d: cdktf.stringToTerraform(struct!.accel3D),
    render_node: cdktf.stringToTerraform(struct!.renderNode),
  }
}


export function domainDevicesVideosModelAccelToHclTerraform(struct?: DomainDevicesVideosModelAccel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    accel2d: {
      value: cdktf.stringToHclTerraform(struct!.accel2D),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    accel3d: {
      value: cdktf.stringToHclTerraform(struct!.accel3D),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    render_node: {
      value: cdktf.stringToHclTerraform(struct!.renderNode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesVideosModelAccelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesVideosModelAccel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accel2D !== undefined) {
      hasAnyValues = true;
      internalValueResult.accel2D = this._accel2D;
    }
    if (this._accel3D !== undefined) {
      hasAnyValues = true;
      internalValueResult.accel3D = this._accel3D;
    }
    if (this._renderNode !== undefined) {
      hasAnyValues = true;
      internalValueResult.renderNode = this._renderNode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesVideosModelAccel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accel2D = undefined;
      this._accel3D = undefined;
      this._renderNode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accel2D = value.accel2D;
      this._accel3D = value.accel3D;
      this._renderNode = value.renderNode;
    }
  }

  // accel2d - computed: false, optional: true, required: false
  private _accel2D?: string; 
  public get accel2D() {
    return this.getStringAttribute('accel2d');
  }
  public set accel2D(value: string) {
    this._accel2D = value;
  }
  public resetAccel2D() {
    this._accel2D = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accel2DInput() {
    return this._accel2D;
  }

  // accel3d - computed: false, optional: true, required: false
  private _accel3D?: string; 
  public get accel3D() {
    return this.getStringAttribute('accel3d');
  }
  public set accel3D(value: string) {
    this._accel3D = value;
  }
  public resetAccel3D() {
    this._accel3D = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accel3DInput() {
    return this._accel3D;
  }

  // render_node - computed: false, optional: true, required: false
  private _renderNode?: string; 
  public get renderNode() {
    return this.getStringAttribute('render_node');
  }
  public set renderNode(value: string) {
    this._renderNode = value;
  }
  public resetRenderNode() {
    this._renderNode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get renderNodeInput() {
    return this._renderNode;
  }
}
export interface DomainDevicesVideosModelResolution {
  /**
  * Sets the horizontal resolution in pixels for the video device; expects a positive integer (for example 1920).
  * 
  * See: <https://libvirt.org/formatdomain.html#video-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#x Domain#x}
  */
  readonly x: number;
  /**
  * Sets the vertical resolution in pixels for the video device; expects a positive integer (for example 1080).
  * 
  * See: <https://libvirt.org/formatdomain.html#video-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#y Domain#y}
  */
  readonly y: number;
}

export function domainDevicesVideosModelResolutionToTerraform(struct?: DomainDevicesVideosModelResolution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    x: cdktf.numberToTerraform(struct!.x),
    y: cdktf.numberToTerraform(struct!.y),
  }
}


export function domainDevicesVideosModelResolutionToHclTerraform(struct?: DomainDevicesVideosModelResolution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    x: {
      value: cdktf.numberToHclTerraform(struct!.x),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    y: {
      value: cdktf.numberToHclTerraform(struct!.y),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesVideosModelResolutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesVideosModelResolution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._x !== undefined) {
      hasAnyValues = true;
      internalValueResult.x = this._x;
    }
    if (this._y !== undefined) {
      hasAnyValues = true;
      internalValueResult.y = this._y;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesVideosModelResolution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._x = undefined;
      this._y = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._x = value.x;
      this._y = value.y;
    }
  }

  // x - computed: false, optional: false, required: true
  private _x?: number; 
  public get x() {
    return this.getNumberAttribute('x');
  }
  public set x(value: number) {
    this._x = value;
  }
  // Temporarily expose input value. Use with caution.
  public get xInput() {
    return this._x;
  }

  // y - computed: false, optional: false, required: true
  private _y?: number; 
  public get y() {
    return this.getNumberAttribute('y');
  }
  public set y(value: number) {
    this._y = value;
  }
  // Temporarily expose input value. Use with caution.
  public get yInput() {
    return this._y;
  }
}
export interface DomainDevicesVideosModel {
  /**
  * Configures hardware acceleration options for the video model, enabling or disabling 2D/3D acceleration if supported by the chosen model.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#accel Domain#accel}
  */
  readonly accel?: DomainDevicesVideosModelAccel;
  /**
  * Controls whether the video device exposes a framebuffer "blob" resource to the guest; accepts "on" or "off" where supported.
  * 
  * See: <https://libvirt.org/formatdomain.html#video-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#blob Domain#blob}
  */
  readonly blob?: string;
  /**
  * Controls whether an EDID block is exposed to the guest display for this video device; accepts "on" or "off".
  * 
  * See: <https://libvirt.org/formatdomain.html#video-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#edid Domain#edid}
  */
  readonly edid?: string;
  /**
  * Sets the number of display heads (monitors) exposed by this video device model; expects a positive integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#video-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#heads Domain#heads}
  */
  readonly heads?: number;
  /**
  * Marks this video device as the primary adapter when set to "yes" and as non-primary when set to "no".
  * 
  * See: <https://libvirt.org/formatdomain.html#video-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#primary Domain#primary}
  */
  readonly primary?: string;
  /**
  * Sets the amount of RAM (in KiB) assigned to the video device, controlling the total memory available to the model; expects a non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#video-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#ram Domain#ram}
  */
  readonly ram?: number;
  /**
  * Configures a fixed default resolution for the video device via its x and y dimensions; only effective when both coordinates are provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#resolution Domain#resolution}
  */
  readonly resolution?: DomainDevicesVideosModelResolution;
  /**
  * Selects the emulated video card model (for example "vga", "qxl", "virtio"); the value is user-provided and passed through to the hypervisor.
  * 
  * See: <https://libvirt.org/formatdomain.html#video-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#type Domain#type}
  */
  readonly type?: string;
  /**
  * Sets the amount of legacy VGA memory (in KiB) exposed by the adapter (vgamem); expects a non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#video-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vga_mem Domain#vga_mem}
  */
  readonly vgaMem?: number;
  /**
  * Sets the amount of video RAM (in KiB) exposed to the guest for this adapter; expects a non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#video-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vram Domain#vram}
  */
  readonly vram?: number;
  /**
  * Sets the additional 64-bit-accessible video RAM (in KiB) for this adapter where supported; expects a non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#video-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vram64 Domain#vram64}
  */
  readonly vram64?: number;
}

export function domainDevicesVideosModelToTerraform(struct?: DomainDevicesVideosModel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    accel: domainDevicesVideosModelAccelToTerraform(struct!.accel),
    blob: cdktf.stringToTerraform(struct!.blob),
    edid: cdktf.stringToTerraform(struct!.edid),
    heads: cdktf.numberToTerraform(struct!.heads),
    primary: cdktf.stringToTerraform(struct!.primary),
    ram: cdktf.numberToTerraform(struct!.ram),
    resolution: domainDevicesVideosModelResolutionToTerraform(struct!.resolution),
    type: cdktf.stringToTerraform(struct!.type),
    vga_mem: cdktf.numberToTerraform(struct!.vgaMem),
    vram: cdktf.numberToTerraform(struct!.vram),
    vram64: cdktf.numberToTerraform(struct!.vram64),
  }
}


export function domainDevicesVideosModelToHclTerraform(struct?: DomainDevicesVideosModel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    accel: {
      value: domainDevicesVideosModelAccelToHclTerraform(struct!.accel),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesVideosModelAccel",
    },
    blob: {
      value: cdktf.stringToHclTerraform(struct!.blob),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    edid: {
      value: cdktf.stringToHclTerraform(struct!.edid),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    heads: {
      value: cdktf.numberToHclTerraform(struct!.heads),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    primary: {
      value: cdktf.stringToHclTerraform(struct!.primary),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ram: {
      value: cdktf.numberToHclTerraform(struct!.ram),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    resolution: {
      value: domainDevicesVideosModelResolutionToHclTerraform(struct!.resolution),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesVideosModelResolution",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    vga_mem: {
      value: cdktf.numberToHclTerraform(struct!.vgaMem),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    vram: {
      value: cdktf.numberToHclTerraform(struct!.vram),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    vram64: {
      value: cdktf.numberToHclTerraform(struct!.vram64),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesVideosModelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesVideosModel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.accel = this._accel?.internalValue;
    }
    if (this._blob !== undefined) {
      hasAnyValues = true;
      internalValueResult.blob = this._blob;
    }
    if (this._edid !== undefined) {
      hasAnyValues = true;
      internalValueResult.edid = this._edid;
    }
    if (this._heads !== undefined) {
      hasAnyValues = true;
      internalValueResult.heads = this._heads;
    }
    if (this._primary !== undefined) {
      hasAnyValues = true;
      internalValueResult.primary = this._primary;
    }
    if (this._ram !== undefined) {
      hasAnyValues = true;
      internalValueResult.ram = this._ram;
    }
    if (this._resolution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resolution = this._resolution?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._vgaMem !== undefined) {
      hasAnyValues = true;
      internalValueResult.vgaMem = this._vgaMem;
    }
    if (this._vram !== undefined) {
      hasAnyValues = true;
      internalValueResult.vram = this._vram;
    }
    if (this._vram64 !== undefined) {
      hasAnyValues = true;
      internalValueResult.vram64 = this._vram64;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesVideosModel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accel.internalValue = undefined;
      this._blob = undefined;
      this._edid = undefined;
      this._heads = undefined;
      this._primary = undefined;
      this._ram = undefined;
      this._resolution.internalValue = undefined;
      this._type = undefined;
      this._vgaMem = undefined;
      this._vram = undefined;
      this._vram64 = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accel.internalValue = value.accel;
      this._blob = value.blob;
      this._edid = value.edid;
      this._heads = value.heads;
      this._primary = value.primary;
      this._ram = value.ram;
      this._resolution.internalValue = value.resolution;
      this._type = value.type;
      this._vgaMem = value.vgaMem;
      this._vram = value.vram;
      this._vram64 = value.vram64;
    }
  }

  // accel - computed: false, optional: true, required: false
  private _accel = new DomainDevicesVideosModelAccelOutputReference(this, "accel");
  public get accel() {
    return this._accel;
  }
  public putAccel(value: DomainDevicesVideosModelAccel) {
    this._accel.internalValue = value;
  }
  public resetAccel() {
    this._accel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accelInput() {
    return this._accel.internalValue;
  }

  // blob - computed: false, optional: true, required: false
  private _blob?: string; 
  public get blob() {
    return this.getStringAttribute('blob');
  }
  public set blob(value: string) {
    this._blob = value;
  }
  public resetBlob() {
    this._blob = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get blobInput() {
    return this._blob;
  }

  // edid - computed: false, optional: true, required: false
  private _edid?: string; 
  public get edid() {
    return this.getStringAttribute('edid');
  }
  public set edid(value: string) {
    this._edid = value;
  }
  public resetEdid() {
    this._edid = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get edidInput() {
    return this._edid;
  }

  // heads - computed: false, optional: true, required: false
  private _heads?: number; 
  public get heads() {
    return this.getNumberAttribute('heads');
  }
  public set heads(value: number) {
    this._heads = value;
  }
  public resetHeads() {
    this._heads = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headsInput() {
    return this._heads;
  }

  // primary - computed: false, optional: true, required: false
  private _primary?: string; 
  public get primary() {
    return this.getStringAttribute('primary');
  }
  public set primary(value: string) {
    this._primary = value;
  }
  public resetPrimary() {
    this._primary = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get primaryInput() {
    return this._primary;
  }

  // ram - computed: false, optional: true, required: false
  private _ram?: number; 
  public get ram() {
    return this.getNumberAttribute('ram');
  }
  public set ram(value: number) {
    this._ram = value;
  }
  public resetRam() {
    this._ram = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ramInput() {
    return this._ram;
  }

  // resolution - computed: false, optional: true, required: false
  private _resolution = new DomainDevicesVideosModelResolutionOutputReference(this, "resolution");
  public get resolution() {
    return this._resolution;
  }
  public putResolution(value: DomainDevicesVideosModelResolution) {
    this._resolution.internalValue = value;
  }
  public resetResolution() {
    this._resolution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resolutionInput() {
    return this._resolution.internalValue;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // vga_mem - computed: false, optional: true, required: false
  private _vgaMem?: number; 
  public get vgaMem() {
    return this.getNumberAttribute('vga_mem');
  }
  public set vgaMem(value: number) {
    this._vgaMem = value;
  }
  public resetVgaMem() {
    this._vgaMem = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vgaMemInput() {
    return this._vgaMem;
  }

  // vram - computed: false, optional: true, required: false
  private _vram?: number; 
  public get vram() {
    return this.getNumberAttribute('vram');
  }
  public set vram(value: number) {
    this._vram = value;
  }
  public resetVram() {
    this._vram = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vramInput() {
    return this._vram;
  }

  // vram64 - computed: false, optional: true, required: false
  private _vram64?: number; 
  public get vram64() {
    return this.getNumberAttribute('vram64');
  }
  public set vram64(value: number) {
    this._vram64 = value;
  }
  public resetVram64() {
    this._vram64 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vram64Input() {
    return this._vram64;
  }
}
export interface DomainDevicesVideos {
  /**
  * Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#acpi Domain#acpi}
  */
  readonly acpi?: DomainDevicesVideosAcpi;
  /**
  * Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: DomainDevicesVideosAddress;
  /**
  * Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#alias Domain#alias}
  */
  readonly alias?: DomainDevicesVideosAlias;
  /**
  * Configures low-level driver options for the video device, such as virtio transport and VGA behavior; attributes are driver- and model-specific.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#driver Domain#driver}
  */
  readonly driver?: DomainDevicesVideosDriver;
  /**
  * Defines the emulated video adapter model (for example `vga`, `cirrus`, `qxl`, `virtio`, `bochs`), which determines capabilities such as resolutions and acceleration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: DomainDevicesVideosModel;
}

export function domainDevicesVideosToTerraform(struct?: DomainDevicesVideos | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    acpi: domainDevicesVideosAcpiToTerraform(struct!.acpi),
    address: domainDevicesVideosAddressToTerraform(struct!.address),
    alias: domainDevicesVideosAliasToTerraform(struct!.alias),
    driver: domainDevicesVideosDriverToTerraform(struct!.driver),
    model: domainDevicesVideosModelToTerraform(struct!.model),
  }
}


export function domainDevicesVideosToHclTerraform(struct?: DomainDevicesVideos | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    acpi: {
      value: domainDevicesVideosAcpiToHclTerraform(struct!.acpi),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesVideosAcpi",
    },
    address: {
      value: domainDevicesVideosAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesVideosAddress",
    },
    alias: {
      value: domainDevicesVideosAliasToHclTerraform(struct!.alias),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesVideosAlias",
    },
    driver: {
      value: domainDevicesVideosDriverToHclTerraform(struct!.driver),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesVideosDriver",
    },
    model: {
      value: domainDevicesVideosModelToHclTerraform(struct!.model),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesVideosModel",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesVideosOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesVideos | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._acpi?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.acpi = this._acpi?.internalValue;
    }
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._alias?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.alias = this._alias?.internalValue;
    }
    if (this._driver?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.driver = this._driver?.internalValue;
    }
    if (this._model?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesVideos | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._acpi.internalValue = undefined;
      this._address.internalValue = undefined;
      this._alias.internalValue = undefined;
      this._driver.internalValue = undefined;
      this._model.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._acpi.internalValue = value.acpi;
      this._address.internalValue = value.address;
      this._alias.internalValue = value.alias;
      this._driver.internalValue = value.driver;
      this._model.internalValue = value.model;
    }
  }

  // acpi - computed: false, optional: true, required: false
  private _acpi = new DomainDevicesVideosAcpiOutputReference(this, "acpi");
  public get acpi() {
    return this._acpi;
  }
  public putAcpi(value: DomainDevicesVideosAcpi) {
    this._acpi.internalValue = value;
  }
  public resetAcpi() {
    this._acpi.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get acpiInput() {
    return this._acpi.internalValue;
  }

  // address - computed: false, optional: true, required: false
  private _address = new DomainDevicesVideosAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DomainDevicesVideosAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // alias - computed: false, optional: true, required: false
  private _alias = new DomainDevicesVideosAliasOutputReference(this, "alias");
  public get alias() {
    return this._alias;
  }
  public putAlias(value: DomainDevicesVideosAlias) {
    this._alias.internalValue = value;
  }
  public resetAlias() {
    this._alias.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aliasInput() {
    return this._alias.internalValue;
  }

  // driver - computed: false, optional: true, required: false
  private _driver = new DomainDevicesVideosDriverOutputReference(this, "driver");
  public get driver() {
    return this._driver;
  }
  public putDriver(value: DomainDevicesVideosDriver) {
    this._driver.internalValue = value;
  }
  public resetDriver() {
    this._driver.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get driverInput() {
    return this._driver.internalValue;
  }

  // model - computed: false, optional: true, required: false
  private _model = new DomainDevicesVideosModelOutputReference(this, "model");
  public get model() {
    return this._model;
  }
  public putModel(value: DomainDevicesVideosModel) {
    this._model.internalValue = value;
  }
  public resetModel() {
    this._model.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model.internalValue;
  }
}

export class DomainDevicesVideosList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesVideos[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesVideosOutputReference {
    return new DomainDevicesVideosOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevicesVsockAcpi {
  /**
  * Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#pstore>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#index Domain#index}
  */
  readonly index?: number;
}

export function domainDevicesVsockAcpiToTerraform(struct?: DomainDevicesVsockAcpi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    index: cdktf.numberToTerraform(struct!.index),
  }
}


export function domainDevicesVsockAcpiToHclTerraform(struct?: DomainDevicesVsockAcpi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    index: {
      value: cdktf.numberToHclTerraform(struct!.index),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesVsockAcpiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesVsockAcpi | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._index !== undefined) {
      hasAnyValues = true;
      internalValueResult.index = this._index;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesVsockAcpi | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._index = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._index = value.index;
    }
  }

  // index - computed: false, optional: true, required: false
  private _index?: number; 
  public get index() {
    return this.getNumberAttribute('index');
  }
  public set index(value: number) {
    this._index = value;
  }
  public resetIndex() {
    this._index = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get indexInput() {
    return this._index;
  }
}
export interface DomainDevicesVsockAddress {
}

export function domainDevicesVsockAddressToTerraform(struct?: DomainDevicesVsockAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function domainDevicesVsockAddressToHclTerraform(struct?: DomainDevicesVsockAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DomainDevicesVsockAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesVsockAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesVsockAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DomainDevicesVsockAlias {
  /**
  * Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
}

export function domainDevicesVsockAliasToTerraform(struct?: DomainDevicesVsockAlias | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function domainDevicesVsockAliasToHclTerraform(struct?: DomainDevicesVsockAlias | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesVsockAliasOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesVsockAlias | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesVsockAlias | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DomainDevicesVsockCid {
  /**
  * Sets a fixed 32‑bit vsock context ID (CID) value to be used by the guest; the value is user‑provided and must be valid for the chosen vsock backend (for example, a positive integer like 3).
  * 
  * See: <https://libvirt.org/formatdomain.html#vsock>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: string;
  /**
  * Controls whether the vsock CID is assigned automatically; when set (typically "yes"/"no"), libvirt or the hypervisor chooses an appropriate CID if automatic assignment is enabled.
  * 
  * See: <https://libvirt.org/formatdomain.html#vsock>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#auto Domain#auto}
  */
  readonly auto?: string;
}

export function domainDevicesVsockCidToTerraform(struct?: DomainDevicesVsockCid | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
    auto: cdktf.stringToTerraform(struct!.auto),
  }
}


export function domainDevicesVsockCidToHclTerraform(struct?: DomainDevicesVsockCid | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auto: {
      value: cdktf.stringToHclTerraform(struct!.auto),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesVsockCidOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesVsockCid | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    if (this._auto !== undefined) {
      hasAnyValues = true;
      internalValueResult.auto = this._auto;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesVsockCid | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
      this._auto = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
      this._auto = value.auto;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  public resetAddress() {
    this._address = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }

  // auto - computed: false, optional: true, required: false
  private _auto?: string; 
  public get auto() {
    return this.getStringAttribute('auto');
  }
  public set auto(value: string) {
    this._auto = value;
  }
  public resetAuto() {
    this._auto = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoInput() {
    return this._auto;
  }
}
export interface DomainDevicesVsockDriver {
  /**
  * Controls Address Translation Service (ATS) support for the virtio vsock device; valid values are "on" or "off".
  * 
  * See: <https://libvirt.org/formatdomain.html#virtio-related-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#ats Domain#ats}
  */
  readonly ats?: string;
  /**
  * Enables or disables use of an emulated IOMMU for the virtio vsock device; valid values are "on" or "off".
  * 
  * See: <https://libvirt.org/formatdomain.html#virtio-related-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#iommu Domain#iommu}
  */
  readonly iommu?: string;
  /**
  * Toggles the virtio "packed" ring layout for the vsock device; valid values are "on" or "off" and support depends on the guest and hypervisor.
  * 
  * See: <https://libvirt.org/formatdomain.html#virtio-related-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#packed Domain#packed}
  */
  readonly packed?: string;
  /**
  * Controls whether each virtqueue of the vsock device uses a separate page (page_per_vq); valid values are "on" or "off".
  * 
  * See: <https://libvirt.org/formatdomain.html#virtio-related-options>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#page_per_vq Domain#page_per_vq}
  */
  readonly pagePerVq?: string;
}

export function domainDevicesVsockDriverToTerraform(struct?: DomainDevicesVsockDriver | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ats: cdktf.stringToTerraform(struct!.ats),
    iommu: cdktf.stringToTerraform(struct!.iommu),
    packed: cdktf.stringToTerraform(struct!.packed),
    page_per_vq: cdktf.stringToTerraform(struct!.pagePerVq),
  }
}


export function domainDevicesVsockDriverToHclTerraform(struct?: DomainDevicesVsockDriver | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ats: {
      value: cdktf.stringToHclTerraform(struct!.ats),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    iommu: {
      value: cdktf.stringToHclTerraform(struct!.iommu),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    packed: {
      value: cdktf.stringToHclTerraform(struct!.packed),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    page_per_vq: {
      value: cdktf.stringToHclTerraform(struct!.pagePerVq),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesVsockDriverOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesVsockDriver | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ats !== undefined) {
      hasAnyValues = true;
      internalValueResult.ats = this._ats;
    }
    if (this._iommu !== undefined) {
      hasAnyValues = true;
      internalValueResult.iommu = this._iommu;
    }
    if (this._packed !== undefined) {
      hasAnyValues = true;
      internalValueResult.packed = this._packed;
    }
    if (this._pagePerVq !== undefined) {
      hasAnyValues = true;
      internalValueResult.pagePerVq = this._pagePerVq;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesVsockDriver | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ats = undefined;
      this._iommu = undefined;
      this._packed = undefined;
      this._pagePerVq = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ats = value.ats;
      this._iommu = value.iommu;
      this._packed = value.packed;
      this._pagePerVq = value.pagePerVq;
    }
  }

  // ats - computed: false, optional: true, required: false
  private _ats?: string; 
  public get ats() {
    return this.getStringAttribute('ats');
  }
  public set ats(value: string) {
    this._ats = value;
  }
  public resetAts() {
    this._ats = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get atsInput() {
    return this._ats;
  }

  // iommu - computed: false, optional: true, required: false
  private _iommu?: string; 
  public get iommu() {
    return this.getStringAttribute('iommu');
  }
  public set iommu(value: string) {
    this._iommu = value;
  }
  public resetIommu() {
    this._iommu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get iommuInput() {
    return this._iommu;
  }

  // packed - computed: false, optional: true, required: false
  private _packed?: string; 
  public get packed() {
    return this.getStringAttribute('packed');
  }
  public set packed(value: string) {
    this._packed = value;
  }
  public resetPacked() {
    this._packed = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get packedInput() {
    return this._packed;
  }

  // page_per_vq - computed: false, optional: true, required: false
  private _pagePerVq?: string; 
  public get pagePerVq() {
    return this.getStringAttribute('page_per_vq');
  }
  public set pagePerVq(value: string) {
    this._pagePerVq = value;
  }
  public resetPagePerVq() {
    this._pagePerVq = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pagePerVqInput() {
    return this._pagePerVq;
  }
}
export interface DomainDevicesVsock {
  /**
  * Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#acpi Domain#acpi}
  */
  readonly acpi?: DomainDevicesVsockAcpi;
  /**
  * Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: DomainDevicesVsockAddress;
  /**
  * Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#alias Domain#alias}
  */
  readonly alias?: DomainDevicesVsockAlias;
  /**
  * Configures the vsock context ID (CID) container, which holds either a fixed CID or indicates automatic assignment for the vsock device.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#cid Domain#cid}
  */
  readonly cid?: DomainDevicesVsockCid;
  /**
  * Configures virtio transport–specific options for the vsock device driver, such as IOMMU and ATS usage.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#driver Domain#driver}
  */
  readonly driver?: DomainDevicesVsockDriver;
  /**
  * Sets the vsock device model, typically one of "virtio", "virtio-transitional", or "virtio-non-transitional"; if omitted, libvirt uses its default vsock model.
  * 
  * See: <https://libvirt.org/formatdomain.html#vsock>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model?: string;
}

export function domainDevicesVsockToTerraform(struct?: DomainDevicesVsock | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    acpi: domainDevicesVsockAcpiToTerraform(struct!.acpi),
    address: domainDevicesVsockAddressToTerraform(struct!.address),
    alias: domainDevicesVsockAliasToTerraform(struct!.alias),
    cid: domainDevicesVsockCidToTerraform(struct!.cid),
    driver: domainDevicesVsockDriverToTerraform(struct!.driver),
    model: cdktf.stringToTerraform(struct!.model),
  }
}


export function domainDevicesVsockToHclTerraform(struct?: DomainDevicesVsock | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    acpi: {
      value: domainDevicesVsockAcpiToHclTerraform(struct!.acpi),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesVsockAcpi",
    },
    address: {
      value: domainDevicesVsockAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesVsockAddress",
    },
    alias: {
      value: domainDevicesVsockAliasToHclTerraform(struct!.alias),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesVsockAlias",
    },
    cid: {
      value: domainDevicesVsockCidToHclTerraform(struct!.cid),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesVsockCid",
    },
    driver: {
      value: domainDevicesVsockDriverToHclTerraform(struct!.driver),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesVsockDriver",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesVsockOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesVsock | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._acpi?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.acpi = this._acpi?.internalValue;
    }
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._alias?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.alias = this._alias?.internalValue;
    }
    if (this._cid?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cid = this._cid?.internalValue;
    }
    if (this._driver?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.driver = this._driver?.internalValue;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesVsock | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._acpi.internalValue = undefined;
      this._address.internalValue = undefined;
      this._alias.internalValue = undefined;
      this._cid.internalValue = undefined;
      this._driver.internalValue = undefined;
      this._model = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._acpi.internalValue = value.acpi;
      this._address.internalValue = value.address;
      this._alias.internalValue = value.alias;
      this._cid.internalValue = value.cid;
      this._driver.internalValue = value.driver;
      this._model = value.model;
    }
  }

  // acpi - computed: false, optional: true, required: false
  private _acpi = new DomainDevicesVsockAcpiOutputReference(this, "acpi");
  public get acpi() {
    return this._acpi;
  }
  public putAcpi(value: DomainDevicesVsockAcpi) {
    this._acpi.internalValue = value;
  }
  public resetAcpi() {
    this._acpi.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get acpiInput() {
    return this._acpi.internalValue;
  }

  // address - computed: false, optional: true, required: false
  private _address = new DomainDevicesVsockAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DomainDevicesVsockAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // alias - computed: false, optional: true, required: false
  private _alias = new DomainDevicesVsockAliasOutputReference(this, "alias");
  public get alias() {
    return this._alias;
  }
  public putAlias(value: DomainDevicesVsockAlias) {
    this._alias.internalValue = value;
  }
  public resetAlias() {
    this._alias.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aliasInput() {
    return this._alias.internalValue;
  }

  // cid - computed: false, optional: true, required: false
  private _cid = new DomainDevicesVsockCidOutputReference(this, "cid");
  public get cid() {
    return this._cid;
  }
  public putCid(value: DomainDevicesVsockCid) {
    this._cid.internalValue = value;
  }
  public resetCid() {
    this._cid.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cidInput() {
    return this._cid.internalValue;
  }

  // driver - computed: false, optional: true, required: false
  private _driver = new DomainDevicesVsockDriverOutputReference(this, "driver");
  public get driver() {
    return this._driver;
  }
  public putDriver(value: DomainDevicesVsockDriver) {
    this._driver.internalValue = value;
  }
  public resetDriver() {
    this._driver.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get driverInput() {
    return this._driver.internalValue;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }
}
export interface DomainDevicesWatchdogsAcpi {
  /**
  * Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.
  * 
  * See: <https://libvirt.org/formatdomain.html#pstore>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#index Domain#index}
  */
  readonly index?: number;
}

export function domainDevicesWatchdogsAcpiToTerraform(struct?: DomainDevicesWatchdogsAcpi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    index: cdktf.numberToTerraform(struct!.index),
  }
}


export function domainDevicesWatchdogsAcpiToHclTerraform(struct?: DomainDevicesWatchdogsAcpi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    index: {
      value: cdktf.numberToHclTerraform(struct!.index),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesWatchdogsAcpiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesWatchdogsAcpi | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._index !== undefined) {
      hasAnyValues = true;
      internalValueResult.index = this._index;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesWatchdogsAcpi | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._index = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._index = value.index;
    }
  }

  // index - computed: false, optional: true, required: false
  private _index?: number; 
  public get index() {
    return this.getNumberAttribute('index');
  }
  public set index(value: number) {
    this._index = value;
  }
  public resetIndex() {
    this._index = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get indexInput() {
    return this._index;
  }
}
export interface DomainDevicesWatchdogsAddress {
}

export function domainDevicesWatchdogsAddressToTerraform(struct?: DomainDevicesWatchdogsAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function domainDevicesWatchdogsAddressToHclTerraform(struct?: DomainDevicesWatchdogsAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DomainDevicesWatchdogsAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesWatchdogsAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesWatchdogsAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DomainDevicesWatchdogsAlias {
  /**
  * Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#name Domain#name}
  */
  readonly name: string;
}

export function domainDevicesWatchdogsAliasToTerraform(struct?: DomainDevicesWatchdogsAlias | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function domainDevicesWatchdogsAliasToHclTerraform(struct?: DomainDevicesWatchdogsAlias | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesWatchdogsAliasOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevicesWatchdogsAlias | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesWatchdogsAlias | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DomainDevicesWatchdogs {
  /**
  * Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#acpi Domain#acpi}
  */
  readonly acpi?: DomainDevicesWatchdogsAcpi;
  /**
  * Selects the action to take when the watchdog fires, such as "reset", "poweroff", "dump", or "none", depending on hypervisor support.
  * 
  * See: <https://libvirt.org/formatdomain.html#watchdog-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#action Domain#action}
  */
  readonly action?: string;
  /**
  * Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#address Domain#address}
  */
  readonly address?: DomainDevicesWatchdogsAddress;
  /**
  * Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#alias Domain#alias}
  */
  readonly alias?: DomainDevicesWatchdogsAlias;
  /**
  * Specifies the watchdog hardware model to emulate (for example, "i6300esb"), and is required when defining a watchdog device.
  * 
  * See: <https://libvirt.org/formatdomain.html#watchdog-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#model Domain#model}
  */
  readonly model: string;
}

export function domainDevicesWatchdogsToTerraform(struct?: DomainDevicesWatchdogs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    acpi: domainDevicesWatchdogsAcpiToTerraform(struct!.acpi),
    action: cdktf.stringToTerraform(struct!.action),
    address: domainDevicesWatchdogsAddressToTerraform(struct!.address),
    alias: domainDevicesWatchdogsAliasToTerraform(struct!.alias),
    model: cdktf.stringToTerraform(struct!.model),
  }
}


export function domainDevicesWatchdogsToHclTerraform(struct?: DomainDevicesWatchdogs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    acpi: {
      value: domainDevicesWatchdogsAcpiToHclTerraform(struct!.acpi),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesWatchdogsAcpi",
    },
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    address: {
      value: domainDevicesWatchdogsAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesWatchdogsAddress",
    },
    alias: {
      value: domainDevicesWatchdogsAliasToHclTerraform(struct!.alias),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesWatchdogsAlias",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesWatchdogsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DomainDevicesWatchdogs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._acpi?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.acpi = this._acpi?.internalValue;
    }
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._alias?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.alias = this._alias?.internalValue;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevicesWatchdogs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._acpi.internalValue = undefined;
      this._action = undefined;
      this._address.internalValue = undefined;
      this._alias.internalValue = undefined;
      this._model = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._acpi.internalValue = value.acpi;
      this._action = value.action;
      this._address.internalValue = value.address;
      this._alias.internalValue = value.alias;
      this._model = value.model;
    }
  }

  // acpi - computed: false, optional: true, required: false
  private _acpi = new DomainDevicesWatchdogsAcpiOutputReference(this, "acpi");
  public get acpi() {
    return this._acpi;
  }
  public putAcpi(value: DomainDevicesWatchdogsAcpi) {
    this._acpi.internalValue = value;
  }
  public resetAcpi() {
    this._acpi.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get acpiInput() {
    return this._acpi.internalValue;
  }

  // action - computed: false, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // address - computed: false, optional: true, required: false
  private _address = new DomainDevicesWatchdogsAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DomainDevicesWatchdogsAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // alias - computed: false, optional: true, required: false
  private _alias = new DomainDevicesWatchdogsAliasOutputReference(this, "alias");
  public get alias() {
    return this._alias;
  }
  public putAlias(value: DomainDevicesWatchdogsAlias) {
    this._alias.internalValue = value;
  }
  public resetAlias() {
    this._alias.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aliasInput() {
    return this._alias.internalValue;
  }

  // model - computed: false, optional: false, required: true
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }
}

export class DomainDevicesWatchdogsList extends cdktf.ComplexList {
  public internalValue? : DomainDevicesWatchdogs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DomainDevicesWatchdogsOutputReference {
    return new DomainDevicesWatchdogsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DomainDevices {
  /**
  * Configures one or more audio backend definitions that map virtual sound devices in the guest to host audio backends.
  * 
  * See: <https://libvirt.org/formatdomain.html#audio-backends>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#audios Domain#audios}
  */
  readonly audios?: DomainDevicesAudios[] | cdktf.IResolvable;
  /**
  * Defines one or more guest channel devices, which provide private communication paths between host and guest (for example, virtio channels for agents or SPICE).
  * 
  * See: <https://libvirt.org/formatdomain.html#channel>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#channels Domain#channels}
  */
  readonly channels?: DomainDevicesChannels[] | cdktf.IResolvable;
  /**
  * Configures one or more console devices for the guest, defining how serial consoles are exposed and connected.
  * 
  * See: <https://libvirt.org/formatdomain.html#console>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#consoles Domain#consoles}
  */
  readonly consoles?: DomainDevicesConsoles[] | cdktf.IResolvable;
  /**
  * Declares one or more device controllers (PCI, USB, SCSI, virtio-serial, etc.) attached to the guest, controlling how device buses are exposed.
  * 
  * See: <https://libvirt.org/formatdomain.html#controllers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#controllers Domain#controllers}
  */
  readonly controllers?: DomainDevicesControllers[] | cdktf.IResolvable;
  /**
  * Configures a virtio-based crypto device that offloads cryptographic operations to the host; the device type and backend parameters are specified in its child attributes.
  * 
  * See: <https://libvirt.org/formatdomain.html#crypto>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#crypto Domain#crypto}
  */
  readonly crypto?: DomainDevicesCrypto[] | cdktf.IResolvable;
  /**
  * Declares one or more block devices (disks, CD-ROMs, etc.) attached to the guest, each with its own source, target, and optional tuning parameters.
  * 
  * See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#disks Domain#disks}
  */
  readonly disks?: DomainDevicesDisks[] | cdktf.IResolvable;
  /**
  * Sets the absolute path to the hypervisor emulator binary used to run this domain (for example "/usr/bin/qemu-system-x86_64").
  * 
  * See: <https://libvirt.org/formatdomain.html#devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#emulator Domain#emulator}
  */
  readonly emulator?: string;
  /**
  * Declares one or more filesystem devices that expose host directories or block devices into the guest.
  * 
  * See: <https://libvirt.org/formatdomain.html#filesystems>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#filesystems Domain#filesystems}
  */
  readonly filesystems?: DomainDevicesFilesystems[] | cdktf.IResolvable;
  /**
  * Configures one or more graphical framebuffer devices (such as VNC, SPICE, or DBus-based displays) for the guest.
  * 
  * See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#graphics Domain#graphics}
  */
  readonly graphics?: DomainDevicesGraphics[] | cdktf.IResolvable;
  /**
  * Defines one or more hostdev entries describing host devices (PCI, USB, SCSI, etc.) that are passed through directly to the guest.
  * 
  * See: <https://libvirt.org/formatdomain.html#host-device-assignment>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#hostdevs Domain#hostdevs}
  */
  readonly hostdevs?: DomainDevicesHostdevs[] | cdktf.IResolvable;
  /**
  * Declares one or more virtual hub devices attached to a guest bus, typically to provide additional USB ports to the guest.
  * 
  * See: <https://libvirt.org/formatdomain.html#hub-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#hubs Domain#hubs}
  */
  readonly hubs?: DomainDevicesHubs[] | cdktf.IResolvable;
  /**
  * Declares one or more guest input devices such as tablets, mice, or keyboards, and configures their type, bus, and optional passthrough settings.
  * 
  * See: <https://libvirt.org/formatdomain.html#input-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#inputs Domain#inputs}
  */
  readonly inputs?: DomainDevicesInputs[] | cdktf.IResolvable;
  /**
  * Defines one or more network interface devices attached to the guest, including their connection mode, model, addressing, and related options.
  * 
  * See: <https://libvirt.org/formatdomain.html#network-interfaces>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#interfaces Domain#interfaces}
  */
  readonly interfaces?: DomainDevicesInterfaces[] | cdktf.IResolvable;
  /**
  * Configures an IOMMU device for the guest, enabling emulated or paravirtual IOMMU functionality; requires a model and may include driver and ACPI options.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#iommu Domain#iommu}
  */
  readonly iommu?: DomainDevicesIommu;
  /**
  * Configures one or more device leases that must be acquired by the lock manager before the domain can start, each represented as a lease entry.
  * 
  * See: <https://libvirt.org/formatdomain.html#device-leases>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#leases Domain#leases}
  */
  readonly leases?: DomainDevicesLeases[] | cdktf.IResolvable;
  /**
  * Configures the guest memory balloon device, which allows the host to dynamically adjust the guest’s available memory.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mem_balloon Domain#mem_balloon}
  */
  readonly memBalloon?: DomainDevicesMemBalloon;
  /**
  * Defines one or more memory device entries (DIMM, NVDIMM, virtio-mem, etc.) that provide additional, hot-pluggable memory to the guest.
  * 
  * See: <https://libvirt.org/formatdomain.html#memory-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#memorydevs Domain#memorydevs}
  */
  readonly memorydevs?: DomainDevicesMemorydevs[] | cdktf.IResolvable;
  /**
  * Adds an NVRAM device to the domain, allowing firmware or platform-specific non-volatile state to be stored separately from normal disks.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#nvram Domain#nvram}
  */
  readonly nvram?: DomainDevicesNvram;
  /**
  * Adds one or more panic devices that report guest panic events to the host, allowing external monitoring or automation on guest crashes.
  * 
  * See: <https://libvirt.org/formatdomain.html#panic-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#panics Domain#panics}
  */
  readonly panics?: DomainDevicesPanics[] | cdktf.IResolvable;
  /**
  * Configures one or more parallel port character devices exposed to the guest, each represented by a parallel element with optional address, backend, and logging settings.
  * 
  * See: <https://libvirt.org/formatdomain.html#parallel-port>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#parallels Domain#parallels}
  */
  readonly parallels?: DomainDevicesParallels[] | cdktf.IResolvable;
  /**
  * Adds a pstore device to the guest for persistent storage of kernel oops/panic logs, mapping to a host backend.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#pstore Domain#pstore}
  */
  readonly pstore?: DomainDevicesPstore;
  /**
  * Configures one or more redirected USB devices exposed to the guest via redirdev, typically used in conjunction with SPICE or similar frontends.
  * 
  * See: <https://libvirt.org/formatdomain.html#redirected-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#redir_devs Domain#redir_devs}
  */
  readonly redirDevs?: DomainDevicesRedirDevs[] | cdktf.IResolvable;
  /**
  * Configures one or more USB redirection filter rules that determine which redirected USB devices are allowed or denied to the guest.
  * 
  * See: <https://libvirt.org/formatdomain.html#redirected-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#redir_filters Domain#redir_filters}
  */
  readonly redirFilters?: DomainDevicesRedirFilters[] | cdktf.IResolvable;
  /**
  * Defines one or more virtual random number generator devices attached to the guest.
  * 
  * See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#rngs Domain#rngs}
  */
  readonly rngs?: DomainDevicesRngs[] | cdktf.IResolvable;
  /**
  * Configures one or more virtual serial port devices attached to the guest.
  * 
  * See: <https://libvirt.org/formatdomain.html#serial-port>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#serials Domain#serials}
  */
  readonly serials?: DomainDevicesSerials[] | cdktf.IResolvable;
  /**
  * Defines one or more shared memory (ivshmem/shmem) devices used to share memory regions between this guest, other guests, and/or the host.
  * 
  * See: <https://libvirt.org/formatdomain.html#shared-memory-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#shmems Domain#shmems}
  */
  readonly shmems?: DomainDevicesShmems[] | cdktf.IResolvable;
  /**
  * Defines one or more virtual smartcard devices attached to the guest.
  * 
  * See: <https://libvirt.org/formatdomain.html#smartcard-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#smartcards Domain#smartcards}
  */
  readonly smartcards?: DomainDevicesSmartcards[] | cdktf.IResolvable;
  /**
  * Configures one or more virtual sound devices attached to the guest.
  * 
  * See: <https://libvirt.org/formatdomain.html#sound-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sounds Domain#sounds}
  */
  readonly sounds?: DomainDevicesSounds[] | cdktf.IResolvable;
  /**
  * Configures one or more TPM devices attached to the guest, including their backend implementation, addressing, and optional ACPI integration.
  * 
  * See: <https://libvirt.org/formatdomain.html#tpm-device>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tpms Domain#tpms}
  */
  readonly tpms?: DomainDevicesTpms[] | cdktf.IResolvable;
  /**
  * Defines one or more video devices attached to the guest, each providing a virtual graphics adapter.
  * 
  * See: <https://libvirt.org/formatdomain.html#video-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#videos Domain#videos}
  */
  readonly videos?: DomainDevicesVideos[] | cdktf.IResolvable;
  /**
  * Configures a virtio vsock device that provides a host/guest communication channel using a CID-based socket interface.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vsock Domain#vsock}
  */
  readonly vsock?: DomainDevicesVsock;
  /**
  * Configures one or more virtual watchdog devices attached to the guest, each controlling timeout behavior and actions on failure.
  * 
  * See: <https://libvirt.org/formatdomain.html#watchdog-devices>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#watchdogs Domain#watchdogs}
  */
  readonly watchdogs?: DomainDevicesWatchdogs[] | cdktf.IResolvable;
}

export function domainDevicesToTerraform(struct?: DomainDevices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    audios: cdktf.listMapper(domainDevicesAudiosToTerraform, false)(struct!.audios),
    channels: cdktf.listMapper(domainDevicesChannelsToTerraform, false)(struct!.channels),
    consoles: cdktf.listMapper(domainDevicesConsolesToTerraform, false)(struct!.consoles),
    controllers: cdktf.listMapper(domainDevicesControllersToTerraform, false)(struct!.controllers),
    crypto: cdktf.listMapper(domainDevicesCryptoToTerraform, false)(struct!.crypto),
    disks: cdktf.listMapper(domainDevicesDisksToTerraform, false)(struct!.disks),
    emulator: cdktf.stringToTerraform(struct!.emulator),
    filesystems: cdktf.listMapper(domainDevicesFilesystemsToTerraform, false)(struct!.filesystems),
    graphics: cdktf.listMapper(domainDevicesGraphicsToTerraform, false)(struct!.graphics),
    hostdevs: cdktf.listMapper(domainDevicesHostdevsToTerraform, false)(struct!.hostdevs),
    hubs: cdktf.listMapper(domainDevicesHubsToTerraform, false)(struct!.hubs),
    inputs: cdktf.listMapper(domainDevicesInputsToTerraform, false)(struct!.inputs),
    interfaces: cdktf.listMapper(domainDevicesInterfacesToTerraform, false)(struct!.interfaces),
    iommu: domainDevicesIommuToTerraform(struct!.iommu),
    leases: cdktf.listMapper(domainDevicesLeasesToTerraform, false)(struct!.leases),
    mem_balloon: domainDevicesMemBalloonToTerraform(struct!.memBalloon),
    memorydevs: cdktf.listMapper(domainDevicesMemorydevsToTerraform, false)(struct!.memorydevs),
    nvram: domainDevicesNvramToTerraform(struct!.nvram),
    panics: cdktf.listMapper(domainDevicesPanicsToTerraform, false)(struct!.panics),
    parallels: cdktf.listMapper(domainDevicesParallelsToTerraform, false)(struct!.parallels),
    pstore: domainDevicesPstoreToTerraform(struct!.pstore),
    redir_devs: cdktf.listMapper(domainDevicesRedirDevsToTerraform, false)(struct!.redirDevs),
    redir_filters: cdktf.listMapper(domainDevicesRedirFiltersToTerraform, false)(struct!.redirFilters),
    rngs: cdktf.listMapper(domainDevicesRngsToTerraform, false)(struct!.rngs),
    serials: cdktf.listMapper(domainDevicesSerialsToTerraform, false)(struct!.serials),
    shmems: cdktf.listMapper(domainDevicesShmemsToTerraform, false)(struct!.shmems),
    smartcards: cdktf.listMapper(domainDevicesSmartcardsToTerraform, false)(struct!.smartcards),
    sounds: cdktf.listMapper(domainDevicesSoundsToTerraform, false)(struct!.sounds),
    tpms: cdktf.listMapper(domainDevicesTpmsToTerraform, false)(struct!.tpms),
    videos: cdktf.listMapper(domainDevicesVideosToTerraform, false)(struct!.videos),
    vsock: domainDevicesVsockToTerraform(struct!.vsock),
    watchdogs: cdktf.listMapper(domainDevicesWatchdogsToTerraform, false)(struct!.watchdogs),
  }
}


export function domainDevicesToHclTerraform(struct?: DomainDevices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    audios: {
      value: cdktf.listMapperHcl(domainDevicesAudiosToHclTerraform, false)(struct!.audios),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesAudiosList",
    },
    channels: {
      value: cdktf.listMapperHcl(domainDevicesChannelsToHclTerraform, false)(struct!.channels),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesChannelsList",
    },
    consoles: {
      value: cdktf.listMapperHcl(domainDevicesConsolesToHclTerraform, false)(struct!.consoles),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesConsolesList",
    },
    controllers: {
      value: cdktf.listMapperHcl(domainDevicesControllersToHclTerraform, false)(struct!.controllers),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesControllersList",
    },
    crypto: {
      value: cdktf.listMapperHcl(domainDevicesCryptoToHclTerraform, false)(struct!.crypto),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesCryptoList",
    },
    disks: {
      value: cdktf.listMapperHcl(domainDevicesDisksToHclTerraform, false)(struct!.disks),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesDisksList",
    },
    emulator: {
      value: cdktf.stringToHclTerraform(struct!.emulator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    filesystems: {
      value: cdktf.listMapperHcl(domainDevicesFilesystemsToHclTerraform, false)(struct!.filesystems),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesFilesystemsList",
    },
    graphics: {
      value: cdktf.listMapperHcl(domainDevicesGraphicsToHclTerraform, false)(struct!.graphics),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesGraphicsList",
    },
    hostdevs: {
      value: cdktf.listMapperHcl(domainDevicesHostdevsToHclTerraform, false)(struct!.hostdevs),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesHostdevsList",
    },
    hubs: {
      value: cdktf.listMapperHcl(domainDevicesHubsToHclTerraform, false)(struct!.hubs),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesHubsList",
    },
    inputs: {
      value: cdktf.listMapperHcl(domainDevicesInputsToHclTerraform, false)(struct!.inputs),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesInputsList",
    },
    interfaces: {
      value: cdktf.listMapperHcl(domainDevicesInterfacesToHclTerraform, false)(struct!.interfaces),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesInterfacesList",
    },
    iommu: {
      value: domainDevicesIommuToHclTerraform(struct!.iommu),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesIommu",
    },
    leases: {
      value: cdktf.listMapperHcl(domainDevicesLeasesToHclTerraform, false)(struct!.leases),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesLeasesList",
    },
    mem_balloon: {
      value: domainDevicesMemBalloonToHclTerraform(struct!.memBalloon),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesMemBalloon",
    },
    memorydevs: {
      value: cdktf.listMapperHcl(domainDevicesMemorydevsToHclTerraform, false)(struct!.memorydevs),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesMemorydevsList",
    },
    nvram: {
      value: domainDevicesNvramToHclTerraform(struct!.nvram),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesNvram",
    },
    panics: {
      value: cdktf.listMapperHcl(domainDevicesPanicsToHclTerraform, false)(struct!.panics),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesPanicsList",
    },
    parallels: {
      value: cdktf.listMapperHcl(domainDevicesParallelsToHclTerraform, false)(struct!.parallels),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesParallelsList",
    },
    pstore: {
      value: domainDevicesPstoreToHclTerraform(struct!.pstore),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesPstore",
    },
    redir_devs: {
      value: cdktf.listMapperHcl(domainDevicesRedirDevsToHclTerraform, false)(struct!.redirDevs),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesRedirDevsList",
    },
    redir_filters: {
      value: cdktf.listMapperHcl(domainDevicesRedirFiltersToHclTerraform, false)(struct!.redirFilters),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesRedirFiltersList",
    },
    rngs: {
      value: cdktf.listMapperHcl(domainDevicesRngsToHclTerraform, false)(struct!.rngs),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesRngsList",
    },
    serials: {
      value: cdktf.listMapperHcl(domainDevicesSerialsToHclTerraform, false)(struct!.serials),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesSerialsList",
    },
    shmems: {
      value: cdktf.listMapperHcl(domainDevicesShmemsToHclTerraform, false)(struct!.shmems),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesShmemsList",
    },
    smartcards: {
      value: cdktf.listMapperHcl(domainDevicesSmartcardsToHclTerraform, false)(struct!.smartcards),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesSmartcardsList",
    },
    sounds: {
      value: cdktf.listMapperHcl(domainDevicesSoundsToHclTerraform, false)(struct!.sounds),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesSoundsList",
    },
    tpms: {
      value: cdktf.listMapperHcl(domainDevicesTpmsToHclTerraform, false)(struct!.tpms),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesTpmsList",
    },
    videos: {
      value: cdktf.listMapperHcl(domainDevicesVideosToHclTerraform, false)(struct!.videos),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesVideosList",
    },
    vsock: {
      value: domainDevicesVsockToHclTerraform(struct!.vsock),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainDevicesVsock",
    },
    watchdogs: {
      value: cdktf.listMapperHcl(domainDevicesWatchdogsToHclTerraform, false)(struct!.watchdogs),
      isBlock: true,
      type: "list",
      storageClassType: "DomainDevicesWatchdogsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainDevicesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainDevices | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._audios?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.audios = this._audios?.internalValue;
    }
    if (this._channels?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.channels = this._channels?.internalValue;
    }
    if (this._consoles?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.consoles = this._consoles?.internalValue;
    }
    if (this._controllers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.controllers = this._controllers?.internalValue;
    }
    if (this._crypto?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.crypto = this._crypto?.internalValue;
    }
    if (this._disks?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.disks = this._disks?.internalValue;
    }
    if (this._emulator !== undefined) {
      hasAnyValues = true;
      internalValueResult.emulator = this._emulator;
    }
    if (this._filesystems?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.filesystems = this._filesystems?.internalValue;
    }
    if (this._graphics?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.graphics = this._graphics?.internalValue;
    }
    if (this._hostdevs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostdevs = this._hostdevs?.internalValue;
    }
    if (this._hubs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hubs = this._hubs?.internalValue;
    }
    if (this._inputs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.inputs = this._inputs?.internalValue;
    }
    if (this._interfaces?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.interfaces = this._interfaces?.internalValue;
    }
    if (this._iommu?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.iommu = this._iommu?.internalValue;
    }
    if (this._leases?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.leases = this._leases?.internalValue;
    }
    if (this._memBalloon?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.memBalloon = this._memBalloon?.internalValue;
    }
    if (this._memorydevs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.memorydevs = this._memorydevs?.internalValue;
    }
    if (this._nvram?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nvram = this._nvram?.internalValue;
    }
    if (this._panics?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.panics = this._panics?.internalValue;
    }
    if (this._parallels?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.parallels = this._parallels?.internalValue;
    }
    if (this._pstore?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pstore = this._pstore?.internalValue;
    }
    if (this._redirDevs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.redirDevs = this._redirDevs?.internalValue;
    }
    if (this._redirFilters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.redirFilters = this._redirFilters?.internalValue;
    }
    if (this._rngs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rngs = this._rngs?.internalValue;
    }
    if (this._serials?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serials = this._serials?.internalValue;
    }
    if (this._shmems?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.shmems = this._shmems?.internalValue;
    }
    if (this._smartcards?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.smartcards = this._smartcards?.internalValue;
    }
    if (this._sounds?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sounds = this._sounds?.internalValue;
    }
    if (this._tpms?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tpms = this._tpms?.internalValue;
    }
    if (this._videos?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.videos = this._videos?.internalValue;
    }
    if (this._vsock?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.vsock = this._vsock?.internalValue;
    }
    if (this._watchdogs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.watchdogs = this._watchdogs?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainDevices | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._audios.internalValue = undefined;
      this._channels.internalValue = undefined;
      this._consoles.internalValue = undefined;
      this._controllers.internalValue = undefined;
      this._crypto.internalValue = undefined;
      this._disks.internalValue = undefined;
      this._emulator = undefined;
      this._filesystems.internalValue = undefined;
      this._graphics.internalValue = undefined;
      this._hostdevs.internalValue = undefined;
      this._hubs.internalValue = undefined;
      this._inputs.internalValue = undefined;
      this._interfaces.internalValue = undefined;
      this._iommu.internalValue = undefined;
      this._leases.internalValue = undefined;
      this._memBalloon.internalValue = undefined;
      this._memorydevs.internalValue = undefined;
      this._nvram.internalValue = undefined;
      this._panics.internalValue = undefined;
      this._parallels.internalValue = undefined;
      this._pstore.internalValue = undefined;
      this._redirDevs.internalValue = undefined;
      this._redirFilters.internalValue = undefined;
      this._rngs.internalValue = undefined;
      this._serials.internalValue = undefined;
      this._shmems.internalValue = undefined;
      this._smartcards.internalValue = undefined;
      this._sounds.internalValue = undefined;
      this._tpms.internalValue = undefined;
      this._videos.internalValue = undefined;
      this._vsock.internalValue = undefined;
      this._watchdogs.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._audios.internalValue = value.audios;
      this._channels.internalValue = value.channels;
      this._consoles.internalValue = value.consoles;
      this._controllers.internalValue = value.controllers;
      this._crypto.internalValue = value.crypto;
      this._disks.internalValue = value.disks;
      this._emulator = value.emulator;
      this._filesystems.internalValue = value.filesystems;
      this._graphics.internalValue = value.graphics;
      this._hostdevs.internalValue = value.hostdevs;
      this._hubs.internalValue = value.hubs;
      this._inputs.internalValue = value.inputs;
      this._interfaces.internalValue = value.interfaces;
      this._iommu.internalValue = value.iommu;
      this._leases.internalValue = value.leases;
      this._memBalloon.internalValue = value.memBalloon;
      this._memorydevs.internalValue = value.memorydevs;
      this._nvram.internalValue = value.nvram;
      this._panics.internalValue = value.panics;
      this._parallels.internalValue = value.parallels;
      this._pstore.internalValue = value.pstore;
      this._redirDevs.internalValue = value.redirDevs;
      this._redirFilters.internalValue = value.redirFilters;
      this._rngs.internalValue = value.rngs;
      this._serials.internalValue = value.serials;
      this._shmems.internalValue = value.shmems;
      this._smartcards.internalValue = value.smartcards;
      this._sounds.internalValue = value.sounds;
      this._tpms.internalValue = value.tpms;
      this._videos.internalValue = value.videos;
      this._vsock.internalValue = value.vsock;
      this._watchdogs.internalValue = value.watchdogs;
    }
  }

  // audios - computed: false, optional: true, required: false
  private _audios = new DomainDevicesAudiosList(this, "audios", false);
  public get audios() {
    return this._audios;
  }
  public putAudios(value: DomainDevicesAudios[] | cdktf.IResolvable) {
    this._audios.internalValue = value;
  }
  public resetAudios() {
    this._audios.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get audiosInput() {
    return this._audios.internalValue;
  }

  // channels - computed: false, optional: true, required: false
  private _channels = new DomainDevicesChannelsList(this, "channels", false);
  public get channels() {
    return this._channels;
  }
  public putChannels(value: DomainDevicesChannels[] | cdktf.IResolvable) {
    this._channels.internalValue = value;
  }
  public resetChannels() {
    this._channels.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get channelsInput() {
    return this._channels.internalValue;
  }

  // consoles - computed: false, optional: true, required: false
  private _consoles = new DomainDevicesConsolesList(this, "consoles", false);
  public get consoles() {
    return this._consoles;
  }
  public putConsoles(value: DomainDevicesConsoles[] | cdktf.IResolvable) {
    this._consoles.internalValue = value;
  }
  public resetConsoles() {
    this._consoles.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get consolesInput() {
    return this._consoles.internalValue;
  }

  // controllers - computed: false, optional: true, required: false
  private _controllers = new DomainDevicesControllersList(this, "controllers", false);
  public get controllers() {
    return this._controllers;
  }
  public putControllers(value: DomainDevicesControllers[] | cdktf.IResolvable) {
    this._controllers.internalValue = value;
  }
  public resetControllers() {
    this._controllers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get controllersInput() {
    return this._controllers.internalValue;
  }

  // crypto - computed: false, optional: true, required: false
  private _crypto = new DomainDevicesCryptoList(this, "crypto", false);
  public get crypto() {
    return this._crypto;
  }
  public putCrypto(value: DomainDevicesCrypto[] | cdktf.IResolvable) {
    this._crypto.internalValue = value;
  }
  public resetCrypto() {
    this._crypto.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cryptoInput() {
    return this._crypto.internalValue;
  }

  // disks - computed: false, optional: true, required: false
  private _disks = new DomainDevicesDisksList(this, "disks", false);
  public get disks() {
    return this._disks;
  }
  public putDisks(value: DomainDevicesDisks[] | cdktf.IResolvable) {
    this._disks.internalValue = value;
  }
  public resetDisks() {
    this._disks.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disksInput() {
    return this._disks.internalValue;
  }

  // emulator - computed: false, optional: true, required: false
  private _emulator?: string; 
  public get emulator() {
    return this.getStringAttribute('emulator');
  }
  public set emulator(value: string) {
    this._emulator = value;
  }
  public resetEmulator() {
    this._emulator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get emulatorInput() {
    return this._emulator;
  }

  // filesystems - computed: false, optional: true, required: false
  private _filesystems = new DomainDevicesFilesystemsList(this, "filesystems", false);
  public get filesystems() {
    return this._filesystems;
  }
  public putFilesystems(value: DomainDevicesFilesystems[] | cdktf.IResolvable) {
    this._filesystems.internalValue = value;
  }
  public resetFilesystems() {
    this._filesystems.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filesystemsInput() {
    return this._filesystems.internalValue;
  }

  // graphics - computed: false, optional: true, required: false
  private _graphics = new DomainDevicesGraphicsList(this, "graphics", false);
  public get graphics() {
    return this._graphics;
  }
  public putGraphics(value: DomainDevicesGraphics[] | cdktf.IResolvable) {
    this._graphics.internalValue = value;
  }
  public resetGraphics() {
    this._graphics.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get graphicsInput() {
    return this._graphics.internalValue;
  }

  // hostdevs - computed: false, optional: true, required: false
  private _hostdevs = new DomainDevicesHostdevsList(this, "hostdevs", false);
  public get hostdevs() {
    return this._hostdevs;
  }
  public putHostdevs(value: DomainDevicesHostdevs[] | cdktf.IResolvable) {
    this._hostdevs.internalValue = value;
  }
  public resetHostdevs() {
    this._hostdevs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostdevsInput() {
    return this._hostdevs.internalValue;
  }

  // hubs - computed: false, optional: true, required: false
  private _hubs = new DomainDevicesHubsList(this, "hubs", false);
  public get hubs() {
    return this._hubs;
  }
  public putHubs(value: DomainDevicesHubs[] | cdktf.IResolvable) {
    this._hubs.internalValue = value;
  }
  public resetHubs() {
    this._hubs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hubsInput() {
    return this._hubs.internalValue;
  }

  // inputs - computed: false, optional: true, required: false
  private _inputs = new DomainDevicesInputsList(this, "inputs", false);
  public get inputs() {
    return this._inputs;
  }
  public putInputs(value: DomainDevicesInputs[] | cdktf.IResolvable) {
    this._inputs.internalValue = value;
  }
  public resetInputs() {
    this._inputs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inputsInput() {
    return this._inputs.internalValue;
  }

  // interfaces - computed: false, optional: true, required: false
  private _interfaces = new DomainDevicesInterfacesList(this, "interfaces", false);
  public get interfaces() {
    return this._interfaces;
  }
  public putInterfaces(value: DomainDevicesInterfaces[] | cdktf.IResolvable) {
    this._interfaces.internalValue = value;
  }
  public resetInterfaces() {
    this._interfaces.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfacesInput() {
    return this._interfaces.internalValue;
  }

  // iommu - computed: false, optional: true, required: false
  private _iommu = new DomainDevicesIommuOutputReference(this, "iommu");
  public get iommu() {
    return this._iommu;
  }
  public putIommu(value: DomainDevicesIommu) {
    this._iommu.internalValue = value;
  }
  public resetIommu() {
    this._iommu.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get iommuInput() {
    return this._iommu.internalValue;
  }

  // leases - computed: false, optional: true, required: false
  private _leases = new DomainDevicesLeasesList(this, "leases", false);
  public get leases() {
    return this._leases;
  }
  public putLeases(value: DomainDevicesLeases[] | cdktf.IResolvable) {
    this._leases.internalValue = value;
  }
  public resetLeases() {
    this._leases.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get leasesInput() {
    return this._leases.internalValue;
  }

  // mem_balloon - computed: false, optional: true, required: false
  private _memBalloon = new DomainDevicesMemBalloonOutputReference(this, "mem_balloon");
  public get memBalloon() {
    return this._memBalloon;
  }
  public putMemBalloon(value: DomainDevicesMemBalloon) {
    this._memBalloon.internalValue = value;
  }
  public resetMemBalloon() {
    this._memBalloon.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memBalloonInput() {
    return this._memBalloon.internalValue;
  }

  // memorydevs - computed: false, optional: true, required: false
  private _memorydevs = new DomainDevicesMemorydevsList(this, "memorydevs", false);
  public get memorydevs() {
    return this._memorydevs;
  }
  public putMemorydevs(value: DomainDevicesMemorydevs[] | cdktf.IResolvable) {
    this._memorydevs.internalValue = value;
  }
  public resetMemorydevs() {
    this._memorydevs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memorydevsInput() {
    return this._memorydevs.internalValue;
  }

  // nvram - computed: false, optional: true, required: false
  private _nvram = new DomainDevicesNvramOutputReference(this, "nvram");
  public get nvram() {
    return this._nvram;
  }
  public putNvram(value: DomainDevicesNvram) {
    this._nvram.internalValue = value;
  }
  public resetNvram() {
    this._nvram.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nvramInput() {
    return this._nvram.internalValue;
  }

  // panics - computed: false, optional: true, required: false
  private _panics = new DomainDevicesPanicsList(this, "panics", false);
  public get panics() {
    return this._panics;
  }
  public putPanics(value: DomainDevicesPanics[] | cdktf.IResolvable) {
    this._panics.internalValue = value;
  }
  public resetPanics() {
    this._panics.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get panicsInput() {
    return this._panics.internalValue;
  }

  // parallels - computed: false, optional: true, required: false
  private _parallels = new DomainDevicesParallelsList(this, "parallels", false);
  public get parallels() {
    return this._parallels;
  }
  public putParallels(value: DomainDevicesParallels[] | cdktf.IResolvable) {
    this._parallels.internalValue = value;
  }
  public resetParallels() {
    this._parallels.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parallelsInput() {
    return this._parallels.internalValue;
  }

  // pstore - computed: false, optional: true, required: false
  private _pstore = new DomainDevicesPstoreOutputReference(this, "pstore");
  public get pstore() {
    return this._pstore;
  }
  public putPstore(value: DomainDevicesPstore) {
    this._pstore.internalValue = value;
  }
  public resetPstore() {
    this._pstore.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pstoreInput() {
    return this._pstore.internalValue;
  }

  // redir_devs - computed: false, optional: true, required: false
  private _redirDevs = new DomainDevicesRedirDevsList(this, "redir_devs", false);
  public get redirDevs() {
    return this._redirDevs;
  }
  public putRedirDevs(value: DomainDevicesRedirDevs[] | cdktf.IResolvable) {
    this._redirDevs.internalValue = value;
  }
  public resetRedirDevs() {
    this._redirDevs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get redirDevsInput() {
    return this._redirDevs.internalValue;
  }

  // redir_filters - computed: false, optional: true, required: false
  private _redirFilters = new DomainDevicesRedirFiltersList(this, "redir_filters", false);
  public get redirFilters() {
    return this._redirFilters;
  }
  public putRedirFilters(value: DomainDevicesRedirFilters[] | cdktf.IResolvable) {
    this._redirFilters.internalValue = value;
  }
  public resetRedirFilters() {
    this._redirFilters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get redirFiltersInput() {
    return this._redirFilters.internalValue;
  }

  // rngs - computed: false, optional: true, required: false
  private _rngs = new DomainDevicesRngsList(this, "rngs", false);
  public get rngs() {
    return this._rngs;
  }
  public putRngs(value: DomainDevicesRngs[] | cdktf.IResolvable) {
    this._rngs.internalValue = value;
  }
  public resetRngs() {
    this._rngs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rngsInput() {
    return this._rngs.internalValue;
  }

  // serials - computed: false, optional: true, required: false
  private _serials = new DomainDevicesSerialsList(this, "serials", false);
  public get serials() {
    return this._serials;
  }
  public putSerials(value: DomainDevicesSerials[] | cdktf.IResolvable) {
    this._serials.internalValue = value;
  }
  public resetSerials() {
    this._serials.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serialsInput() {
    return this._serials.internalValue;
  }

  // shmems - computed: false, optional: true, required: false
  private _shmems = new DomainDevicesShmemsList(this, "shmems", false);
  public get shmems() {
    return this._shmems;
  }
  public putShmems(value: DomainDevicesShmems[] | cdktf.IResolvable) {
    this._shmems.internalValue = value;
  }
  public resetShmems() {
    this._shmems.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shmemsInput() {
    return this._shmems.internalValue;
  }

  // smartcards - computed: false, optional: true, required: false
  private _smartcards = new DomainDevicesSmartcardsList(this, "smartcards", false);
  public get smartcards() {
    return this._smartcards;
  }
  public putSmartcards(value: DomainDevicesSmartcards[] | cdktf.IResolvable) {
    this._smartcards.internalValue = value;
  }
  public resetSmartcards() {
    this._smartcards.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get smartcardsInput() {
    return this._smartcards.internalValue;
  }

  // sounds - computed: false, optional: true, required: false
  private _sounds = new DomainDevicesSoundsList(this, "sounds", false);
  public get sounds() {
    return this._sounds;
  }
  public putSounds(value: DomainDevicesSounds[] | cdktf.IResolvable) {
    this._sounds.internalValue = value;
  }
  public resetSounds() {
    this._sounds.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get soundsInput() {
    return this._sounds.internalValue;
  }

  // tpms - computed: false, optional: true, required: false
  private _tpms = new DomainDevicesTpmsList(this, "tpms", false);
  public get tpms() {
    return this._tpms;
  }
  public putTpms(value: DomainDevicesTpms[] | cdktf.IResolvable) {
    this._tpms.internalValue = value;
  }
  public resetTpms() {
    this._tpms.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tpmsInput() {
    return this._tpms.internalValue;
  }

  // videos - computed: false, optional: true, required: false
  private _videos = new DomainDevicesVideosList(this, "videos", false);
  public get videos() {
    return this._videos;
  }
  public putVideos(value: DomainDevicesVideos[] | cdktf.IResolvable) {
    this._videos.internalValue = value;
  }
  public resetVideos() {
    this._videos.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get videosInput() {
    return this._videos.internalValue;
  }

  // vsock - computed: false, optional: true, required: false
  private _vsock = new DomainDevicesVsockOutputReference(this, "vsock");
  public get vsock() {
    return this._vsock;
  }
  public putVsock(value: DomainDevicesVsock) {
    this._vsock.internalValue = value;
  }
  public resetVsock() {
    this._vsock.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vsockInput() {
    return this._vsock.internalValue;
  }

  // watchdogs - computed: false, optional: true, required: false
  private _watchdogs = new DomainDevicesWatchdogsList(this, "watchdogs", false);
  public get watchdogs() {
    return this._watchdogs;
  }
  public putWatchdogs(value: DomainDevicesWatchdogs[] | cdktf.IResolvable) {
    this._watchdogs.internalValue = value;
  }
  public resetWatchdogs() {
    this._watchdogs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get watchdogsInput() {
    return this._watchdogs.internalValue;
  }
}
export interface DomainFeaturesAia {
  /**
  * Configures the Advanced Interrupt Architecture (AIA) feature state for the domain; valid values are user-provided strings such as "on", "off", or mode-specific values as supported by the hypervisor.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#value Domain#value}
  */
  readonly value: string;
}

export function domainFeaturesAiaToTerraform(struct?: DomainFeaturesAia | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function domainFeaturesAiaToHclTerraform(struct?: DomainFeaturesAia | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesAiaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesAia | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesAia | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._value = value.value;
    }
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DomainFeaturesApic {
  /**
  * Sets whether APIC end-of-interrupt (EOI) optimization is enabled for the guest; valid values are user-provided strings typically interpreted as "on" or "off" by the hypervisor.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#eoi Domain#eoi}
  */
  readonly eoi?: string;
}

export function domainFeaturesApicToTerraform(struct?: DomainFeaturesApic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    eoi: cdktf.stringToTerraform(struct!.eoi),
  }
}


export function domainFeaturesApicToHclTerraform(struct?: DomainFeaturesApic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    eoi: {
      value: cdktf.stringToHclTerraform(struct!.eoi),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesApicOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesApic | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._eoi !== undefined) {
      hasAnyValues = true;
      internalValueResult.eoi = this._eoi;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesApic | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._eoi = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._eoi = value.eoi;
    }
  }

  // eoi - computed: false, optional: true, required: false
  private _eoi?: string; 
  public get eoi() {
    return this.getStringAttribute('eoi');
  }
  public set eoi(value: string) {
    this._eoi = value;
  }
  public resetEoi() {
    this._eoi = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get eoiInput() {
    return this._eoi;
  }
}
export interface DomainFeaturesAsyncTeardown {
  /**
  * Sets whether asynchronous teardown is enabled for the domain; valid values are user-provided strings typically treated as "on"/"off" or "yes"/"no" by the hypervisor.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#enabled Domain#enabled}
  */
  readonly enabled?: string;
}

export function domainFeaturesAsyncTeardownToTerraform(struct?: DomainFeaturesAsyncTeardown | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.stringToTerraform(struct!.enabled),
  }
}


export function domainFeaturesAsyncTeardownToHclTerraform(struct?: DomainFeaturesAsyncTeardown | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.stringToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesAsyncTeardownOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesAsyncTeardown | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesAsyncTeardown | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
    }
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: string; 
  public get enabled() {
    return this.getStringAttribute('enabled');
  }
  public set enabled(value: string) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }
}
export interface DomainFeaturesCapabilitiesAuditControl {
  /**
  * Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesCapabilitiesAuditControlToTerraform(struct?: DomainFeaturesCapabilitiesAuditControl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesCapabilitiesAuditControlToHclTerraform(struct?: DomainFeaturesCapabilitiesAuditControl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesCapabilitiesAuditControlOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesCapabilitiesAuditControl | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesCapabilitiesAuditControl | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesCapabilitiesAuditWrite {
  /**
  * Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesCapabilitiesAuditWriteToTerraform(struct?: DomainFeaturesCapabilitiesAuditWrite | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesCapabilitiesAuditWriteToHclTerraform(struct?: DomainFeaturesCapabilitiesAuditWrite | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesCapabilitiesAuditWriteOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesCapabilitiesAuditWrite | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesCapabilitiesAuditWrite | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesCapabilitiesBlockSuspend {
  /**
  * Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesCapabilitiesBlockSuspendToTerraform(struct?: DomainFeaturesCapabilitiesBlockSuspend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesCapabilitiesBlockSuspendToHclTerraform(struct?: DomainFeaturesCapabilitiesBlockSuspend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesCapabilitiesBlockSuspendOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesCapabilitiesBlockSuspend | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesCapabilitiesBlockSuspend | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesCapabilitiesChown {
  /**
  * Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesCapabilitiesChownToTerraform(struct?: DomainFeaturesCapabilitiesChown | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesCapabilitiesChownToHclTerraform(struct?: DomainFeaturesCapabilitiesChown | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesCapabilitiesChownOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesCapabilitiesChown | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesCapabilitiesChown | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesCapabilitiesDacOverride {
  /**
  * Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesCapabilitiesDacOverrideToTerraform(struct?: DomainFeaturesCapabilitiesDacOverride | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesCapabilitiesDacOverrideToHclTerraform(struct?: DomainFeaturesCapabilitiesDacOverride | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesCapabilitiesDacOverrideOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesCapabilitiesDacOverride | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesCapabilitiesDacOverride | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesCapabilitiesDacReadSearch {
  /**
  * Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesCapabilitiesDacReadSearchToTerraform(struct?: DomainFeaturesCapabilitiesDacReadSearch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesCapabilitiesDacReadSearchToHclTerraform(struct?: DomainFeaturesCapabilitiesDacReadSearch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesCapabilitiesDacReadSearchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesCapabilitiesDacReadSearch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesCapabilitiesDacReadSearch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesCapabilitiesFowner {
  /**
  * Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesCapabilitiesFownerToTerraform(struct?: DomainFeaturesCapabilitiesFowner | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesCapabilitiesFownerToHclTerraform(struct?: DomainFeaturesCapabilitiesFowner | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesCapabilitiesFownerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesCapabilitiesFowner | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesCapabilitiesFowner | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesCapabilitiesFsetId {
  /**
  * Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesCapabilitiesFsetIdToTerraform(struct?: DomainFeaturesCapabilitiesFsetId | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesCapabilitiesFsetIdToHclTerraform(struct?: DomainFeaturesCapabilitiesFsetId | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesCapabilitiesFsetIdOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesCapabilitiesFsetId | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesCapabilitiesFsetId | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesCapabilitiesIpcLock {
  /**
  * Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesCapabilitiesIpcLockToTerraform(struct?: DomainFeaturesCapabilitiesIpcLock | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesCapabilitiesIpcLockToHclTerraform(struct?: DomainFeaturesCapabilitiesIpcLock | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesCapabilitiesIpcLockOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesCapabilitiesIpcLock | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesCapabilitiesIpcLock | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesCapabilitiesIpcOwner {
  /**
  * Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesCapabilitiesIpcOwnerToTerraform(struct?: DomainFeaturesCapabilitiesIpcOwner | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesCapabilitiesIpcOwnerToHclTerraform(struct?: DomainFeaturesCapabilitiesIpcOwner | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesCapabilitiesIpcOwnerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesCapabilitiesIpcOwner | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesCapabilitiesIpcOwner | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesCapabilitiesKill {
  /**
  * Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesCapabilitiesKillToTerraform(struct?: DomainFeaturesCapabilitiesKill | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesCapabilitiesKillToHclTerraform(struct?: DomainFeaturesCapabilitiesKill | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesCapabilitiesKillOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesCapabilitiesKill | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesCapabilitiesKill | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesCapabilitiesLease {
  /**
  * Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesCapabilitiesLeaseToTerraform(struct?: DomainFeaturesCapabilitiesLease | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesCapabilitiesLeaseToHclTerraform(struct?: DomainFeaturesCapabilitiesLease | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesCapabilitiesLeaseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesCapabilitiesLease | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesCapabilitiesLease | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesCapabilitiesLinuxImmutable {
  /**
  * Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesCapabilitiesLinuxImmutableToTerraform(struct?: DomainFeaturesCapabilitiesLinuxImmutable | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesCapabilitiesLinuxImmutableToHclTerraform(struct?: DomainFeaturesCapabilitiesLinuxImmutable | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesCapabilitiesLinuxImmutableOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesCapabilitiesLinuxImmutable | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesCapabilitiesLinuxImmutable | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesCapabilitiesMacAdmin {
  /**
  * Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesCapabilitiesMacAdminToTerraform(struct?: DomainFeaturesCapabilitiesMacAdmin | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesCapabilitiesMacAdminToHclTerraform(struct?: DomainFeaturesCapabilitiesMacAdmin | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesCapabilitiesMacAdminOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesCapabilitiesMacAdmin | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesCapabilitiesMacAdmin | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesCapabilitiesMacOverride {
  /**
  * Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesCapabilitiesMacOverrideToTerraform(struct?: DomainFeaturesCapabilitiesMacOverride | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesCapabilitiesMacOverrideToHclTerraform(struct?: DomainFeaturesCapabilitiesMacOverride | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesCapabilitiesMacOverrideOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesCapabilitiesMacOverride | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesCapabilitiesMacOverride | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesCapabilitiesMkNod {
  /**
  * Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesCapabilitiesMkNodToTerraform(struct?: DomainFeaturesCapabilitiesMkNod | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesCapabilitiesMkNodToHclTerraform(struct?: DomainFeaturesCapabilitiesMkNod | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesCapabilitiesMkNodOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesCapabilitiesMkNod | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesCapabilitiesMkNod | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesCapabilitiesNetAdmin {
  /**
  * Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesCapabilitiesNetAdminToTerraform(struct?: DomainFeaturesCapabilitiesNetAdmin | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesCapabilitiesNetAdminToHclTerraform(struct?: DomainFeaturesCapabilitiesNetAdmin | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesCapabilitiesNetAdminOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesCapabilitiesNetAdmin | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesCapabilitiesNetAdmin | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesCapabilitiesNetBindService {
  /**
  * Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesCapabilitiesNetBindServiceToTerraform(struct?: DomainFeaturesCapabilitiesNetBindService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesCapabilitiesNetBindServiceToHclTerraform(struct?: DomainFeaturesCapabilitiesNetBindService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesCapabilitiesNetBindServiceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesCapabilitiesNetBindService | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesCapabilitiesNetBindService | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesCapabilitiesNetBroadcast {
  /**
  * Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesCapabilitiesNetBroadcastToTerraform(struct?: DomainFeaturesCapabilitiesNetBroadcast | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesCapabilitiesNetBroadcastToHclTerraform(struct?: DomainFeaturesCapabilitiesNetBroadcast | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesCapabilitiesNetBroadcastOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesCapabilitiesNetBroadcast | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesCapabilitiesNetBroadcast | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesCapabilitiesNetRaw {
  /**
  * Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesCapabilitiesNetRawToTerraform(struct?: DomainFeaturesCapabilitiesNetRaw | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesCapabilitiesNetRawToHclTerraform(struct?: DomainFeaturesCapabilitiesNetRaw | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesCapabilitiesNetRawOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesCapabilitiesNetRaw | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesCapabilitiesNetRaw | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesCapabilitiesSetFCap {
  /**
  * Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesCapabilitiesSetFCapToTerraform(struct?: DomainFeaturesCapabilitiesSetFCap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesCapabilitiesSetFCapToHclTerraform(struct?: DomainFeaturesCapabilitiesSetFCap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesCapabilitiesSetFCapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesCapabilitiesSetFCap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesCapabilitiesSetFCap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesCapabilitiesSetGid {
  /**
  * Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesCapabilitiesSetGidToTerraform(struct?: DomainFeaturesCapabilitiesSetGid | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesCapabilitiesSetGidToHclTerraform(struct?: DomainFeaturesCapabilitiesSetGid | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesCapabilitiesSetGidOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesCapabilitiesSetGid | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesCapabilitiesSetGid | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesCapabilitiesSetPCap {
  /**
  * Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesCapabilitiesSetPCapToTerraform(struct?: DomainFeaturesCapabilitiesSetPCap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesCapabilitiesSetPCapToHclTerraform(struct?: DomainFeaturesCapabilitiesSetPCap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesCapabilitiesSetPCapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesCapabilitiesSetPCap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesCapabilitiesSetPCap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesCapabilitiesSetUid {
  /**
  * Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesCapabilitiesSetUidToTerraform(struct?: DomainFeaturesCapabilitiesSetUid | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesCapabilitiesSetUidToHclTerraform(struct?: DomainFeaturesCapabilitiesSetUid | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesCapabilitiesSetUidOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesCapabilitiesSetUid | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesCapabilitiesSetUid | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesCapabilitiesSysAdmin {
  /**
  * Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesCapabilitiesSysAdminToTerraform(struct?: DomainFeaturesCapabilitiesSysAdmin | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesCapabilitiesSysAdminToHclTerraform(struct?: DomainFeaturesCapabilitiesSysAdmin | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesCapabilitiesSysAdminOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesCapabilitiesSysAdmin | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesCapabilitiesSysAdmin | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesCapabilitiesSysBoot {
  /**
  * Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesCapabilitiesSysBootToTerraform(struct?: DomainFeaturesCapabilitiesSysBoot | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesCapabilitiesSysBootToHclTerraform(struct?: DomainFeaturesCapabilitiesSysBoot | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesCapabilitiesSysBootOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesCapabilitiesSysBoot | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesCapabilitiesSysBoot | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesCapabilitiesSysChRoot {
  /**
  * Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesCapabilitiesSysChRootToTerraform(struct?: DomainFeaturesCapabilitiesSysChRoot | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesCapabilitiesSysChRootToHclTerraform(struct?: DomainFeaturesCapabilitiesSysChRoot | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesCapabilitiesSysChRootOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesCapabilitiesSysChRoot | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesCapabilitiesSysChRoot | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesCapabilitiesSysLog {
  /**
  * Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesCapabilitiesSysLogToTerraform(struct?: DomainFeaturesCapabilitiesSysLog | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesCapabilitiesSysLogToHclTerraform(struct?: DomainFeaturesCapabilitiesSysLog | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesCapabilitiesSysLogOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesCapabilitiesSysLog | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesCapabilitiesSysLog | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesCapabilitiesSysModule {
  /**
  * Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesCapabilitiesSysModuleToTerraform(struct?: DomainFeaturesCapabilitiesSysModule | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesCapabilitiesSysModuleToHclTerraform(struct?: DomainFeaturesCapabilitiesSysModule | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesCapabilitiesSysModuleOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesCapabilitiesSysModule | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesCapabilitiesSysModule | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesCapabilitiesSysNice {
  /**
  * Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesCapabilitiesSysNiceToTerraform(struct?: DomainFeaturesCapabilitiesSysNice | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesCapabilitiesSysNiceToHclTerraform(struct?: DomainFeaturesCapabilitiesSysNice | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesCapabilitiesSysNiceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesCapabilitiesSysNice | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesCapabilitiesSysNice | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesCapabilitiesSysPAcct {
  /**
  * Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesCapabilitiesSysPAcctToTerraform(struct?: DomainFeaturesCapabilitiesSysPAcct | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesCapabilitiesSysPAcctToHclTerraform(struct?: DomainFeaturesCapabilitiesSysPAcct | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesCapabilitiesSysPAcctOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesCapabilitiesSysPAcct | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesCapabilitiesSysPAcct | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesCapabilitiesSysPTrace {
  /**
  * Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesCapabilitiesSysPTraceToTerraform(struct?: DomainFeaturesCapabilitiesSysPTrace | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesCapabilitiesSysPTraceToHclTerraform(struct?: DomainFeaturesCapabilitiesSysPTrace | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesCapabilitiesSysPTraceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesCapabilitiesSysPTrace | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesCapabilitiesSysPTrace | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesCapabilitiesSysRawIo {
  /**
  * Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesCapabilitiesSysRawIoToTerraform(struct?: DomainFeaturesCapabilitiesSysRawIo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesCapabilitiesSysRawIoToHclTerraform(struct?: DomainFeaturesCapabilitiesSysRawIo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesCapabilitiesSysRawIoOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesCapabilitiesSysRawIo | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesCapabilitiesSysRawIo | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesCapabilitiesSysResource {
  /**
  * Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesCapabilitiesSysResourceToTerraform(struct?: DomainFeaturesCapabilitiesSysResource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesCapabilitiesSysResourceToHclTerraform(struct?: DomainFeaturesCapabilitiesSysResource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesCapabilitiesSysResourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesCapabilitiesSysResource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesCapabilitiesSysResource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesCapabilitiesSysTime {
  /**
  * Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesCapabilitiesSysTimeToTerraform(struct?: DomainFeaturesCapabilitiesSysTime | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesCapabilitiesSysTimeToHclTerraform(struct?: DomainFeaturesCapabilitiesSysTime | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesCapabilitiesSysTimeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesCapabilitiesSysTime | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesCapabilitiesSysTime | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesCapabilitiesSysTtyCnofig {
  /**
  * Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesCapabilitiesSysTtyCnofigToTerraform(struct?: DomainFeaturesCapabilitiesSysTtyCnofig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesCapabilitiesSysTtyCnofigToHclTerraform(struct?: DomainFeaturesCapabilitiesSysTtyCnofig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesCapabilitiesSysTtyCnofigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesCapabilitiesSysTtyCnofig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesCapabilitiesSysTtyCnofig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesCapabilitiesWakeAlarm {
  /**
  * Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesCapabilitiesWakeAlarmToTerraform(struct?: DomainFeaturesCapabilitiesWakeAlarm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesCapabilitiesWakeAlarmToHclTerraform(struct?: DomainFeaturesCapabilitiesWakeAlarm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesCapabilitiesWakeAlarmOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesCapabilitiesWakeAlarm | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesCapabilitiesWakeAlarm | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesCapabilities {
  /**
  * Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#audit_control Domain#audit_control}
  */
  readonly auditControl?: DomainFeaturesCapabilitiesAuditControl;
  /**
  * Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#audit_write Domain#audit_write}
  */
  readonly auditWrite?: DomainFeaturesCapabilitiesAuditWrite;
  /**
  * Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#block_suspend Domain#block_suspend}
  */
  readonly blockSuspend?: DomainFeaturesCapabilitiesBlockSuspend;
  /**
  * Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#chown Domain#chown}
  */
  readonly chown?: DomainFeaturesCapabilitiesChown;
  /**
  * Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dac_override Domain#dac_override}
  */
  readonly dacOverride?: DomainFeaturesCapabilitiesDacOverride;
  /**
  * Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#dac_read_search Domain#dac_read_search}
  */
  readonly dacReadSearch?: DomainFeaturesCapabilitiesDacReadSearch;
  /**
  * Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#fowner Domain#fowner}
  */
  readonly fowner?: DomainFeaturesCapabilitiesFowner;
  /**
  * Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#fset_id Domain#fset_id}
  */
  readonly fsetId?: DomainFeaturesCapabilitiesFsetId;
  /**
  * Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#ipc_lock Domain#ipc_lock}
  */
  readonly ipcLock?: DomainFeaturesCapabilitiesIpcLock;
  /**
  * Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#ipc_owner Domain#ipc_owner}
  */
  readonly ipcOwner?: DomainFeaturesCapabilitiesIpcOwner;
  /**
  * Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#kill Domain#kill}
  */
  readonly kill?: DomainFeaturesCapabilitiesKill;
  /**
  * Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#lease Domain#lease}
  */
  readonly lease?: DomainFeaturesCapabilitiesLease;
  /**
  * Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#linux_immutable Domain#linux_immutable}
  */
  readonly linuxImmutable?: DomainFeaturesCapabilitiesLinuxImmutable;
  /**
  * Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mac_admin Domain#mac_admin}
  */
  readonly macAdmin?: DomainFeaturesCapabilitiesMacAdmin;
  /**
  * Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mac_override Domain#mac_override}
  */
  readonly macOverride?: DomainFeaturesCapabilitiesMacOverride;
  /**
  * Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mk_nod Domain#mk_nod}
  */
  readonly mkNod?: DomainFeaturesCapabilitiesMkNod;
  /**
  * Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#net_admin Domain#net_admin}
  */
  readonly netAdmin?: DomainFeaturesCapabilitiesNetAdmin;
  /**
  * Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#net_bind_service Domain#net_bind_service}
  */
  readonly netBindService?: DomainFeaturesCapabilitiesNetBindService;
  /**
  * Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#net_broadcast Domain#net_broadcast}
  */
  readonly netBroadcast?: DomainFeaturesCapabilitiesNetBroadcast;
  /**
  * Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#net_raw Domain#net_raw}
  */
  readonly netRaw?: DomainFeaturesCapabilitiesNetRaw;
  /**
  * Sets the overall policy for how listed capabilities are applied to the guest; the value is user-provided and may follow libvirt’s capability policy keywords (for example, to treat unlisted capabilities as denied or allowed).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#policy Domain#policy}
  */
  readonly policy?: string;
  /**
  * Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#set_f_cap Domain#set_f_cap}
  */
  readonly setFCap?: DomainFeaturesCapabilitiesSetFCap;
  /**
  * Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#set_gid Domain#set_gid}
  */
  readonly setGid?: DomainFeaturesCapabilitiesSetGid;
  /**
  * Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#set_p_cap Domain#set_p_cap}
  */
  readonly setPCap?: DomainFeaturesCapabilitiesSetPCap;
  /**
  * Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#set_uid Domain#set_uid}
  */
  readonly setUid?: DomainFeaturesCapabilitiesSetUid;
  /**
  * Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sys_admin Domain#sys_admin}
  */
  readonly sysAdmin?: DomainFeaturesCapabilitiesSysAdmin;
  /**
  * Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sys_boot Domain#sys_boot}
  */
  readonly sysBoot?: DomainFeaturesCapabilitiesSysBoot;
  /**
  * Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sys_ch_root Domain#sys_ch_root}
  */
  readonly sysChRoot?: DomainFeaturesCapabilitiesSysChRoot;
  /**
  * Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sys_log Domain#sys_log}
  */
  readonly sysLog?: DomainFeaturesCapabilitiesSysLog;
  /**
  * Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sys_module Domain#sys_module}
  */
  readonly sysModule?: DomainFeaturesCapabilitiesSysModule;
  /**
  * Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sys_nice Domain#sys_nice}
  */
  readonly sysNice?: DomainFeaturesCapabilitiesSysNice;
  /**
  * Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sys_p_acct Domain#sys_p_acct}
  */
  readonly sysPAcct?: DomainFeaturesCapabilitiesSysPAcct;
  /**
  * Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sys_p_trace Domain#sys_p_trace}
  */
  readonly sysPTrace?: DomainFeaturesCapabilitiesSysPTrace;
  /**
  * Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sys_raw_io Domain#sys_raw_io}
  */
  readonly sysRawIo?: DomainFeaturesCapabilitiesSysRawIo;
  /**
  * Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sys_resource Domain#sys_resource}
  */
  readonly sysResource?: DomainFeaturesCapabilitiesSysResource;
  /**
  * Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sys_time Domain#sys_time}
  */
  readonly sysTime?: DomainFeaturesCapabilitiesSysTime;
  /**
  * Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#sys_tty_cnofig Domain#sys_tty_cnofig}
  */
  readonly sysTtyCnofig?: DomainFeaturesCapabilitiesSysTtyCnofig;
  /**
  * Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#wake_alarm Domain#wake_alarm}
  */
  readonly wakeAlarm?: DomainFeaturesCapabilitiesWakeAlarm;
}

export function domainFeaturesCapabilitiesToTerraform(struct?: DomainFeaturesCapabilities | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    audit_control: domainFeaturesCapabilitiesAuditControlToTerraform(struct!.auditControl),
    audit_write: domainFeaturesCapabilitiesAuditWriteToTerraform(struct!.auditWrite),
    block_suspend: domainFeaturesCapabilitiesBlockSuspendToTerraform(struct!.blockSuspend),
    chown: domainFeaturesCapabilitiesChownToTerraform(struct!.chown),
    dac_override: domainFeaturesCapabilitiesDacOverrideToTerraform(struct!.dacOverride),
    dac_read_search: domainFeaturesCapabilitiesDacReadSearchToTerraform(struct!.dacReadSearch),
    fowner: domainFeaturesCapabilitiesFownerToTerraform(struct!.fowner),
    fset_id: domainFeaturesCapabilitiesFsetIdToTerraform(struct!.fsetId),
    ipc_lock: domainFeaturesCapabilitiesIpcLockToTerraform(struct!.ipcLock),
    ipc_owner: domainFeaturesCapabilitiesIpcOwnerToTerraform(struct!.ipcOwner),
    kill: domainFeaturesCapabilitiesKillToTerraform(struct!.kill),
    lease: domainFeaturesCapabilitiesLeaseToTerraform(struct!.lease),
    linux_immutable: domainFeaturesCapabilitiesLinuxImmutableToTerraform(struct!.linuxImmutable),
    mac_admin: domainFeaturesCapabilitiesMacAdminToTerraform(struct!.macAdmin),
    mac_override: domainFeaturesCapabilitiesMacOverrideToTerraform(struct!.macOverride),
    mk_nod: domainFeaturesCapabilitiesMkNodToTerraform(struct!.mkNod),
    net_admin: domainFeaturesCapabilitiesNetAdminToTerraform(struct!.netAdmin),
    net_bind_service: domainFeaturesCapabilitiesNetBindServiceToTerraform(struct!.netBindService),
    net_broadcast: domainFeaturesCapabilitiesNetBroadcastToTerraform(struct!.netBroadcast),
    net_raw: domainFeaturesCapabilitiesNetRawToTerraform(struct!.netRaw),
    policy: cdktf.stringToTerraform(struct!.policy),
    set_f_cap: domainFeaturesCapabilitiesSetFCapToTerraform(struct!.setFCap),
    set_gid: domainFeaturesCapabilitiesSetGidToTerraform(struct!.setGid),
    set_p_cap: domainFeaturesCapabilitiesSetPCapToTerraform(struct!.setPCap),
    set_uid: domainFeaturesCapabilitiesSetUidToTerraform(struct!.setUid),
    sys_admin: domainFeaturesCapabilitiesSysAdminToTerraform(struct!.sysAdmin),
    sys_boot: domainFeaturesCapabilitiesSysBootToTerraform(struct!.sysBoot),
    sys_ch_root: domainFeaturesCapabilitiesSysChRootToTerraform(struct!.sysChRoot),
    sys_log: domainFeaturesCapabilitiesSysLogToTerraform(struct!.sysLog),
    sys_module: domainFeaturesCapabilitiesSysModuleToTerraform(struct!.sysModule),
    sys_nice: domainFeaturesCapabilitiesSysNiceToTerraform(struct!.sysNice),
    sys_p_acct: domainFeaturesCapabilitiesSysPAcctToTerraform(struct!.sysPAcct),
    sys_p_trace: domainFeaturesCapabilitiesSysPTraceToTerraform(struct!.sysPTrace),
    sys_raw_io: domainFeaturesCapabilitiesSysRawIoToTerraform(struct!.sysRawIo),
    sys_resource: domainFeaturesCapabilitiesSysResourceToTerraform(struct!.sysResource),
    sys_time: domainFeaturesCapabilitiesSysTimeToTerraform(struct!.sysTime),
    sys_tty_cnofig: domainFeaturesCapabilitiesSysTtyCnofigToTerraform(struct!.sysTtyCnofig),
    wake_alarm: domainFeaturesCapabilitiesWakeAlarmToTerraform(struct!.wakeAlarm),
  }
}


export function domainFeaturesCapabilitiesToHclTerraform(struct?: DomainFeaturesCapabilities | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    audit_control: {
      value: domainFeaturesCapabilitiesAuditControlToHclTerraform(struct!.auditControl),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesCapabilitiesAuditControl",
    },
    audit_write: {
      value: domainFeaturesCapabilitiesAuditWriteToHclTerraform(struct!.auditWrite),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesCapabilitiesAuditWrite",
    },
    block_suspend: {
      value: domainFeaturesCapabilitiesBlockSuspendToHclTerraform(struct!.blockSuspend),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesCapabilitiesBlockSuspend",
    },
    chown: {
      value: domainFeaturesCapabilitiesChownToHclTerraform(struct!.chown),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesCapabilitiesChown",
    },
    dac_override: {
      value: domainFeaturesCapabilitiesDacOverrideToHclTerraform(struct!.dacOverride),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesCapabilitiesDacOverride",
    },
    dac_read_search: {
      value: domainFeaturesCapabilitiesDacReadSearchToHclTerraform(struct!.dacReadSearch),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesCapabilitiesDacReadSearch",
    },
    fowner: {
      value: domainFeaturesCapabilitiesFownerToHclTerraform(struct!.fowner),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesCapabilitiesFowner",
    },
    fset_id: {
      value: domainFeaturesCapabilitiesFsetIdToHclTerraform(struct!.fsetId),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesCapabilitiesFsetId",
    },
    ipc_lock: {
      value: domainFeaturesCapabilitiesIpcLockToHclTerraform(struct!.ipcLock),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesCapabilitiesIpcLock",
    },
    ipc_owner: {
      value: domainFeaturesCapabilitiesIpcOwnerToHclTerraform(struct!.ipcOwner),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesCapabilitiesIpcOwner",
    },
    kill: {
      value: domainFeaturesCapabilitiesKillToHclTerraform(struct!.kill),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesCapabilitiesKill",
    },
    lease: {
      value: domainFeaturesCapabilitiesLeaseToHclTerraform(struct!.lease),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesCapabilitiesLease",
    },
    linux_immutable: {
      value: domainFeaturesCapabilitiesLinuxImmutableToHclTerraform(struct!.linuxImmutable),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesCapabilitiesLinuxImmutable",
    },
    mac_admin: {
      value: domainFeaturesCapabilitiesMacAdminToHclTerraform(struct!.macAdmin),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesCapabilitiesMacAdmin",
    },
    mac_override: {
      value: domainFeaturesCapabilitiesMacOverrideToHclTerraform(struct!.macOverride),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesCapabilitiesMacOverride",
    },
    mk_nod: {
      value: domainFeaturesCapabilitiesMkNodToHclTerraform(struct!.mkNod),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesCapabilitiesMkNod",
    },
    net_admin: {
      value: domainFeaturesCapabilitiesNetAdminToHclTerraform(struct!.netAdmin),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesCapabilitiesNetAdmin",
    },
    net_bind_service: {
      value: domainFeaturesCapabilitiesNetBindServiceToHclTerraform(struct!.netBindService),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesCapabilitiesNetBindService",
    },
    net_broadcast: {
      value: domainFeaturesCapabilitiesNetBroadcastToHclTerraform(struct!.netBroadcast),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesCapabilitiesNetBroadcast",
    },
    net_raw: {
      value: domainFeaturesCapabilitiesNetRawToHclTerraform(struct!.netRaw),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesCapabilitiesNetRaw",
    },
    policy: {
      value: cdktf.stringToHclTerraform(struct!.policy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    set_f_cap: {
      value: domainFeaturesCapabilitiesSetFCapToHclTerraform(struct!.setFCap),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesCapabilitiesSetFCap",
    },
    set_gid: {
      value: domainFeaturesCapabilitiesSetGidToHclTerraform(struct!.setGid),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesCapabilitiesSetGid",
    },
    set_p_cap: {
      value: domainFeaturesCapabilitiesSetPCapToHclTerraform(struct!.setPCap),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesCapabilitiesSetPCap",
    },
    set_uid: {
      value: domainFeaturesCapabilitiesSetUidToHclTerraform(struct!.setUid),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesCapabilitiesSetUid",
    },
    sys_admin: {
      value: domainFeaturesCapabilitiesSysAdminToHclTerraform(struct!.sysAdmin),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesCapabilitiesSysAdmin",
    },
    sys_boot: {
      value: domainFeaturesCapabilitiesSysBootToHclTerraform(struct!.sysBoot),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesCapabilitiesSysBoot",
    },
    sys_ch_root: {
      value: domainFeaturesCapabilitiesSysChRootToHclTerraform(struct!.sysChRoot),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesCapabilitiesSysChRoot",
    },
    sys_log: {
      value: domainFeaturesCapabilitiesSysLogToHclTerraform(struct!.sysLog),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesCapabilitiesSysLog",
    },
    sys_module: {
      value: domainFeaturesCapabilitiesSysModuleToHclTerraform(struct!.sysModule),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesCapabilitiesSysModule",
    },
    sys_nice: {
      value: domainFeaturesCapabilitiesSysNiceToHclTerraform(struct!.sysNice),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesCapabilitiesSysNice",
    },
    sys_p_acct: {
      value: domainFeaturesCapabilitiesSysPAcctToHclTerraform(struct!.sysPAcct),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesCapabilitiesSysPAcct",
    },
    sys_p_trace: {
      value: domainFeaturesCapabilitiesSysPTraceToHclTerraform(struct!.sysPTrace),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesCapabilitiesSysPTrace",
    },
    sys_raw_io: {
      value: domainFeaturesCapabilitiesSysRawIoToHclTerraform(struct!.sysRawIo),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesCapabilitiesSysRawIo",
    },
    sys_resource: {
      value: domainFeaturesCapabilitiesSysResourceToHclTerraform(struct!.sysResource),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesCapabilitiesSysResource",
    },
    sys_time: {
      value: domainFeaturesCapabilitiesSysTimeToHclTerraform(struct!.sysTime),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesCapabilitiesSysTime",
    },
    sys_tty_cnofig: {
      value: domainFeaturesCapabilitiesSysTtyCnofigToHclTerraform(struct!.sysTtyCnofig),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesCapabilitiesSysTtyCnofig",
    },
    wake_alarm: {
      value: domainFeaturesCapabilitiesWakeAlarmToHclTerraform(struct!.wakeAlarm),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesCapabilitiesWakeAlarm",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesCapabilitiesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesCapabilities | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auditControl?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auditControl = this._auditControl?.internalValue;
    }
    if (this._auditWrite?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auditWrite = this._auditWrite?.internalValue;
    }
    if (this._blockSuspend?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.blockSuspend = this._blockSuspend?.internalValue;
    }
    if (this._chown?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.chown = this._chown?.internalValue;
    }
    if (this._dacOverride?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dacOverride = this._dacOverride?.internalValue;
    }
    if (this._dacReadSearch?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dacReadSearch = this._dacReadSearch?.internalValue;
    }
    if (this._fowner?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fowner = this._fowner?.internalValue;
    }
    if (this._fsetId?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fsetId = this._fsetId?.internalValue;
    }
    if (this._ipcLock?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipcLock = this._ipcLock?.internalValue;
    }
    if (this._ipcOwner?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipcOwner = this._ipcOwner?.internalValue;
    }
    if (this._kill?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kill = this._kill?.internalValue;
    }
    if (this._lease?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.lease = this._lease?.internalValue;
    }
    if (this._linuxImmutable?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.linuxImmutable = this._linuxImmutable?.internalValue;
    }
    if (this._macAdmin?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.macAdmin = this._macAdmin?.internalValue;
    }
    if (this._macOverride?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.macOverride = this._macOverride?.internalValue;
    }
    if (this._mkNod?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.mkNod = this._mkNod?.internalValue;
    }
    if (this._netAdmin?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.netAdmin = this._netAdmin?.internalValue;
    }
    if (this._netBindService?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.netBindService = this._netBindService?.internalValue;
    }
    if (this._netBroadcast?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.netBroadcast = this._netBroadcast?.internalValue;
    }
    if (this._netRaw?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.netRaw = this._netRaw?.internalValue;
    }
    if (this._policy !== undefined) {
      hasAnyValues = true;
      internalValueResult.policy = this._policy;
    }
    if (this._setFCap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.setFCap = this._setFCap?.internalValue;
    }
    if (this._setGid?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.setGid = this._setGid?.internalValue;
    }
    if (this._setPCap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.setPCap = this._setPCap?.internalValue;
    }
    if (this._setUid?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.setUid = this._setUid?.internalValue;
    }
    if (this._sysAdmin?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sysAdmin = this._sysAdmin?.internalValue;
    }
    if (this._sysBoot?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sysBoot = this._sysBoot?.internalValue;
    }
    if (this._sysChRoot?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sysChRoot = this._sysChRoot?.internalValue;
    }
    if (this._sysLog?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sysLog = this._sysLog?.internalValue;
    }
    if (this._sysModule?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sysModule = this._sysModule?.internalValue;
    }
    if (this._sysNice?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sysNice = this._sysNice?.internalValue;
    }
    if (this._sysPAcct?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sysPAcct = this._sysPAcct?.internalValue;
    }
    if (this._sysPTrace?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sysPTrace = this._sysPTrace?.internalValue;
    }
    if (this._sysRawIo?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sysRawIo = this._sysRawIo?.internalValue;
    }
    if (this._sysResource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sysResource = this._sysResource?.internalValue;
    }
    if (this._sysTime?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sysTime = this._sysTime?.internalValue;
    }
    if (this._sysTtyCnofig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sysTtyCnofig = this._sysTtyCnofig?.internalValue;
    }
    if (this._wakeAlarm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.wakeAlarm = this._wakeAlarm?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesCapabilities | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auditControl.internalValue = undefined;
      this._auditWrite.internalValue = undefined;
      this._blockSuspend.internalValue = undefined;
      this._chown.internalValue = undefined;
      this._dacOverride.internalValue = undefined;
      this._dacReadSearch.internalValue = undefined;
      this._fowner.internalValue = undefined;
      this._fsetId.internalValue = undefined;
      this._ipcLock.internalValue = undefined;
      this._ipcOwner.internalValue = undefined;
      this._kill.internalValue = undefined;
      this._lease.internalValue = undefined;
      this._linuxImmutable.internalValue = undefined;
      this._macAdmin.internalValue = undefined;
      this._macOverride.internalValue = undefined;
      this._mkNod.internalValue = undefined;
      this._netAdmin.internalValue = undefined;
      this._netBindService.internalValue = undefined;
      this._netBroadcast.internalValue = undefined;
      this._netRaw.internalValue = undefined;
      this._policy = undefined;
      this._setFCap.internalValue = undefined;
      this._setGid.internalValue = undefined;
      this._setPCap.internalValue = undefined;
      this._setUid.internalValue = undefined;
      this._sysAdmin.internalValue = undefined;
      this._sysBoot.internalValue = undefined;
      this._sysChRoot.internalValue = undefined;
      this._sysLog.internalValue = undefined;
      this._sysModule.internalValue = undefined;
      this._sysNice.internalValue = undefined;
      this._sysPAcct.internalValue = undefined;
      this._sysPTrace.internalValue = undefined;
      this._sysRawIo.internalValue = undefined;
      this._sysResource.internalValue = undefined;
      this._sysTime.internalValue = undefined;
      this._sysTtyCnofig.internalValue = undefined;
      this._wakeAlarm.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auditControl.internalValue = value.auditControl;
      this._auditWrite.internalValue = value.auditWrite;
      this._blockSuspend.internalValue = value.blockSuspend;
      this._chown.internalValue = value.chown;
      this._dacOverride.internalValue = value.dacOverride;
      this._dacReadSearch.internalValue = value.dacReadSearch;
      this._fowner.internalValue = value.fowner;
      this._fsetId.internalValue = value.fsetId;
      this._ipcLock.internalValue = value.ipcLock;
      this._ipcOwner.internalValue = value.ipcOwner;
      this._kill.internalValue = value.kill;
      this._lease.internalValue = value.lease;
      this._linuxImmutable.internalValue = value.linuxImmutable;
      this._macAdmin.internalValue = value.macAdmin;
      this._macOverride.internalValue = value.macOverride;
      this._mkNod.internalValue = value.mkNod;
      this._netAdmin.internalValue = value.netAdmin;
      this._netBindService.internalValue = value.netBindService;
      this._netBroadcast.internalValue = value.netBroadcast;
      this._netRaw.internalValue = value.netRaw;
      this._policy = value.policy;
      this._setFCap.internalValue = value.setFCap;
      this._setGid.internalValue = value.setGid;
      this._setPCap.internalValue = value.setPCap;
      this._setUid.internalValue = value.setUid;
      this._sysAdmin.internalValue = value.sysAdmin;
      this._sysBoot.internalValue = value.sysBoot;
      this._sysChRoot.internalValue = value.sysChRoot;
      this._sysLog.internalValue = value.sysLog;
      this._sysModule.internalValue = value.sysModule;
      this._sysNice.internalValue = value.sysNice;
      this._sysPAcct.internalValue = value.sysPAcct;
      this._sysPTrace.internalValue = value.sysPTrace;
      this._sysRawIo.internalValue = value.sysRawIo;
      this._sysResource.internalValue = value.sysResource;
      this._sysTime.internalValue = value.sysTime;
      this._sysTtyCnofig.internalValue = value.sysTtyCnofig;
      this._wakeAlarm.internalValue = value.wakeAlarm;
    }
  }

  // audit_control - computed: false, optional: true, required: false
  private _auditControl = new DomainFeaturesCapabilitiesAuditControlOutputReference(this, "audit_control");
  public get auditControl() {
    return this._auditControl;
  }
  public putAuditControl(value: DomainFeaturesCapabilitiesAuditControl) {
    this._auditControl.internalValue = value;
  }
  public resetAuditControl() {
    this._auditControl.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get auditControlInput() {
    return this._auditControl.internalValue;
  }

  // audit_write - computed: false, optional: true, required: false
  private _auditWrite = new DomainFeaturesCapabilitiesAuditWriteOutputReference(this, "audit_write");
  public get auditWrite() {
    return this._auditWrite;
  }
  public putAuditWrite(value: DomainFeaturesCapabilitiesAuditWrite) {
    this._auditWrite.internalValue = value;
  }
  public resetAuditWrite() {
    this._auditWrite.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get auditWriteInput() {
    return this._auditWrite.internalValue;
  }

  // block_suspend - computed: false, optional: true, required: false
  private _blockSuspend = new DomainFeaturesCapabilitiesBlockSuspendOutputReference(this, "block_suspend");
  public get blockSuspend() {
    return this._blockSuspend;
  }
  public putBlockSuspend(value: DomainFeaturesCapabilitiesBlockSuspend) {
    this._blockSuspend.internalValue = value;
  }
  public resetBlockSuspend() {
    this._blockSuspend.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get blockSuspendInput() {
    return this._blockSuspend.internalValue;
  }

  // chown - computed: false, optional: true, required: false
  private _chown = new DomainFeaturesCapabilitiesChownOutputReference(this, "chown");
  public get chown() {
    return this._chown;
  }
  public putChown(value: DomainFeaturesCapabilitiesChown) {
    this._chown.internalValue = value;
  }
  public resetChown() {
    this._chown.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get chownInput() {
    return this._chown.internalValue;
  }

  // dac_override - computed: false, optional: true, required: false
  private _dacOverride = new DomainFeaturesCapabilitiesDacOverrideOutputReference(this, "dac_override");
  public get dacOverride() {
    return this._dacOverride;
  }
  public putDacOverride(value: DomainFeaturesCapabilitiesDacOverride) {
    this._dacOverride.internalValue = value;
  }
  public resetDacOverride() {
    this._dacOverride.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dacOverrideInput() {
    return this._dacOverride.internalValue;
  }

  // dac_read_search - computed: false, optional: true, required: false
  private _dacReadSearch = new DomainFeaturesCapabilitiesDacReadSearchOutputReference(this, "dac_read_search");
  public get dacReadSearch() {
    return this._dacReadSearch;
  }
  public putDacReadSearch(value: DomainFeaturesCapabilitiesDacReadSearch) {
    this._dacReadSearch.internalValue = value;
  }
  public resetDacReadSearch() {
    this._dacReadSearch.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dacReadSearchInput() {
    return this._dacReadSearch.internalValue;
  }

  // fowner - computed: false, optional: true, required: false
  private _fowner = new DomainFeaturesCapabilitiesFownerOutputReference(this, "fowner");
  public get fowner() {
    return this._fowner;
  }
  public putFowner(value: DomainFeaturesCapabilitiesFowner) {
    this._fowner.internalValue = value;
  }
  public resetFowner() {
    this._fowner.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fownerInput() {
    return this._fowner.internalValue;
  }

  // fset_id - computed: false, optional: true, required: false
  private _fsetId = new DomainFeaturesCapabilitiesFsetIdOutputReference(this, "fset_id");
  public get fsetId() {
    return this._fsetId;
  }
  public putFsetId(value: DomainFeaturesCapabilitiesFsetId) {
    this._fsetId.internalValue = value;
  }
  public resetFsetId() {
    this._fsetId.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fsetIdInput() {
    return this._fsetId.internalValue;
  }

  // ipc_lock - computed: false, optional: true, required: false
  private _ipcLock = new DomainFeaturesCapabilitiesIpcLockOutputReference(this, "ipc_lock");
  public get ipcLock() {
    return this._ipcLock;
  }
  public putIpcLock(value: DomainFeaturesCapabilitiesIpcLock) {
    this._ipcLock.internalValue = value;
  }
  public resetIpcLock() {
    this._ipcLock.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipcLockInput() {
    return this._ipcLock.internalValue;
  }

  // ipc_owner - computed: false, optional: true, required: false
  private _ipcOwner = new DomainFeaturesCapabilitiesIpcOwnerOutputReference(this, "ipc_owner");
  public get ipcOwner() {
    return this._ipcOwner;
  }
  public putIpcOwner(value: DomainFeaturesCapabilitiesIpcOwner) {
    this._ipcOwner.internalValue = value;
  }
  public resetIpcOwner() {
    this._ipcOwner.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipcOwnerInput() {
    return this._ipcOwner.internalValue;
  }

  // kill - computed: false, optional: true, required: false
  private _kill = new DomainFeaturesCapabilitiesKillOutputReference(this, "kill");
  public get kill() {
    return this._kill;
  }
  public putKill(value: DomainFeaturesCapabilitiesKill) {
    this._kill.internalValue = value;
  }
  public resetKill() {
    this._kill.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get killInput() {
    return this._kill.internalValue;
  }

  // lease - computed: false, optional: true, required: false
  private _lease = new DomainFeaturesCapabilitiesLeaseOutputReference(this, "lease");
  public get lease() {
    return this._lease;
  }
  public putLease(value: DomainFeaturesCapabilitiesLease) {
    this._lease.internalValue = value;
  }
  public resetLease() {
    this._lease.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get leaseInput() {
    return this._lease.internalValue;
  }

  // linux_immutable - computed: false, optional: true, required: false
  private _linuxImmutable = new DomainFeaturesCapabilitiesLinuxImmutableOutputReference(this, "linux_immutable");
  public get linuxImmutable() {
    return this._linuxImmutable;
  }
  public putLinuxImmutable(value: DomainFeaturesCapabilitiesLinuxImmutable) {
    this._linuxImmutable.internalValue = value;
  }
  public resetLinuxImmutable() {
    this._linuxImmutable.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get linuxImmutableInput() {
    return this._linuxImmutable.internalValue;
  }

  // mac_admin - computed: false, optional: true, required: false
  private _macAdmin = new DomainFeaturesCapabilitiesMacAdminOutputReference(this, "mac_admin");
  public get macAdmin() {
    return this._macAdmin;
  }
  public putMacAdmin(value: DomainFeaturesCapabilitiesMacAdmin) {
    this._macAdmin.internalValue = value;
  }
  public resetMacAdmin() {
    this._macAdmin.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get macAdminInput() {
    return this._macAdmin.internalValue;
  }

  // mac_override - computed: false, optional: true, required: false
  private _macOverride = new DomainFeaturesCapabilitiesMacOverrideOutputReference(this, "mac_override");
  public get macOverride() {
    return this._macOverride;
  }
  public putMacOverride(value: DomainFeaturesCapabilitiesMacOverride) {
    this._macOverride.internalValue = value;
  }
  public resetMacOverride() {
    this._macOverride.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get macOverrideInput() {
    return this._macOverride.internalValue;
  }

  // mk_nod - computed: false, optional: true, required: false
  private _mkNod = new DomainFeaturesCapabilitiesMkNodOutputReference(this, "mk_nod");
  public get mkNod() {
    return this._mkNod;
  }
  public putMkNod(value: DomainFeaturesCapabilitiesMkNod) {
    this._mkNod.internalValue = value;
  }
  public resetMkNod() {
    this._mkNod.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mkNodInput() {
    return this._mkNod.internalValue;
  }

  // net_admin - computed: false, optional: true, required: false
  private _netAdmin = new DomainFeaturesCapabilitiesNetAdminOutputReference(this, "net_admin");
  public get netAdmin() {
    return this._netAdmin;
  }
  public putNetAdmin(value: DomainFeaturesCapabilitiesNetAdmin) {
    this._netAdmin.internalValue = value;
  }
  public resetNetAdmin() {
    this._netAdmin.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get netAdminInput() {
    return this._netAdmin.internalValue;
  }

  // net_bind_service - computed: false, optional: true, required: false
  private _netBindService = new DomainFeaturesCapabilitiesNetBindServiceOutputReference(this, "net_bind_service");
  public get netBindService() {
    return this._netBindService;
  }
  public putNetBindService(value: DomainFeaturesCapabilitiesNetBindService) {
    this._netBindService.internalValue = value;
  }
  public resetNetBindService() {
    this._netBindService.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get netBindServiceInput() {
    return this._netBindService.internalValue;
  }

  // net_broadcast - computed: false, optional: true, required: false
  private _netBroadcast = new DomainFeaturesCapabilitiesNetBroadcastOutputReference(this, "net_broadcast");
  public get netBroadcast() {
    return this._netBroadcast;
  }
  public putNetBroadcast(value: DomainFeaturesCapabilitiesNetBroadcast) {
    this._netBroadcast.internalValue = value;
  }
  public resetNetBroadcast() {
    this._netBroadcast.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get netBroadcastInput() {
    return this._netBroadcast.internalValue;
  }

  // net_raw - computed: false, optional: true, required: false
  private _netRaw = new DomainFeaturesCapabilitiesNetRawOutputReference(this, "net_raw");
  public get netRaw() {
    return this._netRaw;
  }
  public putNetRaw(value: DomainFeaturesCapabilitiesNetRaw) {
    this._netRaw.internalValue = value;
  }
  public resetNetRaw() {
    this._netRaw.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get netRawInput() {
    return this._netRaw.internalValue;
  }

  // policy - computed: false, optional: true, required: false
  private _policy?: string; 
  public get policy() {
    return this.getStringAttribute('policy');
  }
  public set policy(value: string) {
    this._policy = value;
  }
  public resetPolicy() {
    this._policy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get policyInput() {
    return this._policy;
  }

  // set_f_cap - computed: false, optional: true, required: false
  private _setFCap = new DomainFeaturesCapabilitiesSetFCapOutputReference(this, "set_f_cap");
  public get setFCap() {
    return this._setFCap;
  }
  public putSetFCap(value: DomainFeaturesCapabilitiesSetFCap) {
    this._setFCap.internalValue = value;
  }
  public resetSetFCap() {
    this._setFCap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setFCapInput() {
    return this._setFCap.internalValue;
  }

  // set_gid - computed: false, optional: true, required: false
  private _setGid = new DomainFeaturesCapabilitiesSetGidOutputReference(this, "set_gid");
  public get setGid() {
    return this._setGid;
  }
  public putSetGid(value: DomainFeaturesCapabilitiesSetGid) {
    this._setGid.internalValue = value;
  }
  public resetSetGid() {
    this._setGid.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setGidInput() {
    return this._setGid.internalValue;
  }

  // set_p_cap - computed: false, optional: true, required: false
  private _setPCap = new DomainFeaturesCapabilitiesSetPCapOutputReference(this, "set_p_cap");
  public get setPCap() {
    return this._setPCap;
  }
  public putSetPCap(value: DomainFeaturesCapabilitiesSetPCap) {
    this._setPCap.internalValue = value;
  }
  public resetSetPCap() {
    this._setPCap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setPCapInput() {
    return this._setPCap.internalValue;
  }

  // set_uid - computed: false, optional: true, required: false
  private _setUid = new DomainFeaturesCapabilitiesSetUidOutputReference(this, "set_uid");
  public get setUid() {
    return this._setUid;
  }
  public putSetUid(value: DomainFeaturesCapabilitiesSetUid) {
    this._setUid.internalValue = value;
  }
  public resetSetUid() {
    this._setUid.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setUidInput() {
    return this._setUid.internalValue;
  }

  // sys_admin - computed: false, optional: true, required: false
  private _sysAdmin = new DomainFeaturesCapabilitiesSysAdminOutputReference(this, "sys_admin");
  public get sysAdmin() {
    return this._sysAdmin;
  }
  public putSysAdmin(value: DomainFeaturesCapabilitiesSysAdmin) {
    this._sysAdmin.internalValue = value;
  }
  public resetSysAdmin() {
    this._sysAdmin.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sysAdminInput() {
    return this._sysAdmin.internalValue;
  }

  // sys_boot - computed: false, optional: true, required: false
  private _sysBoot = new DomainFeaturesCapabilitiesSysBootOutputReference(this, "sys_boot");
  public get sysBoot() {
    return this._sysBoot;
  }
  public putSysBoot(value: DomainFeaturesCapabilitiesSysBoot) {
    this._sysBoot.internalValue = value;
  }
  public resetSysBoot() {
    this._sysBoot.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sysBootInput() {
    return this._sysBoot.internalValue;
  }

  // sys_ch_root - computed: false, optional: true, required: false
  private _sysChRoot = new DomainFeaturesCapabilitiesSysChRootOutputReference(this, "sys_ch_root");
  public get sysChRoot() {
    return this._sysChRoot;
  }
  public putSysChRoot(value: DomainFeaturesCapabilitiesSysChRoot) {
    this._sysChRoot.internalValue = value;
  }
  public resetSysChRoot() {
    this._sysChRoot.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sysChRootInput() {
    return this._sysChRoot.internalValue;
  }

  // sys_log - computed: false, optional: true, required: false
  private _sysLog = new DomainFeaturesCapabilitiesSysLogOutputReference(this, "sys_log");
  public get sysLog() {
    return this._sysLog;
  }
  public putSysLog(value: DomainFeaturesCapabilitiesSysLog) {
    this._sysLog.internalValue = value;
  }
  public resetSysLog() {
    this._sysLog.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sysLogInput() {
    return this._sysLog.internalValue;
  }

  // sys_module - computed: false, optional: true, required: false
  private _sysModule = new DomainFeaturesCapabilitiesSysModuleOutputReference(this, "sys_module");
  public get sysModule() {
    return this._sysModule;
  }
  public putSysModule(value: DomainFeaturesCapabilitiesSysModule) {
    this._sysModule.internalValue = value;
  }
  public resetSysModule() {
    this._sysModule.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sysModuleInput() {
    return this._sysModule.internalValue;
  }

  // sys_nice - computed: false, optional: true, required: false
  private _sysNice = new DomainFeaturesCapabilitiesSysNiceOutputReference(this, "sys_nice");
  public get sysNice() {
    return this._sysNice;
  }
  public putSysNice(value: DomainFeaturesCapabilitiesSysNice) {
    this._sysNice.internalValue = value;
  }
  public resetSysNice() {
    this._sysNice.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sysNiceInput() {
    return this._sysNice.internalValue;
  }

  // sys_p_acct - computed: false, optional: true, required: false
  private _sysPAcct = new DomainFeaturesCapabilitiesSysPAcctOutputReference(this, "sys_p_acct");
  public get sysPAcct() {
    return this._sysPAcct;
  }
  public putSysPAcct(value: DomainFeaturesCapabilitiesSysPAcct) {
    this._sysPAcct.internalValue = value;
  }
  public resetSysPAcct() {
    this._sysPAcct.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sysPAcctInput() {
    return this._sysPAcct.internalValue;
  }

  // sys_p_trace - computed: false, optional: true, required: false
  private _sysPTrace = new DomainFeaturesCapabilitiesSysPTraceOutputReference(this, "sys_p_trace");
  public get sysPTrace() {
    return this._sysPTrace;
  }
  public putSysPTrace(value: DomainFeaturesCapabilitiesSysPTrace) {
    this._sysPTrace.internalValue = value;
  }
  public resetSysPTrace() {
    this._sysPTrace.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sysPTraceInput() {
    return this._sysPTrace.internalValue;
  }

  // sys_raw_io - computed: false, optional: true, required: false
  private _sysRawIo = new DomainFeaturesCapabilitiesSysRawIoOutputReference(this, "sys_raw_io");
  public get sysRawIo() {
    return this._sysRawIo;
  }
  public putSysRawIo(value: DomainFeaturesCapabilitiesSysRawIo) {
    this._sysRawIo.internalValue = value;
  }
  public resetSysRawIo() {
    this._sysRawIo.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sysRawIoInput() {
    return this._sysRawIo.internalValue;
  }

  // sys_resource - computed: false, optional: true, required: false
  private _sysResource = new DomainFeaturesCapabilitiesSysResourceOutputReference(this, "sys_resource");
  public get sysResource() {
    return this._sysResource;
  }
  public putSysResource(value: DomainFeaturesCapabilitiesSysResource) {
    this._sysResource.internalValue = value;
  }
  public resetSysResource() {
    this._sysResource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sysResourceInput() {
    return this._sysResource.internalValue;
  }

  // sys_time - computed: false, optional: true, required: false
  private _sysTime = new DomainFeaturesCapabilitiesSysTimeOutputReference(this, "sys_time");
  public get sysTime() {
    return this._sysTime;
  }
  public putSysTime(value: DomainFeaturesCapabilitiesSysTime) {
    this._sysTime.internalValue = value;
  }
  public resetSysTime() {
    this._sysTime.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sysTimeInput() {
    return this._sysTime.internalValue;
  }

  // sys_tty_cnofig - computed: false, optional: true, required: false
  private _sysTtyCnofig = new DomainFeaturesCapabilitiesSysTtyCnofigOutputReference(this, "sys_tty_cnofig");
  public get sysTtyCnofig() {
    return this._sysTtyCnofig;
  }
  public putSysTtyCnofig(value: DomainFeaturesCapabilitiesSysTtyCnofig) {
    this._sysTtyCnofig.internalValue = value;
  }
  public resetSysTtyCnofig() {
    this._sysTtyCnofig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sysTtyCnofigInput() {
    return this._sysTtyCnofig.internalValue;
  }

  // wake_alarm - computed: false, optional: true, required: false
  private _wakeAlarm = new DomainFeaturesCapabilitiesWakeAlarmOutputReference(this, "wake_alarm");
  public get wakeAlarm() {
    return this._wakeAlarm;
  }
  public putWakeAlarm(value: DomainFeaturesCapabilitiesWakeAlarm) {
    this._wakeAlarm.internalValue = value;
  }
  public resetWakeAlarm() {
    this._wakeAlarm.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get wakeAlarmInput() {
    return this._wakeAlarm.internalValue;
  }
}
export interface DomainFeaturesCcfAssist {
  /**
  * Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesCcfAssistToTerraform(struct?: DomainFeaturesCcfAssist | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesCcfAssistToHclTerraform(struct?: DomainFeaturesCcfAssist | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesCcfAssistOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesCcfAssist | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesCcfAssist | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesCfpc {
  /**
  * Sets the cfpc policy value; libvirt accepts specific strings such as "on", "off", "workaround", "broken", or "default" depending on the mitigation mode supported by the hypervisor.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#value Domain#value}
  */
  readonly value: string;
}

export function domainFeaturesCfpcToTerraform(struct?: DomainFeaturesCfpc | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function domainFeaturesCfpcToHclTerraform(struct?: DomainFeaturesCfpc | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesCfpcOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesCfpc | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesCfpc | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._value = value.value;
    }
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DomainFeaturesGic {
  /**
  * Sets the desired GIC hardware version presented to the guest, such as "2" or "3", with the exact allowed values depending on the guest architecture and machine type.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#version Domain#version}
  */
  readonly version?: string;
}

export function domainFeaturesGicToTerraform(struct?: DomainFeaturesGic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    version: cdktf.stringToTerraform(struct!.version),
  }
}


export function domainFeaturesGicToHclTerraform(struct?: DomainFeaturesGic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesGicOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesGic | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesGic | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._version = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._version = value.version;
    }
  }

  // version - computed: false, optional: true, required: false
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }
}
export interface DomainFeaturesHap {
  /**
  * Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesHapToTerraform(struct?: DomainFeaturesHap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesHapToHclTerraform(struct?: DomainFeaturesHap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesHapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesHap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesHap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesHpt {
  /**
  * Sets the maximum page size used by the guest hashed page table; value is a number interpreted together with max_page_size_unit (for example, 16 with unit "MiB").
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#max_page_size Domain#max_page_size}
  */
  readonly maxPageSize?: string;
  /**
  * Specifies the unit for hpt.max_page_size (for example "KiB", "MiB", or "GiB"); this is a string unit indicator used in combination with the numeric value.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#max_page_size_unit Domain#max_page_size_unit}
  */
  readonly maxPageSizeUnit?: string;
  /**
  * Controls whether hashed page table resizing is allowed at runtime; valid values are user-provided strings such as "on", "off", or similar policy keywords as supported by libvirt.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#resizing Domain#resizing}
  */
  readonly resizing?: string;
}

export function domainFeaturesHptToTerraform(struct?: DomainFeaturesHpt | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_page_size: cdktf.stringToTerraform(struct!.maxPageSize),
    max_page_size_unit: cdktf.stringToTerraform(struct!.maxPageSizeUnit),
    resizing: cdktf.stringToTerraform(struct!.resizing),
  }
}


export function domainFeaturesHptToHclTerraform(struct?: DomainFeaturesHpt | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_page_size: {
      value: cdktf.stringToHclTerraform(struct!.maxPageSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_page_size_unit: {
      value: cdktf.stringToHclTerraform(struct!.maxPageSizeUnit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resizing: {
      value: cdktf.stringToHclTerraform(struct!.resizing),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesHptOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesHpt | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxPageSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPageSize = this._maxPageSize;
    }
    if (this._maxPageSizeUnit !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPageSizeUnit = this._maxPageSizeUnit;
    }
    if (this._resizing !== undefined) {
      hasAnyValues = true;
      internalValueResult.resizing = this._resizing;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesHpt | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxPageSize = undefined;
      this._maxPageSizeUnit = undefined;
      this._resizing = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxPageSize = value.maxPageSize;
      this._maxPageSizeUnit = value.maxPageSizeUnit;
      this._resizing = value.resizing;
    }
  }

  // max_page_size - computed: false, optional: true, required: false
  private _maxPageSize?: string; 
  public get maxPageSize() {
    return this.getStringAttribute('max_page_size');
  }
  public set maxPageSize(value: string) {
    this._maxPageSize = value;
  }
  public resetMaxPageSize() {
    this._maxPageSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPageSizeInput() {
    return this._maxPageSize;
  }

  // max_page_size_unit - computed: false, optional: true, required: false
  private _maxPageSizeUnit?: string; 
  public get maxPageSizeUnit() {
    return this.getStringAttribute('max_page_size_unit');
  }
  public set maxPageSizeUnit(value: string) {
    this._maxPageSizeUnit = value;
  }
  public resetMaxPageSizeUnit() {
    this._maxPageSizeUnit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPageSizeUnitInput() {
    return this._maxPageSizeUnit;
  }

  // resizing - computed: false, optional: true, required: false
  private _resizing?: string; 
  public get resizing() {
    return this.getStringAttribute('resizing');
  }
  public set resizing(value: string) {
    this._resizing = value;
  }
  public resetResizing() {
    this._resizing = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resizingInput() {
    return this._resizing;
  }
}
export interface DomainFeaturesHtm {
  /**
  * Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesHtmToTerraform(struct?: DomainFeaturesHtm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesHtmToHclTerraform(struct?: DomainFeaturesHtm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesHtmOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesHtm | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesHtm | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesHyperVAvic {
  /**
  * Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesHyperVAvicToTerraform(struct?: DomainFeaturesHyperVAvic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesHyperVAvicToHclTerraform(struct?: DomainFeaturesHyperVAvic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesHyperVAvicOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesHyperVAvic | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesHyperVAvic | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesHyperVEmsrBitmap {
  /**
  * Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesHyperVEmsrBitmapToTerraform(struct?: DomainFeaturesHyperVEmsrBitmap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesHyperVEmsrBitmapToHclTerraform(struct?: DomainFeaturesHyperVEmsrBitmap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesHyperVEmsrBitmapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesHyperVEmsrBitmap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesHyperVEmsrBitmap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesHyperVEvmcs {
  /**
  * Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesHyperVEvmcsToTerraform(struct?: DomainFeaturesHyperVEvmcs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesHyperVEvmcsToHclTerraform(struct?: DomainFeaturesHyperVEvmcs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesHyperVEvmcsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesHyperVEvmcs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesHyperVEvmcs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesHyperVFrequencies {
  /**
  * Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesHyperVFrequenciesToTerraform(struct?: DomainFeaturesHyperVFrequencies | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesHyperVFrequenciesToHclTerraform(struct?: DomainFeaturesHyperVFrequencies | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesHyperVFrequenciesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesHyperVFrequencies | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesHyperVFrequencies | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesHyperVIpi {
  /**
  * Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesHyperVIpiToTerraform(struct?: DomainFeaturesHyperVIpi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesHyperVIpiToHclTerraform(struct?: DomainFeaturesHyperVIpi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesHyperVIpiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesHyperVIpi | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesHyperVIpi | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesHyperVReEnlightenment {
  /**
  * Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesHyperVReEnlightenmentToTerraform(struct?: DomainFeaturesHyperVReEnlightenment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesHyperVReEnlightenmentToHclTerraform(struct?: DomainFeaturesHyperVReEnlightenment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesHyperVReEnlightenmentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesHyperVReEnlightenment | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesHyperVReEnlightenment | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesHyperVRelaxed {
  /**
  * Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesHyperVRelaxedToTerraform(struct?: DomainFeaturesHyperVRelaxed | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesHyperVRelaxedToHclTerraform(struct?: DomainFeaturesHyperVRelaxed | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesHyperVRelaxedOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesHyperVRelaxed | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesHyperVRelaxed | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesHyperVReset {
  /**
  * Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesHyperVResetToTerraform(struct?: DomainFeaturesHyperVReset | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesHyperVResetToHclTerraform(struct?: DomainFeaturesHyperVReset | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesHyperVResetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesHyperVReset | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesHyperVReset | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesHyperVRuntime {
  /**
  * Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesHyperVRuntimeToTerraform(struct?: DomainFeaturesHyperVRuntime | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesHyperVRuntimeToHclTerraform(struct?: DomainFeaturesHyperVRuntime | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesHyperVRuntimeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesHyperVRuntime | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesHyperVRuntime | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesHyperVSpinlocks {
  /**
  * Sets the maximum number of spinlock retries before triggering the Hyper-V enlightenment fallback; the value is a user-provided non-negative integer (e.g., 4095).
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#retries Domain#retries}
  */
  readonly retries?: number;
}

export function domainFeaturesHyperVSpinlocksToTerraform(struct?: DomainFeaturesHyperVSpinlocks | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    retries: cdktf.numberToTerraform(struct!.retries),
  }
}


export function domainFeaturesHyperVSpinlocksToHclTerraform(struct?: DomainFeaturesHyperVSpinlocks | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    retries: {
      value: cdktf.numberToHclTerraform(struct!.retries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesHyperVSpinlocksOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesHyperVSpinlocks | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._retries !== undefined) {
      hasAnyValues = true;
      internalValueResult.retries = this._retries;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesHyperVSpinlocks | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._retries = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._retries = value.retries;
    }
  }

  // retries - computed: false, optional: true, required: false
  private _retries?: number; 
  public get retries() {
    return this.getNumberAttribute('retries');
  }
  public set retries(value: number) {
    this._retries = value;
  }
  public resetRetries() {
    this._retries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retriesInput() {
    return this._retries;
  }
}
export interface DomainFeaturesHyperVStimerDirect {
  /**
  * Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesHyperVStimerDirectToTerraform(struct?: DomainFeaturesHyperVStimerDirect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesHyperVStimerDirectToHclTerraform(struct?: DomainFeaturesHyperVStimerDirect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesHyperVStimerDirectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesHyperVStimerDirect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesHyperVStimerDirect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesHyperVStimer {
  /**
  * Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#direct Domain#direct}
  */
  readonly direct?: DomainFeaturesHyperVStimerDirect;
}

export function domainFeaturesHyperVStimerToTerraform(struct?: DomainFeaturesHyperVStimer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    direct: domainFeaturesHyperVStimerDirectToTerraform(struct!.direct),
  }
}


export function domainFeaturesHyperVStimerToHclTerraform(struct?: DomainFeaturesHyperVStimer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    direct: {
      value: domainFeaturesHyperVStimerDirectToHclTerraform(struct!.direct),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesHyperVStimerDirect",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesHyperVStimerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesHyperVStimer | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._direct?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.direct = this._direct?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesHyperVStimer | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._direct.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._direct.internalValue = value.direct;
    }
  }

  // direct - computed: false, optional: true, required: false
  private _direct = new DomainFeaturesHyperVStimerDirectOutputReference(this, "direct");
  public get direct() {
    return this._direct;
  }
  public putDirect(value: DomainFeaturesHyperVStimerDirect) {
    this._direct.internalValue = value;
  }
  public resetDirect() {
    this._direct.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get directInput() {
    return this._direct.internalValue;
  }
}
export interface DomainFeaturesHyperVSynic {
  /**
  * Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesHyperVSynicToTerraform(struct?: DomainFeaturesHyperVSynic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesHyperVSynicToHclTerraform(struct?: DomainFeaturesHyperVSynic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesHyperVSynicOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesHyperVSynic | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesHyperVSynic | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesHyperVTlbFlushDirect {
  /**
  * Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesHyperVTlbFlushDirectToTerraform(struct?: DomainFeaturesHyperVTlbFlushDirect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesHyperVTlbFlushDirectToHclTerraform(struct?: DomainFeaturesHyperVTlbFlushDirect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesHyperVTlbFlushDirectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesHyperVTlbFlushDirect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesHyperVTlbFlushDirect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesHyperVTlbFlushExtended {
  /**
  * Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesHyperVTlbFlushExtendedToTerraform(struct?: DomainFeaturesHyperVTlbFlushExtended | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesHyperVTlbFlushExtendedToHclTerraform(struct?: DomainFeaturesHyperVTlbFlushExtended | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesHyperVTlbFlushExtendedOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesHyperVTlbFlushExtended | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesHyperVTlbFlushExtended | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesHyperVTlbFlush {
  /**
  * Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#direct Domain#direct}
  */
  readonly direct?: DomainFeaturesHyperVTlbFlushDirect;
  /**
  * Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#extended Domain#extended}
  */
  readonly extended?: DomainFeaturesHyperVTlbFlushExtended;
}

export function domainFeaturesHyperVTlbFlushToTerraform(struct?: DomainFeaturesHyperVTlbFlush | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    direct: domainFeaturesHyperVTlbFlushDirectToTerraform(struct!.direct),
    extended: domainFeaturesHyperVTlbFlushExtendedToTerraform(struct!.extended),
  }
}


export function domainFeaturesHyperVTlbFlushToHclTerraform(struct?: DomainFeaturesHyperVTlbFlush | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    direct: {
      value: domainFeaturesHyperVTlbFlushDirectToHclTerraform(struct!.direct),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesHyperVTlbFlushDirect",
    },
    extended: {
      value: domainFeaturesHyperVTlbFlushExtendedToHclTerraform(struct!.extended),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesHyperVTlbFlushExtended",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesHyperVTlbFlushOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesHyperVTlbFlush | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._direct?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.direct = this._direct?.internalValue;
    }
    if (this._extended?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extended = this._extended?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesHyperVTlbFlush | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._direct.internalValue = undefined;
      this._extended.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._direct.internalValue = value.direct;
      this._extended.internalValue = value.extended;
    }
  }

  // direct - computed: false, optional: true, required: false
  private _direct = new DomainFeaturesHyperVTlbFlushDirectOutputReference(this, "direct");
  public get direct() {
    return this._direct;
  }
  public putDirect(value: DomainFeaturesHyperVTlbFlushDirect) {
    this._direct.internalValue = value;
  }
  public resetDirect() {
    this._direct.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get directInput() {
    return this._direct.internalValue;
  }

  // extended - computed: false, optional: true, required: false
  private _extended = new DomainFeaturesHyperVTlbFlushExtendedOutputReference(this, "extended");
  public get extended() {
    return this._extended;
  }
  public putExtended(value: DomainFeaturesHyperVTlbFlushExtended) {
    this._extended.internalValue = value;
  }
  public resetExtended() {
    this._extended.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extendedInput() {
    return this._extended.internalValue;
  }
}
export interface DomainFeaturesHyperVVapic {
  /**
  * Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesHyperVVapicToTerraform(struct?: DomainFeaturesHyperVVapic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesHyperVVapicToHclTerraform(struct?: DomainFeaturesHyperVVapic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesHyperVVapicOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesHyperVVapic | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesHyperVVapic | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesHyperVVendorId {
  /**
  * Sets the custom Hyper-V vendor ID string exposed to the guest; the value is user-provided and typically limited to 12 ASCII characters (for example, "KVM HvVendor").
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#value Domain#value}
  */
  readonly value?: string;
}

export function domainFeaturesHyperVVendorIdToTerraform(struct?: DomainFeaturesHyperVVendorId | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function domainFeaturesHyperVVendorIdToHclTerraform(struct?: DomainFeaturesHyperVVendorId | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesHyperVVendorIdOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesHyperVVendorId | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesHyperVVendorId | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._value = value.value;
    }
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DomainFeaturesHyperVVpIndex {
  /**
  * Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesHyperVVpIndexToTerraform(struct?: DomainFeaturesHyperVVpIndex | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesHyperVVpIndexToHclTerraform(struct?: DomainFeaturesHyperVVpIndex | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesHyperVVpIndexOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesHyperVVpIndex | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesHyperVVpIndex | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesHyperVXmmInput {
  /**
  * Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesHyperVXmmInputToTerraform(struct?: DomainFeaturesHyperVXmmInput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesHyperVXmmInputToHclTerraform(struct?: DomainFeaturesHyperVXmmInput | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesHyperVXmmInputOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesHyperVXmmInput | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesHyperVXmmInput | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesHyperV {
  /**
  * Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#avic Domain#avic}
  */
  readonly avic?: DomainFeaturesHyperVAvic;
  /**
  * Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#emsr_bitmap Domain#emsr_bitmap}
  */
  readonly emsrBitmap?: DomainFeaturesHyperVEmsrBitmap;
  /**
  * Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#evmcs Domain#evmcs}
  */
  readonly evmcs?: DomainFeaturesHyperVEvmcs;
  /**
  * Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#frequencies Domain#frequencies}
  */
  readonly frequencies?: DomainFeaturesHyperVFrequencies;
  /**
  * Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#ipi Domain#ipi}
  */
  readonly ipi?: DomainFeaturesHyperVIpi;
  /**
  * Sets the Hyper-V enlightenment mode for the domain (for example, "custom" vs. driver-specific modes); the exact allowed values are user-provided and depend on the libvirt/QEMU version.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#mode Domain#mode}
  */
  readonly mode?: string;
  /**
  * Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#re_enlightenment Domain#re_enlightenment}
  */
  readonly reEnlightenment?: DomainFeaturesHyperVReEnlightenment;
  /**
  * Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#relaxed Domain#relaxed}
  */
  readonly relaxed?: DomainFeaturesHyperVRelaxed;
  /**
  * Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#reset Domain#reset}
  */
  readonly reset?: DomainFeaturesHyperVReset;
  /**
  * Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#runtime Domain#runtime}
  */
  readonly runtime?: DomainFeaturesHyperVRuntime;
  /**
  * Configures the Hyper-V spinlock enlightenment, which can reduce CPU waste on spinlocks by triggering a fallback after a configurable number of retries.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#spinlocks Domain#spinlocks}
  */
  readonly spinlocks?: DomainFeaturesHyperVSpinlocks;
  /**
  * Configures the Hyper-V synthetic timer (stimer) feature, which provides paravirtualized timer support to the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#stimer Domain#stimer}
  */
  readonly stimer?: DomainFeaturesHyperVStimer;
  /**
  * Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#synic Domain#synic}
  */
  readonly synic?: DomainFeaturesHyperVSynic;
  /**
  * Enables configuration of Hyper-V TLB flush enlightenment features for the guest; presence of this block allows selecting specific flush modes via its children.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#tlb_flush Domain#tlb_flush}
  */
  readonly tlbFlush?: DomainFeaturesHyperVTlbFlush;
  /**
  * Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vapic Domain#vapic}
  */
  readonly vapic?: DomainFeaturesHyperVVapic;
  /**
  * Enables configuration of a custom Hyper-V CPUID vendor ID string presented to the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vendor_id Domain#vendor_id}
  */
  readonly vendorId?: DomainFeaturesHyperVVendorId;
  /**
  * Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#vp_index Domain#vp_index}
  */
  readonly vpIndex?: DomainFeaturesHyperVVpIndex;
  /**
  * Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#xmm_input Domain#xmm_input}
  */
  readonly xmmInput?: DomainFeaturesHyperVXmmInput;
}

export function domainFeaturesHyperVToTerraform(struct?: DomainFeaturesHyperV | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    avic: domainFeaturesHyperVAvicToTerraform(struct!.avic),
    emsr_bitmap: domainFeaturesHyperVEmsrBitmapToTerraform(struct!.emsrBitmap),
    evmcs: domainFeaturesHyperVEvmcsToTerraform(struct!.evmcs),
    frequencies: domainFeaturesHyperVFrequenciesToTerraform(struct!.frequencies),
    ipi: domainFeaturesHyperVIpiToTerraform(struct!.ipi),
    mode: cdktf.stringToTerraform(struct!.mode),
    re_enlightenment: domainFeaturesHyperVReEnlightenmentToTerraform(struct!.reEnlightenment),
    relaxed: domainFeaturesHyperVRelaxedToTerraform(struct!.relaxed),
    reset: domainFeaturesHyperVResetToTerraform(struct!.reset),
    runtime: domainFeaturesHyperVRuntimeToTerraform(struct!.runtime),
    spinlocks: domainFeaturesHyperVSpinlocksToTerraform(struct!.spinlocks),
    stimer: domainFeaturesHyperVStimerToTerraform(struct!.stimer),
    synic: domainFeaturesHyperVSynicToTerraform(struct!.synic),
    tlb_flush: domainFeaturesHyperVTlbFlushToTerraform(struct!.tlbFlush),
    vapic: domainFeaturesHyperVVapicToTerraform(struct!.vapic),
    vendor_id: domainFeaturesHyperVVendorIdToTerraform(struct!.vendorId),
    vp_index: domainFeaturesHyperVVpIndexToTerraform(struct!.vpIndex),
    xmm_input: domainFeaturesHyperVXmmInputToTerraform(struct!.xmmInput),
  }
}


export function domainFeaturesHyperVToHclTerraform(struct?: DomainFeaturesHyperV | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    avic: {
      value: domainFeaturesHyperVAvicToHclTerraform(struct!.avic),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesHyperVAvic",
    },
    emsr_bitmap: {
      value: domainFeaturesHyperVEmsrBitmapToHclTerraform(struct!.emsrBitmap),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesHyperVEmsrBitmap",
    },
    evmcs: {
      value: domainFeaturesHyperVEvmcsToHclTerraform(struct!.evmcs),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesHyperVEvmcs",
    },
    frequencies: {
      value: domainFeaturesHyperVFrequenciesToHclTerraform(struct!.frequencies),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesHyperVFrequencies",
    },
    ipi: {
      value: domainFeaturesHyperVIpiToHclTerraform(struct!.ipi),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesHyperVIpi",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    re_enlightenment: {
      value: domainFeaturesHyperVReEnlightenmentToHclTerraform(struct!.reEnlightenment),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesHyperVReEnlightenment",
    },
    relaxed: {
      value: domainFeaturesHyperVRelaxedToHclTerraform(struct!.relaxed),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesHyperVRelaxed",
    },
    reset: {
      value: domainFeaturesHyperVResetToHclTerraform(struct!.reset),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesHyperVReset",
    },
    runtime: {
      value: domainFeaturesHyperVRuntimeToHclTerraform(struct!.runtime),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesHyperVRuntime",
    },
    spinlocks: {
      value: domainFeaturesHyperVSpinlocksToHclTerraform(struct!.spinlocks),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesHyperVSpinlocks",
    },
    stimer: {
      value: domainFeaturesHyperVStimerToHclTerraform(struct!.stimer),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesHyperVStimer",
    },
    synic: {
      value: domainFeaturesHyperVSynicToHclTerraform(struct!.synic),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesHyperVSynic",
    },
    tlb_flush: {
      value: domainFeaturesHyperVTlbFlushToHclTerraform(struct!.tlbFlush),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesHyperVTlbFlush",
    },
    vapic: {
      value: domainFeaturesHyperVVapicToHclTerraform(struct!.vapic),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesHyperVVapic",
    },
    vendor_id: {
      value: domainFeaturesHyperVVendorIdToHclTerraform(struct!.vendorId),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesHyperVVendorId",
    },
    vp_index: {
      value: domainFeaturesHyperVVpIndexToHclTerraform(struct!.vpIndex),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesHyperVVpIndex",
    },
    xmm_input: {
      value: domainFeaturesHyperVXmmInputToHclTerraform(struct!.xmmInput),
      isBlock: true,
      type: "struct",
      storageClassType: "DomainFeaturesHyperVXmmInput",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesHyperVOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesHyperV | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._avic?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.avic = this._avic?.internalValue;
    }
    if (this._emsrBitmap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.emsrBitmap = this._emsrBitmap?.internalValue;
    }
    if (this._evmcs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.evmcs = this._evmcs?.internalValue;
    }
    if (this._frequencies?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.frequencies = this._frequencies?.internalValue;
    }
    if (this._ipi?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipi = this._ipi?.internalValue;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._reEnlightenment?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.reEnlightenment = this._reEnlightenment?.internalValue;
    }
    if (this._relaxed?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.relaxed = this._relaxed?.internalValue;
    }
    if (this._reset?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.reset = this._reset?.internalValue;
    }
    if (this._runtime?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.runtime = this._runtime?.internalValue;
    }
    if (this._spinlocks?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spinlocks = this._spinlocks?.internalValue;
    }
    if (this._stimer?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.stimer = this._stimer?.internalValue;
    }
    if (this._synic?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.synic = this._synic?.internalValue;
    }
    if (this._tlbFlush?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlbFlush = this._tlbFlush?.internalValue;
    }
    if (this._vapic?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.vapic = this._vapic?.internalValue;
    }
    if (this._vendorId?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.vendorId = this._vendorId?.internalValue;
    }
    if (this._vpIndex?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.vpIndex = this._vpIndex?.internalValue;
    }
    if (this._xmmInput?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.xmmInput = this._xmmInput?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesHyperV | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._avic.internalValue = undefined;
      this._emsrBitmap.internalValue = undefined;
      this._evmcs.internalValue = undefined;
      this._frequencies.internalValue = undefined;
      this._ipi.internalValue = undefined;
      this._mode = undefined;
      this._reEnlightenment.internalValue = undefined;
      this._relaxed.internalValue = undefined;
      this._reset.internalValue = undefined;
      this._runtime.internalValue = undefined;
      this._spinlocks.internalValue = undefined;
      this._stimer.internalValue = undefined;
      this._synic.internalValue = undefined;
      this._tlbFlush.internalValue = undefined;
      this._vapic.internalValue = undefined;
      this._vendorId.internalValue = undefined;
      this._vpIndex.internalValue = undefined;
      this._xmmInput.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._avic.internalValue = value.avic;
      this._emsrBitmap.internalValue = value.emsrBitmap;
      this._evmcs.internalValue = value.evmcs;
      this._frequencies.internalValue = value.frequencies;
      this._ipi.internalValue = value.ipi;
      this._mode = value.mode;
      this._reEnlightenment.internalValue = value.reEnlightenment;
      this._relaxed.internalValue = value.relaxed;
      this._reset.internalValue = value.reset;
      this._runtime.internalValue = value.runtime;
      this._spinlocks.internalValue = value.spinlocks;
      this._stimer.internalValue = value.stimer;
      this._synic.internalValue = value.synic;
      this._tlbFlush.internalValue = value.tlbFlush;
      this._vapic.internalValue = value.vapic;
      this._vendorId.internalValue = value.vendorId;
      this._vpIndex.internalValue = value.vpIndex;
      this._xmmInput.internalValue = value.xmmInput;
    }
  }

  // avic - computed: false, optional: true, required: false
  private _avic = new DomainFeaturesHyperVAvicOutputReference(this, "avic");
  public get avic() {
    return this._avic;
  }
  public putAvic(value: DomainFeaturesHyperVAvic) {
    this._avic.internalValue = value;
  }
  public resetAvic() {
    this._avic.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get avicInput() {
    return this._avic.internalValue;
  }

  // emsr_bitmap - computed: false, optional: true, required: false
  private _emsrBitmap = new DomainFeaturesHyperVEmsrBitmapOutputReference(this, "emsr_bitmap");
  public get emsrBitmap() {
    return this._emsrBitmap;
  }
  public putEmsrBitmap(value: DomainFeaturesHyperVEmsrBitmap) {
    this._emsrBitmap.internalValue = value;
  }
  public resetEmsrBitmap() {
    this._emsrBitmap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get emsrBitmapInput() {
    return this._emsrBitmap.internalValue;
  }

  // evmcs - computed: false, optional: true, required: false
  private _evmcs = new DomainFeaturesHyperVEvmcsOutputReference(this, "evmcs");
  public get evmcs() {
    return this._evmcs;
  }
  public putEvmcs(value: DomainFeaturesHyperVEvmcs) {
    this._evmcs.internalValue = value;
  }
  public resetEvmcs() {
    this._evmcs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get evmcsInput() {
    return this._evmcs.internalValue;
  }

  // frequencies - computed: false, optional: true, required: false
  private _frequencies = new DomainFeaturesHyperVFrequenciesOutputReference(this, "frequencies");
  public get frequencies() {
    return this._frequencies;
  }
  public putFrequencies(value: DomainFeaturesHyperVFrequencies) {
    this._frequencies.internalValue = value;
  }
  public resetFrequencies() {
    this._frequencies.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get frequenciesInput() {
    return this._frequencies.internalValue;
  }

  // ipi - computed: false, optional: true, required: false
  private _ipi = new DomainFeaturesHyperVIpiOutputReference(this, "ipi");
  public get ipi() {
    return this._ipi;
  }
  public putIpi(value: DomainFeaturesHyperVIpi) {
    this._ipi.internalValue = value;
  }
  public resetIpi() {
    this._ipi.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipiInput() {
    return this._ipi.internalValue;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // re_enlightenment - computed: false, optional: true, required: false
  private _reEnlightenment = new DomainFeaturesHyperVReEnlightenmentOutputReference(this, "re_enlightenment");
  public get reEnlightenment() {
    return this._reEnlightenment;
  }
  public putReEnlightenment(value: DomainFeaturesHyperVReEnlightenment) {
    this._reEnlightenment.internalValue = value;
  }
  public resetReEnlightenment() {
    this._reEnlightenment.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reEnlightenmentInput() {
    return this._reEnlightenment.internalValue;
  }

  // relaxed - computed: false, optional: true, required: false
  private _relaxed = new DomainFeaturesHyperVRelaxedOutputReference(this, "relaxed");
  public get relaxed() {
    return this._relaxed;
  }
  public putRelaxed(value: DomainFeaturesHyperVRelaxed) {
    this._relaxed.internalValue = value;
  }
  public resetRelaxed() {
    this._relaxed.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relaxedInput() {
    return this._relaxed.internalValue;
  }

  // reset - computed: false, optional: true, required: false
  private _reset = new DomainFeaturesHyperVResetOutputReference(this, "reset");
  public get reset() {
    return this._reset;
  }
  public putReset(value: DomainFeaturesHyperVReset) {
    this._reset.internalValue = value;
  }
  public resetReset() {
    this._reset.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resetInput() {
    return this._reset.internalValue;
  }

  // runtime - computed: false, optional: true, required: false
  private _runtime = new DomainFeaturesHyperVRuntimeOutputReference(this, "runtime");
  public get runtime() {
    return this._runtime;
  }
  public putRuntime(value: DomainFeaturesHyperVRuntime) {
    this._runtime.internalValue = value;
  }
  public resetRuntime() {
    this._runtime.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runtimeInput() {
    return this._runtime.internalValue;
  }

  // spinlocks - computed: false, optional: true, required: false
  private _spinlocks = new DomainFeaturesHyperVSpinlocksOutputReference(this, "spinlocks");
  public get spinlocks() {
    return this._spinlocks;
  }
  public putSpinlocks(value: DomainFeaturesHyperVSpinlocks) {
    this._spinlocks.internalValue = value;
  }
  public resetSpinlocks() {
    this._spinlocks.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spinlocksInput() {
    return this._spinlocks.internalValue;
  }

  // stimer - computed: false, optional: true, required: false
  private _stimer = new DomainFeaturesHyperVStimerOutputReference(this, "stimer");
  public get stimer() {
    return this._stimer;
  }
  public putStimer(value: DomainFeaturesHyperVStimer) {
    this._stimer.internalValue = value;
  }
  public resetStimer() {
    this._stimer.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stimerInput() {
    return this._stimer.internalValue;
  }

  // synic - computed: false, optional: true, required: false
  private _synic = new DomainFeaturesHyperVSynicOutputReference(this, "synic");
  public get synic() {
    return this._synic;
  }
  public putSynic(value: DomainFeaturesHyperVSynic) {
    this._synic.internalValue = value;
  }
  public resetSynic() {
    this._synic.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get synicInput() {
    return this._synic.internalValue;
  }

  // tlb_flush - computed: false, optional: true, required: false
  private _tlbFlush = new DomainFeaturesHyperVTlbFlushOutputReference(this, "tlb_flush");
  public get tlbFlush() {
    return this._tlbFlush;
  }
  public putTlbFlush(value: DomainFeaturesHyperVTlbFlush) {
    this._tlbFlush.internalValue = value;
  }
  public resetTlbFlush() {
    this._tlbFlush.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlbFlushInput() {
    return this._tlbFlush.internalValue;
  }

  // vapic - computed: false, optional: true, required: false
  private _vapic = new DomainFeaturesHyperVVapicOutputReference(this, "vapic");
  public get vapic() {
    return this._vapic;
  }
  public putVapic(value: DomainFeaturesHyperVVapic) {
    this._vapic.internalValue = value;
  }
  public resetVapic() {
    this._vapic.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vapicInput() {
    return this._vapic.internalValue;
  }

  // vendor_id - computed: false, optional: true, required: false
  private _vendorId = new DomainFeaturesHyperVVendorIdOutputReference(this, "vendor_id");
  public get vendorId() {
    return this._vendorId;
  }
  public putVendorId(value: DomainFeaturesHyperVVendorId) {
    this._vendorId.internalValue = value;
  }
  public resetVendorId() {
    this._vendorId.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vendorIdInput() {
    return this._vendorId.internalValue;
  }

  // vp_index - computed: false, optional: true, required: false
  private _vpIndex = new DomainFeaturesHyperVVpIndexOutputReference(this, "vp_index");
  public get vpIndex() {
    return this._vpIndex;
  }
  public putVpIndex(value: DomainFeaturesHyperVVpIndex) {
    this._vpIndex.internalValue = value;
  }
  public resetVpIndex() {
    this._vpIndex.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vpIndexInput() {
    return this._vpIndex.internalValue;
  }

  // xmm_input - computed: false, optional: true, required: false
  private _xmmInput = new DomainFeaturesHyperVXmmInputOutputReference(this, "xmm_input");
  public get xmmInput() {
    return this._xmmInput;
  }
  public putXmmInput(value: DomainFeaturesHyperVXmmInput) {
    this._xmmInput.internalValue = value;
  }
  public resetXmmInput() {
    this._xmmInput.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get xmmInputInput() {
    return this._xmmInput.internalValue;
  }
}
export interface DomainFeaturesIbs {
  /**
  * Sets the state of the IBS feature, usually "on" or "off"; this attribute is required when ibs is present and must be explicitly specified.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#value Domain#value}
  */
  readonly value: string;
}

export function domainFeaturesIbsToTerraform(struct?: DomainFeaturesIbs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function domainFeaturesIbsToHclTerraform(struct?: DomainFeaturesIbs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesIbsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesIbs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesIbs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._value = value.value;
    }
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DomainFeaturesIoapic {
  /**
  * Selects the IOAPIC emulation driver, typically using values like "qemu" or "kvm"; the exact string is user-provided but must be supported by the hypervisor.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#driver Domain#driver}
  */
  readonly driver?: string;
}

export function domainFeaturesIoapicToTerraform(struct?: DomainFeaturesIoapic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    driver: cdktf.stringToTerraform(struct!.driver),
  }
}


export function domainFeaturesIoapicToHclTerraform(struct?: DomainFeaturesIoapic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    driver: {
      value: cdktf.stringToHclTerraform(struct!.driver),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesIoapicOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesIoapic | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._driver !== undefined) {
      hasAnyValues = true;
      internalValueResult.driver = this._driver;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesIoapic | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._driver = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._driver = value.driver;
    }
  }

  // driver - computed: false, optional: true, required: false
  private _driver?: string; 
  public get driver() {
    return this.getStringAttribute('driver');
  }
  public set driver(value: string) {
    this._driver = value;
  }
  public resetDriver() {
    this._driver = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get driverInput() {
    return this._driver;
  }
}
export interface DomainFeaturesKvmDirtyRing {
  /**
  * Sets the size of the KVM dirty-ring buffer used for memory dirty tracking; the value is user-provided and must be a positive integer representing the number of slots in the ring (exact limits depend on the host kernel/QEMU).
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#size Domain#size}
  */
  readonly size?: number;
}

export function domainFeaturesKvmDirtyRingToTerraform(struct?: DomainFeaturesKvmDirtyRing | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    size: cdktf.numberToTerraform(struct!.size),
  }
}


export function domainFeaturesKvmDirtyRingToHclTerraform(struct?: DomainFeaturesKvmDirtyRing | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    size: {
      value: cdktf.numberToHclTerraform(struct!.size),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesKvmDirtyRingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesKvmDirtyRing | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._size !== undefined) {
      hasAnyValues = true;
      internalValueResult.size = this._size;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesKvmDirtyRing | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._size = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._size = value.size;
    }
  }

  // size - computed: false, optional: true, required: false
  private _size?: number; 
  public get size() {
    return this.getNumberAttribute('size');
  }
  public set size(value: number) {
    this._size = value;
  }
  public resetSize() {
    this._size = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sizeInput() {
    return this._size;
  }
}
export interface DomainFeaturesKvmHidden {
  /**
  * Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesKvmHiddenToTerraform(struct?: DomainFeaturesKvmHidden | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesKvmHiddenToHclTerraform(struct?: DomainFeaturesKvmHidden | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesKvmHiddenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesKvmHidden | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesKvmHidden | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesKvmHintDedicated {
  /**
  * Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesKvmHintDedicatedToTerraform(struct?: DomainFeaturesKvmHintDedicated | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesKvmHintDedicatedToHclTerraform(struct?: DomainFeaturesKvmHintDedicated | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesKvmHintDedicatedOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesKvmHintDedicated | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesKvmHintDedicated | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesKvmPollControl {
  /**
  * Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesKvmPollControlToTerraform(struct?: DomainFeaturesKvmPollControl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesKvmPollControlToHclTerraform(struct?: DomainFeaturesKvmPollControl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesKvmPollControlOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesKvmPollControl | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesKvmPollControl | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
export interface DomainFeaturesKvmPvipi {
  /**
  * Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
  * 
  * See: <https://libvirt.org/formatdomain.html#hypervisor-features>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/dmacvicar/libvirt/0.9.1/docs/resources/domain#state Domain#state}
  */
  readonly state?: string;
}

export function domainFeaturesKvmPvipiToTerraform(struct?: DomainFeaturesKvmPvipi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    state: cdktf.stringToTerraform(struct!.state),
  }
}


export function domainFeaturesKvmPvipiToHclTerraform(struct?: DomainFeaturesKvmPvipi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DomainFeaturesKvmPvipiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DomainFeaturesKvmPvipi | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DomainFeaturesKvmPvipi | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._state = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._state = value.state;
    }
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }
}
